{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Needlr","text":"<p>Opinionated fluent dependency injection for .NET with source generation.</p> <p> </p>"},{"location":"#what-is-needlr","title":"What is Needlr?","text":"<p>Needlr is a source-generation-first dependency injection library for .NET that provides automatic service registration through a simple, discoverable API. It's designed to minimize boilerplate code by automatically registering types from scanned assemblies.</p> <p>Source Generation First</p> <p>Needlr prioritizes compile-time source generation for AOT compatibility and optimal performance. Both source-gen (<code>.UsingSourceGen()</code>) and reflection (<code>.UsingReflection()</code>) require explicit opt-in\u2014source-gen is recommended for most scenarios.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Source Generation First - Compile-time type discovery for AOT/trimming compatibility</li> <li>Automatic Service Discovery - Automatically registers services from assemblies using conventions</li> <li>Fluent API - Chain-able configuration methods for clean, readable setup</li> <li>ASP.NET Core Integration - Seamless web application creation and configuration</li> <li>Plugin System - Extensible architecture for modular applications</li> <li>Decorator Pattern Support - Automatic decorator wiring with <code>[DecoratorFor&lt;T&gt;]</code> attribute</li> <li>Analyzers &amp; Diagnostics - Catch DI issues at compile-time, not runtime</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<p>See the Getting Started guide for full package requirements. Quick overview:</p> Source Generation (Recommended)Reflection <pre><code>&lt;PackageReference Include=\"NexusLabs.Needlr.Injection\" /&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.Injection.SourceGen\" /&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.Generators\" OutputItemType=\"Analyzer\" ReferenceOutputAssembly=\"false\" /&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.Generators.Attributes\" /&gt;\n&lt;!-- For ASP.NET Core: NexusLabs.Needlr.AspNet --&gt;\n</code></pre> <pre><code>&lt;PackageReference Include=\"NexusLabs.Needlr.Injection\" /&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.Injection.Reflection\" /&gt;\n&lt;!-- For ASP.NET Core: NexusLabs.Needlr.AspNet --&gt;\n</code></pre>"},{"location":"#source-generation-recommended","title":"Source Generation (Recommended)","text":"<pre><code>using NexusLabs.Needlr.AspNet;\nusing NexusLabs.Needlr.Injection;\nusing NexusLabs.Needlr.Injection.SourceGen;\n\nvar app = new Syringe()\n    .UsingSourceGen()\n    .CreateWebApplication(args);\n\napp.Run();\n</code></pre>"},{"location":"#reflection","title":"Reflection","text":"<pre><code>using NexusLabs.Needlr.AspNet;\nusing NexusLabs.Needlr.Injection;\nusing NexusLabs.Needlr.Injection.Reflection;\n\nvar app = new Syringe()\n    .UsingReflection()\n    .CreateWebApplication(args);\n\napp.Run();\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li> <p>:material-rocket-launch:{ .lg .middle } Getting Started</p> <p>Step-by-step guide to set up Needlr in your project</p> <p>:octicons-arrow-right-24: Getting Started</p> </li> <li> <p>:material-book-open-variant:{ .lg .middle } Core Concepts</p> <p>Understand the architecture and design principles</p> <p>:octicons-arrow-right-24: Core Concepts</p> </li> <li> <p>:material-cog:{ .lg .middle } Features</p> <p>Explore hosted services, keyed services, options, and more</p> <p>:octicons-arrow-right-24: Hosted Services</p> </li> <li> <p>:material-alert-circle:{ .lg .middle } Analyzers</p> <p>Compile-time diagnostics to catch DI issues early</p> <p>:octicons-arrow-right-24: Analyzers</p> </li> </ul>"},{"location":"advanced-usage/","title":"Advanced Usage","text":"<p>This guide covers advanced scenarios and techniques for using Needlr in complex applications.</p> <p>Note: Many advanced features require reflection. If you're building an AOT application,  stick to the source-generation patterns described in the Getting Started guide.</p>"},{"location":"advanced-usage/#custom-type-registrars","title":"Custom Type Registrars","text":""},{"location":"advanced-usage/#implementing-ityperegistrar","title":"Implementing ITypeRegistrar","text":"<p>Create custom registration logic by implementing <code>ITypeRegistrar</code>. This is typically used with reflection:</p> <pre><code>using Microsoft.Extensions.DependencyInjection;\nusing NexusLabs.Needlr.Injection;\nusing NexusLabs.Needlr.Injection.Reflection;\n\npublic class ConventionBasedTypeRegistrar : ITypeRegistrar\n{\n    public void RegisterTypes(\n        IServiceCollection services,\n        IEnumerable&lt;Type&gt; types,\n        ILogger logger)\n    {\n        foreach (var type in types)\n        {\n            // Register repositories as scoped\n            if (type.Name.EndsWith(\"Repository\"))\n            {\n                var interfaces = type.GetInterfaces();\n                foreach (var @interface in interfaces)\n                {\n                    services.AddScoped(@interface, type);\n                    logger.LogDebug($\"Registered {type.Name} as {@interface.Name} (Scoped)\");\n                }\n            }\n            // Register services as transient\n            else if (type.Name.EndsWith(\"Service\"))\n            {\n                var interfaces = type.GetInterfaces();\n                foreach (var @interface in interfaces)\n                {\n                    services.AddTransient(@interface, type);\n                    logger.LogDebug($\"Registered {type.Name} as {@interface.Name} (Transient)\");\n                }\n            }\n            // Register singletons for specific patterns\n            else if (type.GetInterfaces().Any(i =&gt; i.Name == \"ISingleton\"))\n            {\n                services.AddSingleton(type);\n                logger.LogDebug($\"Registered {type.Name} as Singleton\");\n            }\n        }\n    }\n}\n\n// Usage (requires reflection strategy)\nvar serviceProvider = new Syringe()\n    .UsingReflection()\n    .UsingTypeRegistrar(new ConventionBasedTypeRegistrar())\n    .BuildServiceProvider();\n</code></pre>"},{"location":"advanced-usage/#custom-type-filterers","title":"Custom Type Filterers","text":""},{"location":"advanced-usage/#implementing-itypefilterer","title":"Implementing ITypeFilterer","text":"<p>Control which types are eligible for registration:</p> <pre><code>public class NamespaceTypeFilterer : ITypeFilterer\n{\n    private readonly string[] _allowedNamespaces;\n\n    public NamespaceTypeFilterer(params string[] allowedNamespaces)\n    {\n        _allowedNamespaces = allowedNamespaces;\n    }\n\n    public IEnumerable&lt;Type&gt; Filter(IEnumerable&lt;Type&gt; types)\n    {\n        return types.Where(type =&gt;\n        {\n            // Skip if no namespace\n            if (type.Namespace == null)\n                return false;\n\n            // Check if in allowed namespaces\n            var isAllowed = _allowedNamespaces.Any(ns =&gt; \n                type.Namespace.StartsWith(ns));\n\n            // Also exclude test classes\n            var isTest = type.Name.EndsWith(\"Test\") || \n                         type.Name.EndsWith(\"Tests\");\n\n            return isAllowed &amp;&amp; !isTest;\n        });\n    }\n}\n\n// Usage (requires reflection strategy)\nvar serviceProvider = new Syringe()\n    .UsingReflection()\n    .UsingTypeFilterer(new NamespaceTypeFilterer(\n        \"MyCompany.Core\",\n        \"MyCompany.Services\",\n        \"MyCompany.Data\"))\n    .BuildServiceProvider();\n</code></pre>"},{"location":"advanced-usage/#chaining-type-filterers","title":"Chaining Type Filterers","text":"<p>Use <code>TypeFilterDecorator</code> to chain multiple filters:</p> <pre><code>public class CompositeFilterer : ITypeFilterer\n{\n    private readonly ITypeFilterer[] _filters;\n\n    public CompositeFilterer(params ITypeFilterer[] filters)\n    {\n        _filters = filters;\n    }\n\n    public IEnumerable&lt;Type&gt; Filter(IEnumerable&lt;Type&gt; types)\n    {\n        var result = types;\n        foreach (var filter in _filters)\n        {\n            result = filter.Filter(result);\n        }\n        return result;\n    }\n}\n\n// Usage (requires reflection strategy)\nvar serviceProvider = new Syringe()\n    .UsingReflection()\n    .UsingTypeFilterer(new CompositeFilterer(\n        new ReflectionTypeFilterer(),\n        new NamespaceTypeFilterer(\"MyCompany\"),\n        new AttributeTypeFilterer&lt;ObsoleteAttribute&gt;(exclude: true)))\n    .BuildServiceProvider();\n</code></pre>"},{"location":"advanced-usage/#complex-decorator-patterns","title":"Complex Decorator Patterns","text":""},{"location":"advanced-usage/#nested-decorators-with-attributes-recommended","title":"Nested Decorators with Attributes (Recommended)","text":"<p>The simplest way to apply multiple decorators is using the <code>[DecoratorFor&lt;T&gt;]</code> attribute:</p> <pre><code>// Base service - registered automatically\npublic class DataService : IDataService\n{\n    public async Task&lt;Data&gt; GetDataAsync()\n    {\n        return await FetchFromDatabase();\n    }\n}\n\n// Caching decorator - Order 1 means closest to original\n[DecoratorFor&lt;IDataService&gt;(Order = 1)]\npublic class CachingDataService : IDataService\n{\n    private readonly IDataService _inner;\n    private readonly IMemoryCache _cache;\n\n    public CachingDataService(IDataService inner, IMemoryCache cache)\n    {\n        _inner = inner;\n        _cache = cache;\n    }\n\n    public async Task&lt;Data&gt; GetDataAsync()\n    {\n        return await _cache.GetOrCreateAsync(\"data\", \n            async entry =&gt; await _inner.GetDataAsync());\n    }\n}\n\n// Logging decorator - Order 2 wraps the caching decorator\n[DecoratorFor&lt;IDataService&gt;(Order = 2)]\npublic class LoggingDataService : IDataService\n{\n    private readonly IDataService _inner;\n    private readonly ILogger&lt;LoggingDataService&gt; _logger;\n\n    public LoggingDataService(IDataService inner, ILogger&lt;LoggingDataService&gt; logger)\n    {\n        _inner = inner;\n        _logger = logger;\n    }\n\n    public async Task&lt;Data&gt; GetDataAsync()\n    {\n        _logger.LogInformation(\"Fetching data...\");\n        var data = await _inner.GetDataAsync();\n        _logger.LogInformation($\"Fetched {data.Count} items\");\n        return data;\n    }\n}\n\n// No plugin needed! Resolution produces:\n// LoggingDataService \u2192 CachingDataService \u2192 DataService\n</code></pre>"},{"location":"advanced-usage/#nested-decorators-manual","title":"Nested Decorators (Manual)","text":"<p>For more control, apply decorators manually in a plugin:</p> <pre><code>// Base service\n[DoNotAutoRegister]\npublic class DataService : IDataService\n{\n    public async Task&lt;Data&gt; GetDataAsync()\n    {\n        // Fetch from database\n        return await FetchFromDatabase();\n    }\n}\n\n// Caching decorator\n[DoNotAutoRegister]\npublic class CachingDataService : IDataService\n{\n    private readonly IDataService _inner;\n    private readonly IMemoryCache _cache;\n\n    public CachingDataService(IDataService inner, IMemoryCache cache)\n    {\n        _inner = inner;\n        _cache = cache;\n    }\n\n    public async Task&lt;Data&gt; GetDataAsync()\n    {\n        return await _cache.GetOrCreateAsync(\"data\", \n            async entry =&gt; await _inner.GetDataAsync());\n    }\n}\n\n// Logging decorator\n[DoNotAutoRegister]\npublic class LoggingDataService : IDataService\n{\n    private readonly IDataService _inner;\n    private readonly ILogger&lt;LoggingDataService&gt; _logger;\n\n    public LoggingDataService(IDataService inner, ILogger&lt;LoggingDataService&gt; logger)\n    {\n        _inner = inner;\n        _logger = logger;\n    }\n\n    public async Task&lt;Data&gt; GetDataAsync()\n    {\n        _logger.LogInformation(\"Fetching data...\");\n        var data = await _inner.GetDataAsync();\n        _logger.LogInformation($\"Fetched {data.Count} items\");\n        return data;\n    }\n}\n\n// Registration plugin\npublic class DataServicePlugin : IServiceCollectionPlugin\n{\n    public void Configure(ServiceCollectionPluginOptions options)\n    {\n        // Register base service\n        options.Services.AddScoped&lt;DataService&gt;();\n\n        // Apply decorators in order (innermost to outermost)\n        options.Services.AddScoped&lt;IDataService&gt;(sp =&gt;\n        {\n            IDataService service = sp.GetRequiredService&lt;DataService&gt;();\n            service = new CachingDataService(service, sp.GetRequiredService&lt;IMemoryCache&gt;());\n            service = new LoggingDataService(service, sp.GetRequiredService&lt;ILogger&lt;LoggingDataService&gt;&gt;());\n            return service;\n        });\n    }\n}\n</code></pre>"},{"location":"advanced-usage/#conditional-decorators","title":"Conditional Decorators","text":"<p>Apply decorators based on configuration:</p> <pre><code>public class ConditionalDecoratorPlugin : IServiceCollectionPlugin\n{\n    public void Configure(ServiceCollectionPluginOptions options)\n    {\n        options.Services.AddScoped&lt;BaseService&gt;();\n\n        options.Services.AddScoped&lt;IService&gt;(sp =&gt;\n        {\n            IService service = sp.GetRequiredService&lt;BaseService&gt;();\n\n            var config = sp.GetRequiredService&lt;IConfiguration&gt;();\n\n            if (config.GetValue&lt;bool&gt;(\"Features:EnableCaching\"))\n            {\n                service = new CachingDecorator(service, sp.GetRequiredService&lt;IMemoryCache&gt;());\n            }\n\n            if (config.GetValue&lt;bool&gt;(\"Features:EnableLogging\"))\n            {\n                service = new LoggingDecorator(service, sp.GetRequiredService&lt;ILogger&lt;LoggingDecorator&gt;&gt;());\n            }\n\n            if (config.GetValue&lt;bool&gt;(\"Features:EnableMetrics\"))\n            {\n                service = new MetricsDecorator(service, sp.GetRequiredService&lt;IMetricsCollector&gt;());\n            }\n\n            return service;\n        });\n    }\n}\n</code></pre>"},{"location":"advanced-usage/#post-plugin-registration-callbacks","title":"Post-Plugin Registration Callbacks","text":"<p>The <code>UsingPostPluginRegistrationCallback</code> method provides a way to register services after all plugins have been processed. This is available on both the <code>Syringe</code> class and <code>CreateWebApplicationOptions</code>.</p>"},{"location":"advanced-usage/#using-with-syringe","title":"Using with Syringe","text":"<p>Register services directly on the Syringe instance:</p> <pre><code>var serviceProvider = new Syringe()\n    .UsingPostPluginRegistrationCallback(services =&gt;\n    {\n        // Override or add services after plugins\n        services.AddSingleton&lt;ICustomService, CustomService&gt;();\n        services.Configure&lt;MyOptions&gt;(options =&gt; \n        {\n            options.EnableFeature = true;\n        });\n    })\n    .UsingPostPluginRegistrationCallback(services =&gt;\n    {\n        // You can chain multiple callbacks\n        services.AddScoped&lt;IAnotherService, AnotherService&gt;();\n    })\n    .BuildServiceProvider();\n</code></pre> <p>You can also use the plural overload <code>UsingPostPluginRegistrationCallbacks</code> to pass in multiple callbacks.</p>"},{"location":"advanced-usage/#using-with-createwebapplicationoptions","title":"Using with CreateWebApplicationOptions","text":"<p>For web applications, add callbacks through the options using the fluent extension methods:</p> <pre><code>var webApplication = new Syringe()\n    .ForWebApplication()\n    .UsingOptions(() =&gt; CreateWebApplicationOptions.Default\n        .UsingPostPluginRegistrationCallback(services =&gt;\n        {\n            services.AddAuthentication();\n            services.AddAuthorization();\n        })\n        .UsingPostPluginRegistrationCallback(services =&gt;\n        {\n            // Configure after authentication is added\n            services.Configure&lt;JwtBearerOptions&gt;(options =&gt;\n            {\n                options.Authority = \"https://auth.example.com\";\n            });\n        }))\n    .BuildWebApplication();\n</code></pre> <p>You can also use the plural overload to add multiple callbacks at once:</p> <pre><code>var webApplication = new Syringe()\n    .ForWebApplication()\n    .UsingOptions(() =&gt; CreateWebApplicationOptions.Default\n        .UsingPostPluginRegistrationCallbacks(\n            services =&gt; services.AddAuthentication(),\n            services =&gt; services.AddAuthorization(),\n            services =&gt; services.AddAntiforgery()))\n    .BuildWebApplication();\n</code></pre>"},{"location":"advanced-usage/#common-use-cases","title":"Common Use Cases","text":"<p>Post-plugin registration callbacks are particularly useful for:</p> <ol> <li>Overriding Plugin Registrations: Replace a service registered by a plugin with a custom implementation</li> <li>Conditional Registration: Add services based on configuration or environment</li> <li>Testing: Override services with mocks or test doubles</li> </ol> <p>Example of overriding a plugin registration:</p> <pre><code>var syringe = new Syringe()\n    .UsingPostPluginRegistrationCallback(services =&gt;\n    {\n        // Remove the default implementation registered by a plugin\n        var descriptor = services.FirstOrDefault(d =&gt; d.ServiceType == typeof(IEmailService));\n        if (descriptor != null)\n        {\n            services.Remove(descriptor);\n        }\n\n        // Add custom implementation\n        services.AddSingleton&lt;IEmailService, CustomEmailService&gt;();\n    });\n</code></pre>"},{"location":"advanced-usage/#custom-assembly-providers","title":"Custom Assembly Providers","text":""},{"location":"advanced-usage/#implementing-iassemblyprovider","title":"Implementing IAssemblyProvider","text":"<p>Create custom assembly discovery logic:</p> <pre><code>public class PluginAssemblyProvider : IAssemblyProvider\n{\n    private readonly string _pluginDirectory;\n\n    public PluginAssemblyProvider(string pluginDirectory)\n    {\n        _pluginDirectory = pluginDirectory;\n    }\n\n    public IEnumerable&lt;Assembly&gt; GetAssemblies()\n    {\n        var assemblies = new List&lt;Assembly&gt;();\n\n        // Load assemblies from plugin directory\n        if (Directory.Exists(_pluginDirectory))\n        {\n            var pluginFiles = Directory.GetFiles(_pluginDirectory, \"*.dll\");\n            foreach (var file in pluginFiles)\n            {\n                try\n                {\n                    var assembly = Assembly.LoadFrom(file);\n                    assemblies.Add(assembly);\n                }\n                catch (Exception ex)\n                {\n                    // Log and continue\n                    Console.WriteLine($\"Failed to load {file}: {ex.Message}\");\n                }\n            }\n        }\n\n        // Also include current domain assemblies\n        assemblies.AddRange(AppDomain.CurrentDomain.GetAssemblies());\n\n        return assemblies.Distinct();\n    }\n}\n\n// Usage (requires reflection strategy for dynamic assembly loading)\nvar serviceProvider = new Syringe()\n    .UsingReflection()\n    .UsingAssemblyProvider(new PluginAssemblyProvider(\"./plugins\"))\n    .BuildServiceProvider();\n</code></pre>"},{"location":"advanced-usage/#advanced-web-application-configuration","title":"Advanced Web Application Configuration","text":""},{"location":"advanced-usage/#using-configuration-callback","title":"Using Configuration Callback","text":"<p>The <code>UsingConfigurationCallback</code> method provides fine-grained control over the WebApplicationBuilder configuration:</p> <pre><code>var webApplication = new Syringe()\n    .UsingSourceGen()  // or .UsingReflection()\n    .ForWebApplication()\n    .UsingConfigurationCallback((builder, options) =&gt;\n    {\n        // Conditional configuration based on environment\n        if (builder.Environment.IsEnvironment(\"Test\"))\n        {\n            // Test-specific configuration\n            builder.Configuration.AddJsonFile(\"appsettings.Test.json\", optional: false);\n        }\n        else\n        {\n            // Production configuration\n            builder.Configuration\n                .AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true)\n                .AddJsonFile($\"appsettings.{builder.Environment.EnvironmentName}.json\", \n                    optional: true, reloadOnChange: true);\n        }\n\n        // Add environment variables with custom prefix\n        builder.Configuration.AddEnvironmentVariables(\"MYAPP_\");\n\n        // Override with in-memory configuration for testing\n        if (builder.Environment.IsDevelopment())\n        {\n            builder.Configuration.AddInMemoryCollection(new Dictionary&lt;string, string?&gt;\n            {\n                [\"DebugMode\"] = \"true\",\n                [\"DetailedErrors\"] = \"true\"\n            });\n        }\n\n        // Configure services before plugin registration\n        builder.Services.Configure&lt;JsonOptions&gt;(opts =&gt;\n        {\n            opts.SerializerOptions.PropertyNamingPolicy = JsonNamingPolicy.CamelCase;\n        });\n\n        // Configure Kestrel\n        builder.WebHost.ConfigureKestrel(serverOptions =&gt;\n        {\n            serverOptions.Limits.MaxRequestBodySize = 50 * 1024 * 1024; // 50MB\n        });\n    })\n    .BuildWebApplication();\n</code></pre>"},{"location":"advanced-usage/#custom-web-application-factory","title":"Custom Web Application Factory","text":"<pre><code>public class CustomWebApplicationFactory : IWebApplicationFactory\n{\n    public WebApplication Create(\n        CreateWebApplicationOptions options,\n        Func&lt;WebApplicationBuilder&gt; createWebApplicationBuilderCallback)\n    {\n        var builder = createWebApplicationBuilderCallback();\n\n        // Custom Kestrel configuration\n        builder.WebHost.ConfigureKestrel(serverOptions =&gt;\n        {\n            serverOptions.ListenAnyIP(5000, listenOptions =&gt;\n            {\n                listenOptions.Protocols = HttpProtocols.Http2;\n            });\n\n            serverOptions.ListenAnyIP(5001, listenOptions =&gt;\n            {\n                listenOptions.UseHttps();\n                listenOptions.Protocols = HttpProtocols.Http1AndHttp2;\n            });\n        });\n\n        // Custom service configuration\n        builder.Services.Configure&lt;KestrelServerOptions&gt;(options =&gt;\n        {\n            options.AllowSynchronousIO = true;\n        });\n\n        // Add custom configuration sources\n        builder.Configuration.AddJsonFile(\"custom-settings.json\", optional: true);\n        builder.Configuration.AddEnvironmentVariables(\"MYAPP_\");\n\n        // Custom logging\n        builder.Logging.ClearProviders();\n        builder.Logging.AddConsole();\n        builder.Logging.AddDebug();\n\n        var app = builder.Build();\n\n        // Custom middleware pipeline\n        if (app.Environment.IsDevelopment())\n        {\n            app.UseDeveloperExceptionPage();\n        }\n        else\n        {\n            app.UseExceptionHandler(\"/error\");\n            app.UseHsts();\n        }\n\n        app.UseHttpsRedirection();\n        app.UseResponseCompression();\n\n        return app;\n    }\n}\n\n// Usage\nvar webApp = new Syringe()\n    .ForWebApplication()\n    .UsingWebApplicationFactory&lt;CustomWebApplicationFactory&gt;()\n    .BuildWebApplication();\n</code></pre>"},{"location":"advanced-usage/#combining-configuration-methods","title":"Combining Configuration Methods","text":"<p>You can combine multiple configuration methods for maximum flexibility:</p> <pre><code>// With reflection and Scrutor\nvar webApp = new Syringe()\n    .UsingReflection()\n    .UsingScrutorTypeRegistrar()\n    .UsingAssemblyProvider(builder =&gt; builder\n        .MatchingAssemblies(x =&gt; x.Contains(\"MyApp\"))\n        .UseLibTestEntryOrdering()\n        .Build())\n    .ForWebApplication()\n    .UsingOptions(() =&gt; CreateWebApplicationOptions\n        .Default\n        .UsingStartupConsoleLogger()\n        .UsingApplicationName(\"MyApp\"))\n    .UsingConfigurationCallback((builder, options) =&gt;\n    {\n        // Fine-tune the configuration\n        builder.Configuration.SetBasePath(AppContext.BaseDirectory);\n        builder.Configuration.AddUserSecrets&lt;Program&gt;();\n\n        // Add services that plugins might depend on\n        builder.Services.AddSingleton&lt;IConfigurationValidator, ConfigurationValidator&gt;();\n    })\n    .BuildWebApplication();\n\n// With source generation\nvar webApp = new Syringe()\n    .UsingSourceGen()\n    .UsingAssemblyProvider(builder =&gt; builder\n        .MatchingAssemblies(x =&gt; x.Contains(\"MyApp\"))\n        .Build())\n    .ForWebApplication()\n    .UsingOptions(() =&gt; CreateWebApplicationOptions\n        .Default\n        .UsingStartupConsoleLogger())\n    .BuildWebApplication();\n</code></pre>"},{"location":"advanced-usage/#delayed-resolution","title":"Delayed Resolution","text":""},{"location":"advanced-usage/#lazy-service-resolution","title":"Lazy Service Resolution","text":"<pre><code>public class LazyServicePlugin : IServiceCollectionPlugin\n{\n    public void Configure(ServiceCollectionPluginOptions options)\n    {\n        // Register lazy wrapper for expensive services\n        options.Services.AddSingleton&lt;Lazy&lt;IExpensiveService&gt;&gt;(sp =&gt;\n            new Lazy&lt;IExpensiveService&gt;(() =&gt; \n                sp.GetRequiredService&lt;IExpensiveService&gt;()));\n\n        // Register the actual expensive service\n        options.Services.AddSingleton&lt;IExpensiveService, ExpensiveService&gt;();\n    }\n}\n\n// Usage in a consumer\npublic class ServiceConsumer\n{\n    private readonly Lazy&lt;IExpensiveService&gt; _expensiveService;\n\n    public ServiceConsumer(Lazy&lt;IExpensiveService&gt; expensiveService)\n    {\n        _expensiveService = expensiveService;\n    }\n\n    public void UseServiceIfNeeded(bool condition)\n    {\n        if (condition)\n        {\n            // Service is only instantiated when actually needed\n            _expensiveService.Value.DoExpensiveWork();\n        }\n    }\n}\n</code></pre>"},{"location":"advanced-usage/#testing-strategies","title":"Testing Strategies","text":""},{"location":"advanced-usage/#integration-testing-with-custom-configuration","title":"Integration Testing with Custom Configuration","text":"<pre><code>public class IntegrationTestBase\n{\n    protected IServiceProvider CreateServiceProvider(\n        Action&lt;Syringe&gt; configureSyringe = null)\n    {\n        var syringe = new Syringe()\n            .UsingReflection()  // Reflection often useful for testing flexibility\n            .UsingAssemblyProvider(builder =&gt; builder\n                .MatchingAssemblies(x =&gt; x.Contains(\"MyApp\"))\n                .Build())\n            .UsingConfiguration(config =&gt; config\n                .AddJsonFile(\"appsettings.test.json\")\n                .AddEnvironmentVariables(\"TEST_\"));\n\n        configureSyringe?.Invoke(syringe);\n\n        return syringe.BuildServiceProvider();\n    }\n}\n\npublic class ServiceIntegrationTests : IntegrationTestBase\n{\n    [Fact]\n    public void Service_WithTestConfiguration_WorksCorrectly()\n    {\n        // Arrange\n        var serviceProvider = CreateServiceProvider(syringe =&gt;\n            syringe.UsingPostPluginRegistrationCallback(services =&gt;\n            {\n                // Override specific services for testing\n                services.AddSingleton&lt;IExternalService, MockExternalService&gt;();\n            }));\n\n        // Act\n        var service = serviceProvider.GetRequiredService&lt;IMyService&gt;();\n        var result = service.DoWork();\n\n        // Assert\n        Assert.NotNull(result);\n    }\n}\n</code></pre>"},{"location":"advanced-usage/#troubleshooting","title":"Troubleshooting","text":""},{"location":"advanced-usage/#debugging-service-registration","title":"Debugging Service Registration","text":"<pre><code>public class DiagnosticPlugin : IPostBuildServiceCollectionPlugin\n{\n    public void Configure(PostBuildServiceCollectionPluginOptions options)\n    {\n        var services = options.Services;\n\n        // Log all registered services\n        foreach (var service in services)\n        {\n            options.Logger.LogDebug(\n                $\"Service: {service.ServiceType.Name}, \" +\n                $\"Implementation: {service.ImplementationType?.Name ?? \"Factory\"}, \" +\n                $\"Lifetime: {service.Lifetime}\");\n        }\n\n        // Verify critical services\n        var criticalServices = new[]\n        {\n            typeof(IConfiguration),\n            typeof(ILogger&lt;&gt;),\n            typeof(IServiceProvider)\n        };\n\n        foreach (var serviceType in criticalServices)\n        {\n            var service = options.ServiceProvider.GetService(serviceType);\n            if (service == null)\n            {\n                options.Logger.LogWarning($\"Critical service not registered: {serviceType.Name}\");\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"advanced-usage/#multi-project-solutions-with-source-generation","title":"Multi-Project Solutions with Source Generation","text":"<p>When using source generation with solutions containing many plugin projects, each project with internal types needs its own <code>[GenerateTypeRegistry]</code> attribute. For large solutions, you can use MSBuild conventions to reduce boilerplate.</p>"},{"location":"advanced-usage/#using-directorybuildprops","title":"Using Directory.Build.props","text":"<p>Create a <code>Directory.Build.props</code> file at your solution root to automatically generate a source file with the attribute for projects matching a naming convention:</p> <pre><code>&lt;!-- Directory.Build.props --&gt;\n&lt;Project&gt;\n\n  &lt;!-- Enable auto-generation for projects matching naming patterns --&gt;\n  &lt;PropertyGroup&gt;\n    &lt;NeedlrAutoGenerate Condition=\"$(MSBuildProjectName.EndsWith('.Plugin'))\"&gt;true&lt;/NeedlrAutoGenerate&gt;\n    &lt;NeedlrAutoGenerate Condition=\"$(MSBuildProjectName.EndsWith('.Plugins'))\"&gt;true&lt;/NeedlrAutoGenerate&gt;\n    &lt;NeedlrAutoGenerate Condition=\"$(MSBuildProjectName.EndsWith('Plugin'))\"&gt;true&lt;/NeedlrAutoGenerate&gt;\n  &lt;/PropertyGroup&gt;\n\n  &lt;!-- Or match by prefix --&gt;\n  &lt;PropertyGroup&gt;\n    &lt;NeedlrAutoGenerate Condition=\"$(MSBuildProjectName.StartsWith('MyCompany.'))\"&gt;true&lt;/NeedlrAutoGenerate&gt;\n  &lt;/PropertyGroup&gt;\n\n  &lt;!-- Set namespace prefix to project name by default --&gt;\n  &lt;PropertyGroup Condition=\"'$(NeedlrAutoGenerate)' == 'true'\"&gt;\n    &lt;NeedlrNamespacePrefix Condition=\"'$(NeedlrNamespacePrefix)' == ''\"&gt;$(MSBuildProjectName)&lt;/NeedlrNamespacePrefix&gt;\n  &lt;/PropertyGroup&gt;\n\n&lt;/Project&gt;\n</code></pre> <p>Then create a <code>Directory.Build.targets</code> file to generate the attribute:</p> <pre><code>&lt;!-- Directory.Build.targets --&gt;\n&lt;Project&gt;\n\n  &lt;Target Name=\"NeedlrGenerateTypeRegistryAttribute\" \n          BeforeTargets=\"CoreCompile\"\n          Condition=\"'$(NeedlrAutoGenerate)' == 'true'\"&gt;\n\n    &lt;PropertyGroup&gt;\n      &lt;_NeedlrGeneratedFile&gt;$(IntermediateOutputPath)NeedlrGeneratedTypeRegistry.g.cs&lt;/_NeedlrGeneratedFile&gt;\n    &lt;/PropertyGroup&gt;\n\n    &lt;WriteLinesToFile\n      File=\"$(_NeedlrGeneratedFile)\"\n      Lines=\"// Auto-generated by Directory.Build.targets;[assembly: NexusLabs.Needlr.Generators.GenerateTypeRegistry(IncludeNamespacePrefixes = new[] { &amp;quot;$(NeedlrNamespacePrefix)&amp;quot; })]\"\n      Overwrite=\"true\" /&gt;\n\n    &lt;ItemGroup&gt;\n      &lt;Compile Include=\"$(_NeedlrGeneratedFile)\" /&gt;\n    &lt;/ItemGroup&gt;\n\n  &lt;/Target&gt;\n\n&lt;/Project&gt;\n</code></pre>"},{"location":"advanced-usage/#solution-structure-example","title":"Solution Structure Example","text":"<pre><code>MySolution/\n\u251c\u2500\u2500 Directory.Build.props           # Naming convention rules\n\u251c\u2500\u2500 Directory.Build.targets         # Auto-generates attribute\n\u251c\u2500\u2500 MyCompany.App/                  # Host - explicit [GenerateTypeRegistry]\n\u2502   \u2514\u2500\u2500 GeneratorAssemblyInfo.cs    # Custom namespace prefixes\n\u251c\u2500\u2500 MyCompany.Auth.Plugin/          # Auto-generates \u2713\n\u251c\u2500\u2500 MyCompany.Caching.Plugin/       # Auto-generates \u2713\n\u251c\u2500\u2500 MyCompany.Logging.Plugin/       # Auto-generates \u2713\n\u2514\u2500\u2500 ... more plugins                # All auto-generate \u2713\n</code></pre>"},{"location":"advanced-usage/#opting-out-specific-projects","title":"Opting Out Specific Projects","text":"<p>To exclude a specific project from auto-generation, add to its <code>.csproj</code>:</p> <pre><code>&lt;PropertyGroup&gt;\n  &lt;NeedlrAutoGenerate&gt;false&lt;/NeedlrAutoGenerate&gt;\n&lt;/PropertyGroup&gt;\n</code></pre>"},{"location":"advanced-usage/#custom-namespace-prefix-per-project","title":"Custom Namespace Prefix Per Project","text":"<p>Override the default namespace prefix in a specific project:</p> <pre><code>&lt;PropertyGroup&gt;\n  &lt;NeedlrNamespacePrefix&gt;MyCompany.CustomNamespace&lt;/NeedlrNamespacePrefix&gt;\n&lt;/PropertyGroup&gt;\n</code></pre>"},{"location":"advanced-usage/#why-this-matters","title":"Why This Matters","text":"<p>When plugin projects contain internal types, the host application's generator cannot access them. Each plugin must generate its own type registry. Without the MSBuild convention approach, you would need to manually add <code>[GenerateTypeRegistry]</code> to every plugin project.</p> <p>The generator emits error <code>NDLRGEN002</code> if it detects internal plugin types in a referenced assembly without <code>[GenerateTypeRegistry]</code>, helping you identify projects that need the attribute.</p>"},{"location":"advanced-usage/#assembly-loading-control","title":"Assembly Loading Control","text":""},{"location":"advanced-usage/#automatic-assembly-loading","title":"Automatic Assembly Loading","text":"<p>When using source generation, Needlr automatically discovers all referenced assemblies that have <code>[GenerateTypeRegistry]</code> and ensures they are loaded at startup. This is critical because:</p> <ul> <li>Module initializers only run when an assembly is loaded - If your code never directly references a type from an assembly, that assembly never loads</li> <li>Transitive dependencies - Plugin assemblies referenced by your project but never directly used in code would be invisible to the type registry</li> </ul> <p>Needlr solves this by generating a <code>ForceLoadReferencedAssemblies()</code> method that uses <code>typeof()</code> to force assembly loading:</p> <pre><code>// Generated in NeedlrSourceGenBootstrap.g.cs\n[MethodImpl(MethodImplOptions.NoInlining)]\nprivate static void ForceLoadReferencedAssemblies()\n{\n    _ = typeof(global::MyApp.Features.Logging.Generated.TypeRegistry).Assembly;\n    _ = typeof(global::MyApp.Features.Scheduling.Generated.TypeRegistry).Assembly;\n    // ... all discovered assemblies with [GenerateTypeRegistry]\n}\n</code></pre> <p>This is fully AOT-compatible - <code>typeof()</code> is resolved at compile time.</p>"},{"location":"advanced-usage/#controlling-assembly-load-order-with-needlrassemblyorder","title":"Controlling Assembly Load Order with [NeedlrAssemblyOrder]","text":"<p>By default, referenced assemblies are loaded in alphabetical order. If you need specific assemblies to load before or after others (e.g., when plugins have dependencies on other plugins being registered first), use the <code>[NeedlrAssemblyOrder]</code> attribute:</p> <pre><code>using NexusLabs.Needlr.Generators;\n\n// In your host application's assembly attributes\n[assembly: GenerateTypeRegistry]\n[assembly: NeedlrAssemblyOrder(\n    First = new[] { \"MyApp.Features.Logging\", \"MyApp.Features.Configuration\" },\n    Last = new[] { \"MyApp.Features.Health\" })]\n</code></pre> <p>How ordering works: 1. Assemblies in <code>First</code> are loaded first, in the order specified 2. All other discovered assemblies are loaded alphabetically 3. Assemblies in <code>Last</code> are loaded last, in the order specified</p> <p>Example scenario: Your <code>AuthenticationPlugin</code> needs <code>ILogger</code> which is registered by <code>LoggingPlugin</code>:</p> <pre><code>[assembly: GenerateTypeRegistry]\n[assembly: NeedlrAssemblyOrder(\n    First = new[] { \"MyApp.Features.Logging\" })]  // Logging loads first\n\nnamespace MyApp.Bootstrap;\n\npublic class Startup\n{\n    // AuthenticationPlugin can now safely depend on ILogger being registered\n}\n</code></pre>"},{"location":"advanced-usage/#when-you-dont-need-assembly-order","title":"When You Don't Need Assembly Order","text":"<p>You typically don't need <code>[NeedlrAssemblyOrder]</code> when:</p> <ul> <li>Plugins don't have inter-dependencies during registration</li> <li>You're using the default registration which handles most scenarios</li> <li>All plugin configuration happens at runtime (not during registration)</li> </ul> <p>You DO need <code>[NeedlrAssemblyOrder]</code> when:</p> <ul> <li>A plugin's <code>Configure()</code> method calls <code>GetRequiredService&lt;T&gt;()</code> and <code>T</code> is registered by another plugin</li> <li>You have strict initialization order requirements</li> <li>Debugging issues where plugins fail because their dependencies aren't registered yet</li> </ul>"},{"location":"advanced-usage/#working-with-other-source-generators","title":"Working with Other Source Generators","text":"<p>When using Needlr with other source generators that modify your types (such as generators that add constructors to partial classes), you may encounter scenarios where Needlr's generator cannot see the constructor that will be added by another generator.</p>"},{"location":"advanced-usage/#the-problem","title":"The Problem","text":"<p>Source generators in .NET run in isolation - they cannot see each other's output. If you have a partial class like:</p> <pre><code>// Your code - another generator will add a constructor\n[CacheProvider(\"EngageFeed\")]  // Triggers CacheProviderGenerator\npublic partial class EngageFeedCacheProvider { }\n\n// CacheProviderGenerator produces:\npublic sealed partial class EngageFeedCacheProvider(ICacheProvider _cacheProvider) { }\n</code></pre> <p>Needlr's generator sees only your original declaration without the constructor, so it would generate an incorrect factory:</p> <pre><code>// Wrong! Missing the ICacheProvider dependency\nsp =&gt; new EngageFeedCacheProvider()\n</code></pre>"},{"location":"advanced-usage/#solution-the-defertocontainer-attribute","title":"Solution: The DeferToContainer Attribute","text":"<p>Use <code>[DeferToContainer]</code> to explicitly declare the constructor parameter types that another generator will add. Needlr will use these types to generate the correct factory:</p> <pre><code>using NexusLabs.Needlr;\n\n// Declare the expected constructor parameters\n[DeferToContainer(typeof(ICacheProvider))]\n[CacheProvider(\"EngageFeed\")]\npublic partial class EngageFeedCacheProvider { }\n</code></pre> <p>Needlr now generates the correct factory:</p> <pre><code>// Correct! Resolves ICacheProvider from the container\nsp =&gt; new EngageFeedCacheProvider(\n    sp.GetRequiredService&lt;ICacheProvider&gt;())\n</code></pre>"},{"location":"advanced-usage/#multiple-dependencies","title":"Multiple Dependencies","text":"<p>You can declare multiple constructor parameters in order:</p> <pre><code>[DeferToContainer(\n    typeof(ICacheProvider), \n    typeof(ILogger&lt;EngageFeedCacheProvider&gt;),\n    typeof(IOptions&lt;CacheOptions&gt;))]\n[CacheProvider(\"EngageFeed\")]\npublic partial class EngageFeedCacheProvider { }\n</code></pre> <p>This generates:</p> <pre><code>sp =&gt; new EngageFeedCacheProvider(\n    sp.GetRequiredService&lt;ICacheProvider&gt;(),\n    sp.GetRequiredService&lt;ILogger&lt;EngageFeedCacheProvider&gt;&gt;(),\n    sp.GetRequiredService&lt;IOptions&lt;CacheOptions&gt;&gt;())\n</code></pre>"},{"location":"advanced-usage/#parameterless-constructor-override","title":"Parameterless Constructor Override","text":"<p>Use <code>[DeferToContainer]</code> without parameters if the other generator will add a parameterless constructor or you want to ensure Needlr doesn't inspect the actual constructors:</p> <pre><code>[DeferToContainer]  // Empty - no constructor parameters\n[SomeOtherGeneratorAttribute]\npublic partial class SimpleService { }\n</code></pre>"},{"location":"advanced-usage/#compile-time-validation","title":"Compile-Time Validation","text":"<p>If the declared parameter types don't match the actual generated constructor, the build will fail with a compile error. This provides compile-time safety - you'll know immediately if the other generator changes its output.</p>"},{"location":"advanced-usage/#critical-the-attribute-must-be-in-your-original-source","title":"\u26a0\ufe0f Critical: The Attribute Must Be in Your Original Source","text":"<p>The <code>[DeferToContainer]</code> attribute MUST be placed on your original partial class declaration - NOT in generated code.</p> <p>Source generators run in isolation and cannot see output from other generators. If another generator adds <code>[DeferToContainer]</code> to its generated output, Needlr's generator will never see it.</p> <pre><code>// \u274c WRONG - Placing attribute in generated code doesn't work!\n// CacheProviderGenerator.g.cs (GENERATED FILE)\n[DeferToContainer(typeof(ICacheProvider))]  // Needlr can't see this!\npublic sealed partial class EngageFeedCacheProvider(ICacheProvider _cacheProvider) { }\n\n// \u2705 CORRECT - Place attribute in your original source file\n// EngageFeedCacheProvider.cs (YOUR FILE)\n[DeferToContainer(typeof(ICacheProvider))]  // Needlr sees this!\n[CacheProvider(\"EngageFeed\")]\npublic partial class EngageFeedCacheProvider { }\n</code></pre> <p>The analyzer <code>NDLRCOR003</code> will detect and report an error if it finds <code>[DeferToContainer]</code> in generated code. See the NDLRCOR003 documentation for more details.</p>"},{"location":"advanced-usage/#when-to-use-defertocontainer","title":"When to Use DeferToContainer","text":"<p>Use <code>[DeferToContainer]</code> when:</p> <ol> <li>Another source generator adds a constructor to your partial class</li> <li>The constructor has dependencies that need to be resolved from DI</li> <li>You're using source generation (<code>.UsingSourceGen()</code>) - reflection-based discovery doesn't have this limitation</li> </ol> <p>You do NOT need <code>[DeferToContainer]</code> when:</p> <ol> <li>Using <code>.UsingReflection()</code> - it discovers constructors at runtime</li> <li>Your class has an explicit constructor in your source code</li> <li>The other generator doesn't add constructor parameters</li> </ol>"},{"location":"advanced-usage/#example-fusioncache-integration","title":"Example: FusionCache Integration","text":"<p>Here's a complete example integrating with a hypothetical <code>CacheProviderGenerator</code>:</p> <pre><code>// In your cache providers project\nnamespace MyApp.Caching;\n\npublic interface ICacheProvider { }\n\n// The CacheProviderGenerator will add:\n// public sealed partial class EngageFeedCacheProvider(ICacheProvider _cacheProvider)\n\n[DeferToContainer(typeof(ICacheProvider))]\n[CacheProvider(\"EngageFeed\")]\npublic partial class EngageFeedCacheProvider { }\n\n[DeferToContainer(typeof(ICacheProvider), typeof(ILogger&lt;UserProfileCacheProvider&gt;))]\n[CacheProvider(\"UserProfile\")]\npublic partial class UserProfileCacheProvider { }\n</code></pre> <pre><code>// In your host application\nvar app = new Syringe()\n    .UsingSourceGen()\n    .ForWebApplication()\n    .BuildWebApplication();\n\n// Both cache providers are correctly registered with their dependencies resolved\n</code></pre>"},{"location":"advanced-usage/#debugging-service-registrations","title":"Debugging Service Registrations","text":"<p>Needlr provides diagnostic tools to help you understand and debug your service registrations.</p>"},{"location":"advanced-usage/#dumping-all-registrations","title":"Dumping All Registrations","text":"<p>Use the <code>Dump()</code> extension method to get a formatted view of all registrations:</p> <pre><code>using NexusLabs.Needlr;\n\nvar services = new ServiceCollection();\nservices.AddTransient&lt;IMyService, MyService&gt;();\nservices.AddSingleton&lt;ICache, MemoryCache&gt;();\nservices.AddScoped&lt;IDbContext, AppDbContext&gt;();\n\n// Dump all registrations to console\nConsole.WriteLine(services.Dump());\n</code></pre> <p>Output: <pre><code>\u2550\u2550\u2550 Service Registrations (3 registrations) \u2550\u2550\u2550\n\n\u250c\u2500 ICache\n\u2502  Lifetime: Singleton\n\u2502  Implementation: MemoryCache\n\u2514\u2500\n\n\u250c\u2500 IDbContext\n\u2502  Lifetime: Scoped\n\u2502  Implementation: AppDbContext\n\u2514\u2500\n\n\u250c\u2500 IMyService\n\u2502  Lifetime: Transient\n\u2502  Implementation: MyService\n\u2514\u2500\n</code></pre></p>"},{"location":"advanced-usage/#filtering-and-grouping","title":"Filtering and Grouping","text":"<p>Use <code>DumpOptions</code> to filter and organize the output:</p> <pre><code>// Only show singletons\nConsole.WriteLine(services.Dump(new DumpOptions \n{ \n    LifetimeFilter = ServiceLifetime.Singleton \n}));\n\n// Group by lifetime\nConsole.WriteLine(services.Dump(new DumpOptions \n{ \n    GroupByLifetime = true \n}));\n\n// Filter by service type\nConsole.WriteLine(services.Dump(new DumpOptions \n{ \n    ServiceTypeFilter = t =&gt; t.Namespace?.Contains(\"MyApp\") == true \n}));\n</code></pre>"},{"location":"advanced-usage/#detailed-registration-info","title":"Detailed Registration Info","text":"<p>Get detailed information about a specific registration:</p> <pre><code>var registrations = services.GetServiceRegistrations();\nforeach (var reg in registrations)\n{\n    Console.WriteLine(reg.ToDetailedString());\n}\n</code></pre>"},{"location":"advanced-usage/#dumping-from-serviceprovider","title":"Dumping from ServiceProvider","text":"<p>You can also dump from a built service provider (requires <code>IServiceCollection</code> to be registered):</p> <pre><code>var provider = new Syringe()\n    .UsingSourceGen()\n    .BuildServiceProvider();\n\n// Needlr automatically registers IServiceCollection, so Dump() works\nConsole.WriteLine(provider.Dump());\n</code></pre>"},{"location":"advanced-usage/#container-verification","title":"Container Verification","text":"<p>Needlr provides verification APIs to detect common configuration issues at startup.</p>"},{"location":"advanced-usage/#detecting-lifetime-mismatches","title":"Detecting Lifetime Mismatches","text":"<p>A lifetime mismatch (also called \"captive dependency\") occurs when a longer-lived service depends on a shorter-lived service. For example, a Singleton that depends on a Scoped service will \"capture\" that scoped instance, causing it to live for the entire application lifetime instead of the intended scope.</p> <pre><code>using NexusLabs.Needlr;\n\nvar services = new ServiceCollection();\nservices.AddScoped&lt;IDbContext, AppDbContext&gt;();        // Scoped\nservices.AddSingleton&lt;ICacheService, CacheService&gt;();  // Singleton depends on IDbContext\n\n// Detect mismatches\nvar mismatches = services.DetectLifetimeMismatches();\n\nforeach (var mismatch in mismatches)\n{\n    Console.WriteLine(mismatch.ToDetailedString());\n}\n</code></pre> <p>Output: <pre><code>\u250c\u2500 Lifetime Mismatch\n\u2502  ICacheService (Singleton)\n\u2502    \u2514\u2500 depends on \u2500\u25b6 IDbContext (Scoped)\n\u2502\n\u2502  Problem: Singleton service will capture Scoped dependency\n\u2502  Fix: Change ICacheService to Scoped,\n\u2502       or change IDbContext to Singleton,\n\u2502       or inject IServiceScopeFactory instead.\n\u2514\u2500\n</code></pre></p>"},{"location":"advanced-usage/#lifetime-hierarchy","title":"Lifetime Hierarchy","text":"<p>From longest to shortest lifetime: 1. Singleton - Lives for entire application lifetime 2. Scoped - Lives for the scope/request lifetime 3. Transient - New instance every time</p> <p>A mismatch is detected when a service depends on another with a shorter lifetime: - \u274c Singleton \u2192 Scoped (mismatch) - \u274c Singleton \u2192 Transient (mismatch) - \u274c Scoped \u2192 Transient (mismatch) - \u2705 Scoped \u2192 Singleton (ok) - \u2705 Transient \u2192 anything (ok)</p>"},{"location":"advanced-usage/#automatic-verification-with-verify","title":"Automatic Verification with Verify()","text":"<p>Use the <code>Verify()</code> extension method to automatically detect and handle issues:</p> <pre><code>// Throws ContainerVerificationException on issues (strict mode)\nservices.Verify(VerificationOptions.Strict);\n\n// Warns to console but doesn't throw (default behavior)\nservices.Verify();\n\n// Disable verification (silent mode)\nservices.Verify(VerificationOptions.Disabled);\n\n// Custom configuration\nservices.Verify(new VerificationOptions\n{\n    LifetimeMismatchBehavior = VerificationBehavior.Throw,\n    CircularDependencyBehavior = VerificationBehavior.Warn,\n    IssueReporter = issue =&gt; logger.LogWarning(issue.Message)\n});\n</code></pre>"},{"location":"advanced-usage/#getting-detailed-diagnostics","title":"Getting Detailed Diagnostics","text":"<p>Use <code>VerifyWithDiagnostics()</code> to get a result object instead of throwing:</p> <pre><code>var result = services.VerifyWithDiagnostics();\n\nif (!result.IsValid)\n{\n    Console.WriteLine(result.ToDetailedReport());\n    // \u274c Container verification found 2 issue(s):\n    // \n    // [LifetimeMismatch] Lifetime mismatch: ICacheService (Singleton) depends on IDbContext (Scoped)\n    // ...\n}\n\n// Or throw if needed\nresult.ThrowIfInvalid();\n</code></pre>"},{"location":"advanced-usage/#compile-time-detection","title":"Compile-Time Detection","text":"<p>Needlr includes Roslyn analyzers that detect issues at compile time:</p> <ul> <li>NDLRCOR005: Lifetime mismatch warnings</li> <li>NDLRCOR006: Circular dependency errors</li> </ul> <p>These analyzers work with Needlr's registration attributes (<code>[Singleton]</code>, <code>[Scoped]</code>, <code>[Transient]</code>, <code>[RegisterAs]</code>).</p>"},{"location":"benchmarks/","title":"Benchmarks","text":"<p>Performance comparison between source-generated and reflection-based dependency injection.</p> <p>Key Takeaway</p> <p>Source generation provides faster container build times compared to reflection. Service resolution performance is identical once the container is built.</p>"},{"location":"benchmarks/#results","title":"Results","text":"<p>Loading benchmark results...</p>"},{"location":"benchmarks/#running-benchmarks-locally","title":"Running Benchmarks Locally","text":"<pre><code>cd src/NexusLabs.Needlr.Benchmarks\ndotnet run -c Release -- --filter '*Build*'\n</code></pre> <p>To run all benchmarks:</p> <pre><code>dotnet run -c Release -- --filter '*'\n</code></pre>"},{"location":"benchmarks/#ci-integration","title":"CI Integration","text":"<p>Benchmarks run automatically:</p> <ul> <li>Weekly: Every Sunday at 3am UTC (if code has changed)</li> <li>On-demand: Via workflow dispatch</li> </ul> <p>Results are published to this page after each run.</p>"},{"location":"benchmarks/#methodology","title":"Methodology","text":"<p>All benchmarks use BenchmarkDotNet with:</p> <ul> <li>ShortRun job: 3 warmup iterations, 3 target iterations</li> <li>Memory diagnostics: Tracks allocations per operation</li> <li>Baseline comparison: Reflection is always the baseline</li> </ul> <p>Each benchmark class follows strict rules:</p> <ol> <li>One baseline per class (reflection approach)</li> <li>All methods in a class compare the same scenario</li> <li>Benchmark methods contain only what needs to be measured</li> </ol>"},{"location":"breadcrumbs/","title":"Breadcrumb Documentation","text":"<p>Needlr's source generator can include helpful documentation comments (breadcrumbs) in generated code to help developers understand why and how code was generated. This is particularly useful for debugging, learning, and working with AI assistants.</p>"},{"location":"breadcrumbs/#overview","title":"Overview","text":"<p>Breadcrumbs are self-documenting comments embedded in generated source code that explain: - What triggered the code generation - Source file locations of discovered types - Lifetime configurations (Singleton, Scoped, Transient) - Interceptor chains and their execution order - Decorator chains and their order</p>"},{"location":"breadcrumbs/#breadcrumb-levels","title":"Breadcrumb Levels","text":"<p>Needlr supports three breadcrumb levels:</p> Level Description Use Case <code>None</code> Only <code>// &lt;auto-generated/&gt;</code> header Production builds where file size matters <code>Minimal</code> Brief inline comments (default) Normal development <code>Verbose</code> Full context boxes with source paths Debugging or learning how generation works"},{"location":"breadcrumbs/#configuration","title":"Configuration","text":"<p>Set the breadcrumb level using the <code>NeedlrBreadcrumbLevel</code> MSBuild property.</p>"},{"location":"breadcrumbs/#per-project-configuration","title":"Per-Project Configuration","text":"<p>In your <code>.csproj</code> file:</p> <pre><code>&lt;PropertyGroup&gt;\n  &lt;NeedlrBreadcrumbLevel&gt;Verbose&lt;/NeedlrBreadcrumbLevel&gt;\n&lt;/PropertyGroup&gt;\n</code></pre>"},{"location":"breadcrumbs/#solution-wide-configuration","title":"Solution-Wide Configuration","text":"<p>In a <code>Directory.Build.props</code> file at your solution root:</p> <pre><code>&lt;Project&gt;\n  &lt;PropertyGroup&gt;\n    &lt;NeedlrBreadcrumbLevel&gt;Verbose&lt;/NeedlrBreadcrumbLevel&gt;\n  &lt;/PropertyGroup&gt;\n\n  &lt;!-- Import Needlr generator props --&gt;\n  &lt;Import Project=\"$(MSBuildThisFileDirectory)../packages/nexuslabs.needlr.generators/*/build/NexusLabs.Needlr.Generators.props\" \n          Condition=\"Exists('$(MSBuildThisFileDirectory)../packages/nexuslabs.needlr.generators')\" /&gt;\n&lt;/Project&gt;\n</code></pre>"},{"location":"breadcrumbs/#inheritance-and-overrides","title":"Inheritance and Overrides","text":"<p>Child projects automatically inherit the breadcrumb level from parent <code>Directory.Build.props</code> files. Individual projects can override the inherited setting:</p> <pre><code>Solution/\n\u251c\u2500\u2500 Directory.Build.props          # Sets NeedlrBreadcrumbLevel=Minimal (inherited by all)\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 MyApp/\n\u2502   \u2502   \u2514\u2500\u2500 MyApp.csproj           # Inherits Minimal\n\u2502   \u2514\u2500\u2500 MyApp.Debug/\n\u2502       \u2514\u2500\u2500 MyApp.Debug.csproj     # Can override to Verbose\n</code></pre>"},{"location":"breadcrumbs/#output-examples","title":"Output Examples","text":""},{"location":"breadcrumbs/#none-level","title":"None Level","text":"<pre><code>// &lt;auto-generated/&gt;\n#nullable enable\n\nusing System;\nusing System.Collections.Generic;\n\nnamespace MyApp.Generated\n{\n    public static class TypeRegistry\n    {\n        private static readonly InjectableTypeInfo[] _types = new InjectableTypeInfo[]\n        {\n            new InjectableTypeInfo(typeof(global::MyApp.MyService), new Type[] { typeof(global::MyApp.IMyService) }, InjectableLifetime.Singleton),\n        };\n        // ... rest of generated code\n    }\n}\n</code></pre>"},{"location":"breadcrumbs/#minimal-level-default","title":"Minimal Level (Default)","text":"<pre><code>// &lt;auto-generated/&gt;\n#nullable enable\n\nusing System;\nusing System.Collections.Generic;\n\nnamespace MyApp.Generated\n{\n    public static class TypeRegistry\n    {\n        // Injectable types discovered in this assembly\n        private static readonly InjectableTypeInfo[] _types = new InjectableTypeInfo[]\n        {\n            // MyService -&gt; IMyService (Singleton)\n            new InjectableTypeInfo(typeof(global::MyApp.MyService), new Type[] { typeof(global::MyApp.IMyService) }, InjectableLifetime.Singleton),\n        };\n        // ... rest of generated code\n    }\n}\n</code></pre>"},{"location":"breadcrumbs/#verbose-level","title":"Verbose Level","text":"<pre><code>// &lt;auto-generated/&gt;\n// \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n// Needlr Type Registry\n// Assembly: MyApp\n// Breadcrumb Level: Verbose\n// \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n#nullable enable\n\nusing System;\nusing System.Collections.Generic;\n\nnamespace MyApp.Generated\n{\n    public static class TypeRegistry\n    {\n        // \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        // \u2502 Injectable Types                                                        \u2502\n        // \u2502 Total types discovered: 1                                               \u2502\n        // \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        private static readonly InjectableTypeInfo[] _types = new InjectableTypeInfo[]\n        {\n            // \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            // \u2502 Type: MyService                                                         \u2502\n            // \u2502 Source: Services/MyService.cs                                           \u2502\n            // \u2502 Implements: IMyService                                                  \u2502\n            // \u2502 Lifetime: Singleton                                                     \u2502\n            // \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            new InjectableTypeInfo(typeof(global::MyApp.MyService), new Type[] { typeof(global::MyApp.IMyService) }, InjectableLifetime.Singleton),\n        };\n        // ... rest of generated code\n    }\n}\n</code></pre>"},{"location":"breadcrumbs/#interceptor-proxy-documentation","title":"Interceptor Proxy Documentation","text":"<p>When using interceptors, verbose breadcrumbs provide detailed information about proxy classes:</p> <pre><code>// \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n// \u2502 Interceptor Proxy: OrderService                                         \u2502\n// \u2502 Source: Services/OrderService.cs                                        \u2502\n// \u2502 Target Interface: IOrderService                                         \u2502\n// \u2502 Interceptors (execution order):                                         \u2502\n// \u2502   1. LoggingInterceptor                                                 \u2502\n// \u2502   2. CachingInterceptor                                                 \u2502\n// \u2502   3. ValidationInterceptor                                              \u2502\n// \u2502 Methods proxied: GetOrder, ProcessOrder, GetOrderAsync                  \u2502\n// \u2502 Methods forwarded: ToString, GetHashCode                                \u2502\n// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\npublic sealed class OrderService_InterceptorProxy : IOrderService\n{\n    // ... generated proxy implementation\n}\n</code></pre>"},{"location":"breadcrumbs/#source-path-resolution","title":"Source Path Resolution","text":"<p>Verbose breadcrumbs show source file paths relative to the project directory:</p> Scenario Path Display File in project <code>Services/MyService.cs</code> File in subfolder <code>Domain/Entities/Order.cs</code> External assembly <code>[AssemblyName]</code> Unknown location <code>[unknown]</code>"},{"location":"breadcrumbs/#best-practices","title":"Best Practices","text":"<ol> <li>Development: Use <code>Minimal</code> (default) for day-to-day development</li> <li>Debugging: Switch to <code>Verbose</code> when troubleshooting generated code issues</li> <li>CI/CD: Consider <code>None</code> for release builds to minimize generated file size</li> <li>Learning: Use <code>Verbose</code> when first learning how Needlr's generator works</li> </ol>"},{"location":"breadcrumbs/#configuration-in-cicd","title":"Configuration in CI/CD","text":"<p>You can set the breadcrumb level based on build configuration:</p> <pre><code>&lt;PropertyGroup Condition=\"'$(Configuration)' == 'Release'\"&gt;\n  &lt;NeedlrBreadcrumbLevel&gt;None&lt;/NeedlrBreadcrumbLevel&gt;\n&lt;/PropertyGroup&gt;\n\n&lt;PropertyGroup Condition=\"'$(Configuration)' == 'Debug'\"&gt;\n  &lt;NeedlrBreadcrumbLevel&gt;Verbose&lt;/NeedlrBreadcrumbLevel&gt;\n&lt;/PropertyGroup&gt;\n</code></pre>"},{"location":"breadcrumbs/#troubleshooting","title":"Troubleshooting","text":""},{"location":"breadcrumbs/#breadcrumbs-not-appearing","title":"Breadcrumbs Not Appearing","text":"<ol> <li>Ensure <code>NexusLabs.Needlr.Generators</code> package is referenced</li> <li>Verify the <code>.props</code> file is being imported (check build output)</li> <li>Rebuild the project (breadcrumb level is read at generation time)</li> </ol>"},{"location":"breadcrumbs/#case-sensitivity","title":"Case Sensitivity","text":"<p>The breadcrumb level value is case-insensitive: - <code>Verbose</code>, <code>verbose</code>, <code>VERBOSE</code>, <code>VeRbOsE</code> all work the same</p>"},{"location":"breadcrumbs/#invalid-values","title":"Invalid Values","text":"<p>If an invalid value is specified, Needlr defaults to <code>Minimal</code>: - <code>InvalidLevel</code> \u2192 defaults to <code>Minimal</code> - Empty string \u2192 defaults to <code>Minimal</code> - Whitespace only \u2192 defaults to <code>Minimal</code></p>"},{"location":"breadcrumbs/#compile-time-diagnostics","title":"Compile-Time Diagnostics","text":"<p>In addition to inline breadcrumbs, Needlr can generate separate diagnostic files at build time. These files provide higher-level views of your dependency injection configuration without cluttering your generated code.</p>"},{"location":"breadcrumbs/#enabling-diagnostics","title":"Enabling Diagnostics","text":"<p>Add the <code>NeedlrDiagnostics</code> property to your project:</p> <pre><code>&lt;PropertyGroup&gt;\n  &lt;NeedlrDiagnostics&gt;true&lt;/NeedlrDiagnostics&gt;\n&lt;/PropertyGroup&gt;\n</code></pre> <p>This generates three markdown files in your build output folder (e.g., <code>bin/Debug/net10.0/NeedlrDiagnostics/</code>):</p> File Description <code>DependencyGraph.md</code> Mermaid diagram showing service dependencies <code>LifetimeSummary.md</code> Breakdown of Singleton/Scoped/Transient registrations <code>RegistrationIndex.md</code> Complete index of all services, decorators, and plugins"},{"location":"breadcrumbs/#custom-output-path","title":"Custom Output Path","text":"<p>Specify a custom output directory (relative paths are resolved from the project directory):</p> <pre><code>&lt;PropertyGroup&gt;\n  &lt;NeedlrDiagnostics&gt;true&lt;/NeedlrDiagnostics&gt;\n  &lt;NeedlrDiagnosticsPath&gt;docs/diagnostics&lt;/NeedlrDiagnosticsPath&gt;\n&lt;/PropertyGroup&gt;\n</code></pre>"},{"location":"breadcrumbs/#filtering-types","title":"Filtering Types","text":"<p>Filter diagnostics to specific types (comma-separated fully qualified names):</p> <pre><code>&lt;PropertyGroup&gt;\n  &lt;NeedlrDiagnostics&gt;true&lt;/NeedlrDiagnostics&gt;\n  &lt;NeedlrDiagnosticsFilter&gt;MyApp.OrderService,MyApp.PaymentService&lt;/NeedlrDiagnosticsFilter&gt;\n&lt;/PropertyGroup&gt;\n</code></pre>"},{"location":"breadcrumbs/#example-output","title":"Example Output","text":""},{"location":"breadcrumbs/#dependencygraphmd","title":"DependencyGraph.md","text":"<p>The dependency graph now includes rich visualization sections:</p> <pre><code># Needlr Dependency Graph\n\nGenerated: 2026-01-25 10:00:00 UTC\nAssembly: MyApp\n\n## Referenced Plugin Assemblies\n\nTypes from referenced assemblies with `[GenerateTypeRegistry]`:\n\n### MyApp.Plugins\n\n\\`\\`\\`mermaid\ngraph TD\n    subgraph Singleton[\"MyApp.Plugins - Singleton\"]\n        OrderHandler[\"OrderHandler\"]\n        PaymentHandler[\"PaymentHandler\"]\n        Connection{{\"Connection\"}}\n        ConnectionFactory[\"ConnectionFactory\"]\n    end\n    PaymentHandler --&gt; OrderHandler\n    ConnectionFactory -.-&gt;|produces| Connection\n\\`\\`\\`\n\n| Service | Lifetime | Interfaces |\n|---------|----------|------------|\n| OrderHandler | Singleton | IHandler&lt;Order&gt; |\n| PaymentHandler | Singleton | IHandler&lt;Payment&gt; |\n| Connection | Singleton | IConnection |\n| ConnectionFactory | Singleton | IConnectionFactory |\n\n## Service Dependencies\n\n\\`\\`\\`mermaid\ngraph TD\n    subgraph Singleton\n        Logger[\"Logger\"]\n        ConfigService[\"ConfigService\"]\n    end\n    subgraph Scoped\n        OrderService[\"OrderService\"]\n    end\n    OrderService --&gt; Logger\n    OrderService --&gt; ConfigService\n\\`\\`\\`\n\n## Decorator Chains\n\nShows decorator wrapping order from outermost to innermost:\n\n\\`\\`\\`mermaid\ngraph LR\n    CachingDecorator[[\"CachingDecorator\"]] --&gt; LoggingDecorator[[\"LoggingDecorator\"]] --&gt; OrderService[\"OrderService\"]\n\\`\\`\\`\n\n## Keyed Services\n\nGroups services by their `[Keyed]` attribute values:\n\n\\`\\`\\`mermaid\ngraph TD\n    subgraph key_redis[\"redis\"]\n        RedisCache[\"RedisCache\"]\n    end\n    subgraph key_memory[\"memory\"]\n        MemoryCache[\"MemoryCache\"]\n    end\n\\`\\`\\`\n\n## Plugin Assemblies\n\nShows plugins grouped by their source assembly:\n\n\\`\\`\\`mermaid\ngraph TD\n    subgraph asm_MyApp_Plugins[\"MyApp.Plugins\"]\n        OrderPlugin([\"OrderPlugin\"])\n        PaymentPlugin([\"PaymentPlugin\"])\n    end\n\\`\\`\\`\n\n## Factory Services\n\nShows all factory\u2192product relationships from host and referenced assemblies:\n\n\\`\\`\\`mermaid\ngraph LR\n    ConnectionFactory[\"ConnectionFactory\"]\n    Connection{{\"Connection\"}}\n    ConnectionFactory -.-&gt;|produces| Connection\n    HttpClientFactory[\"HttpClientFactory\"]\n    HttpClient{{\"HttpClient\"}}\n    HttpClientFactory -.-&gt;|produces| HttpClient\n\\`\\`\\`\n\n&gt; Note: This section aggregates factories from the host assembly and all referenced plugin assemblies\n&gt; with `[GenerateTypeRegistry]`. Hexagon shapes indicate factory-produced types.\n\n## Interface Mapping\n\nShows interface-to-implementation relationships with dotted edges:\n\n\\`\\`\\`mermaid\ngraph LR\n    IOrderService((\"IOrderService\")) -.-&gt; OrderService[\"OrderService\"]\n    ILogger((\"ILogger\")) -.-&gt; Logger[\"Logger\"]\n\\`\\`\\`\n\n## Complexity Metrics\n\n| Metric | Value |\n|--------|-------|\n| Total Services | 15 |\n| Max Dependency Depth | 4 |\n| Hub Services (\u22653 dependents) | 2 |\n\n**Hub Services:** Logger (8), ConfigService (5)\n\n## Dependency Details\n\n| Service | Lifetime | Dependencies |\n|---------|----------|--------------|\n| Logger | Singleton | - |\n| OrderService | Scoped | ILogger, IConfigService |\n</code></pre>"},{"location":"breadcrumbs/#lifetimesummarymd","title":"LifetimeSummary.md","text":"<pre><code># Needlr Lifetime Summary\n\nGenerated: 2026-01-25 10:00:00 UTC\nAssembly: MyApp\n\n| Lifetime | Count | Percentage |\n|----------|-------|------------|\n| Singleton | 5 | 50.0% |\n| Scoped | 3 | 30.0% |\n| Transient | 2 | 20.0% |\n| **Total** | **10** | **100%** |\n</code></pre>"},{"location":"breadcrumbs/#registrationindexmd","title":"RegistrationIndex.md","text":"<pre><code># Needlr Registration Index\n\nGenerated: 2026-01-25 10:00:00 UTC\nAssembly: MyApp\n\n## Services (10)\n\n| # | Interface | Implementation | Lifetime | Source |\n|---|-----------|----------------|----------|--------|\n| 1 | ILogger | Logger | Singleton | Services/Logger.cs |\n| 2 | IOrderService | OrderService | Scoped | Services/OrderService.cs |\n\n## Decorators (2)\n\n| Service | Decorator Chain |\n|---------|-----------------|\n| IOrderService | LoggingDecorator \u2192 CachingDecorator |\n</code></pre>"},{"location":"breadcrumbs/#configuration-properties-summary","title":"Configuration Properties Summary","text":"Property Default Description <code>NeedlrDiagnostics</code> <code>false</code> Enable diagnostic file generation <code>NeedlrDiagnosticsPath</code> <code>$(OutputPath)NeedlrDiagnostics</code> Output directory (defaults to bin folder) <code>NeedlrDiagnosticsFilter</code> (all) Comma-separated type names to include"},{"location":"breadcrumbs/#analyzer-status","title":"Analyzer Status","text":"<p>When diagnostics are enabled, Needlr also generates <code>AnalyzerStatus.md</code> showing which analyzers are active and their current severity. This provides a single place to understand what compile-time protection is enabled for your project.</p>"},{"location":"breadcrumbs/#example-analyzerstatusmd","title":"Example AnalyzerStatus.md","text":"<pre><code># Needlr Analyzer Status\n\nGenerated: 2026-01-25 10:00:00 UTC\n\n## Active Analyzers\n\n| ID | Name | Status | Default Severity | Description |\n|:---|:-----|:-------|:-----------------|:------------|\n| NDLRCOR001 | Reflection in AOT | \u26aa Conditional | Error | Detects reflection APIs in AOT projects |\n| NDLRCOR005 | Lifetime Mismatch | \u2705 Active | Warning | Detects captive dependencies |\n| NDLRCOR009 | Lazy Resolution | \u2705 Active | Info | Lazy&lt;T&gt; references undiscovered type |\n| NDLRCOR010 | Collection Resolution | \u2705 Active | Info | IEnumerable&lt;T&gt; has no implementations |\n\n## Mode\n\n**Source Generation**: Enabled (GenerateTypeRegistry detected)\n\n## Configuration\n\nAnalyzer severity can be configured via `.editorconfig`:\n\n\\`\\`\\`ini\n# Example: Suppress Lazy resolution warnings\ndotnet_diagnostic.NDLRCOR009.severity = none\n\n# Example: Promote to warning\ndotnet_diagnostic.NDLRCOR009.severity = warning\n\\`\\`\\`\n</code></pre>"},{"location":"breadcrumbs/#understanding-analyzer-status","title":"Understanding Analyzer Status","text":"Status Meaning \u2705 Active Analyzer is running and checking your code \u26aa Conditional Analyzer only activates under certain conditions (e.g., AOT projects) \u274c Disabled Analyzer is disabled via configuration"},{"location":"breadcrumbs/#configuring-analyzers","title":"Configuring Analyzers","text":"<p>Use <code>.editorconfig</code> to adjust analyzer severity:</p> <pre><code># .editorconfig in your project root\n[*.cs]\n\n# Disable resolution validation (if using reflection)\ndotnet_diagnostic.NDLRCOR009.severity = none\ndotnet_diagnostic.NDLRCOR010.severity = none\n\n# Promote lifetime mismatch to error\ndotnet_diagnostic.NDLRCOR005.severity = error\n</code></pre> <p>See Analyzers Documentation for the complete list of available analyzers.</p>"},{"location":"core-concepts/","title":"Core Concepts","text":"<p>This guide explains the fundamental concepts and architecture of Needlr.</p>"},{"location":"core-concepts/#architecture-overview","title":"Architecture Overview","text":"<p>Needlr is built around several key components that work together to provide automatic dependency injection. Needlr is source-generation-first: compile-time discovery is the recommended approach, though both source-gen (<code>.UsingSourceGen()</code>) and reflection (<code>.UsingReflection()</code>) require explicit opt-in.</p> <pre><code>                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                         \u2502   Discovery Strategy    \u2502\n                         \u2502 (.UsingSourceGen() or   \u2502\n                         \u2502  .UsingReflection())    \u2502\n                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                     \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Syringe   \u2502\u2500\u2500\u2500\u2500\u25b6\u2502     Assembly Provider          \u2502\u2500\u2500\u2500\u2500\u25b6\u2502 Type Discovery  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502                                                           \u2502\n       \u25bc                                                           \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502Type Filterer\u2502\u2500\u2500\u2500\u2500\u25b6\u2502 Type Registrar   \u2502\u2500\u2500\u2500\u2500\u25b6\u2502      Service Collection         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502                                                           \u2502\n       \u25bc                                                           \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Plugins   \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502Service Provider \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"core-concepts/#source-generation-vs-reflection","title":"Source Generation vs Reflection","text":"<p>Needlr supports two discovery strategies:</p>"},{"location":"core-concepts/#source-generation-recommended","title":"Source Generation (Recommended)","text":"<p>Uses compile-time code generation to discover and register types:</p> <pre><code>using NexusLabs.Needlr.Injection.SourceGen;\n\nvar syringe = new Syringe()\n    .UsingSourceGen();  // Configures all source-gen components\n</code></pre> <p>Benefits: - \u2705 AOT compatible - \u2705 Trimming safe - \u2705 Faster startup (no runtime scanning) - \u2705 Compile-time error detection</p> <p>Requirements: - Add <code>NexusLabs.Needlr.Generators</code> as an analyzer - Add <code>NexusLabs.Needlr.Generators.Attributes</code> - All types must be known at compile time</p>"},{"location":"core-concepts/#reflection-dynamic-scenarios","title":"Reflection (Dynamic Scenarios)","text":"<p>Uses runtime reflection to discover and register types:</p> <pre><code>using NexusLabs.Needlr.Injection.Reflection;\n\nvar syringe = new Syringe()\n    .UsingReflection();  // Configures all reflection components\n</code></pre> <p>Benefits: - \u2705 Dynamic plugin loading - \u2705 Runtime assembly scanning - \u2705 Scrutor integration support</p> <p>Drawbacks: - \u274c Not AOT compatible - \u274c Not trimming safe - \u274c Slower startup</p>"},{"location":"core-concepts/#bundle-auto-fallback","title":"Bundle (Auto-Fallback)","text":"<p>Automatically chooses source-gen if available, falls back to reflection:</p> <pre><code>using NexusLabs.Needlr.Injection.Bundle;\n\nvar syringe = new Syringe()\n    .UsingAutoConfiguration();  // Source-gen preferred, reflection fallback\n</code></pre>"},{"location":"core-concepts/#the-syringe-class","title":"The Syringe Class","text":"<p>The <code>Syringe</code> class is the central configuration point for Needlr. It's an immutable record that creates new instances when configured, following a fluent API pattern.</p>"},{"location":"core-concepts/#key-properties","title":"Key Properties","text":"<ul> <li>TypeRegistrar: Determines how types are registered</li> <li>TypeFilterer: Controls which types get automatically registered</li> <li>AssemblyProvider: Specifies which assemblies to scan</li> <li>PluginFactory: Discovers and creates plugin instances</li> <li>ServiceProviderBuilderFactory: Creates the appropriate service provider builder</li> </ul>"},{"location":"core-concepts/#immutability","title":"Immutability","text":"<p>Each configuration method returns a new <code>Syringe</code> instance:</p> <pre><code>var syringe1 = new Syringe();\nvar syringe2 = syringe1.UsingSourceGen();\n// syringe1 != syringe2 (different instances)\n</code></pre> <p>This pattern helps support the fluent-builder syntax.</p>"},{"location":"core-concepts/#required-configuration","title":"Required Configuration","text":"<p>Unlike earlier versions, you must explicitly configure a discovery strategy:</p> <pre><code>// \u274c This will throw an InvalidOperationException\nvar provider = new Syringe().BuildServiceProvider();\n\n// \u2705 Correct - specify strategy\nvar provider = new Syringe()\n    .UsingSourceGen()\n    .BuildServiceProvider();\n</code></pre>"},{"location":"core-concepts/#assembly-scanning","title":"Assembly Scanning","text":""},{"location":"core-concepts/#assembly-provider","title":"Assembly Provider","text":"<p>The <code>IAssemblyProvider</code> determines which assemblies are scanned for types:</p> <pre><code>var provider = new AssemblyProviderBuilder()\n    .MatchingAssemblies(x =&gt; x.Contains(\"MyApp\"))\n    .UseLibTestEntryOrdering()\n    .Build();\n</code></pre>"},{"location":"core-concepts/#assembly-loaders","title":"Assembly Loaders","text":"<p>Different loaders provide different scanning strategies:</p> <ul> <li>DefaultAssemblyLoader: Scans current domain assemblies</li> <li>AllAssembliesLoader: Scans all loaded assemblies</li> <li>FileMatchAssemblyLoader: Scans assemblies matching file patterns</li> </ul> <p>NOTE: you can provide your own custom loaders.</p>"},{"location":"core-concepts/#assembly-sorters","title":"Assembly Sorters","text":"<p>Control the order in which assemblies are processed:</p> <ul> <li>DefaultAssemblySorter: No specific ordering</li> <li>AlphabeticalAssemblySorter: Alphabetical by name</li> <li>LibTestEntryAssemblySorter: Libraries first, then tests, then entry assembly</li> </ul> <p>NOTE: you can provider your own custom sorters.</p>"},{"location":"core-concepts/#type-registration","title":"Type Registration","text":""},{"location":"core-concepts/#type-registrars","title":"Type Registrars","text":"<p>Type registrars determine how discovered types are registered:</p>"},{"location":"core-concepts/#generatedtyperegistrar-source-generation","title":"GeneratedTypeRegistrar (Source Generation)","text":"<p>Used with source generation strategy: - Types discovered at compile time - AOT and trimming compatible - No runtime reflection</p>"},{"location":"core-concepts/#reflectiontyperegistrar-reflection","title":"ReflectionTypeRegistrar (Reflection)","text":"<p>Used with reflection strategy: - Types discovered at runtime - Supports dynamic scenarios</p>"},{"location":"core-concepts/#scrutortyperegistrar-reflection-only","title":"ScrutorTypeRegistrar (Reflection only)","text":"<p>Uses Scrutor library for advanced registration scenarios (requires reflection): - Assembly scanning with filters - Decorator pattern support - Advanced lifetime management</p> <p>NOTE: you can provide your own custom type registrars.</p>"},{"location":"core-concepts/#type-filterers","title":"Type Filterers","text":"<p>Control which types are eligible for automatic registration:</p>"},{"location":"core-concepts/#generatedtypefilterer-source-generation","title":"GeneratedTypeFilterer (Source Generation)","text":"<p>For source-gen, filtering is done at compile time based on: - Types with <code>[DoNotAutoRegister]</code> attribute excluded - Types with <code>[DoNotInject]</code> attribute excluded - Abstract classes and interfaces excluded</p>"},{"location":"core-concepts/#reflectiontypefilterer-reflection","title":"ReflectionTypeFilterer (Reflection)","text":"<p>For reflection, filters at runtime based on: - Excludes types with <code>[DoNotAutoRegister]</code> attribute - Excludes types with <code>[DoNotInject]</code> attribute - Excludes abstract classes and interfaces - Excludes compiler-generated types</p>"},{"location":"core-concepts/#custom-type-filterers","title":"Custom Type Filterers","text":"<p>Implement <code>ITypeFilterer</code> for custom filtering logic:</p> <pre><code>public class MyTypeFilterer : ITypeFilterer\n{\n    public IEnumerable&lt;Type&gt; Filter(IEnumerable&lt;Type&gt; types)\n    {\n        return types.Where(t =&gt; \n            !t.Name.EndsWith(\"Test\") &amp;&amp; \n            t.Namespace?.StartsWith(\"MyCompany\") == true);\n    }\n}\n</code></pre> <p>Note: you can provide your own custom type filterers.</p>"},{"location":"core-concepts/#service-collection-population","title":"Service Collection Population","text":"<p>The <code>IServiceCollectionPopulator</code> orchestrates the registration process:</p> <ol> <li>Discovers types from assemblies</li> <li>Applies type filtering</li> <li>Registers types using the configured registrar</li> <li>Executes plugins</li> </ol>"},{"location":"core-concepts/#plugin-system","title":"Plugin System","text":""},{"location":"core-concepts/#plugin-types","title":"Plugin Types","text":""},{"location":"core-concepts/#iservicecollectionplugin","title":"IServiceCollectionPlugin","text":"<p>Configures services during the initial registration phase:</p> <pre><code>public class MyServicePlugin : IServiceCollectionPlugin\n{\n    public void Configure(ServiceCollectionPluginOptions options)\n    {\n        options.Services.AddSingleton&lt;IMyService, MyService&gt;();\n        options.Logger.LogInformation(\"Configured MyService\");\n    }\n}\n</code></pre>"},{"location":"core-concepts/#ipostbuildservicecollectionplugin","title":"IPostBuildServiceCollectionPlugin","text":"<p>Executes after the main service collection is built:</p> <pre><code>public class MyPostBuildPlugin : IPostBuildServiceCollectionPlugin\n{\n    public void Configure(PostBuildServiceCollectionPluginOptions options)\n    {\n        // Access built services\n        var myService = options.Services.GetService&lt;IMyService&gt;();\n        // Additional configuration\n    }\n}\n</code></pre>"},{"location":"core-concepts/#iwebapplicationbuilderplugin","title":"IWebApplicationBuilderPlugin","text":"<p>Configures the WebApplicationBuilder:</p> <pre><code>public class MyBuilderPlugin : IWebApplicationBuilderPlugin\n{\n    public void Configure(WebApplicationBuilderPluginOptions options)\n    {\n        options.Builder.Services.AddCors();\n        options.Builder.Configuration.AddJsonFile(\"custom.json\");\n    }\n}\n</code></pre>"},{"location":"core-concepts/#iwebapplicationplugin","title":"IWebApplicationPlugin","text":"<p>Configures the WebApplication after building:</p> <pre><code>public class MyAppPlugin : IWebApplicationPlugin\n{\n    public void Configure(WebApplicationPluginOptions options)\n    {\n        options.WebApplication.MapGet(\"/health\", () =&gt; \"Healthy\");\n        options.WebApplication.UseCors();\n    }\n}\n</code></pre>"},{"location":"core-concepts/#plugin-discovery","title":"Plugin Discovery","text":"<p>Plugins are automatically discovered and registered: - Scanned from assemblies like other types - Sorted by <code>[PluginOrder]</code> attribute (lower values first) - Plugins with same order are sorted alphabetically by type name - Executed in deterministic order</p> <pre><code>// Control plugin execution order\n[PluginOrder(-100)]  // Executes first\npublic class InfrastructurePlugin : IServiceCollectionPlugin { }\n\n[PluginOrder(100)]   // Executes last\npublic class ValidationPlugin : IServiceCollectionPlugin { }\n</code></pre> <p>See Plugin Development Guide for full ordering documentation.</p> <p>NOTE: The <code>[DoNotAutoRegister]</code> attribute is used for dynamically discovering  and registering types, but it is not applicable for plugins. In fact, by default, all built-in plugins are marked with this attribute so that they will not be resolvable on the dependency container itself. This attribute is not to control the discoverability of plugins.</p>"},{"location":"core-concepts/#lifetime-management","title":"Lifetime Management","text":""},{"location":"core-concepts/#default-lifetimes","title":"Default Lifetimes","text":"<ul> <li>Singleton: Created once and reused (default for most types in Needlr)</li> <li>Transient: Created each time requested </li> <li>Scoped: Created once per request/scope</li> </ul>"},{"location":"core-concepts/#lifetime-detection","title":"Lifetime Detection","text":"<p>Needlr automatically determines appropriate lifetimes based on: - Type characteristics (stateless vs stateful) - Interface implementations - Decorator patterns</p>"},{"location":"core-concepts/#decorator-pattern","title":"Decorator Pattern","text":"<p>Decorators wrap a service to add behavior (logging, caching, retry, etc.) without modifying the original implementation.</p>"},{"location":"core-concepts/#why-explicit-decoratorfort-is-required","title":"Why Explicit <code>[DecoratorFor&lt;T&gt;]</code> Is Required","text":"<p>Needlr requires explicit decorator registration rather than auto-detecting and wiring decorators. Here's why:</p> <p>1. Ordering Ambiguity When multiple decorators exist for the same service, the order matters significantly. <code>Cache(Log(Service))</code> behaves differently than <code>Log(Cache(Service))</code>. Without explicit ordering, Needlr would have to choose arbitrarily, leading to runtime surprises.</p> <p>2. Intent Clarity A class that implements <code>IFoo</code> and takes <code>IFoo</code> in its constructor might be a decorator, but it could also be a fallback wrapper, adapter, or composite meant for manual composition. The pattern is ambiguous.</p> <p>3. Multiple Implementations If you have <code>FooA : IFoo</code> and <code>FooB : IFoo</code>, should a decorator wrap both? Only one? The explicit attribute makes your intent clear.</p> <p>Note: Needlr does auto-detect the decorator pattern to exclude such types from being registered as the interface they decorate (preventing circular dependencies). But wiring the decoration chain requires explicit opt-in.</p>"},{"location":"core-concepts/#automatic-decorators-with-decoratorfort-recommended","title":"Automatic Decorators with <code>[DecoratorFor&lt;T&gt;]</code> (Recommended)","text":"<p>The simplest approach - decorate classes with the attribute and Needlr handles the rest:</p> <pre><code>public interface IService { string GetValue(); }\npublic class ServiceImpl : IService { public string GetValue() =&gt; \"Original\"; }\n\n[DecoratorFor&lt;IService&gt;(Order = 1)]\npublic class LoggingDecorator : IService\n{\n    private readonly IService _inner;\n    public LoggingDecorator(IService inner) =&gt; _inner = inner;\n    public string GetValue()\n    {\n        Console.WriteLine(\"Logging...\");\n        return _inner.GetValue();\n    }\n}\n\n[DecoratorFor&lt;IService&gt;(Order = 2)]\npublic class CachingDecorator : IService\n{\n    private readonly IService _inner;\n    private string? _cached;\n    public CachingDecorator(IService inner) =&gt; _inner = inner;\n    public string GetValue() =&gt; _cached ??= _inner.GetValue();\n}\n</code></pre> <ul> <li>Order property: Lower values are applied first (closest to original)</li> <li>Result chain: CachingDecorator \u2192 LoggingDecorator \u2192 ServiceImpl</li> <li>Works with both source generation and reflection</li> </ul>"},{"location":"core-concepts/#manual-decoration","title":"Manual Decoration","text":"<pre><code>services.AddSingleton&lt;IService, ServiceImpl&gt;();\nservices.AddSingleton&lt;IService&gt;(sp =&gt; \n    new ServiceDecorator(sp.GetRequiredService&lt;ServiceImpl&gt;()));\n</code></pre>"},{"location":"core-concepts/#using-adddecorator-extension","title":"Using AddDecorator Extension","text":"<pre><code>new Syringe()\n    .UsingSourceGen()  // or .UsingReflection()\n    .AddDecorator&lt;IService, ServiceDecorator&gt;()\n    .BuildServiceProvider();\n</code></pre>"},{"location":"core-concepts/#with-scrutor-reflection-only","title":"With Scrutor (Reflection only)","text":"<pre><code>services.Decorate&lt;IService, ServiceDecorator&gt;();\n</code></pre>"},{"location":"core-concepts/#configuration-integration","title":"Configuration Integration","text":""},{"location":"core-concepts/#automatic-iconfiguration","title":"Automatic IConfiguration","text":"<p>Needlr automatically registers <code>IConfiguration</code>:</p> <pre><code>var provider = new Syringe()\n    .UsingSourceGen()  // or .UsingReflection()\n    .UsingConfiguration()  // Adds IConfiguration support\n    .BuildServiceProvider();\n</code></pre>"},{"location":"core-concepts/#web-application-integration","title":"Web Application Integration","text":""},{"location":"core-concepts/#webapplicationsyringe","title":"WebApplicationSyringe","text":"<p>Extends Syringe for web applications:</p> <pre><code>var webApp = new Syringe()\n    .UsingSourceGen()  // or .UsingReflection()\n    .ForWebApplication()  // Returns WebApplicationSyringe\n    .UsingOptions(() =&gt; CreateWebApplicationOptions.Default)\n    .BuildWebApplication();\n</code></pre>"},{"location":"core-concepts/#best-practices","title":"Best Practices","text":""},{"location":"core-concepts/#1-choose-the-right-discovery-strategy","title":"1. Choose the Right Discovery Strategy","text":"<ul> <li>Use Source Generation for AOT, trimmed, or performance-critical apps</li> <li>Use Reflection only when dynamic discovery is required</li> </ul>"},{"location":"core-concepts/#2-use-appropriate-attributes","title":"2. Use Appropriate Attributes","text":"<ul> <li><code>[DoNotAutoRegister]</code>: Exclude from automatic registration</li> <li><code>[DoNotInject]</code>: Prevent dependency injection</li> </ul>"},{"location":"core-concepts/#3-leverage-assembly-filtering","title":"3. Leverage Assembly Filtering","text":"<p>Filter assemblies to improve performance:</p> <pre><code>.UsingAssemblyProvider(builder =&gt; builder\n    .MatchingAssemblies(x =&gt; x.StartsWith(\"MyCompany\"))\n    .Build())\n</code></pre>"},{"location":"core-concepts/#4-order-matters","title":"4. Order Matters","text":"<p>Use assembly ordering for predictable registration order:</p> <pre><code>.UseLibTestEntryOrdering()  // Libraries \u2192 Executables \u2192 Tests\n</code></pre> <p>Or use the expression-based API for custom ordering:</p> <pre><code>.OrderAssemblies(order =&gt; order\n    .By(a =&gt; a.Name.StartsWith(\"Core\"))      // Core assemblies first\n    .ThenBy(a =&gt; a.Name.StartsWith(\"Feature\")) // Then features\n    .ThenBy(a =&gt; a.Name.Contains(\"Tests\")))   // Tests last\n</code></pre>"},{"location":"core-concepts/#5-plugin-organization","title":"5. Plugin Organization","text":"<ul> <li>Group related configuration in plugins</li> <li>Use appropriate plugin types for timing</li> <li>Keep plugins focused and single-purpose</li> </ul>"},{"location":"core-concepts/#6-immutability","title":"6. Immutability","text":"<p>Remember that Syringe is immutable:</p> <pre><code>var configured = new Syringe()\n    .UsingSourceGen()  // or .UsingReflection()\n    .UsingConfiguration();\n// Chain all configuration before building\n</code></pre>"},{"location":"factories/","title":"Factory Delegates (Source Generation Only)","text":"<p>When a class has constructor parameters that cannot be auto-injected (value types, strings, delegates), Needlr typically excludes it from auto-registration. The <code>[GenerateFactory]</code> attribute solves this by generating factory interfaces and delegates that handle the injectable parameters while letting you provide the runtime parameters.</p>"},{"location":"factories/#basic-usage","title":"Basic Usage","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n// This service has both injectable (ILogger) and runtime (connectionString) parameters\n[GenerateFactory]\npublic sealed class DatabaseConnection\n{\n    /// &lt;summary&gt;\n    /// Creates a new database connection.\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"logger\"&gt;The logger for diagnostics.&lt;/param&gt;\n    /// &lt;param name=\"connectionString\"&gt;The database connection string.&lt;/param&gt;\n    public DatabaseConnection(ILogger&lt;DatabaseConnection&gt; logger, string connectionString)\n    {\n        // ...\n    }\n}\n</code></pre> <p>The source generator creates: - <code>IDatabaseConnectionFactory</code> - Interface with <code>Create(string connectionString)</code> method - <code>Func&lt;string, DatabaseConnection&gt;</code> - Delegate for functional-style creation</p> <p>Both are registered as Singletons. XML documentation from your constructor parameters is propagated to the factory's <code>Create</code> method for rich IntelliSense.</p>"},{"location":"factories/#resolving-factories","title":"Resolving Factories","text":"<pre><code>// Using the factory interface (recommended for testability)\nvar factory = serviceProvider.GetRequiredService&lt;MyApp.Generated.IDatabaseConnectionFactory&gt;();\nvar prodDb = factory.Create(\"Server=prod;Database=app\");\nvar testDb = factory.Create(\"Server=localhost;Database=test\");\n\n// Using the Func delegate (concise syntax)\nvar createDb = serviceProvider.GetRequiredService&lt;Func&lt;string, DatabaseConnection&gt;&gt;();\nvar db = createDb(\"Server=dev;Database=sandbox\");\n</code></pre>"},{"location":"factories/#generic-factory-for-interface-return-types","title":"Generic Factory for Interface Return Types","text":"<p>Use <code>[GenerateFactory&lt;TInterface&gt;]</code> to have the factory return an interface instead of the concrete type. This enables mocking both the factory and its returned instances:</p> <pre><code>public interface IRequestHandler\n{\n    Guid CorrelationId { get; }\n    string Handle(string request);\n}\n\n[GenerateFactory&lt;IRequestHandler&gt;]\npublic sealed class RequestHandler : IRequestHandler\n{\n    /// &lt;summary&gt;Creates a new request handler.&lt;/summary&gt;\n    /// &lt;param name=\"config\"&gt;Application configuration.&lt;/param&gt;\n    /// &lt;param name=\"correlationId\"&gt;Unique ID for tracing this request.&lt;/param&gt;\n    public RequestHandler(IConfiguration config, Guid correlationId)\n    {\n        CorrelationId = correlationId;\n        // ...\n    }\n\n    // ...\n}\n</code></pre> <p>The generated factory: <pre><code>public interface IRequestHandlerFactory\n{\n    /// &lt;summary&gt;Creates a new instance of RequestHandler.&lt;/summary&gt;\n    /// &lt;param name=\"correlationId\"&gt;Unique ID for tracing this request.&lt;/param&gt;\n    IRequestHandler Create(Guid correlationId);  // Returns interface, not concrete type\n}\n\n// Func also returns the interface\nFunc&lt;Guid, IRequestHandler&gt;\n</code></pre></p>"},{"location":"factories/#multiple-constructors","title":"Multiple Constructors","text":"<p>Each public constructor with runtime parameters gets its own <code>Create()</code> overload:</p> <pre><code>[GenerateFactory]\npublic sealed class ReportGenerator\n{\n    /// &lt;param name=\"timeProvider\"&gt;Time provider for timestamps.&lt;/param&gt;\n    /// &lt;param name=\"title\"&gt;Report title.&lt;/param&gt;\n    public ReportGenerator(ITimeProvider timeProvider, string title) { }\n\n    /// &lt;param name=\"timeProvider\"&gt;Time provider for timestamps.&lt;/param&gt;\n    /// &lt;param name=\"title\"&gt;Report title.&lt;/param&gt;\n    /// &lt;param name=\"maxItems\"&gt;Maximum items to include.&lt;/param&gt;\n    public ReportGenerator(ITimeProvider timeProvider, string title, int maxItems) { }\n}\n</code></pre> <p>Generated interface: <pre><code>public interface IReportGeneratorFactory\n{\n    /// &lt;summary&gt;Creates a new instance of ReportGenerator.&lt;/summary&gt;\n    /// &lt;param name=\"title\"&gt;Report title.&lt;/param&gt;\n    ReportGenerator Create(string title);\n\n    /// &lt;summary&gt;Creates a new instance of ReportGenerator.&lt;/summary&gt;\n    /// &lt;param name=\"title\"&gt;Report title.&lt;/param&gt;\n    /// &lt;param name=\"maxItems\"&gt;Maximum items to include.&lt;/param&gt;\n    ReportGenerator Create(string title, int maxItems);\n}\n</code></pre></p>"},{"location":"factories/#controlling-generation-mode","title":"Controlling Generation Mode","text":"<p>By default, both the <code>Func&lt;&gt;</code> delegate and <code>IFactory</code> interface are generated. Use the <code>Mode</code> property to control this:</p> <pre><code>// Only generate Func&lt;&gt; delegate\n[GenerateFactory(Mode = FactoryGenerationMode.Func)]\npublic class FuncOnlyService { }\n\n// Only generate IFactory interface\n[GenerateFactory(Mode = FactoryGenerationMode.Interface)]\npublic class InterfaceOnlyService { }\n\n// Generate both (default)\n[GenerateFactory(Mode = FactoryGenerationMode.All)]\npublic class BothService { }\n</code></pre>"},{"location":"factories/#parameter-classification","title":"Parameter Classification","text":"<p>Needlr classifies constructor parameters as: - Injectable: Interfaces and classes (resolved from the container) - Runtime: Value types, strings, delegates, arrays (must be provided to <code>Create()</code>)</p> <p>Only constructors with at least one runtime parameter are eligible for factory generation.</p>"},{"location":"factories/#analyzers","title":"Analyzers","text":"<p>Needlr includes analyzers to help with factory usage:</p> Diagnostic Severity Description NDLRGEN003 Warning All parameters are injectable - factory provides no value NDLRGEN004 Warning No parameters are injectable - low value factory NDLRGEN005 Error Generic type T in <code>[GenerateFactory&lt;T&gt;]</code> is not implemented by the class"},{"location":"factories/#namespace","title":"Namespace","text":"<p>Generated factories are placed in <code>{AssemblyName}.Generated</code> namespace:</p> <pre><code>using MyApp.Generated;  // Contains IDatabaseConnectionFactory, IReportGeneratorFactory, etc.\n</code></pre>"},{"location":"factories/#when-to-use-factories","title":"When to Use Factories","text":"<p>Use <code>[GenerateFactory]</code> when: - Your class requires runtime configuration (connection strings, API keys, correlation IDs) - You need to create multiple instances with different runtime parameters - You want to avoid manual <code>IServiceProvider.GetRequiredService&lt;&gt;()</code> calls in factory methods</p> <p>Use <code>[GenerateFactory&lt;TInterface&gt;]</code> when: - You want to mock the factory in unit tests - You want to mock the returned instances - You prefer interface-based dependency injection</p>"},{"location":"factories/#complete-example","title":"Complete Example","text":"<pre><code>using NexusLabs.Needlr.Generators;\nusing MyApp.Generated;\n\n// Define your service with mixed parameters\n[GenerateFactory]\npublic sealed class EmailSender\n{\n    private readonly ISmtpClient _smtp;\n    private readonly ILogger&lt;EmailSender&gt; _logger;\n\n    public string FromAddress { get; }\n\n    /// &lt;summary&gt;Creates a new email sender.&lt;/summary&gt;\n    /// &lt;param name=\"smtp\"&gt;SMTP client for sending emails.&lt;/param&gt;\n    /// &lt;param name=\"logger\"&gt;Logger for diagnostics.&lt;/param&gt;\n    /// &lt;param name=\"fromAddress\"&gt;The sender email address.&lt;/param&gt;\n    public EmailSender(ISmtpClient smtp, ILogger&lt;EmailSender&gt; logger, string fromAddress)\n    {\n        _smtp = smtp;\n        _logger = logger;\n        FromAddress = fromAddress;\n    }\n\n    public Task SendAsync(string to, string subject, string body) { /* ... */ }\n}\n\n// Use the generated factory\npublic class NotificationService\n{\n    private readonly IEmailSenderFactory _emailFactory;\n\n    public NotificationService(IEmailSenderFactory emailFactory)\n    {\n        _emailFactory = emailFactory;\n    }\n\n    public async Task NotifyUserAsync(User user, string message)\n    {\n        // Create sender with appropriate from address\n        var sender = _emailFactory.Create(\"noreply@myapp.com\");\n        await sender.SendAsync(user.Email, \"Notification\", message);\n    }\n\n    public async Task NotifySupportAsync(string issue)\n    {\n        var sender = _emailFactory.Create(\"support@myapp.com\");\n        await sender.SendAsync(\"team@myapp.com\", \"Support Issue\", issue);\n    }\n}\n</code></pre>"},{"location":"getting-started/","title":"Getting Started with Needlr","text":"<p>Needlr is an opinionated dependency injection library for .NET that simplifies service registration and web application setup through automatic discovery and a fluent API.</p> <p>Needlr is source-generation-first: The recommended approach uses compile-time source generation for AOT compatibility. Both source-gen and reflection require explicit opt-in via <code>.UsingSourceGen()</code> or <code>.UsingReflection()</code>.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Add the Needlr packages to your project. Choose your discovery strategy:</p>"},{"location":"getting-started/#option-1-source-generation-recommended","title":"Option 1: Source Generation (Recommended)","text":"<p>Best for AOT-compiled applications, trimmed deployments, and optimal startup performance:</p> <pre><code>&lt;!-- Core dependency injection --&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.Injection\" /&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.Injection.SourceGen\" /&gt;\n\n&lt;!-- Source generator (runs at compile time) --&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.Generators\" OutputItemType=\"Analyzer\" ReferenceOutputAssembly=\"false\" /&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.Generators.Attributes\" /&gt;\n\n&lt;!-- For ASP.NET Core web applications --&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.AspNet\" /&gt;\n</code></pre>"},{"location":"getting-started/#option-2-reflection-dynamic-scenarios","title":"Option 2: Reflection (Dynamic Scenarios)","text":"<p>For applications that need runtime type discovery or dynamic plugin loading:</p> <pre><code>&lt;!-- Core dependency injection --&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.Injection\" /&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.Injection.Reflection\" /&gt;\n\n&lt;!-- For ASP.NET Core web applications --&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.AspNet\" /&gt;\n\n&lt;!-- Optional: Scrutor-based type registration --&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.Injection.Scrutor\" /&gt;\n</code></pre>"},{"location":"getting-started/#option-3-bundle-auto-fallback","title":"Option 3: Bundle (Auto-Fallback)","text":"<p>Includes both strategies with automatic fallback from source-gen to reflection:</p> <pre><code>&lt;!-- Includes both source-gen and reflection with auto-detection --&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.Injection.Bundle\" /&gt;\n\n&lt;!-- For ASP.NET Core web applications --&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.AspNet\" /&gt;\n</code></pre>"},{"location":"getting-started/#your-first-application","title":"Your First Application","text":""},{"location":"getting-started/#console-application-source-generation","title":"Console Application (Source Generation)","text":"<pre><code>using NexusLabs.Needlr.Injection;\nusing NexusLabs.Needlr.Injection.SourceGen;\nusing Microsoft.Extensions.DependencyInjection;\n\n// Create a service provider with source-gen discovery\nvar serviceProvider = new Syringe()\n    .UsingSourceGen()\n    .BuildServiceProvider();\n\n// Get your service (automatically registered at compile time)\nvar myService = serviceProvider.GetRequiredService&lt;MyService&gt;();\nmyService.DoWork();\n\n// Your service class - automatically discovered by source generator\npublic class MyService\n{\n    public void DoWork()\n    {\n        Console.WriteLine(\"Work is being done!\");\n    }\n}\n</code></pre>"},{"location":"getting-started/#console-application-reflection","title":"Console Application (Reflection)","text":"<pre><code>using NexusLabs.Needlr.Injection;\nusing NexusLabs.Needlr.Injection.Reflection;\nusing Microsoft.Extensions.DependencyInjection;\n\n// Create a service provider with reflection-based discovery\nvar serviceProvider = new Syringe()\n    .UsingReflection()\n    .BuildServiceProvider();\n\n// Get your service (automatically registered at runtime)\nvar myService = serviceProvider.GetRequiredService&lt;MyService&gt;();\nmyService.DoWork();\n</code></pre>"},{"location":"getting-started/#web-application-source-generation","title":"Web Application (Source Generation)","text":"<pre><code>using NexusLabs.Needlr.AspNet;\nusing NexusLabs.Needlr.Injection;\nusing NexusLabs.Needlr.Injection.SourceGen;\n\n// Create and run a web application\nvar webApplication = new Syringe()\n    .UsingSourceGen()\n    .ForWebApplication()\n    .BuildWebApplication();\n\nawait webApplication.RunAsync();\n\n// Add a minimal API endpoint using a plugin\ninternal sealed class HelloWorldPlugin : IWebApplicationPlugin\n{\n    public void Configure(WebApplicationPluginOptions options)\n    {\n        options.WebApplication.MapGet(\"/\", () =&gt; \"Hello, World!\");\n    }\n}\n</code></pre>"},{"location":"getting-started/#web-application-reflection","title":"Web Application (Reflection)","text":"<pre><code>using NexusLabs.Needlr.AspNet;\nusing NexusLabs.Needlr.Injection;\nusing NexusLabs.Needlr.Injection.Reflection;\n\n// Create and run a web application with reflection\nvar webApplication = new Syringe()\n    .UsingReflection()\n    .ForWebApplication()\n    .BuildWebApplication();\n\nawait webApplication.RunAsync();\n</code></pre>"},{"location":"getting-started/#key-concepts","title":"Key Concepts","text":""},{"location":"getting-started/#automatic-registration","title":"Automatic Registration","text":"<p>By default, Needlr automatically registers: - All non-nested non-abstract classes (public and internal) in scanned assemblies - Classes as both themselves and their interfaces - With Singleton lifetime by default (use <code>[Transient]</code> or <code>[Scoped]</code> attributes to override)</p> <p>By default, Needlr automatically dots NOT register: - Anything marked with the <code>[DoNotAutoRegister]</code> attribute - Record types - Nested classes - Interfaces or abstract classes - Types where the only constructor are non-injectable types (i.e. value types)</p> <p>NOTE: there are nuances to what is automatically registered to the dependency container by default </p>"},{"location":"getting-started/#the-syringe-class","title":"The Syringe Class","text":"<p>The <code>Syringe</code> class is your entry point for configuring dependency injection. You must configure a discovery strategy:</p> <pre><code>// Source generation (recommended for AOT)\nvar syringe = new Syringe()\n    .UsingSourceGen()\n    .UsingAssemblyProvider(builder =&gt; builder\n        .MatchingAssemblies(x =&gt; x.Contains(\"MyApp\"))\n        .Build());\n\n// Reflection with Scrutor (for dynamic scenarios)\nvar syringe = new Syringe()\n    .UsingReflection()\n    .UsingScrutorTypeRegistrar()\n    .UsingAssemblyProvider(builder =&gt; builder\n        .MatchingAssemblies(x =&gt; x.Contains(\"MyApp\"))\n        .Build());\n</code></pre>"},{"location":"getting-started/#preventing-auto-registration","title":"Preventing Auto-Registration","text":"<p>Use the <code>[DoNotAutoRegister]</code> attribute to exclude types:</p> <pre><code>[DoNotAutoRegister]\npublic class ManuallyRegisteredService\n{\n    // This won't be automatically registered\n}\n</code></pre>"},{"location":"getting-started/#controlling-interface-registration","title":"Controlling Interface Registration","text":"<p>By default, classes are registered as all their interfaces. Use <code>[RegisterAs&lt;T&gt;]</code> for explicit control:</p> <pre><code>public interface IReader { }\npublic interface IWriter { }\npublic interface ILogger { }\n\n// Only registered as IReader, not IWriter or ILogger\n[RegisterAs&lt;IReader&gt;]\npublic class FileService : IReader, IWriter, ILogger { }\n</code></pre> <p>See RegisterAs Documentation for more details.</p>"},{"location":"getting-started/#configuration-options","title":"Configuration Options","text":""},{"location":"getting-started/#source-generation-configuration","title":"Source Generation Configuration","text":"<pre><code>using NexusLabs.Needlr.Injection.SourceGen;\n\nvar serviceProvider = new Syringe()\n    .UsingSourceGen()\n    .BuildServiceProvider();\n</code></pre>"},{"location":"getting-started/#reflection-configuration","title":"Reflection Configuration","text":"<pre><code>using NexusLabs.Needlr.Injection.Reflection;\n\nvar serviceProvider = new Syringe()\n    .UsingReflection()\n    .BuildServiceProvider();\n</code></pre>"},{"location":"getting-started/#auto-configuration-bundle","title":"Auto-Configuration (Bundle)","text":"<pre><code>using NexusLabs.Needlr.Injection.Bundle;\n\nvar serviceProvider = new Syringe()\n    .UsingAutoConfiguration()  // Tries source-gen first, falls back to reflection\n    .BuildServiceProvider();\n</code></pre>"},{"location":"getting-started/#custom-assembly-scanning","title":"Custom Assembly Scanning","text":"<pre><code>var serviceProvider = new Syringe()\n    .UsingSourceGen()  // or .UsingReflection()\n    .UsingAssemblyProvider(builder =&gt; builder\n        .MatchingAssemblies(x =&gt; \n            x.Contains(\"MyCompany\") || \n            x.Contains(\"MyApp\"))\n        .UseLibTestEntryOrdering()  // Sort assemblies appropriately\n        .Build())\n    .BuildServiceProvider();\n</code></pre>"},{"location":"getting-started/#web-application-options","title":"Web Application Options","text":""},{"location":"getting-started/#source-generation-web-application","title":"Source Generation Web Application","text":"<pre><code>using NexusLabs.Needlr.Injection.SourceGen;\n\nvar webApplication = new Syringe()\n    .UsingSourceGen()\n    .ForWebApplication()\n    .BuildWebApplication();\n</code></pre>"},{"location":"getting-started/#reflection-web-application","title":"Reflection Web Application","text":"<pre><code>using NexusLabs.Needlr.Injection.Reflection;\n\nvar webApplication = new Syringe()\n    .UsingReflection()\n    .ForWebApplication()\n    .BuildWebApplication();\n</code></pre>"},{"location":"getting-started/#with-custom-options","title":"With Custom Options","text":"<pre><code>var webApplication = new Syringe()\n    .UsingSourceGen()  // or .UsingReflection()\n    .ForWebApplication()\n    .UsingOptions(() =&gt; CreateWebApplicationOptions\n        .Default\n        .UsingStartupConsoleLogger()\n        .UsingApplicationName(\"MyApp\"))\n    .BuildWebApplication();\n</code></pre>"},{"location":"getting-started/#with-configuration-callback","title":"With Configuration Callback","text":"<p>The <code>UsingConfigurationCallback</code> method allows you to customize the WebApplicationBuilder before the application is built:</p> <pre><code>var webApplication = new Syringe()\n    .UsingSourceGen()  // or .UsingReflection()\n    .ForWebApplication()\n    .UsingConfigurationCallback((builder, options) =&gt;\n    {\n        // Customize configuration sources\n        builder.Configuration\n            .SetBasePath(AppContext.BaseDirectory)\n            .AddJsonFile(\"appsettings.local.json\", optional: true)\n            .AddEnvironmentVariables(\"MYAPP_\");\n\n        // Add services before plugin registration\n        builder.Services.AddSingleton&lt;ICustomService, CustomService&gt;();\n\n        // Configure logging\n        builder.Logging.AddConsole();\n        builder.Logging.SetMinimumLevel(LogLevel.Debug);\n    })\n    .BuildWebApplication();\n</code></pre>"},{"location":"getting-started/#with-web-application-factory","title":"With Web Application Factory","text":"<pre><code>var webApplication = new Syringe()\n    .UsingSourceGen()  // or .UsingReflection()\n    .ForWebApplication()\n    .UsingWebApplicationFactory&lt;CustomWebApplicationFactory&gt;()\n    .BuildWebApplication();\n</code></pre>"},{"location":"getting-started/#choosing-source-generation-vs-reflection","title":"Choosing Source Generation vs Reflection","text":"Feature Source Generation Reflection AOT Compatible \u2705 Yes \u274c No Trimming Safe \u2705 Yes \u274c No Startup Performance \u2705 Faster \u26a0\ufe0f Slower Dynamic Plugin Loading \u274c No \u2705 Yes Runtime Assembly Scanning \u274c No \u2705 Yes Scrutor Support \u274c No \u2705 Yes <p>Use Source Generation when: - Building AOT-compiled applications - Targeting trimmed/self-contained deployments - You want faster startup times - All plugins are known at compile time</p> <p>Use Reflection when: - Loading plugins dynamically at runtime - Scanning assemblies not known at compile time - Using Scrutor for advanced registration patterns</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Core Concepts for deeper understanding</li> <li>Explore Plugin Development to extend functionality</li> <li>Discover Factory Delegates for types with runtime parameters</li> <li>Read about Interceptors for cross-cutting concerns</li> <li>See Advanced Usage for complex scenarios</li> </ul>"},{"location":"hosted-services/","title":"Hosted Service Auto-Discovery","text":"<p>Needlr automatically discovers and registers classes that inherit from <code>BackgroundService</code> or implement <code>IHostedService</code>. No additional attributes are required.</p>"},{"location":"hosted-services/#how-it-works","title":"How It Works","text":"<p>When you use <code>[GenerateTypeRegistry]</code>, Needlr scans for:</p> <ol> <li>Classes inheriting from <code>Microsoft.Extensions.Hosting.BackgroundService</code></li> <li>Classes directly implementing <code>Microsoft.Extensions.Hosting.IHostedService</code></li> </ol> <p>These are automatically registered with the dual-registration pattern:</p> <pre><code>// Generated code:\nservices.AddSingleton&lt;MyWorkerService&gt;();\nservices.AddSingleton&lt;IHostedService&gt;(sp =&gt; sp.GetRequiredService&lt;MyWorkerService&gt;());\n</code></pre> <p>This pattern allows: - Resolving by concrete type (<code>MyWorkerService</code>) - Resolution via <code>IHostedService</code> for the host to start/stop - Decorators to be applied via <code>IHostedService</code></p>"},{"location":"hosted-services/#automatic-startup","title":"Automatic Startup","text":"<p>When using <code>.ForWebApplication()</code> or <code>.ForHost()</code> to build a <code>WebApplication</code> or <code>IHost</code>, your discovered hosted services will automatically start when you call <code>StartAsync()</code> or <code>RunAsync()</code>:</p> <pre><code>var app = new Syringe()\n    .UsingSourceGen()\n    .ForWebApplication()\n    .BuildWebApplication();\n\n// Your hosted services start here\nawait app.RunAsync();\n</code></pre> <p>The .NET host runtime handles starting all <code>IHostedService</code> registrations, including your auto-discovered background services. They will also be stopped when the application shuts down.</p>"},{"location":"hosted-services/#basic-example","title":"Basic Example","text":"<pre><code>// Just inherit from BackgroundService - no attributes needed\npublic sealed class OrderProcessingWorker : BackgroundService\n{\n    private readonly IOrderQueue _orderQueue;\n\n    public OrderProcessingWorker(IOrderQueue orderQueue)\n    {\n        _orderQueue = orderQueue;\n    }\n\n    protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n    {\n        while (!stoppingToken.IsCancellationRequested)\n        {\n            var order = await _orderQueue.DequeueAsync(stoppingToken);\n            // Process order...\n        }\n    }\n}\n</code></pre>"},{"location":"hosted-services/#excluding-a-hosted-service","title":"Excluding a Hosted Service","text":"<p>Use <code>[DoNotAutoRegister]</code> to prevent auto-discovery:</p> <pre><code>[DoNotAutoRegister]\npublic sealed class ManuallyRegisteredWorker : BackgroundService\n{\n    protected override Task ExecuteAsync(CancellationToken stoppingToken) \n        =&gt; Task.CompletedTask;\n}\n</code></pre>"},{"location":"hosted-services/#decorating-hosted-services","title":"Decorating Hosted Services","text":"<p>You can apply decorators to all hosted services using <code>[DecoratorFor&lt;IHostedService&gt;]</code>:</p> <pre><code>[DecoratorFor&lt;IHostedService&gt;(Order = 0)]\npublic sealed class TimingHostedServiceDecorator : IHostedService\n{\n    private readonly IHostedService _inner;\n    private readonly ILogger&lt;TimingHostedServiceDecorator&gt; _logger;\n\n    public TimingHostedServiceDecorator(\n        IHostedService inner, \n        ILogger&lt;TimingHostedServiceDecorator&gt; logger)\n    {\n        _inner = inner;\n        _logger = logger;\n    }\n\n    public async Task StartAsync(CancellationToken cancellationToken)\n    {\n        var sw = Stopwatch.StartNew();\n        await _inner.StartAsync(cancellationToken);\n        _logger.LogInformation(\"Started {Type} in {Elapsed}ms\", \n            _inner.GetType().Name, sw.ElapsedMilliseconds);\n    }\n\n    public Task StopAsync(CancellationToken cancellationToken) \n        =&gt; _inner.StopAsync(cancellationToken);\n}\n</code></pre>"},{"location":"hosted-services/#multi-level-decoration","title":"Multi-Level Decoration","text":"<p>Multiple decorators can be stacked using the <code>Order</code> property:</p> <pre><code>[DecoratorFor&lt;IHostedService&gt;(Order = 0)]  // Innermost (closest to service)\npublic sealed class TrackerDecorator : IHostedService { ... }\n\n[DecoratorFor&lt;IHostedService&gt;(Order = 1)]\npublic sealed class LoggingDecorator : IHostedService { ... }\n\n[DecoratorFor&lt;IHostedService&gt;(Order = 2)]  // Outermost\npublic sealed class MetricsDecorator : IHostedService { ... }\n</code></pre> <p>Resolution order: <code>MetricsDecorator \u2192 LoggingDecorator \u2192 TrackerDecorator \u2192 ActualService</code></p>"},{"location":"hosted-services/#resolution-behavior","title":"Resolution Behavior","text":"<pre><code>var provider = new Syringe()\n    .UsingSourceGen()\n    .BuildServiceProvider();\n\n// Concrete resolution - NOT decorated\nvar worker = provider.GetRequiredService&lt;OrderProcessingWorker&gt;();\n\n// Interface resolution - decorated\nvar hostedServices = provider.GetServices&lt;IHostedService&gt;();\n// Each IHostedService is wrapped by all applicable decorators\n</code></pre>"},{"location":"hosted-services/#discovery-rules","title":"Discovery Rules","text":"<p>A type is discovered as a hosted service if: - \u2705 Inherits from <code>BackgroundService</code> OR implements <code>IHostedService</code> - \u2705 Is a concrete class (not abstract) - \u2705 Is accessible (public, or internal in the current assembly) - \u274c Does NOT have <code>[DoNotAutoRegister]</code> - \u274c Does NOT have <code>[DecoratorFor&lt;IHostedService&gt;]</code> (decorators are not services)</p>"},{"location":"hosted-services/#notes","title":"Notes","text":"<ul> <li>Hosted services are always registered as Singleton lifetime</li> <li>Decorators with <code>[DecoratorFor&lt;IHostedService&gt;]</code> are excluded from hosted service discovery to prevent circular dependencies</li> <li>Works with both source-gen and reflection paths</li> </ul>"},{"location":"interceptors/","title":"Interceptors","text":"<p>Interceptors provide a powerful way to add cross-cutting concerns to your services without modifying their implementation. Unlike decorators, which require implementing every method of an interface, interceptors handle method invocations with a single implementation that works across any service.</p> <p>Note: Interceptors are a source-generation only feature. They are not available with reflection-based registration.</p>"},{"location":"interceptors/#quick-start","title":"Quick Start","text":""},{"location":"interceptors/#1-create-an-interceptor","title":"1. Create an Interceptor","text":"<pre><code>using NexusLabs.Needlr;\n\npublic class LoggingInterceptor : IMethodInterceptor\n{\n    private readonly ILogger _logger;\n\n    public LoggingInterceptor(ILogger&lt;LoggingInterceptor&gt; logger)\n    {\n        _logger = logger;\n    }\n\n    public async ValueTask&lt;object?&gt; InterceptAsync(IMethodInvocation invocation)\n    {\n        _logger.LogInformation(\"Calling {Method}\", invocation.Method.Name);\n\n        try\n        {\n            var result = await invocation.ProceedAsync();\n            _logger.LogInformation(\"{Method} completed\", invocation.Method.Name);\n            return result;\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"{Method} failed\", invocation.Method.Name);\n            throw;\n        }\n    }\n}\n</code></pre>"},{"location":"interceptors/#2-apply-to-a-service","title":"2. Apply to a Service","text":"<pre><code>[Intercept&lt;LoggingInterceptor&gt;]\npublic class OrderService : IOrderService\n{\n    public Order GetOrder(int id) =&gt; /* ... */;\n    public Task&lt;Order&gt; CreateOrderAsync(CreateOrderRequest request) =&gt; /* ... */;\n    public void CancelOrder(int orderId) =&gt; /* ... */;\n}\n</code></pre>"},{"location":"interceptors/#3-use-the-service","title":"3. Use the Service","text":"<pre><code>var provider = new Syringe()\n    .UsingSourceGen()\n    .BuildServiceProvider();\n\nvar orderService = provider.GetRequiredService&lt;IOrderService&gt;();\norderService.GetOrder(123);  // Logging interceptor wraps this call\n</code></pre>"},{"location":"interceptors/#interceptors-vs-decorators","title":"Interceptors vs Decorators","text":"Feature Decorator Interceptor Implementation One class per service One class for any service Method handling Implement every interface method Single <code>InterceptAsync</code> handles all Apply to One service type Any service with <code>[Intercept]</code> Best for Service-specific behavior Cross-cutting concerns Reflection support Yes No (source-gen only)"},{"location":"interceptors/#when-to-use-each","title":"When to Use Each","text":"<p>Use Decorators when: - You need different behavior for different methods - You're modifying only one service type - You need reflection support</p> <p>Use Interceptors when: - The same logic applies to all methods (logging, timing, caching) - You want to reuse the same interceptor across many services - You're using source generation</p>"},{"location":"interceptors/#class-level-vs-method-level-interceptors","title":"Class-Level vs Method-Level Interceptors","text":""},{"location":"interceptors/#class-level-all-methods","title":"Class-Level (All Methods)","text":"<p>Apply to all methods of a service:</p> <pre><code>[Intercept&lt;TimingInterceptor&gt;]\n[Intercept&lt;LoggingInterceptor&gt;]\npublic class ProductService : IProductService\n{\n    public Product GetProduct(int id) =&gt; /* ... */;     // Both interceptors run\n    public void UpdateProduct(Product p) =&gt; /* ... */;  // Both interceptors run\n}\n</code></pre>"},{"location":"interceptors/#method-level-selective","title":"Method-Level (Selective)","text":"<p>Apply to specific methods only:</p> <pre><code>public class CalculatorService : ICalculatorService\n{\n    public int Add(int a, int b) =&gt; a + b;  // No interceptor (direct call)\n\n    [Intercept&lt;TimingInterceptor&gt;]\n    public int Multiply(int a, int b)       // Only TimingInterceptor\n    {\n        Thread.Sleep(100);  // Expensive operation\n        return a * b;\n    }\n\n    [Intercept&lt;TimingInterceptor&gt;]\n    [Intercept&lt;CachingInterceptor&gt;]\n    public int Divide(int a, int b)         // Both interceptors\n    {\n        return a / b;\n    }\n}\n</code></pre>"},{"location":"interceptors/#interceptor-ordering","title":"Interceptor Ordering","text":"<p>When multiple interceptors are applied, use the <code>Order</code> property to control execution order:</p> <pre><code>[Intercept&lt;TimingInterceptor&gt;(Order = 1)]    // Runs first (outermost)\n[Intercept&lt;CachingInterceptor&gt;(Order = 2)]   // Runs second (inner)\npublic class DataService : IDataService { }\n</code></pre> <p>Execution flow: <pre><code>TimingInterceptor.InterceptAsync\n    \u2192 CachingInterceptor.InterceptAsync\n        \u2192 DataService.GetData (actual method)\n    \u2190 CachingInterceptor returns\n\u2190 TimingInterceptor returns\n</code></pre></p> <p>Lower <code>Order</code> values run first and are the outermost wrapper.</p>"},{"location":"interceptors/#imethodinvocation-interface","title":"IMethodInvocation Interface","text":"<p>The <code>IMethodInvocation</code> interface provides context about the intercepted call:</p> <pre><code>public interface IMethodInvocation\n{\n    object Target { get; }           // The service instance\n    MethodInfo Method { get; }       // Method being called\n    object?[] Arguments { get; }     // Arguments (can be modified)\n    Type[] GenericArguments { get; } // Generic type arguments (if any)\n\n    ValueTask&lt;object?&gt; ProceedAsync();  // Continue to next interceptor or target\n}\n</code></pre>"},{"location":"interceptors/#accessing-method-information","title":"Accessing Method Information","text":"<pre><code>public async ValueTask&lt;object?&gt; InterceptAsync(IMethodInvocation invocation)\n{\n    // Get the service type\n    var serviceType = invocation.Target.GetType().Name;\n\n    // Get method name\n    var methodName = invocation.Method.Name;\n\n    // Get arguments\n    var args = string.Join(\", \", invocation.Arguments);\n\n    Console.WriteLine($\"Calling {serviceType}.{methodName}({args})\");\n\n    return await invocation.ProceedAsync();\n}\n</code></pre>"},{"location":"interceptors/#modifying-arguments","title":"Modifying Arguments","text":"<pre><code>public async ValueTask&lt;object?&gt; InterceptAsync(IMethodInvocation invocation)\n{\n    // Modify the first argument before calling\n    if (invocation.Arguments.Length &gt; 0 &amp;&amp; invocation.Arguments[0] is string s)\n    {\n        invocation.Arguments[0] = s.ToUpperInvariant();\n    }\n\n    return await invocation.ProceedAsync();\n}\n</code></pre>"},{"location":"interceptors/#modifying-return-values","title":"Modifying Return Values","text":"<pre><code>public async ValueTask&lt;object?&gt; InterceptAsync(IMethodInvocation invocation)\n{\n    var result = await invocation.ProceedAsync();\n\n    // Wrap the result\n    if (result is string s)\n    {\n        return $\"[Modified] {s}\";\n    }\n\n    return result;\n}\n</code></pre>"},{"location":"interceptors/#common-interceptor-patterns","title":"Common Interceptor Patterns","text":""},{"location":"interceptors/#timing-interceptor","title":"Timing Interceptor","text":"<pre><code>public class TimingInterceptor : IMethodInterceptor\n{\n    private readonly ILogger _logger;\n\n    public TimingInterceptor(ILogger&lt;TimingInterceptor&gt; logger) =&gt; _logger = logger;\n\n    public async ValueTask&lt;object?&gt; InterceptAsync(IMethodInvocation invocation)\n    {\n        var sw = Stopwatch.StartNew();\n\n        try\n        {\n            return await invocation.ProceedAsync();\n        }\n        finally\n        {\n            _logger.LogInformation(\n                \"{Type}.{Method} completed in {Elapsed}ms\",\n                invocation.Target.GetType().Name,\n                invocation.Method.Name,\n                sw.ElapsedMilliseconds);\n        }\n    }\n}\n</code></pre>"},{"location":"interceptors/#caching-interceptor","title":"Caching Interceptor","text":"<pre><code>public class CachingInterceptor : IMethodInterceptor\n{\n    private readonly ConcurrentDictionary&lt;string, object?&gt; _cache = new();\n\n    public async ValueTask&lt;object?&gt; InterceptAsync(IMethodInvocation invocation)\n    {\n        var cacheKey = BuildCacheKey(invocation);\n\n        if (_cache.TryGetValue(cacheKey, out var cached))\n        {\n            return cached;\n        }\n\n        var result = await invocation.ProceedAsync();\n        _cache[cacheKey] = result;\n        return result;\n    }\n\n    private static string BuildCacheKey(IMethodInvocation invocation)\n    {\n        var args = string.Join(\",\", invocation.Arguments.Select(a =&gt; a?.ToString() ?? \"null\"));\n        return $\"{invocation.Target.GetType().Name}.{invocation.Method.Name}({args})\";\n    }\n}\n</code></pre>"},{"location":"interceptors/#retry-interceptor","title":"Retry Interceptor","text":"<pre><code>public class RetryInterceptor : IMethodInterceptor\n{\n    private readonly ILogger _logger;\n\n    public RetryInterceptor(ILogger&lt;RetryInterceptor&gt; logger) =&gt; _logger = logger;\n\n    public async ValueTask&lt;object?&gt; InterceptAsync(IMethodInvocation invocation)\n    {\n        const int maxRetries = 3;\n\n        for (var attempt = 1; attempt &lt;= maxRetries; attempt++)\n        {\n            try\n            {\n                return await invocation.ProceedAsync();\n            }\n            catch (Exception ex) when (attempt &lt; maxRetries)\n            {\n                _logger.LogWarning(ex, \n                    \"Attempt {Attempt}/{Max} failed for {Method}, retrying...\",\n                    attempt, maxRetries, invocation.Method.Name);\n\n                await Task.Delay(TimeSpan.FromSeconds(Math.Pow(2, attempt)));\n            }\n        }\n\n        throw new InvalidOperationException(\"Should not reach here\");\n    }\n}\n</code></pre>"},{"location":"interceptors/#validation-interceptor","title":"Validation Interceptor","text":"<pre><code>public class ValidationInterceptor : IMethodInterceptor\n{\n    public async ValueTask&lt;object?&gt; InterceptAsync(IMethodInvocation invocation)\n    {\n        // Validate all arguments\n        foreach (var arg in invocation.Arguments)\n        {\n            if (arg is null)\n            {\n                throw new ArgumentNullException(\n                    $\"Null argument passed to {invocation.Method.Name}\");\n            }\n        }\n\n        return await invocation.ProceedAsync();\n    }\n}\n</code></pre>"},{"location":"interceptors/#interceptor-dependencies","title":"Interceptor Dependencies","text":"<p>Interceptors are registered as services and can have their own dependencies:</p> <pre><code>public class AuditInterceptor : IMethodInterceptor\n{\n    private readonly IAuditService _audit;\n    private readonly ICurrentUser _user;\n\n    public AuditInterceptor(IAuditService audit, ICurrentUser user)\n    {\n        _audit = audit;\n        _user = user;\n    }\n\n    public async ValueTask&lt;object?&gt; InterceptAsync(IMethodInvocation invocation)\n    {\n        await _audit.LogAsync(new AuditEntry\n        {\n            User = _user.Id,\n            Action = invocation.Method.Name,\n            Timestamp = DateTime.UtcNow\n        });\n\n        return await invocation.ProceedAsync();\n    }\n}\n</code></pre>"},{"location":"interceptors/#auto-registration-exclusion","title":"Auto-Registration Exclusion","text":"<p>Interceptors are automatically excluded from Needlr's auto-registration because they implement <code>IMethodInterceptor</code>, which is marked with <code>[DoNotAutoRegister]</code>. This is by design\u2014interceptors are resolved by the generated proxy, not by user code.</p> <p>You do not need to add <code>[DoNotAutoRegister]</code> to your interceptor classes.</p>"},{"location":"interceptors/#limitations","title":"Limitations","text":"<ol> <li> <p>Source-generation only: Interceptors are not available with reflection-based registration.</p> </li> <li> <p>Interface-based: The intercepted service must implement at least one interface. The proxy is registered for the interface, not the concrete type.</p> </li> <li> <p>Generic methods: Generic methods are not currently supported for interception.</p> </li> <li> <p>Async overhead: All interception goes through <code>ValueTask&lt;object?&gt;</code>, so there's boxing overhead for value types and sync methods pay the async state machine cost.</p> </li> </ol>"},{"location":"interceptors/#analyzers","title":"Analyzers","text":"<p>Needlr provides analyzers to catch common interceptor mistakes at compile time:</p> Rule ID Severity Description NDLRCOR007 Error Intercept type must implement IMethodInterceptor NDLRCOR008 Warning [Intercept] applied to class without interfaces"},{"location":"interceptors/#see-also","title":"See Also","text":"<ul> <li>Decorators - For service-specific wrapping</li> <li>Getting Started - Source generation setup</li> <li>Example: AotSourceGenConsoleApp - Working interceptor examples</li> </ul>"},{"location":"keyed-services/","title":"Keyed Services","text":"<p>Keyed services allow multiple implementations of the same interface to be registered with different keys, enabling consumers to resolve specific implementations.</p>"},{"location":"keyed-services/#registering-keyed-services","title":"Registering Keyed Services","text":"<p>Use the <code>[Keyed]</code> attribute to register a service with a specific key:</p> <pre><code>public interface ICacheProvider\n{\n    string Name { get; }\n}\n\n[Keyed(\"redis\")]\npublic sealed class RedisCacheProvider : ICacheProvider\n{\n    public string Name =&gt; \"redis\";\n}\n\n[Keyed(\"memory\")]\npublic sealed class MemoryCacheProvider : ICacheProvider\n{\n    public string Name =&gt; \"memory\";\n}\n</code></pre> <p>This generates registrations equivalent to:</p> <pre><code>services.AddKeyedSingleton&lt;ICacheProvider, RedisCacheProvider&gt;(\"redis\");\nservices.AddKeyedSingleton&lt;ICacheProvider, MemoryCacheProvider&gt;(\"memory\");\n</code></pre>"},{"location":"keyed-services/#consuming-keyed-services","title":"Consuming Keyed Services","text":"<p>Use the <code>[FromKeyedServices]</code> attribute (from <code>Microsoft.Extensions.DependencyInjection</code>) on constructor parameters to resolve keyed services:</p> <pre><code>public sealed class CacheManager\n{\n    private readonly ICacheProvider _primaryCache;\n    private readonly ICacheProvider _fallbackCache;\n\n    public CacheManager(\n        [FromKeyedServices(\"redis\")] ICacheProvider primaryCache,\n        [FromKeyedServices(\"memory\")] ICacheProvider fallbackCache)\n    {\n        _primaryCache = primaryCache;\n        _fallbackCache = fallbackCache;\n    }\n}\n</code></pre>"},{"location":"keyed-services/#mixing-keyed-and-regular-dependencies","title":"Mixing Keyed and Regular Dependencies","text":"<p>You can combine keyed and regular (unkeyed) dependencies in the same constructor:</p> <pre><code>public sealed class OrderService\n{\n    public OrderService(\n        [FromKeyedServices(\"primary\")] IPaymentProcessor processor,\n        ILogger&lt;OrderService&gt; logger)  // Regular dependency\n    {\n        // ...\n    }\n}\n</code></pre>"},{"location":"keyed-services/#registering-via-plugin","title":"Registering via Plugin","text":"<p>For more complex registration scenarios, use <code>IServiceCollectionPlugin</code>:</p> <pre><code>public sealed class PaymentServicesPlugin : IServiceCollectionPlugin\n{\n    public void Configure(ServiceCollectionPluginOptions options)\n    {\n        options.Services.AddKeyedSingleton&lt;IPaymentProcessor, StripeProcessor&gt;(\"stripe\");\n        options.Services.AddKeyedSingleton&lt;IPaymentProcessor, PayPalProcessor&gt;(\"paypal\");\n    }\n}\n</code></pre>"},{"location":"keyed-services/#notes","title":"Notes","text":"<ul> <li><code>[Keyed]</code> can be applied multiple times to register the same class with different keys</li> <li>Keyed services respect the same lifetime rules as regular services</li> <li>The key is a string value passed to <code>[FromKeyedServices(\"key\")]</code> when resolving</li> <li>This feature requires .NET 8+ (where keyed services were introduced)</li> <li>Both source-gen and reflection paths support keyed services</li> </ul>"},{"location":"open-generic-decorators/","title":"Open Generic Decorators","text":"<p>Open generic decorators allow you to define a single decorator class that automatically wraps all closed implementations of an open generic interface. This is a source-generation-only feature.</p>"},{"location":"open-generic-decorators/#overview","title":"Overview","text":"<p>When you have a generic interface like <code>IHandler&lt;T&gt;</code> with multiple implementations (<code>OrderHandler : IHandler&lt;Order&gt;</code>, <code>PaymentHandler : IHandler&lt;Payment&gt;</code>, etc.), you typically want to apply cross-cutting concerns (logging, validation, metrics) to all of them.</p> <p>With <code>[OpenDecoratorFor]</code>, you define the decorator once and Needlr generates the decorator registrations for every closed implementation at compile time.</p>"},{"location":"open-generic-decorators/#basic-usage","title":"Basic Usage","text":"<pre><code>using NexusLabs.Needlr;\nusing NexusLabs.Needlr.Generators;\n\n// Define your open generic interface\npublic interface IHandler&lt;T&gt;\n{\n    Task HandleAsync(T message);\n}\n\n// Define concrete handlers\n[Singleton]\npublic class OrderHandler : IHandler&lt;Order&gt;\n{\n    public Task HandleAsync(Order message) { /* ... */ }\n}\n\n[Singleton]\npublic class PaymentHandler : IHandler&lt;Payment&gt;\n{\n    public Task HandleAsync(Payment message) { /* ... */ }\n}\n\n// Define an open generic decorator\n[OpenDecoratorFor(typeof(IHandler&lt;&gt;))]\npublic class LoggingDecorator&lt;T&gt; : IHandler&lt;T&gt;\n{\n    private readonly IHandler&lt;T&gt; _inner;\n    private readonly ILogger&lt;LoggingDecorator&lt;T&gt;&gt; _logger;\n\n    public LoggingDecorator(IHandler&lt;T&gt; inner, ILogger&lt;LoggingDecorator&lt;T&gt;&gt; logger)\n    {\n        _inner = inner;\n        _logger = logger;\n    }\n\n    public async Task HandleAsync(T message)\n    {\n        _logger.LogInformation(\"Handling {MessageType}\", typeof(T).Name);\n        await _inner.HandleAsync(message);\n        _logger.LogInformation(\"Handled {MessageType}\", typeof(T).Name);\n    }\n}\n</code></pre>"},{"location":"open-generic-decorators/#what-gets-generated","title":"What Gets Generated","text":"<p>At compile time, Needlr discovers all closed implementations of <code>IHandler&lt;T&gt;</code> and generates decorator registrations for each:</p> <pre><code>// Generated code (simplified)\nservices.AddDecorator&lt;IHandler&lt;Order&gt;, LoggingDecorator&lt;Order&gt;&gt;();\nservices.AddDecorator&lt;IHandler&lt;Payment&gt;, LoggingDecorator&lt;Payment&gt;&gt;();\n</code></pre>"},{"location":"open-generic-decorators/#ordering-multiple-decorators","title":"Ordering Multiple Decorators","text":"<p>Use the <code>Order</code> property to control decorator application order (lower = closer to the original service):</p> <pre><code>[OpenDecoratorFor(typeof(IHandler&lt;&gt;), Order = 1)]\npublic class LoggingDecorator&lt;T&gt; : IHandler&lt;T&gt; { /* ... */ }\n\n[OpenDecoratorFor(typeof(IHandler&lt;&gt;), Order = 2)]\npublic class MetricsDecorator&lt;T&gt; : IHandler&lt;T&gt; { /* ... */ }\n\n// Result chain: MetricsDecorator \u2192 LoggingDecorator \u2192 Handler\n</code></pre>"},{"location":"open-generic-decorators/#multi-parameter-generics","title":"Multi-Parameter Generics","text":"<p>Open generic decorators work with interfaces that have multiple type parameters:</p> <pre><code>public interface IRequestHandler&lt;TRequest, TResponse&gt;\n{\n    TResponse Handle(TRequest request);\n}\n\n[OpenDecoratorFor(typeof(IRequestHandler&lt;,&gt;))]\npublic class ValidationDecorator&lt;TRequest, TResponse&gt; : IRequestHandler&lt;TRequest, TResponse&gt;\n{\n    private readonly IRequestHandler&lt;TRequest, TResponse&gt; _inner;\n\n    public ValidationDecorator(IRequestHandler&lt;TRequest, TResponse&gt; inner) =&gt; _inner = inner;\n\n    public TResponse Handle(TRequest request)\n    {\n        Validate(request);\n        return _inner.Handle(request);\n    }\n}\n</code></pre>"},{"location":"open-generic-decorators/#comparison-with-decoratorfort","title":"Comparison with <code>[DecoratorFor&lt;T&gt;]</code>","text":"Feature <code>[DecoratorFor&lt;T&gt;]</code> <code>[OpenDecoratorFor]</code> Supports closed types \u2705 \u274c Supports open generics \u274c \u2705 Works with reflection \u2705 \u274c Works with source-gen \u2705 \u2705 Attribute location <code>NexusLabs.Needlr</code> <code>NexusLabs.Needlr.Generators</code> <p>Use <code>[DecoratorFor&lt;T&gt;]</code> when: - You're decorating a specific closed type (e.g., <code>IOrderService</code>) - You need reflection path compatibility</p> <p>Use <code>[OpenDecoratorFor]</code> when: - You want to decorate all implementations of a generic interface - You're using source generation (required) - You want compile-time expansion</p>"},{"location":"open-generic-decorators/#validation","title":"Validation","text":"<p>Needlr provides compile-time analyzers to catch configuration errors:</p> Diagnostic Description NDLRGEN006 Type argument must be an open generic interface NDLRGEN007 Decorator class must be an open generic with matching arity NDLRGEN008 Decorator must implement the interface it decorates"},{"location":"open-generic-decorators/#example-errors","title":"Example Errors","text":"<pre><code>// NDLRGEN006: Must use typeof(IHandler&lt;&gt;), not typeof(IHandler&lt;string&gt;)\n[OpenDecoratorFor(typeof(IHandler&lt;string&gt;))]  // \u274c Error\npublic class BadDecorator&lt;T&gt; : IHandler&lt;T&gt; { }\n\n// NDLRGEN007: Decorator must be generic with same parameter count\n[OpenDecoratorFor(typeof(IHandler&lt;&gt;))]\npublic class BadDecorator : IHandler&lt;string&gt; { }  // \u274c Error - not generic\n\n// NDLRGEN008: Decorator must implement the interface\n[OpenDecoratorFor(typeof(IHandler&lt;&gt;))]\npublic class BadDecorator&lt;T&gt; { }  // \u274c Error - doesn't implement IHandler&lt;T&gt;\n</code></pre>"},{"location":"open-generic-decorators/#namespace-import","title":"Namespace Import","text":"<p>The <code>[OpenDecoratorFor]</code> attribute is in the <code>NexusLabs.Needlr.Generators</code> namespace:</p> <pre><code>using NexusLabs.Needlr.Generators;\n</code></pre> <p>This is intentional - it signals that the feature is source-generation-only.</p>"},{"location":"open-generic-decorators/#common-patterns","title":"Common Patterns","text":""},{"location":"open-generic-decorators/#cqrs-commandquery-decorators","title":"CQRS Command/Query Decorators","text":"<pre><code>public interface ICommandHandler&lt;TCommand&gt; where TCommand : ICommand\n{\n    Task HandleAsync(TCommand command, CancellationToken ct);\n}\n\npublic interface IQueryHandler&lt;TQuery, TResult&gt; where TQuery : IQuery&lt;TResult&gt;\n{\n    Task&lt;TResult&gt; HandleAsync(TQuery query, CancellationToken ct);\n}\n\n// Apply validation to all commands\n[OpenDecoratorFor(typeof(ICommandHandler&lt;&gt;), Order = 1)]\npublic class ValidationDecorator&lt;T&gt; : ICommandHandler&lt;T&gt; where T : ICommand\n{\n    private readonly ICommandHandler&lt;T&gt; _inner;\n    private readonly IValidator&lt;T&gt; _validator;\n\n    public ValidationDecorator(ICommandHandler&lt;T&gt; inner, IValidator&lt;T&gt; validator)\n    {\n        _inner = inner;\n        _validator = validator;\n    }\n\n    public async Task HandleAsync(T command, CancellationToken ct)\n    {\n        await _validator.ValidateAndThrowAsync(command, ct);\n        await _inner.HandleAsync(command, ct);\n    }\n}\n</code></pre>"},{"location":"open-generic-decorators/#retryresilience-patterns","title":"Retry/Resilience Patterns","text":"<pre><code>[OpenDecoratorFor(typeof(IHandler&lt;&gt;), Order = 0)]  // Outermost\npublic class RetryDecorator&lt;T&gt; : IHandler&lt;T&gt;\n{\n    private readonly IHandler&lt;T&gt; _inner;\n    private readonly IAsyncPolicy _policy;\n\n    public RetryDecorator(IHandler&lt;T&gt; inner, IAsyncPolicy policy)\n    {\n        _inner = inner;\n        _policy = policy;\n    }\n\n    public Task HandleAsync(T message) =&gt; \n        _policy.ExecuteAsync(() =&gt; _inner.HandleAsync(message));\n}\n</code></pre>"},{"location":"open-generic-decorators/#limitations","title":"Limitations","text":"<ol> <li>Source-generation only: This feature is not available in the reflection path</li> <li>Compile-time discovery: Only implementations visible at compile time are decorated</li> <li>Same assembly or referenced assemblies: Implementations must be discoverable by the source generator</li> </ol>"},{"location":"options/","title":"Options Binding","text":"<p>The <code>[Options]</code> attribute provides automatic configuration binding for your options classes, integrating with Microsoft's Options pattern.</p>"},{"location":"options/#quick-start","title":"Quick Start","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n[Options]\npublic class CacheSettings\n{\n    public int TimeoutSeconds { get; set; } = 300;\n    public int MaxItems { get; set; } = 1000;\n}\n</code></pre> <pre><code>// appsettings.json\n{\n  \"CacheSettings\": {\n    \"TimeoutSeconds\": 600,\n    \"MaxItems\": 5000\n  }\n}\n</code></pre> <p>The generator automatically: 1. Binds your options class to the configuration section 2. Registers it with the DI container 3. Makes it available via <code>IOptions&lt;CacheSettings&gt;</code>, <code>IOptionsSnapshot&lt;CacheSettings&gt;</code>, or <code>IOptionsMonitor&lt;CacheSettings&gt;</code></p>"},{"location":"options/#section-name","title":"Section Name","text":""},{"location":"options/#convention-based-default","title":"Convention-Based (Default)","text":"<p>By default, the section name is inferred from the class name:</p> Class Name Section Name <code>CacheSettings</code> <code>CacheSettings</code> <code>DatabaseOptions</code> <code>DatabaseOptions</code> <code>SmtpConfiguration</code> <code>SmtpConfiguration</code>"},{"location":"options/#explicit-section-name","title":"Explicit Section Name","text":"<p>Specify a custom section name:</p> <pre><code>[Options(\"MyApp:Database\")]\npublic class DatabaseOptions\n{\n    public string ConnectionString { get; set; } = \"\";\n}\n</code></pre> <pre><code>{\n  \"MyApp\": {\n    \"Database\": {\n      \"ConnectionString\": \"Server=...\"\n    }\n  }\n}\n</code></pre>"},{"location":"options/#named-options","title":"Named Options","text":"<p>For multiple configurations of the same type, use named options:</p> <pre><code>[Options(\"Databases:Primary\", Name = \"Primary\")]\npublic class DatabaseOptions\n{\n    public string ConnectionString { get; set; } = \"\";\n}\n\n[Options(\"Databases:Replica\", Name = \"Replica\")]\npublic class ReplicaDatabaseOptions : DatabaseOptions { }\n</code></pre> <p>Retrieve named options using <code>IOptionsSnapshot&lt;T&gt;</code> or <code>IOptionsMonitor&lt;T&gt;</code>:</p> <pre><code>public class MyService\n{\n    public MyService(IOptionsSnapshot&lt;DatabaseOptions&gt; options)\n    {\n        var primary = options.Get(\"Primary\");\n        var replica = options.Get(\"Replica\");\n    }\n}\n</code></pre>"},{"location":"options/#validation","title":"Validation","text":""},{"location":"options/#data-annotations","title":"Data Annotations","text":"<p>Use standard <code>System.ComponentModel.DataAnnotations</code> attributes:</p> <pre><code>using System.ComponentModel.DataAnnotations;\n\n[Options(ValidateOnStart = true)]\npublic class ApiSettings\n{\n    [Required]\n    public string ApiKey { get; set; } = \"\";\n\n    [Range(1, 300)]\n    public int TimeoutSeconds { get; set; } = 30;\n\n    [Url]\n    public string BaseUrl { get; set; } = \"\";\n}\n</code></pre> <p>When <code>ValidateOnStart = true</code>, the application will fail to start if validation fails.</p>"},{"location":"options/#custom-validation-method","title":"Custom Validation Method","text":"<p>Add a <code>Validate()</code> method to your options class:</p> <pre><code>[Options(ValidateOnStart = true)]\npublic class StripeOptions\n{\n    public string ApiKey { get; set; } = \"\";\n    public bool IsProduction { get; set; }\n\n    // Convention: method named \"Validate\" is auto-discovered\n    public IEnumerable&lt;ValidationError&gt; Validate()\n    {\n        if (IsProduction &amp;&amp; !ApiKey.StartsWith(\"sk_live_\"))\n            yield return \"Production requires a live API key\";\n\n        if (!IsProduction &amp;&amp; !ApiKey.StartsWith(\"sk_test_\"))\n            yield return \"Test mode requires a test API key\";\n    }\n}\n</code></pre>"},{"location":"options/#custom-method-name","title":"Custom Method Name","text":"<p>Use a different method name with <code>ValidateMethod</code>:</p> <pre><code>[Options(ValidateOnStart = true, ValidateMethod = nameof(CheckConfiguration))]\npublic class EmailOptions\n{\n    public string SmtpHost { get; set; } = \"\";\n\n    public IEnumerable&lt;ValidationError&gt; CheckConfiguration()\n    {\n        if (string.IsNullOrEmpty(SmtpHost))\n            yield return \"SMTP host is required\";\n    }\n}\n</code></pre>"},{"location":"options/#external-validator","title":"External Validator","text":"<p>Delegate validation to a separate class:</p> <pre><code>[Options(ValidateOnStart = true, Validator = typeof(PaymentOptionsValidator))]\npublic class PaymentOptions\n{\n    public string MerchantId { get; set; } = \"\";\n    public decimal MinAmount { get; set; }\n    public decimal MaxAmount { get; set; }\n}\n\npublic class PaymentOptionsValidator : IOptionsValidator&lt;PaymentOptions&gt;\n{\n    public IEnumerable&lt;ValidationError&gt; Validate(PaymentOptions options)\n    {\n        if (string.IsNullOrEmpty(options.MerchantId))\n            yield return \"MerchantId is required\";\n\n        if (options.MinAmount &gt;= options.MaxAmount)\n            yield return \"MinAmount must be less than MaxAmount\";\n    }\n}\n</code></pre>"},{"location":"options/#fluentvalidation-integration","title":"FluentValidation Integration","text":"<p>If you're using FluentValidation, validators are automatically discovered:</p> <pre><code>[Options(\"Database\", ValidateOnStart = true, Validator = typeof(DatabaseOptionsValidator))]\npublic class DatabaseOptions\n{\n    public string ConnectionString { get; set; } = \"\";\n    public int MaxPoolSize { get; set; } = 100;\n}\n\npublic class DatabaseOptionsValidator : AbstractValidator&lt;DatabaseOptions&gt;\n{\n    public DatabaseOptionsValidator()\n    {\n        RuleFor(x =&gt; x.ConnectionString)\n            .NotEmpty()\n            .WithMessage(\"Connection string is required\");\n\n        RuleFor(x =&gt; x.MaxPoolSize)\n            .InclusiveBetween(1, 1000);\n    }\n}\n</code></pre> <p>See FluentValidation Integration for more details.</p>"},{"location":"options/#attribute-properties","title":"Attribute Properties","text":"Property Type Default Description <code>SectionName</code> <code>string?</code> Class name Configuration section to bind <code>Name</code> <code>string?</code> <code>null</code> Named options identifier <code>ValidateOnStart</code> <code>bool</code> <code>false</code> Validate at application startup <code>ValidateMethod</code> <code>string?</code> <code>\"Validate\"</code> Custom validation method name <code>Validator</code> <code>Type?</code> <code>null</code> External validator type"},{"location":"options/#generated-code","title":"Generated Code","text":"<p>The <code>[Options]</code> attribute causes the generator to emit registration code in <code>TypeRegistry.RegisterOptions()</code>:</p> <pre><code>// Generated code (simplified)\npublic static void RegisterOptions(IServiceCollection services, IConfiguration configuration)\n{\n    // Without validation\n    services.Configure&lt;CacheSettings&gt;(configuration.GetSection(\"CacheSettings\"));\n\n    // With validation\n    services.AddOptions&lt;ApiSettings&gt;()\n        .BindConfiguration(\"ApiSettings\")\n        .ValidateDataAnnotations()\n        .ValidateOnStart();\n}\n</code></pre>"},{"location":"options/#consuming-options","title":"Consuming Options","text":"<p>Inject options using standard Microsoft.Extensions.Options patterns:</p> <pre><code>public class MyService\n{\n    private readonly CacheSettings _settings;\n\n    // Option 1: IOptions&lt;T&gt; - singleton, doesn't reload\n    public MyService(IOptions&lt;CacheSettings&gt; options)\n    {\n        _settings = options.Value;\n    }\n\n    // Option 2: IOptionsSnapshot&lt;T&gt; - scoped, reloads per request\n    public MyService(IOptionsSnapshot&lt;CacheSettings&gt; options)\n    {\n        _settings = options.Value;\n    }\n\n    // Option 3: IOptionsMonitor&lt;T&gt; - singleton, live reload\n    public MyService(IOptionsMonitor&lt;CacheSettings&gt; options)\n    {\n        _settings = options.CurrentValue;\n        options.OnChange(newValue =&gt; { /* handle reload */ });\n    }\n}\n</code></pre>"},{"location":"options/#immutable-options","title":"Immutable Options","text":"<p>The <code>[Options]</code> attribute supports immutable options patterns, including <code>init</code>-only properties and records with init properties.</p>"},{"location":"options/#init-only-properties","title":"Init-Only Properties","text":"<pre><code>[Options(\"Cache\")]\npublic class CacheOptions\n{\n    public required string Host { get; init; }\n    public int Port { get; init; } = 6379;\n    public int TimeoutMs { get; init; } = 5000;\n}\n</code></pre>"},{"location":"options/#records-with-init-properties","title":"Records with Init Properties","text":"<pre><code>[Options(\"Redis\")]\npublic record RedisOptions\n{\n    public string Host { get; init; } = \"localhost\";\n    public int Port { get; init; } = 6379;\n}\n</code></pre>"},{"location":"options/#configuration-reload-with-immutable-types","title":"Configuration Reload with Immutable Types","text":"<p>Immutable types work correctly with <code>IOptionsMonitor&lt;T&gt;</code> for configuration reload. When the configuration file changes:</p> <ol> <li>A new instance is created with the updated values</li> <li><code>IOptionsMonitor&lt;T&gt;.CurrentValue</code> returns the new instance</li> <li><code>OnChange()</code> callbacks receive the new instance</li> </ol> <pre><code>public class CacheService\n{\n    private readonly IOptionsMonitor&lt;CacheOptions&gt; _options;\n\n    public CacheService(IOptionsMonitor&lt;CacheOptions&gt; options)\n    {\n        _options = options;\n\n        // React to configuration changes\n        options.OnChange(newOptions =&gt;\n        {\n            // newOptions is a new immutable instance\n            Console.WriteLine($\"Cache timeout changed to {newOptions.TimeoutMs}ms\");\n        });\n    }\n\n    public CacheOptions CurrentConfig =&gt; _options.CurrentValue;\n}\n</code></pre>"},{"location":"options/#positional-records","title":"Positional Records","text":"<p>Positional records (records with primary constructor parameters) are supported when declared as <code>partial</code>:</p> <pre><code>// \u2705 WORKS - partial positional record\n[Options(\"Redis\")]\npublic partial record RedisOptions(string Host, int Port);\n\n// \u2705 WORKS - init-only properties (no partial needed)\n[Options(\"Redis\")]\npublic record RedisOptions\n{\n    public string Host { get; init; } = \"\";\n    public int Port { get; init; } = 6379;\n}\n</code></pre> <p>When you use <code>partial</code>, Needlr generates a parameterless constructor that chains to the primary constructor:</p> <pre><code>// Generated code:\npublic partial record RedisOptions\n{\n    public RedisOptions() : this(string.Empty, default) { }\n}\n</code></pre> <p>This enables Microsoft's configuration binder to instantiate the record.</p> <p>\u26a0\ufe0f Non-partial positional records will emit warning NDLRGEN021 because they cannot work with configuration binding at runtime.</p>"},{"location":"options/#aot-compatibility","title":"AOT Compatibility","text":"<p>\u26a0\ufe0f Important: The <code>[Options]</code> attribute is not compatible with Native AOT.</p> <p>The generated code uses <code>Configure&lt;T&gt;()</code> and <code>BindConfiguration()</code> which rely on reflection for property binding. These APIs have <code>[RequiresDynamicCode]</code> attributes, making them incompatible with AOT compilation.</p> <p>If your project has <code>PublishAot=true</code> or <code>IsAotCompatible=true</code>, the generator will emit error NDLRGEN020.</p> <p>Workaround for AOT projects: Bind configuration manually:</p> <pre><code>public class CacheSettings\n{\n    public int TimeoutSeconds { get; set; }\n\n    public static CacheSettings FromConfiguration(IConfiguration config)\n    {\n        var section = config.GetSection(\"CacheSettings\");\n        return new CacheSettings\n        {\n            TimeoutSeconds = section.GetValue&lt;int&gt;(\"TimeoutSeconds\")\n        };\n    }\n}\n\n// In startup:\nvar settings = CacheSettings.FromConfiguration(configuration);\nservices.AddSingleton(Microsoft.Extensions.Options.Options.Create(settings));\n</code></pre>"},{"location":"options/#analyzers","title":"Analyzers","text":"<p>The following analyzers help catch common mistakes:</p> Analyzer Severity Description NDLRGEN014 Error Validator type has no validation method NDLRGEN015 Error Validator type mismatch NDLRGEN016 Error Validation method not found NDLRGEN017 Error Validation method has wrong signature NDLRGEN018 Warning Validator won't run (ValidateOnStart is false) NDLRGEN019 Warning Validation method won't run (ValidateOnStart is false) NDLRGEN020 Error [Options] is not compatible with Native AOT NDLRGEN021 Warning Positional record must be partial for [Options]"},{"location":"options/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Always validate in production: Use <code>ValidateOnStart = true</code> to fail fast on misconfiguration</p> </li> <li> <p>Use strongly-typed sections: Prefer explicit section names over relying on conventions when your config structure is complex</p> </li> <li> <p>Separate validation logic: Use external validators for complex validation rules to keep options classes clean</p> </li> <li> <p>Document required settings: Use <code>[Required]</code> and XML comments to make configuration requirements clear</p> </li> <li> <p>Provide sensible defaults: Initialize properties with default values for optional settings</p> </li> </ol>"},{"location":"options/#see-also","title":"See Also","text":"<ul> <li>FluentValidation Integration</li> <li>Getting Started</li> <li>Analyzers Reference</li> </ul>"},{"location":"plugin-development/","title":"Plugin Development Guide","text":"<p>Plugins are a powerful way to extend Needlr's functionality and configure your application in a modular, reusable way.</p>"},{"location":"plugin-development/#plugin-types","title":"Plugin Types","text":"<p>Needlr provides several main plugin interfaces, each serving a specific purpose in the application lifecycle. They are intended to be split out into different packages as necessary with some in the core set of packages and others split out into others so you can control what you incorporate.</p>"},{"location":"plugin-development/#1-iservicecollectionplugin","title":"1. IServiceCollectionPlugin","text":"<p>Configures services during the initial registration phase.</p> <pre><code>using Microsoft.Extensions.DependencyInjection;\nusing NexusLabs.Needlr;\n\npublic class DatabasePlugin : IServiceCollectionPlugin\n{\n    public void Configure(ServiceCollectionPluginOptions options)\n    {\n        // Access the service collection\n        options.Services.AddDbContext&lt;MyDbContext&gt;(opts =&gt;\n            opts.UseSqlServer(options.Configuration.GetConnectionString(\"Default\")));\n\n        // Log registration activities\n        options.Logger.LogInformation(\"Database context registered\");\n\n        // Access configuration\n        var connectionString = options.Configuration.GetConnectionString(\"Default\");\n\n        // Register additional services\n        options.Services.AddScoped&lt;IRepository, Repository&gt;();\n    }\n}\n</code></pre>"},{"location":"plugin-development/#2-ipostbuildservicecollectionplugin","title":"2. IPostBuildServiceCollectionPlugin","text":"<p>Executes after the main service collection has been built, useful for validation or late configuration.</p> <pre><code>public class ValidationPlugin : IPostBuildServiceCollectionPlugin\n{\n    public void Configure(PostBuildServiceCollectionPluginOptions options)\n    {\n        // Validate that required services are registered\n        var requiredService = options.ServiceProvider.GetService&lt;IRequiredService&gt;();\n        if (requiredService == null)\n        {\n            options.Logger.LogError(\"IRequiredService is not registered!\");\n            throw new InvalidOperationException(\"Required service missing\");\n        }\n\n        // Perform post-build configuration\n        var configService = options.ServiceProvider.GetRequiredService&lt;IConfigurationService&gt;();\n        configService.Validate();\n\n        options.Logger.LogInformation(\"Post-build validation completed\");\n    }\n}\n</code></pre>"},{"location":"plugin-development/#3-iwebapplicationbuilderplugin","title":"3. IWebApplicationBuilderPlugin","text":"<p>Configures the WebApplicationBuilder before the application is built.</p> <pre><code>public class SecurityPlugin : IWebApplicationBuilderPlugin\n{\n    public void Configure(WebApplicationBuilderPluginOptions options)\n    {\n        // Configure services\n        options.Builder.Services.AddAuthentication()\n            .AddJwtBearer(opts =&gt; \n            {\n                opts.Authority = options.Builder.Configuration[\"Auth:Authority\"];\n            });\n\n        options.Builder.Services.AddAuthorization(opts =&gt;\n        {\n            opts.AddPolicy(\"AdminOnly\", policy =&gt; \n                policy.RequireRole(\"Admin\"));\n        });\n\n        // Configure Kestrel\n        options.Builder.WebHost.ConfigureKestrel(serverOptions =&gt;\n        {\n            serverOptions.Limits.MaxRequestBodySize = 10 * 1024 * 1024; // 10MB\n        });\n\n        // Add configuration sources\n        options.Builder.Configuration.AddJsonFile(\"security.json\", optional: true);\n\n        options.Logger.LogInformation(\"Security configured\");\n    }\n}\n</code></pre>"},{"location":"plugin-development/#4-iwebapplicationplugin","title":"4. IWebApplicationPlugin","text":"<p>Configures the WebApplication after it's built, typically for middleware and endpoint configuration.</p> <pre><code>public class ApiPlugin : IWebApplicationPlugin\n{\n    public void Configure(WebApplicationPluginOptions options)\n    {\n        var app = options.WebApplication;\n\n        // Configure middleware pipeline\n        if (app.Environment.IsDevelopment())\n        {\n            app.UseSwagger();\n            app.UseSwaggerUI();\n        }\n\n        app.UseAuthentication();\n        app.UseAuthorization();\n\n        // Map endpoints\n        app.MapGet(\"/api/health\", () =&gt; Results.Ok(new { Status = \"Healthy\" }))\n            .WithName(\"HealthCheck\")\n            .WithOpenApi();\n\n        app.MapPost(\"/api/data\", async (DataRequest request, IDataService service) =&gt;\n        {\n            var result = await service.ProcessAsync(request);\n            return Results.Ok(result);\n        })\n        .RequireAuthorization(\"AdminOnly\");\n\n        options.Logger.LogInformation(\"API endpoints configured\");\n    }\n}\n</code></pre>"},{"location":"plugin-development/#plugin-discovery-and-registration","title":"Plugin Discovery and Registration","text":""},{"location":"plugin-development/#automatic-discovery","title":"Automatic Discovery","text":"<p>Plugins are automatically discovered through assembly scanning. You must configure a discovery strategy:</p> <pre><code>// With source generation\nvar webApp = new Syringe()\n    .UsingSourceGen()\n    .ForWebApplication()\n    .BuildWebApplication();\n\n// With reflection\nvar webApp = new Syringe()\n    .UsingReflection()\n    .ForWebApplication()\n    .BuildWebApplication();\n</code></pre> <p>For built-in plugins, you do not need to annotate them with the special attributes that prevent auto-registration and injection prevention since this is done by the framework itself.</p>"},{"location":"plugin-development/#controlling-plugin-discovery","title":"Controlling Plugin Discovery","text":""},{"location":"plugin-development/#assembly-filtering","title":"Assembly Filtering","text":"<p>Control which assemblies are scanned for plugins:</p> <pre><code>var webApp = new Syringe()\n    .UsingSourceGen()  // or .UsingReflection()\n    .UsingAssemblyProvider(builder =&gt; builder\n        .MatchingAssemblies(x =&gt; \n            x.Contains(\"MyCompany.Plugins\"))\n        .Build())\n    .ForWebApplication()\n    .BuildWebApplication();\n</code></pre>"},{"location":"plugin-development/#plugin-execution-order","title":"Plugin Execution Order","text":"<p>Plugins are executed in a deterministic order based on two factors:</p> <ol> <li>Plugin Order Attribute - Explicit ordering via <code>[PluginOrder]</code></li> <li>Type Name - Alphabetical sorting when orders are equal</li> </ol>"},{"location":"plugin-development/#using-the-pluginorder-attribute","title":"Using the PluginOrder Attribute","text":"<p>Use the <code>[PluginOrder]</code> attribute to control when your plugin executes relative to others:</p> <pre><code>using NexusLabs.Needlr;\n\n// Executes first - negative values run before default (0)\n[PluginOrder(-100)]\npublic class DatabaseMigrationPlugin : IServiceCollectionPlugin\n{\n    public void Configure(ServiceCollectionPluginOptions options)\n    {\n        // Run migrations before other plugins register services\n        options.Services.AddDbContext&lt;MyDbContext&gt;();\n    }\n}\n\n// Executes at default order (0) - no attribute needed\npublic class BusinessLogicPlugin : IServiceCollectionPlugin\n{\n    public void Configure(ServiceCollectionPluginOptions options)\n    {\n        // Normal service registration\n        options.Services.AddScoped&lt;IOrderService, OrderService&gt;();\n    }\n}\n\n// Executes last - positive values run after default (0)\n[PluginOrder(100)]\npublic class ValidationPlugin : IServiceCollectionPlugin\n{\n    public void Configure(ServiceCollectionPluginOptions options)\n    {\n        // Validate all registrations are complete\n    }\n}\n</code></pre>"},{"location":"plugin-development/#order-values","title":"Order Values","text":"Order Range Typical Use Case -100 to -50 Infrastructure setup (database, logging, configuration) -50 to -1 Core services that others depend on 0 (default) Normal business logic plugins 1 to 50 Plugins that depend on other registrations 50 to 100 Validation, cleanup, and finalization"},{"location":"plugin-development/#same-order-determinism","title":"Same-Order Determinism","text":"<p>When multiple plugins have the same order value, they are sorted alphabetically by their fully qualified type name. This ensures deterministic execution across builds:</p> <pre><code>// Both have Order = 0, so they execute alphabetically\npublic class AuditPlugin : IServiceCollectionPlugin { }      // Executes first\npublic class ZipCodePlugin : IServiceCollectionPlugin { }    // Executes second\n</code></pre>"},{"location":"plugin-development/#works-with-all-plugin-types","title":"Works with All Plugin Types","text":"<p>The <code>[PluginOrder]</code> attribute works with all Needlr plugin interfaces:</p> <pre><code>// IServiceCollectionPlugin\n[PluginOrder(-50)]\npublic class EarlyServicePlugin : IServiceCollectionPlugin { }\n\n// IWebApplicationBuilderPlugin\n[PluginOrder(10)]\npublic class MiddlewareSetupPlugin : IWebApplicationBuilderPlugin { }\n\n// IWebApplicationPlugin\n[PluginOrder(100)]\npublic class FinalEndpointPlugin : IWebApplicationPlugin { }\n\n// IHostApplicationBuilderPlugin\n[PluginOrder(-100)]\npublic class HostSetupPlugin : IHostApplicationBuilderPlugin { }\n</code></pre>"},{"location":"plugin-development/#parity-between-reflection-and-source-generation","title":"Parity Between Reflection and Source Generation","text":"<p>Plugin ordering works identically whether you use reflection or source generation:</p> <pre><code>// Both produce the same plugin execution order\nvar reflectionApp = new Syringe()\n    .UsingReflection()\n    .ForWebApplication()\n    .BuildWebApplication();\n\nvar sourceGenApp = new Syringe()\n    .UsingSourceGen()\n    .ForWebApplication()\n    .BuildWebApplication();\n</code></pre>"},{"location":"plugin-development/#assembly-filtering_1","title":"Assembly Filtering","text":"<p>You can also control which assemblies are scanned for plugins:</p> <pre><code>var webApp = new Syringe()\n    .UsingSourceGen()  // or .UsingReflection()\n    .UsingAssemblyProvider(builder =&gt; builder\n        .MatchingAssemblies(x =&gt; x.Contains(\"MyCompany.Plugins\"))\n        .UseLibTestEntryOrdering() // Libraries \u2192 Executables \u2192 Tests\n        .Build())\n    .ForWebApplication()\n    .BuildWebApplication();\n</code></pre>"},{"location":"plugin-development/#execution-timeline","title":"Execution Timeline","text":"<p>Within each lifecycle phase, plugins are sorted by <code>[PluginOrder]</code> then by type name:</p> <ol> <li>IServiceCollectionPlugin - During service registration</li> <li>IPostBuildServiceCollectionPlugin - After service provider is built</li> <li>IWebApplicationBuilderPlugin - Before WebApplication.Build()</li> <li>IWebApplicationPlugin - After WebApplication.Build()</li> </ol>"},{"location":"plugin-development/#advanced-plugin-patterns","title":"Advanced Plugin Patterns","text":""},{"location":"plugin-development/#configuration-driven-plugins","title":"Configuration-Driven Plugins","text":"<pre><code>public class FeatureTogglePlugin : IServiceCollectionPlugin\n{\n    public void Configure(ServiceCollectionPluginOptions options)\n    {\n        var features = options.Configuration.GetSection(\"Features\");\n\n        if (features.GetValue&lt;bool&gt;(\"EnableCache\"))\n        {\n            options.Services.AddMemoryCache();\n            options.Services.AddSingleton&lt;ICacheService, MemoryCacheService&gt;();\n            options.Logger.LogInformation(\"Cache feature enabled\");\n        }\n\n        if (features.GetValue&lt;bool&gt;(\"EnableMetrics\"))\n        {\n            options.Services.AddSingleton&lt;IMetricsService, MetricsService&gt;();\n            options.Logger.LogInformation(\"Metrics feature enabled\");\n        }\n    }\n}\n</code></pre>"},{"location":"plugin-development/#composite-plugins","title":"Composite Plugins","text":"<p>Plugins may implement multiple plugin interfaces. This is especially common for ASP.NET plugins because we may want to configure both the builder and the web application that is created.</p> <pre><code>public class MicroservicePlugin : IServiceCollectionPlugin, \n    IWebApplicationBuilderPlugin, \n    IWebApplicationPlugin\n{\n    public void Configure(ServiceCollectionPluginOptions options)\n    {\n        // Register core services\n        options.Services.AddHealthChecks();\n        options.Services.AddHttpClient();\n    }\n\n    public void Configure(WebApplicationBuilderPluginOptions options)\n    {\n        // Configure distributed tracing\n        options.Builder.Services.AddOpenTelemetry()\n            .WithTracing(builder =&gt; builder\n                .AddAspNetCoreInstrumentation()\n                .AddHttpClientInstrumentation());\n    }\n\n    public void Configure(WebApplicationPluginOptions options)\n    {\n        // Configure middleware and endpoints\n        options.WebApplication.UseHealthChecks(\"/health\");\n        options.WebApplication.MapMetrics();\n    }\n}\n</code></pre>"},{"location":"plugin-development/#plugin-with-dependencies","title":"Plugin with Dependencies","text":"<p>The built-in plugins do not support dependency injection through their constructors, so if you need dependencies then you will need to access them from the dependency injection framework based on the lifecycle.</p> <pre><code>public class DependentPlugin : IPostBuildServiceCollectionPlugin\n{\n    public void Configure(PostBuildServiceCollectionPluginOptions options)\n    {\n        // Get services that were registered by other plugins\n        var dbContext = options.ServiceProvider.GetRequiredService&lt;MyDbContext&gt;();\n        var cache = options.ServiceProvider.GetService&lt;IMemoryCache&gt;();\n\n        if (cache != null)\n        {\n            // Initialize cache with data from database\n            var initialData = dbContext.Settings.ToList();\n            foreach (var setting in initialData)\n            {\n                cache.Set(setting.Key, setting.Value);\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"register-as/","title":"RegisterAs\\ - Explicit Interface Registration <p>The <code>[RegisterAs&lt;T&gt;]</code> attribute gives you explicit control over which interfaces a class is registered as in dependency injection. By default, Needlr registers a class as all non-system interfaces it implements. Use <code>[RegisterAs&lt;T&gt;]</code> when you want to limit which interfaces are publicly resolvable.</p>","text":""},{"location":"register-as/#basic-usage","title":"Basic Usage","text":"<pre><code>public interface IReader { string Read(); }\npublic interface IWriter { void Write(string data); }\npublic interface ILogger { void Log(string message); }\n\n// Only registered as IReader - not as IWriter or ILogger\n[RegisterAs&lt;IReader&gt;]\npublic class FileService : IReader, IWriter, ILogger\n{\n    public string Read() =&gt; \"file content\";\n    public void Write(string data) { /* ... */ }\n    public void Log(string message) { /* ... */ }\n}\n</code></pre> <p>With this configuration: - \u2705 <code>provider.GetService&lt;IReader&gt;()</code> returns <code>FileService</code> - \u2705 <code>provider.GetService&lt;FileService&gt;()</code> returns <code>FileService</code> (concrete type always registered) - \u274c <code>provider.GetService&lt;IWriter&gt;()</code> returns <code>null</code> - \u274c <code>provider.GetService&lt;ILogger&gt;()</code> returns <code>null</code></p>"},{"location":"register-as/#multiple-registeras-attributes","title":"Multiple RegisterAs Attributes","text":"<p>You can apply multiple <code>[RegisterAs&lt;T&gt;]</code> attributes to register as multiple specific interfaces:</p> <pre><code>[RegisterAs&lt;IReader&gt;]\n[RegisterAs&lt;IWriter&gt;]\npublic class FileService : IReader, IWriter, ILogger\n{\n    // Registered as IReader and IWriter, but NOT as ILogger\n}\n</code></pre>"},{"location":"register-as/#use-cases","title":"Use Cases","text":""},{"location":"register-as/#1-controlling-public-api-surface","title":"1. Controlling Public API Surface","text":"<p>When a class implements internal utility interfaces that shouldn't be exposed:</p> <pre><code>public interface IOrderService { void PlaceOrder(); }\ninternal interface IOrderValidator { bool Validate(); }\ninternal interface IAuditLogger { void Log(); }\n\n[RegisterAs&lt;IOrderService&gt;]\npublic class OrderService : IOrderService, IOrderValidator, IAuditLogger\n{\n    // Only IOrderService is resolvable - internal interfaces are hidden\n}\n</code></pre>"},{"location":"register-as/#2-avoiding-ambiguous-registrations","title":"2. Avoiding Ambiguous Registrations","text":"<p>When multiple classes implement the same interface but you want specific resolution:</p> <pre><code>public interface INotificationSender { void Send(); }\npublic interface IEmailSender { void SendEmail(); }\npublic interface ISmsSender { void SendSms(); }\n\n[RegisterAs&lt;IEmailSender&gt;]\npublic class EmailService : INotificationSender, IEmailSender\n{\n    // Only registered as IEmailSender, not INotificationSender\n}\n\n[RegisterAs&lt;ISmsSender&gt;]\npublic class SmsService : INotificationSender, ISmsSender\n{\n    // Only registered as ISmsSender, not INotificationSender\n}\n</code></pre>"},{"location":"register-as/#3-interface-hierarchies","title":"3. Interface Hierarchies","text":"<p>You can register as a base interface even if the class implements a derived interface:</p> <pre><code>public interface IRepository { }\npublic interface IUserRepository : IRepository { User Get(int id); }\n\n[RegisterAs&lt;IRepository&gt;]\npublic class UserRepository : IUserRepository\n{\n    public User Get(int id) =&gt; /* ... */;\n\n    // Registered as IRepository, not IUserRepository\n}\n</code></pre>"},{"location":"register-as/#behavior","title":"Behavior","text":"Scenario Result No <code>[RegisterAs&lt;T&gt;]</code> All non-system interfaces are registered One <code>[RegisterAs&lt;T&gt;]</code> Only that interface is registered Multiple <code>[RegisterAs&lt;T&gt;]</code> Only specified interfaces are registered Concrete type Always registered as itself"},{"location":"register-as/#analyzer-support","title":"Analyzer Support","text":"<p>Needlr includes compile-time validation:</p> Rule Severity Description NDLRCOR015 Error <code>T</code> must be an interface implemented by the class"},{"location":"register-as/#works-with-both-paths","title":"Works With Both Paths","text":"<p><code>[RegisterAs&lt;T&gt;]</code> works identically in both: - Source Generation - Full AOT/trimming compatibility - Reflection - Traditional runtime discovery</p>"},{"location":"register-as/#lifetime-behavior","title":"Lifetime Behavior","text":"<p><code>[RegisterAs&lt;T&gt;]</code> does not affect lifetime. Use it alongside lifetime attributes:</p> <pre><code>[Transient]\n[RegisterAs&lt;IReader&gt;]\npublic class TransientReader : IReader, IWriter\n{\n    // Transient, registered only as IReader\n}\n</code></pre>"},{"location":"register-as/#see-also","title":"See Also","text":"<ul> <li>Getting Started</li> <li>DoNotAutoRegister - Exclude from all registration</li> <li>NDLRCOR015 - Analyzer documentation</li> </ul>"},{"location":"service-catalog/","title":"Service Catalog","text":"<p>The Service Catalog provides compile-time metadata about all services discovered and registered by Needlr. It allows you to query your DI registrations at runtime without reflection.</p>"},{"location":"service-catalog/#overview","title":"Overview","text":"<p>When you use <code>[GenerateTypeRegistry]</code>, Needlr generates a <code>ServiceCatalog</code> class that implements <code>IServiceCatalog</code>. This catalog is automatically registered as a singleton in your DI container and can be resolved like any other service.</p> <pre><code>var catalog = serviceProvider.GetRequiredService&lt;IServiceCatalog&gt;();\n</code></pre>"},{"location":"service-catalog/#whats-in-the-catalog","title":"What's in the Catalog","text":"<p>The <code>IServiceCatalog</code> interface exposes collections for each type of registration Needlr discovers:</p> <ul> <li>Services - All standard service registrations with their lifetime, interfaces, and constructor parameters</li> <li>Decorators - All decorators with their target service type and order</li> <li>HostedServices - All discovered <code>BackgroundService</code>/<code>IHostedService</code> implementations</li> <li>InterceptedServices - Services with <code>[Intercept]</code> applied</li> <li>Options - Configuration bindings via <code>[Options]</code></li> <li>Plugins - Discovered Needlr plugins</li> </ul> <p>Each entry includes the type name, assembly, and source file path (when available).</p>"},{"location":"service-catalog/#usage-examples","title":"Usage Examples","text":""},{"location":"service-catalog/#resolving-the-catalog","title":"Resolving the Catalog","text":"<pre><code>var provider = new Syringe()\n    .UsingSourceGen()\n    .BuildServiceProvider();\n\nvar catalog = provider.GetRequiredService&lt;IServiceCatalog&gt;();\n</code></pre>"},{"location":"service-catalog/#finding-services-by-interface","title":"Finding Services by Interface","text":"<pre><code>// Find all services implementing a specific interface\nvar handlers = catalog.Services\n    .Where(s =&gt; s.Interfaces.Any(i =&gt; i.Contains(\"ICommandHandler\")))\n    .ToList();\n\nforeach (var handler in handlers)\n{\n    Console.WriteLine($\"{handler.ShortTypeName} ({handler.Lifetime})\");\n}\n</code></pre>"},{"location":"service-catalog/#listing-decorators-in-order","title":"Listing Decorators in Order","text":"<pre><code>// Find all decorators for IHostedService in decoration order\nvar hostedServiceDecorators = catalog.Decorators\n    .Where(d =&gt; d.ServiceTypeName.Contains(\"IHostedService\"))\n    .OrderBy(d =&gt; d.Order)\n    .ToList();\n\nforeach (var decorator in hostedServiceDecorators)\n{\n    Console.WriteLine($\"Order {decorator.Order}: {decorator.ShortDecoratorTypeName}\");\n}\n</code></pre>"},{"location":"service-catalog/#inspecting-hosted-services","title":"Inspecting Hosted Services","text":"<pre><code>foreach (var hostedService in catalog.HostedServices)\n{\n    Console.WriteLine($\"Hosted Service: {hostedService.ShortTypeName}\");\n\n    foreach (var param in hostedService.ConstructorParameters)\n    {\n        Console.WriteLine($\"  - {param.Name}: {param.TypeName}\");\n    }\n}\n</code></pre>"},{"location":"service-catalog/#querying-options-configuration","title":"Querying Options Configuration","text":"<pre><code>// Find options with validation enabled\nvar validatedOptions = catalog.Options\n    .Where(o =&gt; o.ValidateOnStart || o.HasValidator || o.HasDataAnnotations)\n    .ToList();\n\nforeach (var opt in validatedOptions)\n{\n    Console.WriteLine($\"{opt.ShortTypeName} -&gt; Section: {opt.SectionName}\");\n}\n</code></pre>"},{"location":"service-catalog/#use-cases","title":"Use Cases","text":"<ul> <li>Debugging: Inspect what Needlr discovered and registered at runtime</li> <li>Documentation: Generate API documentation from registration metadata</li> <li>Health Checks: Verify expected services are registered</li> <li>Admin Endpoints: Expose service registration info in admin/diagnostic APIs</li> <li>Testing: Assert specific registrations exist in integration tests</li> </ul>"},{"location":"service-catalog/#notes","title":"Notes","text":"<ul> <li>The catalog is generated at compile time - it reflects what the source generator discovered</li> <li>Types excluded with <code>[DoNotAutoRegister]</code> or <code>[DoNotInject]</code> will not appear in the catalog</li> <li>The catalog is registered as a singleton and is the same instance across resolutions</li> <li>Interface names in the catalog include the <code>global::</code> prefix for fully qualified names</li> </ul>"},{"location":"service-catalog/#api-reference","title":"API Reference","text":"<p>See the source code for full type definitions: - IServiceCatalog - Catalog Entry Types</p>"},{"location":"video-tutorials/","title":"Needlr Video Tutorials","text":"<p>A collection of video tutorials and demonstrations to help developers learn and use Needlr effectively.</p>"},{"location":"video-tutorials/#getting-started","title":"Getting Started","text":""},{"location":"video-tutorials/#how-i-made-c-plugins-super-simple-in-my-dotnet-apps","title":"How I Made C# Plugins Super Simple in My DotNet Apps!","text":"<p>Description: Needlr is my opinionated framework that I use for scanning assemblies for types to register for dependency injection. Like Autofac and Scrutor, you can automatically register types that you can resolve from the dependency container later once the IServiceProvider has been built!</p> <p>Video Link: https://www.youtube.com/watch?v=IH5HEkcMsMg</p> <p>Topics Covered: - Problems with extension method patterns in ASP.NET Core - Plugin-based architecture approach - Automatic type discovery and registration - Web application plugin implementation - Comparison with traditional DI setup patterns - Fluent builder syntax with Syringe class - Weather forecast API example transformation - How Needlr keeps entry points thin - Real-world usage in BrandGhost (https://www.brandghost.ai) application</p>"},{"location":"analyzers/","title":"Needlr Analyzers","text":"<p>Needlr includes optional Roslyn analyzers to help developers avoid common mistakes and ensure best practices.</p>"},{"location":"analyzers/#core-analyzers-nexuslabsneedlranalyzers","title":"Core Analyzers (NexusLabs.Needlr.Analyzers)","text":"<p>These analyzers are included with the <code>NexusLabs.Needlr</code> package.</p> Rule ID Severity Description NDLRCOR001 Error Reflection API used in AOT project NDLRCOR002 Warning Plugin has constructor dependencies NDLRCOR003 Error [DeferToContainer] attribute in generated code is ignored NDLRCOR004 Warning Injectable type in global namespace may not be discovered NDLRCOR005 Warning Lifetime mismatch: longer-lived service depends on shorter-lived service NDLRCOR006 Error Circular dependency detected NDLRCOR007 Error Intercept type must implement IMethodInterceptor NDLRCOR008 Warning [Intercept] applied to class without interfaces NDLRCOR009 Info Lazy references undiscovered type NDLRCOR010 Info IEnumerable has no discovered implementations NDLRCOR011 Info [FromKeyedServices] keyed service usage tracking NDLRCOR012 Error Disposable captive dependency NDLRCOR015 Error [RegisterAs] type T not implemented by class"},{"location":"analyzers/#signalr-analyzers-nexuslabsneedlrsignalranalyzers","title":"SignalR Analyzers (NexusLabs.Needlr.SignalR.Analyzers)","text":"<p>These analyzers are included with the <code>NexusLabs.Needlr.SignalR</code> package.</p> Rule ID Severity Description NDLRSIG001 Warning HubPath must be a constant expression NDLRSIG002 Warning HubType must be a typeof expression"},{"location":"analyzers/#generator-diagnostics-nexuslabsneedlrgenerators","title":"Generator Diagnostics (NexusLabs.Needlr.Generators)","text":"<p>These diagnostics are emitted by the source generator to detect configuration issues at compile time.</p> Rule ID Severity Description NDLRGEN001 Error Internal type in referenced assembly cannot be registered NDLRGEN002 Error Referenced assembly has internal plugin types but no type registry NDLRGEN003 Warning [GenerateFactory] all parameters are injectable NDLRGEN004 Warning [GenerateFactory] no parameters are injectable NDLRGEN005 Error [GenerateFactory] type T not implemented by class NDLRGEN006 Error [OpenDecoratorFor] type must be an open generic interface NDLRGEN007 Error [OpenDecoratorFor] decorator must be an open generic class NDLRGEN008 Error [OpenDecoratorFor] decorator must implement the interface NDLRGEN014 Error [Options] Validator type has no validation method NDLRGEN015 Error [Options] Validator type mismatch NDLRGEN016 Error [Options] Validation method not found NDLRGEN017 Error [Options] Validation method has wrong signature NDLRGEN018 Warning [Options] Validator won't run (ValidateOnStart is false) NDLRGEN019 Warning [Options] Validation method won't run (ValidateOnStart is false) NDLRGEN020 Error [Options] is not compatible with Native AOT NDLRGEN021 Warning [Options] Positional record must be partial NDLRGEN022 Error Disposable captive dependency (uses inferred lifetimes)"},{"location":"analyzers/#diagnostic-id-naming-convention","title":"Diagnostic ID Naming Convention","text":"<p>Needlr uses a component-based naming convention for diagnostic IDs:</p> Component Prefix Example Core Analyzers <code>NDLRCOR</code> <code>NDLRCOR001</code> SignalR Analyzers <code>NDLRSIG</code> <code>NDLRSIG001</code> Source Generators <code>NDLRGEN</code> <code>NDLRGEN001</code>"},{"location":"analyzers/#suppressing-warnings","title":"Suppressing Warnings","text":"<p>To suppress a specific analyzer warning, use pragma directives:</p> <pre><code>#pragma warning disable NDLRCOR001\n// Code that triggers the warning\n#pragma warning restore NDLRCOR001\n</code></pre> <p>Or suppress in your project file for the entire project:</p> <pre><code>&lt;PropertyGroup&gt;\n  &lt;NoWarn&gt;$(NoWarn);NDLRCOR002&lt;/NoWarn&gt;\n&lt;/PropertyGroup&gt;\n</code></pre> <p>Or configure severity in <code>.editorconfig</code> (recommended):</p> <pre><code># .editorconfig\n[*.cs]\n# Disable a diagnostic\ndotnet_diagnostic.NDLRCOR009.severity = none\n\n# Promote to warning\ndotnet_diagnostic.NDLRCOR010.severity = warning\n\n# Promote to error\ndotnet_diagnostic.NDLRCOR005.severity = error\n</code></pre>"},{"location":"analyzers/#resolution-validation-analyzers","title":"Resolution Validation Analyzers","text":"<p>NDLRCOR009, NDLRCOR010, and NDLRCOR011 are resolution validation analyzers that help catch potential issues with service resolution patterns.</p> <p>These analyzers: - Only activate when <code>[assembly: GenerateTypeRegistry]</code> is present - Default to <code>Info</code> severity (non-blocking) - Can be promoted to <code>Warning</code> or <code>Error</code> via <code>.editorconfig</code></p> Analyzer Purpose NDLRCOR009 Validates <code>Lazy&lt;T&gt;</code> references discoverable types NDLRCOR010 Validates <code>IEnumerable&lt;T&gt;</code> has implementations NDLRCOR011 Tracks <code>[FromKeyedServices]</code> keyed service usage <p>To see which analyzers are active in your project, enable diagnostics output:</p> <pre><code>&lt;PropertyGroup&gt;\n  &lt;NeedlrDiagnostics&gt;true&lt;/NeedlrDiagnostics&gt;\n&lt;/PropertyGroup&gt;\n</code></pre> <p>This generates <code>AnalyzerStatus.md</code> in your output directory showing all analyzers and their current severity.</p>"},{"location":"analyzers/#configuration","title":"Configuration","text":"<p>Analyzers are automatically enabled when you reference the Needlr packages. No additional configuration is required.</p> <p>For AOT projects, ensure your project has the appropriate settings for the analyzers to detect AOT mode:</p> <pre><code>&lt;PropertyGroup&gt;\n  &lt;PublishAot&gt;true&lt;/PublishAot&gt;\n  &lt;!-- or --&gt;\n  &lt;IsAotCompatible&gt;true&lt;/IsAotCompatible&gt;\n&lt;/PropertyGroup&gt;\n</code></pre>"},{"location":"analyzers/NDLRCOR001/","title":"NDLRCOR001: Reflection API used in AOT project","text":""},{"location":"analyzers/NDLRCOR001/#cause","title":"Cause","text":"<p>You are using a reflection-based Needlr API in a project that has AOT (Ahead-of-Time) compilation or trimming enabled.</p>"},{"location":"analyzers/NDLRCOR001/#rule-description","title":"Rule Description","text":"<p>Native AOT and trimmed applications cannot use reflection reliably. The Needlr library provides source-generation-based alternatives for all reflection-based components. Using reflection APIs in an AOT-enabled project will cause runtime failures.</p> <p>This analyzer triggers when you use any of the following in a project with <code>PublishAot=true</code> or <code>IsAotCompatible=true</code>:</p>"},{"location":"analyzers/NDLRCOR001/#reflection-types","title":"Reflection Types","text":"<ul> <li><code>ReflectionPluginFactory</code></li> <li><code>ReflectionTypeRegistrar</code></li> <li><code>ReflectionTypeFilterer</code></li> <li><code>ReflectionAssemblyLoader</code></li> <li><code>ReflectionAssemblyProvider</code></li> <li><code>ReflectionServiceProviderBuilder</code></li> </ul>"},{"location":"analyzers/NDLRCOR001/#reflection-extension-methods","title":"Reflection Extension Methods","text":"<ul> <li><code>UsingReflectionTypeRegistrar()</code></li> <li><code>UsingReflectionTypeFilterer()</code></li> <li><code>UsingReflectionPluginFactory()</code></li> <li><code>UsingReflectionAssemblyLoader()</code></li> <li><code>UsingReflectionAssemblyProvider()</code></li> </ul>"},{"location":"analyzers/NDLRCOR001/#how-to-fix","title":"How to Fix","text":"<p>Replace reflection-based APIs with their source-generation equivalents:</p>"},{"location":"analyzers/NDLRCOR001/#before-reflection","title":"Before (Reflection)","text":"<pre><code>var app = new Syringe()\n    .UsingReflection()\n    .ForWebApplication()\n    .BuildWebApplication();\n</code></pre>"},{"location":"analyzers/NDLRCOR001/#after-source-generation","title":"After (Source Generation)","text":"<pre><code>var app = new Syringe()\n    .UsingSourceGen()\n    .ForWebApplication()\n    .BuildWebApplication();\n</code></pre> <p>Ensure you have the source generator packages installed:</p> <pre><code>&lt;PackageReference Include=\"NexusLabs.Needlr.Generators\" OutputItemType=\"Analyzer\" ReferenceOutputAssembly=\"false\" /&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.Generators.Attributes\" /&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.Injection.SourceGen\" /&gt;\n</code></pre>"},{"location":"analyzers/NDLRCOR001/#when-to-suppress","title":"When to Suppress","text":"<p>Only suppress this warning if you are certain the reflection code path will not be executed at runtime, such as in conditional compilation scenarios where the reflection code is only used in non-AOT builds.</p> <pre><code>#pragma warning disable NDLRCOR001\n// Reflection code that won't run in AOT\n#pragma warning restore NDLRCOR001\n</code></pre>"},{"location":"analyzers/NDLRCOR001/#see-also","title":"See Also","text":"<ul> <li>Getting Started Guide</li> <li>Source Generation vs Reflection</li> </ul>"},{"location":"analyzers/NDLRCOR002/","title":"NDLRCOR002: Plugin has constructor dependencies","text":""},{"location":"analyzers/NDLRCOR002/#cause","title":"Cause","text":"<p>A class implementing <code>IServiceCollectionPlugin</code> or <code>IPostBuildServiceCollectionPlugin</code> has a constructor with parameters but no public parameterless constructor.</p>"},{"location":"analyzers/NDLRCOR002/#rule-description","title":"Rule Description","text":"<p>Needlr plugin classes are instantiated by the framework before the dependency injection container is fully built. This means constructor injection is not available for plugin classes in the same way it is for regular services.</p> <p>If a plugin has constructor parameters and no parameterless constructor, the framework may not be able to instantiate it, leading to runtime errors.</p>"},{"location":"analyzers/NDLRCOR002/#how-to-fix","title":"How to Fix","text":""},{"location":"analyzers/NDLRCOR002/#option-1-add-a-parameterless-constructor","title":"Option 1: Add a parameterless constructor","text":"<pre><code>public class MyPlugin : IServiceCollectionPlugin\n{\n    public MyPlugin() { }\n\n    public MyPlugin(ILogger logger) \n    { \n        // Optional: for use when instantiated via DI\n    }\n\n    public void Configure(ServiceCollectionPluginOptions options)\n    {\n        // Plugin configuration\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR002/#option-2-use-ipostbuildservicecollectionplugin-with-service-resolution","title":"Option 2: Use IPostBuildServiceCollectionPlugin with service resolution","text":"<p>If you need access to services, use <code>IPostBuildServiceCollectionPlugin</code> which runs after the container is built:</p> <pre><code>public class MyPlugin : IPostBuildServiceCollectionPlugin\n{\n    public void Configure(PostBuildServiceCollectionPluginOptions options)\n    {\n        var logger = options.ServiceProvider.GetRequiredService&lt;ILogger&lt;MyPlugin&gt;&gt;();\n        // Use the logger\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR002/#option-3-access-services-through-the-options-parameter","title":"Option 3: Access services through the options parameter","text":"<pre><code>public class MyPlugin : IServiceCollectionPlugin\n{\n    public void Configure(ServiceCollectionPluginOptions options)\n    {\n        // Register your service that needs dependencies\n        options.Services.AddSingleton&lt;MyService&gt;();\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR002/#when-to-suppress","title":"When to Suppress","text":"<p>Suppress this warning if: - The plugin is intentionally designed to be instantiated via DI after container construction - The plugin is abstract and constructor parameters are for derived classes - You are using a custom plugin factory that handles constructor injection</p> <pre><code>#pragma warning disable NDLRCOR002\npublic class MyCustomPlugin : IServiceCollectionPlugin\n{\n    public MyCustomPlugin(IPluginFactory factory) { }\n    // ...\n}\n#pragma warning restore NDLRCOR002\n</code></pre>"},{"location":"analyzers/NDLRCOR002/#see-also","title":"See Also","text":"<ul> <li>Plugin Development Guide</li> <li>Core Concepts</li> </ul>"},{"location":"analyzers/NDLRCOR003/","title":"NDLRCOR003: [DeferToContainer] attribute in generated code is ignored","text":""},{"location":"analyzers/NDLRCOR003/#cause","title":"Cause","text":"<p>A <code>[DeferToContainer]</code> attribute was found in generated code (a <code>.g.cs</code>, <code>.generated.cs</code>, or <code>.designer.cs</code> file, or in an <code>obj/*/generated/</code> folder).</p>"},{"location":"analyzers/NDLRCOR003/#rule-description","title":"Rule Description","text":"<p>Source generators in Roslyn run in parallel and in isolation. Each generator only sees:</p> <ol> <li>Original user-written source code</li> <li>Referenced assemblies (metadata)</li> </ol> <p>Generators cannot see output from other generators in the same compilation. This means if one generator (like <code>CacheProviderGenerator</code>) adds <code>[DeferToContainer]</code> to a generated partial class, Needlr's <code>TypeRegistryGenerator</code> will never see it.</p> <pre><code>Compilation Pipeline:\n\n     Original Source Files\n           \u2502\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502           \u2502\n     \u25bc           \u25bc\n[CacheProvider  [TypeRegistry\n Generator]      Generator]\n     \u2502           \u2502\n     \u25bc           \u25bc\n  Output A     Output B    \u25c4\u2500\u2500 These can't see each other!\n     \u2502           \u2502\n     \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\n           \u25bc\n    Final Compilation\n           \u2502\n           \u25bc\n      [Analyzers]  \u25c4\u2500\u2500 CAN see everything (this is how we detect the issue)\n</code></pre> <p>When <code>TypeRegistryGenerator</code> runs, it only sees your original partial class (without the attribute) and generates incorrect factory code with a parameterless constructor call.</p>"},{"location":"analyzers/NDLRCOR003/#how-to-fix","title":"How to Fix","text":"<p>Move the <code>[DeferToContainer]</code> attribute to your original source file - the partial class declaration you wrote, not the one generated.</p>"},{"location":"analyzers/NDLRCOR003/#before-broken","title":"Before (broken)","text":"<pre><code>// Your code (MyService.cs)\n[CacheProvider(\"EngageFeed\")]  // This triggers CacheProviderGenerator\npublic partial class EngageFeedCacheProvider { }\n\n// Generated by CacheProviderGenerator (EngageFeedCacheProvider.g.cs)\n[DeferToContainer(typeof(ICacheProvider))]  // \u274c TypeRegistryGenerator won't see this!\npublic sealed partial class EngageFeedCacheProvider(ICacheProvider _cacheProvider)\n{\n    // ...\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR003/#after-correct","title":"After (correct)","text":"<pre><code>// Your code (MyService.cs)\n[DeferToContainer(typeof(ICacheProvider))]  // \u2705 TypeRegistryGenerator sees this!\n[CacheProvider(\"EngageFeed\")]\npublic partial class EngageFeedCacheProvider { }\n\n// Generated by CacheProviderGenerator (EngageFeedCacheProvider.g.cs)\npublic sealed partial class EngageFeedCacheProvider(ICacheProvider _cacheProvider)\n{\n    // ...\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR003/#impact-if-ignored","title":"Impact if Ignored","text":"<p>If you ignore this error, Needlr will generate factory code like:</p> <pre><code>sp =&gt; new EngageFeedCacheProvider()  // Missing the constructor parameter!\n</code></pre> <p>This will cause a compile error: <pre><code>CS7036: There is no argument given that corresponds to the required parameter \n'_cacheProvider' of 'EngageFeedCacheProvider.EngageFeedCacheProvider(ICacheProvider)'\n</code></pre></p>"},{"location":"analyzers/NDLRCOR003/#for-generator-authors","title":"For Generator Authors","text":"<p>If you're writing a source generator that adds constructors to partial classes, do not add <code>[DeferToContainer]</code> to your generated output. Instead, document that users must add the attribute to their original partial class.</p> <p>Example documentation for your generator's users:</p> <pre><code>## Usage with Needlr\n\nIf using Needlr for dependency injection, add the `[DeferToContainer]` attribute \nto your original class declaration:\n\n```csharp\n[DeferToContainer(typeof(ICacheProvider))]\n[CacheProvider(\"EngageFeed\")]\npublic partial class EngageFeedCacheProvider { }\n</code></pre> <p>This tells Needlr's source generator what constructor parameters to expect. <pre><code>## When to Suppress\n\nThis diagnostic should generally **not be suppressed**. The attribute in generated code will not work as intended.\n\nIf you must suppress it (for example, during migration), be aware that you'll need to manually register the service:\n\n```csharp\n#pragma warning disable NDLRCOR003\n// In generated file - this won't work but we're registering manually\n#pragma warning restore NDLRCOR003\n\n// In your Program.cs or startup:\nbuilder.Services.AddSingleton&lt;EngageFeedCacheProvider&gt;(sp =&gt; \n    new EngageFeedCacheProvider(sp.GetRequiredService&lt;ICacheProvider&gt;()));\n</code></pre></p>"},{"location":"analyzers/NDLRCOR003/#see-also","title":"See Also","text":"<ul> <li>Advanced Usage - Working with Other Source Generators</li> <li>DeferToContainer Attribute Reference</li> </ul>"},{"location":"analyzers/NDLRCOR004/","title":"NDLRCOR004: Injectable type in global namespace may not be discovered","text":""},{"location":"analyzers/NDLRCOR004/#cause","title":"Cause","text":"<p>A type that appears to be designed for dependency injection is defined in the global namespace (no <code>namespace</code> declaration), but the assembly's <code>[GenerateTypeRegistry]</code> attribute has <code>IncludeNamespacePrefixes</code> set to values that don't include an empty string (<code>\"\"</code>).</p>"},{"location":"analyzers/NDLRCOR004/#rule-description","title":"Rule Description","text":"<p>When using Needlr's source generation with namespace filtering, types in the global namespace are excluded by default. This is because:</p> <ol> <li> <p>Namespace filtering is exact prefix matching: If you set <code>IncludeNamespacePrefixes = new[] { \"MyCompany\" }</code>, only types in namespaces starting with <code>MyCompany.</code> are included.</p> </li> <li> <p>Global namespace has no prefix: Types without a <code>namespace</code> declaration have no namespace to match against.</p> </li> <li> <p>Silent exclusion: Unlike a compile error, these types are silently skipped during type discovery.</p> </li> </ol> <p>This analyzer detects types that: - Are in the global namespace - Appear to be injectable (have DI attributes, implement interfaces, or have constructor dependencies) - Would be excluded by the current <code>IncludeNamespacePrefixes</code> configuration</p> <pre><code>// \u26a0\ufe0f This triggers the warning\n[assembly: GenerateTypeRegistry(IncludeNamespacePrefixes = new[] { \"MyCompany\" })]\n\npublic class AmplitudeConfiguration  // No namespace! Won't be discovered!\n{\n    public string ApiKey { get; set; }\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR004/#how-to-fix","title":"How to Fix","text":""},{"location":"analyzers/NDLRCOR004/#option-1-add-a-namespace-recommended","title":"Option 1: Add a Namespace (Recommended)","text":"<p>Move the type into an appropriate namespace:</p> <pre><code>namespace MyCompany.Telemetry\n{\n    public class AmplitudeConfiguration\n    {\n        public string ApiKey { get; set; }\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR004/#option-2-include-global-namespace-in-prefixes","title":"Option 2: Include Global Namespace in Prefixes","text":"<p>Add an empty string <code>\"\"</code> to your <code>IncludeNamespacePrefixes</code> to explicitly include global namespace types:</p> <pre><code>[assembly: GenerateTypeRegistry(IncludeNamespacePrefixes = new[] { \"MyCompany\", \"\" })]\n</code></pre> <p>This tells Needlr: \"Include types in <code>MyCompany.*</code> namespaces AND types in the global namespace.\"</p>"},{"location":"analyzers/NDLRCOR004/#option-3-mark-as-not-injectable","title":"Option 3: Mark as Not Injectable","text":"<p>If the type shouldn't be registered with DI, add <code>[DoNotInject]</code> or <code>[DoNotAutoRegister]</code>:</p> <pre><code>[DoNotInject]\npublic class AmplitudeConfiguration { }\n</code></pre>"},{"location":"analyzers/NDLRCOR004/#impact-if-ignored","title":"Impact if Ignored","text":"<p>If you ignore this warning:</p> <ol> <li> <p>Runtime exception: Services depending on the undiscovered type will throw <code>InvalidOperationException</code>:    <pre><code>System.InvalidOperationException: No service for type 'AmplitudeConfiguration' has been registered.\n</code></pre></p> </li> <li> <p>Silent failures: The application may start but fail when the missing type is first requested.</p> </li> <li> <p>Debugging difficulty: The root cause isn't obvious since there's no compile error.</p> </li> </ol>"},{"location":"analyzers/NDLRCOR004/#why-this-happens","title":"Why This Happens","text":"<p>This commonly occurs when:</p> <ol> <li> <p>MSBuild conventions auto-set prefixes: Some build configurations automatically set <code>IncludeNamespacePrefixes</code> based on the project name.</p> </li> <li> <p>Copy-paste errors: Types copied from examples or templates may lack namespace declarations.</p> </li> <li> <p>Migration from reflection: Reflection-based discovery scanned all types regardless of namespace. Source generation requires explicit configuration.</p> </li> </ol>"},{"location":"analyzers/NDLRCOR004/#detection-criteria","title":"Detection Criteria","text":"<p>This analyzer reports a warning when ALL of these conditions are true:</p> <ol> <li>The type is in the global namespace</li> <li>The assembly has <code>[GenerateTypeRegistry]</code> with <code>IncludeNamespacePrefixes</code> set</li> <li><code>IncludeNamespacePrefixes</code> doesn't include <code>\"\"</code> (empty string)</li> <li>The type is NOT marked with <code>[DoNotInject]</code> or <code>[DoNotAutoRegister]</code></li> <li>The type appears injectable:</li> <li>Has a lifetime attribute (<code>[Singleton]</code>, <code>[Scoped]</code>, <code>[Transient]</code>)</li> <li>Implements one or more interfaces</li> <li>Has a constructor with interface/abstract class parameters</li> </ol>"},{"location":"analyzers/NDLRCOR004/#when-to-suppress","title":"When to Suppress","text":"<p>Suppress this warning if:</p> <ul> <li>The type is intentionally not registered with DI</li> <li>You're manually registering the type elsewhere</li> <li>The type is only used as a data transfer object (DTO)</li> </ul> <pre><code>#pragma warning disable NDLRCOR004\npublic class MyGlobalType { }  // Not intended for DI\n#pragma warning restore NDLRCOR004\n</code></pre> <p>Or in your project file: <pre><code>&lt;NoWarn&gt;$(NoWarn);NDLRCOR004&lt;/NoWarn&gt;\n</code></pre></p>"},{"location":"analyzers/NDLRCOR004/#see-also","title":"See Also","text":"<ul> <li>Advanced Usage - Namespace Filtering</li> <li>NDLRCOR001: Plugin constructor dependency not registered</li> <li>Core Concepts - Type Discovery</li> </ul>"},{"location":"analyzers/NDLRCOR005/","title":"NDLRCOR005: Lifetime mismatch - longer-lived service depends on shorter-lived service","text":""},{"location":"analyzers/NDLRCOR005/#cause","title":"Cause","text":"<p>A service with a longer lifetime (e.g., Singleton) has a constructor dependency on a service with a shorter lifetime (e.g., Scoped or Transient). This creates a \"captive dependency\" where the shorter-lived service is captured and held beyond its intended lifetime.</p>"},{"location":"analyzers/NDLRCOR005/#rule-description","title":"Rule Description","text":"<p>In dependency injection, services have three standard lifetimes:</p> Lifetime Rank Description Transient 0 New instance per request Scoped 1 One instance per scope (e.g., per HTTP request) Singleton 2 Single instance for application lifetime <p>A lifetime mismatch occurs when a longer-lived service depends on a shorter-lived one:</p> <pre><code>// \u26a0\ufe0f NDLRCOR005: Singleton depends on Scoped\n[Singleton]\npublic class CacheService(IUserContext userContext)  // IUserContext is Scoped\n{\n    private readonly IUserContext _userContext = userContext;\n\n    public string GetCacheKey() =&gt; $\"user_{_userContext.UserId}\";\n}\n\n[Scoped]\npublic class UserContext : IUserContext\n{\n    public int UserId { get; set; }\n}\n</code></pre> <p>Why this is dangerous:</p> <ol> <li> <p>Stale data: The Singleton captures the first <code>IUserContext</code> instance and uses it for ALL requests, even though <code>UserContext</code> was meant to change per-request.</p> </li> <li> <p>Memory leaks: Scoped services are designed to be disposed at scope end. A Singleton holding a reference prevents garbage collection.</p> </li> <li> <p>Concurrency bugs: Scoped services often aren't thread-safe because they're designed for single-request use. A Singleton may use them from multiple threads simultaneously.</p> </li> <li> <p>Silent failures: No runtime exception occurs\u2014the application works but produces incorrect results.</p> </li> </ol>"},{"location":"analyzers/NDLRCOR005/#common-mismatch-patterns","title":"Common Mismatch Patterns","text":""},{"location":"analyzers/NDLRCOR005/#singleton-scoped-most-dangerous","title":"Singleton \u2192 Scoped (Most Dangerous)","text":"<pre><code>[Singleton]\npublic class EmailService(IDbContext dbContext) { }  // DbContext is Scoped!\n</code></pre>"},{"location":"analyzers/NDLRCOR005/#singleton-transient","title":"Singleton \u2192 Transient","text":"<pre><code>[Singleton]\npublic class LoggingService(ITimeProvider time) { }  // May capture stale time\n</code></pre>"},{"location":"analyzers/NDLRCOR005/#scoped-transient","title":"Scoped \u2192 Transient","text":"<pre><code>[Scoped]\npublic class RequestHandler(IValidator validator) { }  // Less dangerous but still problematic\n</code></pre>"},{"location":"analyzers/NDLRCOR005/#how-to-fix","title":"How to Fix","text":""},{"location":"analyzers/NDLRCOR005/#option-1-match-lifetimes-recommended","title":"Option 1: Match Lifetimes (Recommended)","text":"<p>Make the consumer's lifetime equal or shorter than its dependencies:</p> <pre><code>// \u2705 Scoped depends on Scoped - OK!\n[Scoped]\npublic class CacheService(IUserContext userContext) { }\n</code></pre>"},{"location":"analyzers/NDLRCOR005/#option-2-use-factory-pattern","title":"Option 2: Use Factory Pattern","text":"<p>Inject a factory that creates fresh instances:</p> <pre><code>[Singleton]\npublic class CacheService(IServiceScopeFactory scopeFactory)\n{\n    public string GetCacheKey()\n    {\n        using var scope = scopeFactory.CreateScope();\n        var userContext = scope.ServiceProvider.GetRequiredService&lt;IUserContext&gt;();\n        return $\"user_{userContext.UserId}\";\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR005/#option-3-use-func-or-lazy","title":"Option 3: Use Func or Lazy <p>Configure a factory delegate:</p> <pre><code>[Singleton]\npublic class CacheService(Func&lt;IUserContext&gt; userContextFactory)\n{\n    public string GetCacheKey()\n    {\n        var userContext = userContextFactory();  // Fresh instance each call\n        return $\"user_{userContext.UserId}\";\n    }\n}\n</code></pre>","text":""},{"location":"analyzers/NDLRCOR005/#option-4-redesign-the-dependency","title":"Option 4: Redesign the Dependency <p>Sometimes the design needs rethinking. If a Singleton truly needs request-specific data, consider:</p> <ul> <li>Passing the data as a method parameter</li> <li>Using <code>IHttpContextAccessor</code> (for ASP.NET Core)</li> <li>Using ambient context patterns (with caution)</li> </ul>","text":""},{"location":"analyzers/NDLRCOR005/#runtime-detection","title":"Runtime Detection","text":"<p>This analyzer detects mismatches at compile-time for types with Needlr lifetime attributes. For additional runtime validation:</p> <pre><code>// Verify at startup\nservices.Verify(VerificationOptions.Strict);\n\n// Or get detailed diagnostics\nvar result = services.VerifyWithDiagnostics();\nif (!result.IsValid)\n{\n    Console.WriteLine(result.ToDetailedReport());\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR005/#detection-limitations","title":"Detection Limitations","text":"<p>This analyzer can only detect mismatches when:</p> <ol> <li>Both the consumer and dependency have explicit lifetime attributes (<code>[Singleton]</code>, <code>[Scoped]</code>, <code>[Transient]</code>, or <code>[RegisterAs]</code>)</li> <li>The dependency type is a concrete class (not an interface)</li> </ol> <p>For interface dependencies, use the runtime <code>Verify()</code> method which has access to the full service collection.</p>"},{"location":"analyzers/NDLRCOR005/#when-to-suppress","title":"When to Suppress","text":"<p>Suppress this warning only if you:</p> <ol> <li>Understand the implications and have mitigated them</li> <li>The dependency is thread-safe and stateless</li> <li>The dependency is intentionally shared across scopes</li> </ol> <pre><code>[Singleton]\n#pragma warning disable NDLRCOR005\npublic class MetricsService(ICounter counter) { }  // ICounter is thread-safe\n#pragma warning restore NDLRCOR005\n</code></pre>"},{"location":"analyzers/NDLRCOR005/#see-also","title":"See Also","text":"<ul> <li>Advanced Usage - Container Verification</li> <li>NDLRCOR006: Circular dependency detected</li> <li>Microsoft Docs: Service Lifetimes</li> </ul>"},{"location":"analyzers/NDLRCOR006/","title":"NDLRCOR006: Circular dependency detected","text":""},{"location":"analyzers/NDLRCOR006/#cause","title":"Cause","text":"<p>A service directly or indirectly depends on itself, creating a circular reference chain. This will cause a runtime exception when the dependency injection container attempts to resolve the service.</p>"},{"location":"analyzers/NDLRCOR006/#rule-description","title":"Rule Description","text":"<p>A circular dependency occurs when the dependency graph contains a cycle:</p> <pre><code>A \u2192 B \u2192 C \u2192 A  (cycle!)\n</code></pre> <p>This is impossible to resolve because: - To create <code>A</code>, we need <code>B</code> - To create <code>B</code>, we need <code>C</code> - To create <code>C</code>, we need <code>A</code> \u2190 but we haven't finished creating <code>A</code> yet!</p> <pre><code>// \u26a0\ufe0f NDLRCOR006: Circular dependency: OrderService \u2192 InventoryService \u2192 OrderService\n[Scoped]\npublic class OrderService(IInventoryService inventory)\n{\n    public void PlaceOrder() =&gt; inventory.Reserve();\n}\n\n[Scoped]\npublic class InventoryService(IOrderService orders)  // Depends back on OrderService!\n{\n    public void Reserve() =&gt; orders.ValidateStock();\n}\n</code></pre> <p>What happens at runtime:</p> <pre><code>System.InvalidOperationException: A circular dependency was detected for the service of type 'IOrderService'.\nIOrderService -&gt; OrderService -&gt; IInventoryService -&gt; InventoryService -&gt; IOrderService\n</code></pre> <p>Or worse, a <code>StackOverflowException</code> if the container doesn't detect the cycle.</p>"},{"location":"analyzers/NDLRCOR006/#common-circular-dependency-patterns","title":"Common Circular Dependency Patterns","text":""},{"location":"analyzers/NDLRCOR006/#direct-cycle-a-b-a","title":"Direct Cycle (A \u2192 B \u2192 A)","text":"<pre><code>[Scoped] public class UserService(IRoleService roles) { }\n[Scoped] public class RoleService(IUserService users) { }\n</code></pre>"},{"location":"analyzers/NDLRCOR006/#indirect-cycle-a-b-c-a","title":"Indirect Cycle (A \u2192 B \u2192 C \u2192 A)","text":"<pre><code>[Scoped] public class OrderService(IPaymentService payments) { }\n[Scoped] public class PaymentService(INotificationService notifications) { }\n[Scoped] public class NotificationService(IOrderService orders) { }  // Cycle!\n</code></pre>"},{"location":"analyzers/NDLRCOR006/#self-reference-a-a","title":"Self-Reference (A \u2192 A)","text":"<pre><code>[Scoped] \npublic class TreeNode(ITreeNode parent) { }  // References itself\n</code></pre>"},{"location":"analyzers/NDLRCOR006/#how-to-fix","title":"How to Fix","text":""},{"location":"analyzers/NDLRCOR006/#option-1-refactor-to-remove-the-cycle-recommended","title":"Option 1: Refactor to Remove the Cycle (Recommended)","text":"<p>Often circular dependencies indicate a design problem. Consider:</p> <p>Extract shared logic: <pre><code>// Before: OrderService \u2194 InventoryService\n\n// After: Both depend on shared service\n[Scoped] public class StockValidator { }  // Shared logic here\n[Scoped] public class OrderService(IStockValidator validator) { }\n[Scoped] public class InventoryService(IStockValidator validator) { }\n</code></pre></p> <p>Use events/mediator: <pre><code>// Before: Direct dependency\n[Scoped] public class OrderService(IInventoryService inventory) { }\n\n// After: Decoupled via events\n[Scoped] public class OrderService(IEventBus events)\n{\n    public void PlaceOrder() =&gt; events.Publish(new OrderPlacedEvent());\n}\n\n[Scoped] public class InventoryHandler : IEventHandler&lt;OrderPlacedEvent&gt; { }\n</code></pre></p>"},{"location":"analyzers/NDLRCOR006/#option-2-use-lazy-deferred-resolution","title":"Option 2: Use Lazy (Deferred Resolution) <p>Break the cycle by deferring one dependency:</p> <pre><code>[Scoped]\npublic class OrderService(IInventoryService inventory) { }\n\n[Scoped]\npublic class InventoryService(Lazy&lt;IOrderService&gt; orders)  // Lazy breaks the cycle\n{\n    public void Reserve() =&gt; orders.Value.ValidateStock();\n}\n</code></pre> <p>Note: This only delays the problem\u2014the cycle still exists and may cause issues.</p>","text":""},{"location":"analyzers/NDLRCOR006/#option-3-use-factoryfunc","title":"Option 3: Use Factory/Func <p>Similar to Lazy, create instances on-demand: <pre><code>[Scoped]\npublic class InventoryService(Func&lt;IOrderService&gt; orderFactory)\n{\n    public void Reserve()\n    {\n        var orders = orderFactory();\n        orders.ValidateStock();\n    }\n}\n</code></pre>","text":""},{"location":"analyzers/NDLRCOR006/#option-4-property-injection-not-recommended","title":"Option 4: Property Injection (Not Recommended) <p>Some DI containers support property injection to break cycles:</p> <pre><code>[Scoped]\npublic class InventoryService\n{\n    [Inject] public IOrderService Orders { get; set; }  // Set after construction\n}\n</code></pre> <p>Warning: Property injection hides dependencies and makes testing harder. Use sparingly.</p>","text":""},{"location":"analyzers/NDLRCOR006/#prevention-best-practices","title":"Prevention Best Practices","text":"<ol> <li> <p>Single Responsibility: Each service should do one thing. Large services often develop circular dependencies.</p> </li> <li> <p>Dependency Direction: Dependencies should flow one way (e.g., Controllers \u2192 Services \u2192 Repositories).</p> </li> <li> <p>Interface Segregation: Split large interfaces into smaller, focused ones.</p> </li> <li> <p>Layer Architecture: Use clear layers where higher layers depend on lower layers, never the reverse.</p> </li> </ol> <pre><code>Controllers (top)\n    \u2193\nServices\n    \u2193\nRepositories (bottom)\n</code></pre>"},{"location":"analyzers/NDLRCOR006/#runtime-detection","title":"Runtime Detection","text":"<p>For comprehensive cycle detection including dynamic registrations:</p> <pre><code>// Detect all cycles at startup\nservices.Verify(VerificationOptions.Strict);\n\n// Or get detailed chain information\nvar result = services.VerifyWithDiagnostics();\nforeach (var issue in result.Issues.Where(i =&gt; i.Type == VerificationIssueType.CircularDependency))\n{\n    Console.WriteLine(issue.DetailedMessage);\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR006/#detection-limitations","title":"Detection Limitations","text":"<p>This analyzer detects cycles at compile-time by:</p> <ol> <li>Building a dependency graph from constructor parameters</li> <li>Traversing the graph using DFS to find back-edges</li> </ol> <p>Limitations:</p> <ul> <li>Only analyzes types with Needlr registration attributes</li> <li>Cannot detect cycles involving factory-registered services</li> <li>Cannot detect cycles created by runtime configuration</li> </ul> <p>Use the runtime <code>Verify()</code> method for complete coverage.</p>"},{"location":"analyzers/NDLRCOR006/#when-to-suppress","title":"When to Suppress","text":"<p>Generally, do not suppress this diagnostic. Circular dependencies will cause runtime failures.</p> <p>However, if you're using <code>Lazy&lt;T&gt;</code> or <code>Func&lt;T&gt;</code> to intentionally break the cycle:</p> <pre><code>#pragma warning disable NDLRCOR006\n[Scoped] public class ServiceA(Lazy&lt;IServiceB&gt; b) { }  // Lazy breaks cycle\n[Scoped] public class ServiceB(IServiceA a) { }\n#pragma warning restore NDLRCOR006\n</code></pre>"},{"location":"analyzers/NDLRCOR006/#see-also","title":"See Also","text":"<ul> <li>Advanced Usage - Container Verification</li> <li>NDLRCOR005: Lifetime mismatch</li> <li>Martin Fowler: Inversion of Control Containers</li> </ul>"},{"location":"analyzers/NDLRCOR007/","title":"NDLRCOR007: Intercept type must implement IMethodInterceptor","text":""},{"location":"analyzers/NDLRCOR007/#cause","title":"Cause","text":"<p>A type used in an <code>[Intercept]</code> or <code>[Intercept&lt;T&gt;]</code> attribute does not implement the <code>IMethodInterceptor</code> interface.</p>"},{"location":"analyzers/NDLRCOR007/#rule-description","title":"Rule Description","text":"<p>When using the <code>[Intercept]</code> attribute to apply an interceptor to a service, the specified type must implement <code>IMethodInterceptor</code>. This interface defines the <code>InterceptAsync</code> method that is called when intercepted methods are invoked.</p> <pre><code>// \u274c NDLRCOR007: MyLogger does not implement IMethodInterceptor\n[Intercept&lt;MyLogger&gt;]\npublic class OrderService : IOrderService\n{\n    public Order GetOrder(int id) =&gt; /* ... */;\n}\n\npublic class MyLogger  // Missing IMethodInterceptor implementation\n{\n    public void Log(string message) =&gt; Console.WriteLine(message);\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR007/#how-to-fix","title":"How to Fix","text":"<p>Implement <code>IMethodInterceptor</code> on the interceptor class:</p> <pre><code>// \u2705 Fixed: LoggingInterceptor implements IMethodInterceptor\n[Intercept&lt;LoggingInterceptor&gt;]\npublic class OrderService : IOrderService\n{\n    public Order GetOrder(int id) =&gt; /* ... */;\n}\n\npublic class LoggingInterceptor : IMethodInterceptor\n{\n    public async ValueTask&lt;object?&gt; InterceptAsync(IMethodInvocation invocation)\n    {\n        Console.WriteLine($\"Calling {invocation.Method.Name}\");\n        return await invocation.ProceedAsync();\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR007/#imethodinterceptor-interface","title":"IMethodInterceptor Interface","text":"<pre><code>public interface IMethodInterceptor\n{\n    ValueTask&lt;object?&gt; InterceptAsync(IMethodInvocation invocation);\n}\n</code></pre> <p>The interface requires a single method: - <code>InterceptAsync</code>: Called when an intercepted method is invoked. Call <code>invocation.ProceedAsync()</code> to continue to the next interceptor or the actual method.</p>"},{"location":"analyzers/NDLRCOR007/#when-to-suppress","title":"When to Suppress","text":"<p>Do not suppress this diagnostic. Using a type that doesn't implement <code>IMethodInterceptor</code> will cause a compilation error in the generated code.</p>"},{"location":"analyzers/NDLRCOR007/#see-also","title":"See Also","text":"<ul> <li>Interceptors - Full interceptor documentation</li> <li>IMethodInterceptor - Interface details</li> </ul>"},{"location":"analyzers/NDLRCOR008/","title":"NDLRCOR008: [Intercept] applied to class without interfaces","text":""},{"location":"analyzers/NDLRCOR008/#cause","title":"Cause","text":"<p>An <code>[Intercept]</code> or <code>[Intercept&lt;T&gt;]</code> attribute is applied to a class that does not implement any user-defined interfaces.</p>"},{"location":"analyzers/NDLRCOR008/#rule-description","title":"Rule Description","text":"<p>Interceptors work by generating a proxy class that implements the service's interfaces. When a consumer resolves <code>IOrderService</code>, they receive the proxy instead of the original implementation. The proxy intercepts method calls and forwards them through the interceptor chain.</p> <p>If the class doesn't implement any interfaces, there's nothing for the proxy to implement, and the interceptor cannot be applied.</p> <pre><code>// \u26a0\ufe0f NDLRCOR008: OrderService doesn't implement any interfaces\n[Intercept&lt;LoggingInterceptor&gt;]\npublic class OrderService  // No interface!\n{\n    public Order GetOrder(int id) =&gt; /* ... */;\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR008/#how-to-fix","title":"How to Fix","text":""},{"location":"analyzers/NDLRCOR008/#option-1-add-an-interface-recommended","title":"Option 1: Add an Interface (Recommended)","text":"<p>Define an interface for your service:</p> <pre><code>// \u2705 Fixed: OrderService now implements IOrderService\npublic interface IOrderService\n{\n    Order GetOrder(int id);\n}\n\n[Intercept&lt;LoggingInterceptor&gt;]\npublic class OrderService : IOrderService\n{\n    public Order GetOrder(int id) =&gt; /* ... */;\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR008/#option-2-use-a-decorator-instead","title":"Option 2: Use a Decorator Instead","text":"<p>If you can't add an interface, consider using a decorator pattern with manual registration:</p> <pre><code>public class OrderService\n{\n    public virtual Order GetOrder(int id) =&gt; /* ... */;\n}\n\npublic class LoggingOrderService : OrderService\n{\n    private readonly OrderService _inner;\n\n    public LoggingOrderService(OrderService inner) =&gt; _inner = inner;\n\n    public override Order GetOrder(int id)\n    {\n        Console.WriteLine(\"Getting order...\");\n        return _inner.GetOrder(id);\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR008/#option-3-remove-the-attribute","title":"Option 3: Remove the Attribute","text":"<p>If interception isn't needed, remove the <code>[Intercept]</code> attribute:</p> <pre><code>// No interception\npublic class OrderService\n{\n    public Order GetOrder(int id) =&gt; /* ... */;\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR008/#why-interfaces-are-required","title":"Why Interfaces Are Required","text":"<p>The source generator creates a proxy class like this:</p> <pre><code>// Generated proxy\ninternal sealed class OrderService_InterceptorProxy : IOrderService\n{\n    private readonly OrderService _target;\n    private readonly IServiceProvider _serviceProvider;\n\n    public Order GetOrder(int id)\n    {\n        // Interceptor chain logic...\n    }\n}\n</code></pre> <p>The proxy must implement an interface so that consumers can depend on the interface while receiving the proxy. Without an interface, this pattern isn't possible.</p>"},{"location":"analyzers/NDLRCOR008/#when-to-suppress","title":"When to Suppress","text":"<p>Suppress this warning if you're intentionally applying <code>[Intercept]</code> for future use when an interface will be added:</p> <pre><code>#pragma warning disable NDLRCOR008\n[Intercept&lt;LoggingInterceptor&gt;]  // Interface coming in next PR\npublic class OrderService\n{\n    // ...\n}\n#pragma warning restore NDLRCOR008\n</code></pre>"},{"location":"analyzers/NDLRCOR008/#see-also","title":"See Also","text":"<ul> <li>Interceptors - Full interceptor documentation</li> <li>Decorators - Alternative for interface-less services</li> </ul>"},{"location":"analyzers/NDLRCOR009/","title":"NDLRCOR009: Lazy references undiscovered type","text":""},{"location":"analyzers/NDLRCOR009/#cause","title":"Cause","text":"<p>A constructor parameter of type <code>Lazy&lt;T&gt;</code> references a type <code>T</code> that was not discovered by source generation.</p>"},{"location":"analyzers/NDLRCOR009/#rule-description","title":"Rule Description","text":"<p>When using source generation with <code>[assembly: GenerateTypeRegistry]</code>, Needlr scans your codebase to discover injectable types. This analyzer detects when a <code>Lazy&lt;T&gt;</code> dependency references a type that wasn't found during that scan.</p> <pre><code>// \u26a0\ufe0f NDLRCOR009: IUnknownService not discovered\npublic class OrderService(Lazy&lt;IUnknownService&gt; unknown)\n{\n    // ...\n}\n</code></pre> <p>This is an informational diagnostic (not a warning or error) because: - The type may be registered via reflection at runtime - The type may come from a third-party library - The type may be registered manually in an <code>IServiceCollectionPlugin</code></p>"},{"location":"analyzers/NDLRCOR009/#how-to-fix","title":"How to Fix","text":""},{"location":"analyzers/NDLRCOR009/#option-1-ensure-the-type-is-discoverable","title":"Option 1: Ensure the Type is Discoverable","text":"<p>Make sure the implementation is in a namespace matching your <code>IncludeNamespacePrefixes</code>:</p> <pre><code>[assembly: GenerateTypeRegistry(IncludeNamespacePrefixes = new[] { \"MyApp\" })]\n\nnamespace MyApp.Services\n{\n    public interface IUnknownService { }\n\n    // \u2705 This will be discovered\n    public class UnknownService : IUnknownService { }\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR009/#option-2-register-manually-via-plugin","title":"Option 2: Register Manually via Plugin","text":"<p>If the type is intentionally registered elsewhere:</p> <pre><code>public class MyPlugin : IServiceCollectionPlugin\n{\n    public void Configure(IServiceCollection services)\n    {\n        // Registered manually - Lazy&lt;IExternalService&gt; will work\n        services.AddSingleton&lt;IExternalService, ExternalService&gt;();\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR009/#option-3-suppress-the-diagnostic","title":"Option 3: Suppress the Diagnostic","text":"<p>If you know the type will be available at runtime:</p> <pre><code>#pragma warning disable NDLRCOR009\npublic class OrderService(Lazy&lt;IExternalService&gt; external)\n#pragma warning restore NDLRCOR009\n{\n    // ...\n}\n</code></pre> <p>Or suppress project-wide in <code>.editorconfig</code>:</p> <pre><code># .editorconfig\n[*.cs]\ndotnet_diagnostic.NDLRCOR009.severity = none\n</code></pre>"},{"location":"analyzers/NDLRCOR009/#when-this-analyzer-activates","title":"When This Analyzer Activates","text":"<p>This analyzer only runs when <code>[assembly: GenerateTypeRegistry]</code> is present. In reflection-only projects, there's no type registry to validate against.</p>"},{"location":"analyzers/NDLRCOR009/#severity-levels","title":"Severity Levels","text":"Level Meaning <code>info</code> (default) Informational hint in IDE <code>warning</code> Promote to build warning <code>error</code> Fail the build <code>none</code> Disable completely <p>Configure in <code>.editorconfig</code>:</p> <pre><code># Promote to warning for stricter validation\ndotnet_diagnostic.NDLRCOR009.severity = warning\n</code></pre>"},{"location":"analyzers/NDLRCOR009/#see-also","title":"See Also","text":"<ul> <li>Lazy Injection - How <code>Lazy&lt;T&gt;</code> works in Needlr</li> <li>AnalyzerStatus.md - View all active analyzers in diagnostics output</li> </ul>"},{"location":"analyzers/NDLRCOR010/","title":"NDLRCOR010: IEnumerable has no discovered implementations","text":""},{"location":"analyzers/NDLRCOR010/#cause","title":"Cause","text":"<p>A constructor parameter of type <code>IEnumerable&lt;T&gt;</code> references an interface <code>T</code> that has no implementations discovered by source generation.</p>"},{"location":"analyzers/NDLRCOR010/#rule-description","title":"Rule Description","text":"<p>When using source generation with <code>[assembly: GenerateTypeRegistry]</code>, Needlr scans your codebase to discover injectable types. This analyzer detects when an <code>IEnumerable&lt;T&gt;</code> dependency references an interface with no discovered implementations.</p> <pre><code>// \u26a0\ufe0f NDLRCOR010: No implementations of IPlugin discovered\npublic class PluginHost(IEnumerable&lt;IPlugin&gt; plugins)\n{\n    // plugins will be empty unless registered via reflection\n}\n</code></pre> <p>This is an informational diagnostic (not a warning or error) because: - Implementations may be registered via reflection at runtime - Implementations may come from a third-party library - Implementations may be registered manually in an <code>IServiceCollectionPlugin</code> - An empty collection is valid in some scenarios</p>"},{"location":"analyzers/NDLRCOR010/#how-to-fix","title":"How to Fix","text":""},{"location":"analyzers/NDLRCOR010/#option-1-add-implementations","title":"Option 1: Add Implementations","text":"<p>Create classes that implement the interface:</p> <pre><code>public interface IPlugin { }\n\n// \u2705 These will be discovered and registered\npublic class LoggingPlugin : IPlugin { }\npublic class CachingPlugin : IPlugin { }\npublic class MetricsPlugin : IPlugin { }\n</code></pre>"},{"location":"analyzers/NDLRCOR010/#option-2-ensure-namespace-matches","title":"Option 2: Ensure Namespace Matches","text":"<p>Make sure implementations are in a namespace matching your <code>IncludeNamespacePrefixes</code>:</p> <pre><code>[assembly: GenerateTypeRegistry(IncludeNamespacePrefixes = new[] { \"MyApp\" })]\n\nnamespace MyApp.Plugins  // \u2705 Matches prefix\n{\n    public class MyPlugin : IPlugin { }\n}\n\nnamespace ThirdParty.Plugins  // \u274c Won't be discovered\n{\n    public class ExternalPlugin : IPlugin { }\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR010/#option-3-register-manually-via-plugin","title":"Option 3: Register Manually via Plugin","text":"<p>For external implementations:</p> <pre><code>public class ExternalPluginRegistration : IServiceCollectionPlugin\n{\n    public void Configure(IServiceCollection services)\n    {\n        services.AddSingleton&lt;IPlugin, ThirdPartyPlugin&gt;();\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR010/#option-4-suppress-the-diagnostic","title":"Option 4: Suppress the Diagnostic","text":"<p>If empty collections are expected:</p> <pre><code>#pragma warning disable NDLRCOR010\npublic class PluginHost(IEnumerable&lt;IOptionalPlugin&gt; plugins)\n#pragma warning restore NDLRCOR010\n{\n    // Empty collection is valid here\n}\n</code></pre> <p>Or suppress project-wide in <code>.editorconfig</code>:</p> <pre><code># .editorconfig\n[*.cs]\ndotnet_diagnostic.NDLRCOR010.severity = none\n</code></pre>"},{"location":"analyzers/NDLRCOR010/#when-this-analyzer-activates","title":"When This Analyzer Activates","text":"<p>This analyzer only runs when: 1. <code>[assembly: GenerateTypeRegistry]</code> is present 2. The <code>IEnumerable&lt;T&gt;</code> parameter uses an interface type (not a concrete class) 3. The interface is not a framework type (System., Microsoft.)</p>"},{"location":"analyzers/NDLRCOR010/#severity-levels","title":"Severity Levels","text":"Level Meaning <code>info</code> (default) Informational hint in IDE <code>warning</code> Promote to build warning <code>error</code> Fail the build <code>none</code> Disable completely <p>Configure in <code>.editorconfig</code>:</p> <pre><code># Promote to warning for stricter validation\ndotnet_diagnostic.NDLRCOR010.severity = warning\n</code></pre>"},{"location":"analyzers/NDLRCOR010/#see-also","title":"See Also","text":"<ul> <li>Collection Injection - How <code>IEnumerable&lt;T&gt;</code> works in Needlr</li> <li>AnalyzerStatus.md - View all active analyzers in diagnostics output</li> </ul>"},{"location":"analyzers/NDLRCOR011/","title":"NDLRCOR011: Keyed Service Unknown Key","text":""},{"location":"analyzers/NDLRCOR011/#cause","title":"Cause","text":"<p>A constructor parameter uses <code>[FromKeyedServices(\"key\")]</code> to resolve a keyed service, but no <code>[Keyed(\"key\")]</code> registration was found in the compilation.</p>"},{"location":"analyzers/NDLRCOR011/#rule-description","title":"Rule Description","text":"<p>When using source generation with <code>[assembly: GenerateTypeRegistry]</code>, Needlr validates that <code>[FromKeyedServices(\"key\")]</code> parameters reference keys that are statically discoverable.</p> <pre><code>// \u2139\ufe0f NDLRCOR011: No registration found for key \"unknown\"\npublic class PaymentHandler(\n    [FromKeyedServices(\"unknown\")] IPaymentProcessor processor)\n{\n}\n</code></pre> <p>This is an informational diagnostic (not a warning or error) because: - Keys may be registered at runtime via <code>IServiceCollectionPlugin</code> - The analyzer only validates statically-discoverable <code>[Keyed]</code> registrations</p>"},{"location":"analyzers/NDLRCOR011/#how-to-fix","title":"How to Fix","text":""},{"location":"analyzers/NDLRCOR011/#option-1-add-keyed-attribute","title":"Option 1: Add [Keyed] Attribute","text":"<p>Register the service with a matching key:</p> <pre><code>[Keyed(\"primary\")]\npublic class StripeProcessor : IPaymentProcessor { }\n\n// \u2705 Now validated - \"primary\" key is discovered\npublic class PaymentHandler(\n    [FromKeyedServices(\"primary\")] IPaymentProcessor processor)\n{\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR011/#option-2-register-via-plugin-suppress-diagnostic","title":"Option 2: Register via Plugin (Suppress Diagnostic)","text":"<p>If registering via plugin, suppress the diagnostic:</p> <pre><code>// Plugin registers keyed services at runtime\npublic class PaymentPlugin : IServiceCollectionPlugin\n{\n    public void Configure(ServiceCollectionPluginOptions options)\n    {\n        options.Services.AddKeyedSingleton&lt;IPaymentProcessor, StripeProcessor&gt;(\"primary\");\n    }\n}\n\n// Suppress because key is registered via plugin\n#pragma warning disable NDLRCOR011\npublic class PaymentHandler(\n    [FromKeyedServices(\"primary\")] IPaymentProcessor processor)\n#pragma warning restore NDLRCOR011\n{\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR011/#option-3-project-wide-suppression","title":"Option 3: Project-Wide Suppression","text":"<pre><code># .editorconfig\n[*.cs]\ndotnet_diagnostic.NDLRCOR011.severity = none\n</code></pre>"},{"location":"analyzers/NDLRCOR011/#validation-logic","title":"Validation Logic","text":"<p>The analyzer: 1. Collects all <code>[Keyed(\"key\")]</code> attributes from classes in the compilation 2. Collects all <code>[FromKeyedServices(\"key\")]</code> parameters 3. Reports diagnostic when a key is not found in discovered registrations</p> <p>Keys registered via plugins cannot be validated at compile time.</p>"},{"location":"analyzers/NDLRCOR011/#when-this-analyzer-activates","title":"When This Analyzer Activates","text":"<p>This analyzer only runs when: 1. <code>[assembly: GenerateTypeRegistry]</code> is present 2. A constructor parameter has <code>[FromKeyedServices(\"key\")]</code> attribute 3. The parameter type is not a framework type (System., Microsoft.)</p>"},{"location":"analyzers/NDLRCOR011/#severity-levels","title":"Severity Levels","text":"Level Meaning <code>info</code> (default) Informational hint in IDE <code>warning</code> Promote to build warning <code>error</code> Fail the build <code>none</code> Disable completely"},{"location":"analyzers/NDLRCOR011/#see-also","title":"See Also","text":"<ul> <li>Keyed Attribute - Static keyed service registration</li> <li>AnalyzerStatus.md - View all active analyzers</li> </ul>"},{"location":"analyzers/NDLRCOR012/","title":"NDLRCOR012: Disposable captive dependency","text":""},{"location":"analyzers/NDLRCOR012/#cause","title":"Cause","text":"<p>A service with a longer lifetime holds a reference to an <code>IDisposable</code> or <code>IAsyncDisposable</code> dependency with a shorter lifetime. When the shorter-lived scope ends, the dependency will be disposed while the longer-lived service still holds a reference, causing <code>ObjectDisposedException</code> at runtime.</p>"},{"location":"analyzers/NDLRCOR012/#rule-description","title":"Rule Description","text":"<p>This is a more severe form of captive dependency (see NDLRCOR005) that specifically targets disposable services. While a general captive dependency causes stale data, a disposable captive dependency causes runtime crashes.</p> <pre><code>// \u274c NDLRCOR012: Singleton holds Scoped IDisposable\n[Singleton]\npublic class CacheService\n{\n    private readonly MyDbContext _dbContext;\n\n    public CacheService(MyDbContext dbContext)\n    {\n        _dbContext = dbContext;\n    }\n\n    public async Task RefreshCache()\n    {\n        // \ud83d\udca5 ObjectDisposedException - dbContext was disposed when scope ended!\n        var data = await _dbContext.Items.ToListAsync();\n    }\n}\n\n[Scoped]\npublic class MyDbContext : DbContext, IDisposable\n{\n    // ...\n}\n</code></pre> <p>Why this is dangerous:</p> <ol> <li>Runtime exceptions: Accessing a disposed object throws <code>ObjectDisposedException</code></li> <li>Unpredictable timing: The exception may occur long after the service was created</li> <li>Hard to debug: The stack trace points to the usage site, not the registration problem</li> </ol>"},{"location":"analyzers/NDLRCOR012/#mismatch-patterns-that-trigger-this-error","title":"Mismatch Patterns That Trigger This Error","text":"Consumer Dependency Result Singleton Scoped IDisposable \u274c Error Singleton Transient IDisposable \u274c Error Scoped Transient IDisposable \u274c Error"},{"location":"analyzers/NDLRCOR012/#how-to-fix","title":"How to Fix","text":""},{"location":"analyzers/NDLRCOR012/#option-1-match-lifetimes","title":"Option 1: Match Lifetimes","text":"<p>Make the consumer's lifetime equal or shorter than its dependencies:</p> <pre><code>// \u2705 Scoped depends on Scoped - OK!\n[Scoped]\npublic class CacheService(MyDbContext dbContext) { }\n</code></pre>"},{"location":"analyzers/NDLRCOR012/#option-2-use-iservicescopefactory","title":"Option 2: Use IServiceScopeFactory","text":"<p>Create a new scope when you need the disposable service:</p> <pre><code>[Singleton]\npublic class CacheService\n{\n    private readonly IServiceScopeFactory _scopeFactory;\n\n    public CacheService(IServiceScopeFactory scopeFactory)\n    {\n        _scopeFactory = scopeFactory;\n    }\n\n    public async Task RefreshCache()\n    {\n        using var scope = _scopeFactory.CreateScope();\n        var dbContext = scope.ServiceProvider.GetRequiredService&lt;MyDbContext&gt;();\n        var data = await dbContext.Items.ToListAsync();\n        // dbContext is disposed when scope ends - that's fine, we're done with it\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR012/#option-3-use-func-factory","title":"Option 3: Use Func Factory <p>Inject a factory that creates fresh instances:</p> <pre><code>[Singleton]\npublic class CacheService(Func&lt;MyDbContext&gt; dbContextFactory)\n{\n    public async Task RefreshCache()\n    {\n        using var dbContext = dbContextFactory();\n        var data = await dbContext.Items.ToListAsync();\n    }\n}\n</code></pre>","text":""},{"location":"analyzers/NDLRCOR012/#detection-limitations","title":"Detection Limitations","text":"<p>This analyzer only fires when:</p> <ol> <li>Both types have explicit lifetime attributes (<code>[Singleton]</code>, <code>[Scoped]</code>, <code>[Transient]</code>)</li> <li>The dependency is a concrete class (not an interface)</li> <li>The dependency directly implements <code>IDisposable</code> or <code>IAsyncDisposable</code></li> </ol> <p>This conservative approach ensures zero false positives but may miss some cases (false negatives are acceptable).</p>"},{"location":"analyzers/NDLRCOR012/#not-detected-by-design","title":"Not Detected (by design) <pre><code>// Interface dependency - can't determine concrete type\n[Singleton]\npublic class Service(IDbContext dbContext) { }  // No error (might not be disposable)\n\n// No explicit lifetime attributes\npublic class Service(ScopedDisposable dep) { }  // No error (lifetime unknown)\n</code></pre>","text":""},{"location":"analyzers/NDLRCOR012/#when-to-suppress","title":"When to Suppress","text":"<p>You should rarely suppress this error. Consider suppressing only if:</p> <ol> <li>You've implemented proper disposal handling manually</li> <li>The disposable's <code>Dispose()</code> is a no-op or the object remains usable after disposal</li> </ol> <pre><code>[Singleton]\n#pragma warning disable NDLRCOR012\npublic class Service(PooledConnection connection) { }  // Connection returns to pool\n#pragma warning restore NDLRCOR012\n</code></pre>"},{"location":"analyzers/NDLRCOR012/#see-also","title":"See Also","text":"<ul> <li>NDLRCOR005: Lifetime mismatch - General captive dependency warning</li> <li>NDLRCOR006: Circular dependency detected</li> </ul>"},{"location":"analyzers/NDLRCOR015/","title":"NDLRCOR015: [RegisterAs\\] type argument not implemented","text":""},{"location":"analyzers/NDLRCOR015/#summary","title":"Summary","text":"<p>The type specified in <code>[RegisterAs&lt;T&gt;]</code> must be an interface that the decorated class actually implements.</p>"},{"location":"analyzers/NDLRCOR015/#description","title":"Description","text":"<p>When using <code>[RegisterAs&lt;T&gt;]</code> to control which interface a class is registered as in dependency injection, the type argument <code>T</code> must be an interface that the class implements. If the class doesn't implement the specified interface, the registration would be invalid and the service could not be resolved.</p>"},{"location":"analyzers/NDLRCOR015/#severity","title":"Severity","text":"<p>Error - This is a compile-time error because the service registration would fail at runtime.</p>"},{"location":"analyzers/NDLRCOR015/#example","title":"Example","text":""},{"location":"analyzers/NDLRCOR015/#invalid-code","title":"Invalid Code","text":"<pre><code>public interface IReader { string Read(); }\npublic interface IWriter { void Write(string data); }\n\n// \u274c Error: MyService does not implement IWriter\n[RegisterAs&lt;IWriter&gt;]\npublic class MyService : IReader\n{\n    public string Read() =&gt; \"data\";\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR015/#valid-code","title":"Valid Code","text":"<pre><code>public interface IReader { string Read(); }\npublic interface IWriter { void Write(string data); }\npublic interface ILogger { void Log(string message); }\n\n// \u2705 OK: MyService implements IReader\n[RegisterAs&lt;IReader&gt;]\npublic class MyService : IReader, IWriter, ILogger\n{\n    public string Read() =&gt; \"data\";\n    public void Write(string data) { }\n    public void Log(string message) { }\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR015/#how-to-fix","title":"How to Fix","text":"<ol> <li>Add the interface to the class - Make the class implement the interface specified in <code>[RegisterAs&lt;T&gt;]</code></li> <li>Change the type argument - Use a different interface that the class already implements</li> <li>Remove the attribute - If you want all interfaces registered, remove <code>[RegisterAs&lt;T&gt;]</code> entirely</li> </ol>"},{"location":"analyzers/NDLRCOR015/#when-to-suppress","title":"When to Suppress","text":"<p>Do not suppress this diagnostic. If the class doesn't implement the interface, the registration is invalid and will fail.</p>"},{"location":"analyzers/NDLRCOR015/#related-rules","title":"Related Rules","text":"<ul> <li>NDLRCOR014 - Similar validation for <code>[GenerateFactory&lt;T&gt;]</code></li> </ul>"},{"location":"analyzers/NDLRCOR015/#see-also","title":"See Also","text":"<ul> <li>RegisterAs Documentation</li> </ul>"},{"location":"analyzers/NDLRGEN001/","title":"NDLRGEN001: Internal type in referenced assembly cannot be registered","text":""},{"location":"analyzers/NDLRGEN001/#cause","title":"Cause","text":"<p>You are scanning a namespace that contains internal types in a referenced assembly, but those types cannot be registered because they are not accessible from the generated code.</p>"},{"location":"analyzers/NDLRGEN001/#rule-description","title":"Rule Description","text":"<p>When using source generation with <code>[GenerateTypeRegistry]</code>, the generator scans specified namespace prefixes to discover types for automatic registration. If an internal type in a referenced assembly matches the namespace filter and would otherwise be registerable (e.g., implements an interface or is a plugin), the generator cannot access it.</p> <p>This error indicates a configuration problem that would cause silent runtime failures if not addressed.</p>"},{"location":"analyzers/NDLRGEN001/#how-to-fix","title":"How to Fix","text":"<p>You have two options:</p>"},{"location":"analyzers/NDLRGEN001/#option-1-add-generatetyperegistry-to-the-referenced-assembly","title":"Option 1: Add [GenerateTypeRegistry] to the Referenced Assembly","text":"<p>Add the <code>[GenerateTypeRegistry]</code> attribute to the assembly containing the internal types. This allows that assembly to generate its own type registry that can access its internal types.</p> <pre><code>// In the referenced assembly (e.g., MyPlugin project)\nusing NexusLabs.Needlr.Generators;\n\n[assembly: GenerateTypeRegistry(IncludeNamespacePrefixes = new[] { \"MyPlugin\" })]\n\nnamespace MyPlugin\n{\n    internal class MyInternalService : IMyService { }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN001/#option-2-make-the-type-public","title":"Option 2: Make the Type Public","text":"<p>If the type can be made public, change its accessibility:</p> <pre><code>namespace MyPlugin\n{\n    public class MyService : IMyService { }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN001/#when-to-suppress","title":"When to Suppress","text":"<p>Only suppress this error if you intentionally don't want the internal type to be registered:</p> <pre><code>#pragma warning disable NDLRGEN001\n// Intentionally not registering this internal type\n#pragma warning restore NDLRGEN001\n</code></pre>"},{"location":"analyzers/NDLRGEN001/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN001/#code-with-error","title":"Code with Error","text":"<pre><code>// HostApp project\nusing NexusLabs.Needlr.Generators;\n\n// Scanning \"MyPlugin\" namespace but MyPlugin assembly has internal types\n[assembly: GenerateTypeRegistry(IncludeNamespacePrefixes = new[] { \"MyPlugin\" })]\n</code></pre> <pre><code>// MyPlugin project (referenced by HostApp) - NO [GenerateTypeRegistry]\nnamespace MyPlugin\n{\n    public interface IMyService { }\n    internal class MyInternalService : IMyService { }  // Error: Cannot be registered\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN001/#fixed-code","title":"Fixed Code","text":"<pre><code>// MyPlugin project - WITH [GenerateTypeRegistry]\nusing NexusLabs.Needlr.Generators;\n\n[assembly: GenerateTypeRegistry(IncludeNamespacePrefixes = new[] { \"MyPlugin\" })]\n\nnamespace MyPlugin\n{\n    public interface IMyService { }\n    internal class MyInternalService : IMyService { }  // Now properly registered\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN001/#see-also","title":"See Also","text":"<ul> <li>NDLRGEN002 - Missing type registry for internal plugin types</li> <li>Advanced Usage - Multi-Project Solutions</li> <li>Getting Started Guide</li> </ul>"},{"location":"analyzers/NDLRGEN002/","title":"NDLRGEN002: Referenced assembly has internal plugin types but no type registry","text":""},{"location":"analyzers/NDLRGEN002/#cause","title":"Cause","text":"<p>A referenced assembly contains internal types that implement Needlr plugin interfaces (e.g., <code>IServiceCollectionPlugin</code>), but the assembly does not have a <code>[GenerateTypeRegistry]</code> attribute.</p>"},{"location":"analyzers/NDLRGEN002/#rule-description","title":"Rule Description","text":"<p>When using source generation, internal plugin types in referenced assemblies cannot be discovered by the host application's generator. This means internal plugins will silently fail to load at runtime.</p> <p>This error proactively detects this misconfiguration at compile time, preventing runtime failures.</p>"},{"location":"analyzers/NDLRGEN002/#plugin-interfaces-checked","title":"Plugin Interfaces Checked","text":"<p>The generator checks for internal types implementing any of these interfaces:</p> <ul> <li><code>NexusLabs.Needlr.IServiceCollectionPlugin</code></li> <li><code>NexusLabs.Needlr.IPostBuildServiceCollectionPlugin</code></li> <li><code>NexusLabs.Needlr.IWebApplicationPlugin</code></li> <li><code>NexusLabs.Needlr.IWebApplicationBuilderPlugin</code></li> <li><code>NexusLabs.Needlr.SignalR.IHubRegistrationPlugin</code></li> <li><code>NexusLabs.Needlr.SemanticKernel.IKernelBuilderPlugin</code></li> </ul>"},{"location":"analyzers/NDLRGEN002/#how-to-fix","title":"How to Fix","text":"<p>You have two options:</p>"},{"location":"analyzers/NDLRGEN002/#option-1-add-generatetyperegistry-to-the-plugin-assembly","title":"Option 1: Add [GenerateTypeRegistry] to the Plugin Assembly","text":"<p>Add the <code>[GenerateTypeRegistry]</code> attribute to the assembly containing the internal plugin:</p> <pre><code>// In the plugin assembly (e.g., MyPlugin project)\nusing NexusLabs.Needlr.Generators;\n\n[assembly: GenerateTypeRegistry(IncludeNamespacePrefixes = new[] { \"MyPlugin\" })]\n\nnamespace MyPlugin\n{\n    internal class MyPlugin : IServiceCollectionPlugin\n    {\n        public void Configure(ServiceCollectionPluginOptions options) { }\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN002/#option-2-make-the-plugin-type-public","title":"Option 2: Make the Plugin Type Public","text":"<p>If the plugin can be made public, change its accessibility:</p> <pre><code>namespace MyPlugin\n{\n    public class MyPlugin : IServiceCollectionPlugin\n    {\n        public void Configure(ServiceCollectionPluginOptions options) { }\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN002/#when-to-suppress","title":"When to Suppress","text":"<p>Only suppress this error if you intentionally don't want the plugin to be discovered:</p> <pre><code>#pragma warning disable NDLRGEN002\n// Intentionally keeping this plugin internal and unregistered\n#pragma warning restore NDLRGEN002\n</code></pre>"},{"location":"analyzers/NDLRGEN002/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN002/#code-with-error","title":"Code with Error","text":"<pre><code>// HostApp project\nusing NexusLabs.Needlr.Generators;\n\n[assembly: GenerateTypeRegistry]\n</code></pre> <pre><code>// MyPlugin project (referenced by HostApp) - NO [GenerateTypeRegistry]\nnamespace MyPlugin\n{\n    internal class AuthenticationPlugin : IWebApplicationBuilderPlugin\n    {\n        public void Configure(WebApplicationBuilderPluginOptions options)\n        {\n            options.Builder.Services.AddAuthentication();\n        }\n    }\n}\n</code></pre> <p>Result: <code>NDLRGEN002</code> error - AuthenticationPlugin will not be discovered at runtime.</p>"},{"location":"analyzers/NDLRGEN002/#fixed-code","title":"Fixed Code","text":"<pre><code>// MyPlugin project - WITH [GenerateTypeRegistry]\nusing NexusLabs.Needlr.Generators;\n\n[assembly: GenerateTypeRegistry(IncludeNamespacePrefixes = new[] { \"MyPlugin\" })]\n\nnamespace MyPlugin\n{\n    internal class AuthenticationPlugin : IWebApplicationBuilderPlugin\n    {\n        public void Configure(WebApplicationBuilderPluginOptions options)\n        {\n            options.Builder.Services.AddAuthentication();\n        }\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN002/#multi-project-solutions","title":"Multi-Project Solutions","text":"<p>For solutions with many plugin projects, consider using MSBuild conventions to automatically add <code>[GenerateTypeRegistry]</code> to matching projects. See Advanced Usage - Multi-Project Solutions for details.</p>"},{"location":"analyzers/NDLRGEN002/#see-also","title":"See Also","text":"<ul> <li>NDLRGEN001 - Internal type in referenced assembly cannot be registered</li> <li>Advanced Usage - Multi-Project Solutions</li> <li>Getting Started Guide</li> </ul>"},{"location":"analyzers/NDLRGEN003/","title":"NDLRGEN003: All factory parameters are injectable","text":""},{"location":"analyzers/NDLRGEN003/#diagnostic-info","title":"Diagnostic Info","text":"Property Value ID NDLRGEN003 Category NexusLabs.Needlr.Generators Severity Warning Enabled Yes"},{"location":"analyzers/NDLRGEN003/#description","title":"Description","text":"<p>This warning is raised when a class marked with <code>[GenerateFactory]</code> has a constructor where all parameters are injectable types (interfaces or classes). In this case, the factory provides no additional value since the type could be auto-registered normally.</p>"},{"location":"analyzers/NDLRGEN003/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN003/#code-that-triggers-the-warning","title":"Code that triggers the warning","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n// \u26a0\ufe0f NDLRGEN003: All parameters are injectable, factory provides no value\n[GenerateFactory]\npublic class MyService\n{\n    public MyService(ILogger&lt;MyService&gt; logger, IConfiguration config)\n    {\n        // Both parameters are injectable - no need for a factory\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN003/#how-to-fix","title":"How to fix","text":"<p>Either remove the <code>[GenerateFactory]</code> attribute (the type will be auto-registered normally), or add a runtime parameter that justifies the factory:</p> <p>Option 1: Remove the attribute <pre><code>// Let Needlr auto-register this normally\npublic class MyService\n{\n    public MyService(ILogger&lt;MyService&gt; logger, IConfiguration config)\n    {\n    }\n}\n</code></pre></p> <p>Option 2: Add a runtime parameter <pre><code>[GenerateFactory]\npublic class MyService\n{\n    public MyService(ILogger&lt;MyService&gt; logger, IConfiguration config, string tenantId)\n    {\n        // Now the factory makes sense - tenantId must be provided at runtime\n    }\n}\n</code></pre></p>"},{"location":"analyzers/NDLRGEN003/#why-this-matters","title":"Why This Matters","text":"<p>Factory generation adds code to your assembly. If all parameters can be auto-injected, the factory is unnecessary overhead. The type can simply be registered directly with the container.</p>"},{"location":"analyzers/NDLRGEN003/#see-also","title":"See Also","text":"<ul> <li>Factory Delegates</li> <li>NDLRGEN004 - No injectable parameters</li> <li>NDLRGEN005 - Invalid generic type parameter</li> </ul>"},{"location":"analyzers/NDLRGEN004/","title":"NDLRGEN004: No factory parameters are injectable","text":""},{"location":"analyzers/NDLRGEN004/#diagnostic-info","title":"Diagnostic Info","text":"Property Value ID NDLRGEN004 Category NexusLabs.Needlr.Generators Severity Warning Enabled Yes"},{"location":"analyzers/NDLRGEN004/#description","title":"Description","text":"<p>This warning is raised when a class marked with <code>[GenerateFactory]</code> has a constructor where no parameters are injectable types. The factory will still work, but it provides low value since there are no dependencies to inject - you could simply use <code>new</code> directly.</p>"},{"location":"analyzers/NDLRGEN004/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN004/#code-that-triggers-the-warning","title":"Code that triggers the warning","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n// \u26a0\ufe0f NDLRGEN004: No parameters are injectable, factory provides low value\n[GenerateFactory]\npublic class ConnectionString\n{\n    public ConnectionString(string server, int port, string database)\n    {\n        // All parameters are runtime - nothing to inject\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN004/#how-to-fix","title":"How to fix","text":"<p>Either remove the <code>[GenerateFactory]</code> attribute and use <code>new</code> directly, or add an injectable dependency:</p> <p>Option 1: Remove the attribute and use <code>new</code> <pre><code>// Just use new directly - no factory needed\npublic class ConnectionString\n{\n    public ConnectionString(string server, int port, string database) { }\n}\n\n// Usage\nvar conn = new ConnectionString(\"localhost\", 5432, \"mydb\");\n</code></pre></p> <p>Option 2: Add an injectable dependency <pre><code>[GenerateFactory]\npublic class ConnectionString\n{\n    public ConnectionString(IConfiguration config, string server, int port, string database)\n    {\n        // Now the factory provides value - it injects IConfiguration\n    }\n}\n</code></pre></p>"},{"location":"analyzers/NDLRGEN004/#why-this-matters","title":"Why This Matters","text":"<p>The primary purpose of factory generation is to partition constructor parameters into those that can be auto-injected and those that must be provided at runtime. If there's nothing to inject, the factory is just an extra layer of indirection.</p>"},{"location":"analyzers/NDLRGEN004/#when-to-suppress","title":"When to Suppress","text":"<p>You might intentionally want a factory for a type with no injectable dependencies if: - You want consistent factory patterns across your codebase - You anticipate adding injectable dependencies later - You prefer resolving factories from DI for consistency</p> <pre><code>#pragma warning disable NDLRGEN004\n[GenerateFactory]\npublic class ConnectionString { /* ... */ }\n#pragma warning restore NDLRGEN004\n</code></pre>"},{"location":"analyzers/NDLRGEN004/#see-also","title":"See Also","text":"<ul> <li>Factory Delegates</li> <li>NDLRGEN003 - All parameters injectable</li> <li>NDLRGEN005 - Invalid generic type parameter</li> </ul>"},{"location":"analyzers/NDLRGEN005/","title":"NDLRGEN005: Factory generic type not implemented by class","text":""},{"location":"analyzers/NDLRGEN005/#diagnostic-info","title":"Diagnostic Info","text":"Property Value ID NDLRGEN005 Category NexusLabs.Needlr.Generators Severity Error Enabled Yes"},{"location":"analyzers/NDLRGEN005/#description","title":"Description","text":"<p>This error is raised when a class uses <code>[GenerateFactory&lt;T&gt;]</code> with a type parameter <code>T</code> that the class does not implement. The generic type must be an interface or base class that the decorated class implements or inherits from.</p>"},{"location":"analyzers/NDLRGEN005/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN005/#code-that-triggers-the-error","title":"Code that triggers the error","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\npublic interface IRequestHandler { }\npublic interface IMessageHandler { }\n\n// \u274c NDLRGEN005: MyHandler does not implement IMessageHandler\n[GenerateFactory&lt;IMessageHandler&gt;]\npublic class MyHandler : IRequestHandler\n{\n    public MyHandler(ILogger logger, Guid correlationId) { }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN005/#how-to-fix","title":"How to fix","text":"<p>Use an interface that the class actually implements:</p> <pre><code>// \u2705 Correct - MyHandler implements IRequestHandler\n[GenerateFactory&lt;IRequestHandler&gt;]\npublic class MyHandler : IRequestHandler\n{\n    public MyHandler(ILogger logger, Guid correlationId) { }\n}\n</code></pre> <p>Or implement the interface you want to use:</p> <pre><code>// \u2705 Correct - MyHandler now implements IMessageHandler\n[GenerateFactory&lt;IMessageHandler&gt;]\npublic class MyHandler : IRequestHandler, IMessageHandler\n{\n    public MyHandler(ILogger logger, Guid correlationId) { }\n}\n</code></pre> <p>Or use the non-generic attribute to return the concrete type:</p> <pre><code>// \u2705 Correct - returns concrete MyHandler type\n[GenerateFactory]\npublic class MyHandler : IRequestHandler\n{\n    public MyHandler(ILogger logger, Guid correlationId) { }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN005/#why-this-matters","title":"Why This Matters","text":"<p>The <code>[GenerateFactory&lt;T&gt;]</code> attribute changes the return type of the factory's <code>Create()</code> method from the concrete class to <code>T</code>. If the class doesn't implement <code>T</code>, the generated code would have an invalid cast and fail to compile.</p>"},{"location":"analyzers/NDLRGEN005/#generated-code-comparison","title":"Generated Code Comparison","text":"<p>Non-generic <code>[GenerateFactory]</code>: <pre><code>public interface IMyHandlerFactory\n{\n    MyHandler Create(Guid correlationId);  // Returns concrete type\n}\n</code></pre></p> <p>Generic <code>[GenerateFactory&lt;IRequestHandler&gt;]</code>: <pre><code>public interface IMyHandlerFactory\n{\n    IRequestHandler Create(Guid correlationId);  // Returns interface\n}\n</code></pre></p>"},{"location":"analyzers/NDLRGEN005/#see-also","title":"See Also","text":"<ul> <li>Factory Delegates</li> <li>NDLRGEN003 - All parameters injectable</li> <li>NDLRGEN004 - No injectable parameters</li> </ul>"},{"location":"analyzers/NDLRGEN006/","title":"NDLRGEN006: [OpenDecoratorFor] type argument must be an open generic interface","text":""},{"location":"analyzers/NDLRGEN006/#cause","title":"Cause","text":"<p>The type argument passed to <code>[OpenDecoratorFor]</code> is not an open generic interface (unbound generic type).</p>"},{"location":"analyzers/NDLRGEN006/#rule-description","title":"Rule Description","text":"<p>The <code>[OpenDecoratorFor]</code> attribute is designed to create decorators for all closed implementations of an open generic interface. The type argument must be:</p> <ol> <li>An interface (not a class or struct)</li> <li>An open/unbound generic using the <code>typeof(IInterface&lt;&gt;)</code> syntax</li> </ol> <p>Common mistakes include: - Passing a closed generic type like <code>typeof(IHandler&lt;string&gt;)</code> - Passing a non-generic interface like <code>typeof(IService)</code> - Passing a class instead of an interface</p>"},{"location":"analyzers/NDLRGEN006/#how-to-fix","title":"How to Fix","text":"<p>Use the open generic <code>typeof()</code> syntax with empty angle brackets:</p> <pre><code>// \u274c Wrong - closed generic\n[OpenDecoratorFor(typeof(IHandler&lt;string&gt;))]\n\n// \u274c Wrong - non-generic\n[OpenDecoratorFor(typeof(IService))]\n\n// \u2705 Correct - open generic interface\n[OpenDecoratorFor(typeof(IHandler&lt;&gt;))]\n</code></pre>"},{"location":"analyzers/NDLRGEN006/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN006/#code-with-error","title":"Code with Error","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\npublic interface IHandler&lt;T&gt; { void Handle(T message); }\n\n// NDLRGEN006: Type argument 'IHandler&lt;string&gt;' is not an open generic interface\n[OpenDecoratorFor(typeof(IHandler&lt;string&gt;))]\npublic class LoggingDecorator&lt;T&gt; : IHandler&lt;T&gt;\n{\n    private readonly IHandler&lt;T&gt; _inner;\n    public LoggingDecorator(IHandler&lt;T&gt; inner) =&gt; _inner = inner;\n    public void Handle(T message) =&gt; _inner.Handle(message);\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN006/#fixed-code","title":"Fixed Code","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\npublic interface IHandler&lt;T&gt; { void Handle(T message); }\n\n// \u2705 Using open generic syntax\n[OpenDecoratorFor(typeof(IHandler&lt;&gt;))]\npublic class LoggingDecorator&lt;T&gt; : IHandler&lt;T&gt;\n{\n    private readonly IHandler&lt;T&gt; _inner;\n    public LoggingDecorator(IHandler&lt;T&gt; inner) =&gt; _inner = inner;\n    public void Handle(T message) =&gt; _inner.Handle(message);\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN006/#alternative-approaches","title":"Alternative Approaches","text":"<p>If you want to decorate a specific closed type instead of all implementations:</p> <pre><code>// Use [DecoratorFor&lt;T&gt;] for closed types\n[DecoratorFor&lt;IHandler&lt;string&gt;&gt;]\npublic class StringHandlerDecorator : IHandler&lt;string&gt;\n{\n    private readonly IHandler&lt;string&gt; _inner;\n    public StringHandlerDecorator(IHandler&lt;string&gt; inner) =&gt; _inner = inner;\n    public void Handle(string message) =&gt; _inner.Handle(message);\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN006/#see-also","title":"See Also","text":"<ul> <li>NDLRGEN007 - Decorator class must be an open generic</li> <li>NDLRGEN008 - Decorator must implement the interface</li> <li>Open Generic Decorators Guide</li> </ul>"},{"location":"analyzers/NDLRGEN007/","title":"NDLRGEN007: [OpenDecoratorFor] decorator must be an open generic class","text":""},{"location":"analyzers/NDLRGEN007/#cause","title":"Cause","text":"<p>A class marked with <code>[OpenDecoratorFor(typeof(IInterface&lt;&gt;))]</code> is either: 1. Not a generic class, or 2. Has a different number of type parameters than the interface</p>"},{"location":"analyzers/NDLRGEN007/#rule-description","title":"Rule Description","text":"<p>When using <code>[OpenDecoratorFor]</code>, the decorator class must be an open generic with the same number of type parameters as the interface it decorates. This is because Needlr needs to close both the interface and decorator with the same type arguments at compile time.</p> <p>For example: - <code>IHandler&lt;T&gt;</code> (1 type parameter) \u2192 decorator must have 1 type parameter - <code>IRequestHandler&lt;TRequest, TResponse&gt;</code> (2 type parameters) \u2192 decorator must have 2 type parameters</p>"},{"location":"analyzers/NDLRGEN007/#how-to-fix","title":"How to Fix","text":"<p>Ensure your decorator class: 1. Is a generic class 2. Has the same number of type parameters as the target interface</p> <pre><code>// \u274c Wrong - decorator is not generic\n[OpenDecoratorFor(typeof(IHandler&lt;&gt;))]\npublic class LoggingDecorator : IHandler&lt;string&gt; { }\n\n// \u274c Wrong - arity mismatch (1 vs 2)\n[OpenDecoratorFor(typeof(IRequestHandler&lt;,&gt;))]\npublic class LoggingDecorator&lt;T&gt; : IRequestHandler&lt;T, T&gt; { }\n\n// \u2705 Correct - same arity\n[OpenDecoratorFor(typeof(IHandler&lt;&gt;))]\npublic class LoggingDecorator&lt;T&gt; : IHandler&lt;T&gt; { }\n\n// \u2705 Correct - both have 2 type parameters\n[OpenDecoratorFor(typeof(IRequestHandler&lt;,&gt;))]\npublic class LoggingDecorator&lt;TRequest, TResponse&gt; : IRequestHandler&lt;TRequest, TResponse&gt; { }\n</code></pre>"},{"location":"analyzers/NDLRGEN007/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN007/#code-with-error","title":"Code with Error","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\npublic interface IHandler&lt;T&gt; { void Handle(T message); }\n\n// NDLRGEN007: Class 'LoggingDecorator' must be an open generic class with 1 type parameter(s)\n[OpenDecoratorFor(typeof(IHandler&lt;&gt;))]\npublic class LoggingDecorator : IHandler&lt;string&gt;\n{\n    private readonly IHandler&lt;string&gt; _inner;\n    public LoggingDecorator(IHandler&lt;string&gt; inner) =&gt; _inner = inner;\n    public void Handle(string message) =&gt; _inner.Handle(message);\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN007/#fixed-code","title":"Fixed Code","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\npublic interface IHandler&lt;T&gt; { void Handle(T message); }\n\n// \u2705 Decorator is now generic\n[OpenDecoratorFor(typeof(IHandler&lt;&gt;))]\npublic class LoggingDecorator&lt;T&gt; : IHandler&lt;T&gt;\n{\n    private readonly IHandler&lt;T&gt; _inner;\n    public LoggingDecorator(IHandler&lt;T&gt; inner) =&gt; _inner = inner;\n    public void Handle(T message) =&gt; _inner.Handle(message);\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN007/#alternative-approaches","title":"Alternative Approaches","text":"<p>If you want to create a non-generic decorator for a specific closed type:</p> <pre><code>// Use [DecoratorFor&lt;T&gt;] for closed types\n[DecoratorFor&lt;IHandler&lt;string&gt;&gt;]\npublic class StringHandlerDecorator : IHandler&lt;string&gt;\n{\n    private readonly IHandler&lt;string&gt; _inner;\n    public StringHandlerDecorator(IHandler&lt;string&gt; inner) =&gt; _inner = inner;\n    public void Handle(string message) =&gt; _inner.Handle(message);\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN007/#see-also","title":"See Also","text":"<ul> <li>NDLRGEN006 - Type argument must be an open generic interface</li> <li>NDLRGEN008 - Decorator must implement the interface</li> <li>Open Generic Decorators Guide</li> </ul>"},{"location":"analyzers/NDLRGEN008/","title":"NDLRGEN008: [OpenDecoratorFor] decorator must implement the interface","text":""},{"location":"analyzers/NDLRGEN008/#cause","title":"Cause","text":"<p>A class marked with <code>[OpenDecoratorFor(typeof(IInterface&lt;&gt;))]</code> does not implement the open generic interface specified in the attribute.</p>"},{"location":"analyzers/NDLRGEN008/#rule-description","title":"Rule Description","text":"<p>For the decorator pattern to work, the decorator class must implement the same interface as the services it wraps. This allows the decorator to be substituted for the original service in the DI container.</p> <p>When using <code>[OpenDecoratorFor(typeof(IHandler&lt;&gt;))]</code>, your decorator class must implement <code>IHandler&lt;T&gt;</code>.</p>"},{"location":"analyzers/NDLRGEN008/#how-to-fix","title":"How to Fix","text":"<p>Add the interface implementation to your decorator class:</p> <pre><code>// \u274c Wrong - doesn't implement IHandler&lt;T&gt;\n[OpenDecoratorFor(typeof(IHandler&lt;&gt;))]\npublic class LoggingDecorator&lt;T&gt;\n{\n    // Missing : IHandler&lt;T&gt;\n}\n\n// \u2705 Correct - implements IHandler&lt;T&gt;\n[OpenDecoratorFor(typeof(IHandler&lt;&gt;))]\npublic class LoggingDecorator&lt;T&gt; : IHandler&lt;T&gt;\n{\n    private readonly IHandler&lt;T&gt; _inner;\n    public LoggingDecorator(IHandler&lt;T&gt; inner) =&gt; _inner = inner;\n    public void Handle(T message) =&gt; _inner.Handle(message);\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN008/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN008/#code-with-error","title":"Code with Error","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\npublic interface IHandler&lt;T&gt; { void Handle(T message); }\n\n// NDLRGEN008: Class 'LoggingDecorator' has [OpenDecoratorFor(IHandler&lt;&gt;)] \n//             but does not implement 'IHandler&lt;&gt;'\n[OpenDecoratorFor(typeof(IHandler&lt;&gt;))]\npublic class LoggingDecorator&lt;T&gt;\n{\n    private readonly IHandler&lt;T&gt; _inner;\n\n    public LoggingDecorator(IHandler&lt;T&gt; inner) =&gt; _inner = inner;\n\n    public void Handle(T message)\n    {\n        Console.WriteLine(\"Logging...\");\n        _inner.Handle(message);\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN008/#fixed-code","title":"Fixed Code","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\npublic interface IHandler&lt;T&gt; { void Handle(T message); }\n\n// \u2705 Now implements IHandler&lt;T&gt;\n[OpenDecoratorFor(typeof(IHandler&lt;&gt;))]\npublic class LoggingDecorator&lt;T&gt; : IHandler&lt;T&gt;  // Added interface\n{\n    private readonly IHandler&lt;T&gt; _inner;\n\n    public LoggingDecorator(IHandler&lt;T&gt; inner) =&gt; _inner = inner;\n\n    public void Handle(T message)\n    {\n        Console.WriteLine(\"Logging...\");\n        _inner.Handle(message);\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN008/#why-this-matters","title":"Why This Matters","text":"<p>The decorator pattern relies on polymorphism - the decorator must be usable wherever the original interface is expected:</p> <pre><code>IHandler&lt;Order&gt; handler = new OrderHandler();\nIHandler&lt;Order&gt; decorated = new LoggingDecorator&lt;Order&gt;(handler);\n\n// The container resolves IHandler&lt;Order&gt; \u2192 LoggingDecorator&lt;Order&gt;\n// LoggingDecorator&lt;Order&gt; wraps the original OrderHandler\n</code></pre> <p>If the decorator doesn't implement the interface, this substitution is impossible.</p>"},{"location":"analyzers/NDLRGEN008/#see-also","title":"See Also","text":"<ul> <li>NDLRGEN006 - Type argument must be an open generic interface</li> <li>NDLRGEN007 - Decorator class must be an open generic</li> <li>Open Generic Decorators Guide</li> </ul>"},{"location":"analyzers/NDLRGEN014/","title":"NDLRGEN014: Validator type has no validation method","text":""},{"location":"analyzers/NDLRGEN014/#cause","title":"Cause","text":"<p>A type specified in <code>[Options(Validator = typeof(...))]</code> does not have a valid validation method.</p>"},{"location":"analyzers/NDLRGEN014/#rule-description","title":"Rule Description","text":"<p>When you specify a <code>Validator</code> type on the <code>[Options]</code> attribute, that type must have a way to validate the options. The validator must either:</p> <ol> <li>Implement <code>IOptionsValidator&lt;T&gt;</code> (from <code>NexusLabs.Needlr.Generators</code>)</li> <li>Have a <code>Validate(TOptions)</code> method that returns <code>IEnumerable&lt;ValidationError&gt;</code> or <code>IEnumerable&lt;string&gt;</code></li> </ol>"},{"location":"analyzers/NDLRGEN014/#how-to-fix","title":"How to Fix","text":"<p>Add a validation method to your validator type:</p> <pre><code>// \u274c Wrong - no validation method\npublic class MyOptionsValidator\n{\n    // Missing Validate method\n}\n\n// \u2705 Option 1: Implement IOptionsValidator&lt;T&gt;\npublic class MyOptionsValidator : IOptionsValidator&lt;MyOptions&gt;\n{\n    public IEnumerable&lt;ValidationError&gt; Validate(MyOptions options)\n    {\n        if (string.IsNullOrEmpty(options.ApiKey))\n            yield return \"ApiKey is required\";\n    }\n}\n\n// \u2705 Option 2: Add a Validate method with correct signature\npublic class MyOptionsValidator\n{\n    public IEnumerable&lt;string&gt; Validate(MyOptions options)\n    {\n        if (string.IsNullOrEmpty(options.ApiKey))\n            yield return \"ApiKey is required\";\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN014/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN014/#code-with-error","title":"Code with Error","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n[Options(Validator = typeof(StripeOptionsValidator), ValidateOnStart = true)]\npublic class StripeOptions\n{\n    public string ApiKey { get; set; } = \"\";\n}\n\n// NDLRGEN014: Validator type 'StripeOptionsValidator' must have a Validate method\npublic class StripeOptionsValidator\n{\n    // No validation method!\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN014/#fixed-code","title":"Fixed Code","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n[Options(Validator = typeof(StripeOptionsValidator), ValidateOnStart = true)]\npublic class StripeOptions\n{\n    public string ApiKey { get; set; } = \"\";\n}\n\npublic class StripeOptionsValidator : IOptionsValidator&lt;StripeOptions&gt;\n{\n    public IEnumerable&lt;ValidationError&gt; Validate(StripeOptions options)\n    {\n        if (!options.ApiKey.StartsWith(\"sk_\"))\n            yield return \"ApiKey must start with 'sk_'\";\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN014/#valid-validation-method-signatures","title":"Valid Validation Method Signatures","text":"<p>The following signatures are recognized:</p> <pre><code>// Instance method on external validator\nIEnumerable&lt;ValidationError&gt; Validate(TOptions options)\nIEnumerable&lt;string&gt; Validate(TOptions options)\n\n// Static method on external validator\nstatic IEnumerable&lt;ValidationError&gt; Validate(TOptions options)\nstatic IEnumerable&lt;string&gt; Validate(TOptions options)\n</code></pre>"},{"location":"analyzers/NDLRGEN014/#see-also","title":"See Also","text":"<ul> <li>NDLRGEN015 - Validator type mismatch</li> <li>NDLRGEN016 - Validation method not found</li> <li>NDLRGEN017 - Validation method has wrong signature</li> <li>Options Documentation</li> </ul>"},{"location":"analyzers/NDLRGEN015/","title":"NDLRGEN015: Validator type mismatch","text":""},{"location":"analyzers/NDLRGEN015/#cause","title":"Cause","text":"<p>A validator's generic type parameter doesn't match the options type it's applied to.</p>"},{"location":"analyzers/NDLRGEN015/#rule-description","title":"Rule Description","text":"<p>When using <code>[Options(Validator = typeof(SomeValidator))]</code>, the validator must be designed to validate the same type as the options class. If you have <code>IOptionsValidator&lt;DatabaseOptions&gt;</code> but apply it to <code>CacheOptions</code>, this error is raised.</p>"},{"location":"analyzers/NDLRGEN015/#how-to-fix","title":"How to Fix","text":"<p>Ensure the validator is for the correct options type:</p> <pre><code>// \u274c Wrong - validator is for DatabaseOptions, not CacheOptions\n[Options(Validator = typeof(DatabaseOptionsValidator), ValidateOnStart = true)]\npublic class CacheOptions  // Mismatch!\n{\n    public int TimeoutSeconds { get; set; }\n}\n\npublic class DatabaseOptionsValidator : IOptionsValidator&lt;DatabaseOptions&gt;\n{\n    public IEnumerable&lt;ValidationError&gt; Validate(DatabaseOptions options) { ... }\n}\n\n// \u2705 Correct - validator matches options type\n[Options(Validator = typeof(CacheOptionsValidator), ValidateOnStart = true)]\npublic class CacheOptions\n{\n    public int TimeoutSeconds { get; set; }\n}\n\npublic class CacheOptionsValidator : IOptionsValidator&lt;CacheOptions&gt;\n{\n    public IEnumerable&lt;ValidationError&gt; Validate(CacheOptions options) { ... }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN015/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN015/#code-with-error","title":"Code with Error","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n// NDLRGEN015: Validator 'PaymentValidator' validates 'PaymentOptions' \n//             but is applied to options type 'ShippingOptions'\n[Options(Validator = typeof(PaymentValidator), ValidateOnStart = true)]\npublic class ShippingOptions\n{\n    public string Carrier { get; set; } = \"\";\n}\n\npublic class PaymentValidator : IOptionsValidator&lt;PaymentOptions&gt;\n{\n    public IEnumerable&lt;ValidationError&gt; Validate(PaymentOptions options)\n    {\n        // This validates PaymentOptions, not ShippingOptions!\n        yield break;\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN015/#fixed-code","title":"Fixed Code","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n[Options(Validator = typeof(ShippingValidator), ValidateOnStart = true)]\npublic class ShippingOptions\n{\n    public string Carrier { get; set; } = \"\";\n}\n\n// \u2705 Validator now matches the options type\npublic class ShippingValidator : IOptionsValidator&lt;ShippingOptions&gt;\n{\n    public IEnumerable&lt;ValidationError&gt; Validate(ShippingOptions options)\n    {\n        if (string.IsNullOrEmpty(options.Carrier))\n            yield return \"Carrier is required\";\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN015/#common-causes","title":"Common Causes","text":"<ol> <li>Copy-paste error - Copied validation setup from another options class</li> <li>Refactoring - Renamed options class but forgot to update validator</li> <li>Wrong validator - Selected wrong validator from IntelliSense</li> </ol>"},{"location":"analyzers/NDLRGEN015/#see-also","title":"See Also","text":"<ul> <li>NDLRGEN014 - Validator type has no validation method</li> <li>NDLRGEN016 - Validation method not found</li> <li>Options Documentation</li> </ul>"},{"location":"analyzers/NDLRGEN016/","title":"NDLRGEN016: Validation method not found","text":""},{"location":"analyzers/NDLRGEN016/#cause","title":"Cause","text":"<p>The <code>ValidateMethod</code> specified in <code>[Options]</code> does not exist on the target type.</p>"},{"location":"analyzers/NDLRGEN016/#rule-description","title":"Rule Description","text":"<p>When you use <code>[Options(ValidateMethod = \"MethodName\")]</code>, the generator looks for a method with that name on: 1. The options class itself (if no <code>Validator</code> is specified) 2. The validator class (if <code>Validator</code> is specified)</p> <p>If the method doesn't exist, this error is raised.</p>"},{"location":"analyzers/NDLRGEN016/#how-to-fix","title":"How to Fix","text":"<p>Add the method with the correct name:</p> <pre><code>// \u274c Wrong - method name doesn't match\n[Options(ValidateMethod = \"ValidateSettings\", ValidateOnStart = true)]\npublic class AppSettings\n{\n    public string Name { get; set; } = \"\";\n\n    // Method is named \"Validate\", not \"ValidateSettings\"\n    public IEnumerable&lt;ValidationError&gt; Validate() { ... }\n}\n\n// \u2705 Correct - method name matches\n[Options(ValidateMethod = \"ValidateSettings\", ValidateOnStart = true)]\npublic class AppSettings\n{\n    public string Name { get; set; } = \"\";\n\n    public IEnumerable&lt;ValidationError&gt; ValidateSettings()\n    {\n        if (string.IsNullOrEmpty(Name))\n            yield return \"Name is required\";\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN016/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN016/#code-with-error","title":"Code with Error","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n// NDLRGEN016: Method 'CheckValidity' not found on type 'DatabaseOptions'\n[Options(ValidateMethod = \"CheckValidity\", ValidateOnStart = true)]\npublic class DatabaseOptions\n{\n    public string ConnectionString { get; set; } = \"\";\n\n    // No method named \"CheckValidity\" exists!\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN016/#fixed-code","title":"Fixed Code","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n[Options(ValidateMethod = \"CheckValidity\", ValidateOnStart = true)]\npublic class DatabaseOptions\n{\n    public string ConnectionString { get; set; } = \"\";\n\n    // \u2705 Added the method with matching name\n    public IEnumerable&lt;ValidationError&gt; CheckValidity()\n    {\n        if (string.IsNullOrEmpty(ConnectionString))\n            yield return \"ConnectionString is required\";\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN016/#using-convention-based-naming","title":"Using Convention-Based Naming","text":"<p>If you name your method <code>Validate</code>, you don't need to specify <code>ValidateMethod</code>:</p> <pre><code>// No need for ValidateMethod - \"Validate\" is discovered by convention\n[Options(ValidateOnStart = true)]\npublic class CacheOptions\n{\n    public int TimeoutSeconds { get; set; }\n\n    // Convention: method named \"Validate\" is auto-discovered\n    public IEnumerable&lt;ValidationError&gt; Validate()\n    {\n        if (TimeoutSeconds &lt;= 0)\n            yield return \"TimeoutSeconds must be positive\";\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN016/#see-also","title":"See Also","text":"<ul> <li>NDLRGEN014 - Validator type has no validation method</li> <li>NDLRGEN017 - Validation method has wrong signature</li> <li>Options Documentation</li> </ul>"},{"location":"analyzers/NDLRGEN017/","title":"NDLRGEN017: Validation method has wrong signature","text":""},{"location":"analyzers/NDLRGEN017/#cause","title":"Cause","text":"<p>A validation method exists but has an incorrect signature.</p>"},{"location":"analyzers/NDLRGEN017/#rule-description","title":"Rule Description","text":"<p>Validation methods must follow specific signatures to be recognized by the generator:</p> <p>For methods on the options class itself: <pre><code>IEnumerable&lt;ValidationError&gt; Validate()\nIEnumerable&lt;string&gt; Validate()\n</code></pre></p> <p>For methods on an external validator: <pre><code>IEnumerable&lt;ValidationError&gt; Validate(TOptions options)\nIEnumerable&lt;string&gt; Validate(TOptions options)\n</code></pre></p> <p>If your method doesn't match one of these patterns, this error is raised.</p>"},{"location":"analyzers/NDLRGEN017/#how-to-fix","title":"How to Fix","text":"<p>Correct the method signature:</p> <pre><code>// \u274c Wrong - returns void instead of IEnumerable\n[Options(ValidateOnStart = true)]\npublic class ApiOptions\n{\n    public string Key { get; set; } = \"\";\n\n    public void Validate()  // Wrong return type!\n    {\n        if (string.IsNullOrEmpty(Key))\n            throw new Exception(\"Key required\");\n    }\n}\n\n// \u2705 Correct - returns IEnumerable&lt;ValidationError&gt;\n[Options(ValidateOnStart = true)]\npublic class ApiOptions\n{\n    public string Key { get; set; } = \"\";\n\n    public IEnumerable&lt;ValidationError&gt; Validate()\n    {\n        if (string.IsNullOrEmpty(Key))\n            yield return \"Key is required\";\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN017/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN017/#code-with-error","title":"Code with Error","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n// NDLRGEN017: Method 'Validate' on type 'EmailOptions' has wrong signature\n[Options(ValidateOnStart = true)]\npublic class EmailOptions\n{\n    public string SmtpHost { get; set; } = \"\";\n\n    // Wrong: takes a parameter (should be parameterless for instance methods)\n    public IEnumerable&lt;string&gt; Validate(bool strict)\n    {\n        if (string.IsNullOrEmpty(SmtpHost))\n            yield return \"SmtpHost required\";\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN017/#fixed-code","title":"Fixed Code","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n[Options(ValidateOnStart = true)]\npublic class EmailOptions\n{\n    public string SmtpHost { get; set; } = \"\";\n\n    // \u2705 Correct: no parameters for instance method on options class\n    public IEnumerable&lt;string&gt; Validate()\n    {\n        if (string.IsNullOrEmpty(SmtpHost))\n            yield return \"SmtpHost required\";\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN017/#valid-signatures","title":"Valid Signatures","text":""},{"location":"analyzers/NDLRGEN017/#on-options-class-instance-method-no-parameters","title":"On Options Class (instance method, no parameters)","text":"<pre><code>public IEnumerable&lt;ValidationError&gt; Validate()\npublic IEnumerable&lt;string&gt; Validate()\n</code></pre>"},{"location":"analyzers/NDLRGEN017/#on-external-validator-takes-options-as-parameter","title":"On External Validator (takes options as parameter)","text":"<pre><code>// Instance method\npublic IEnumerable&lt;ValidationError&gt; Validate(TOptions options)\npublic IEnumerable&lt;string&gt; Validate(TOptions options)\n\n// Static method\npublic static IEnumerable&lt;ValidationError&gt; Validate(TOptions options)\npublic static IEnumerable&lt;string&gt; Validate(TOptions options)\n</code></pre>"},{"location":"analyzers/NDLRGEN017/#common-mistakes","title":"Common Mistakes","text":"Wrong Signature Problem Correct Signature <code>void Validate()</code> Wrong return type <code>IEnumerable&lt;ValidationError&gt; Validate()</code> <code>bool Validate()</code> Wrong return type <code>IEnumerable&lt;string&gt; Validate()</code> <code>List&lt;string&gt; Validate()</code> Must be IEnumerable <code>IEnumerable&lt;string&gt; Validate()</code> <code>IEnumerable&lt;ValidationError&gt; Validate(bool flag)</code> Extra parameter <code>IEnumerable&lt;ValidationError&gt; Validate()</code>"},{"location":"analyzers/NDLRGEN017/#see-also","title":"See Also","text":"<ul> <li>NDLRGEN014 - Validator type has no validation method</li> <li>NDLRGEN016 - Validation method not found</li> <li>Options Documentation</li> </ul>"},{"location":"analyzers/NDLRGEN018/","title":"NDLRGEN018: Validator won't run","text":""},{"location":"analyzers/NDLRGEN018/#cause","title":"Cause","text":"<p>A <code>Validator</code> is specified but <code>ValidateOnStart</code> is <code>false</code>, so the validator will never be invoked.</p>"},{"location":"analyzers/NDLRGEN018/#rule-description","title":"Rule Description","text":"<p>When you specify <code>[Options(Validator = typeof(...))]</code> but don't set <code>ValidateOnStart = true</code>, the validator is registered but never actually called. This is likely a configuration mistake.</p> <p>This is a warning because the code is technically valid, but probably not what you intended.</p>"},{"location":"analyzers/NDLRGEN018/#how-to-fix","title":"How to Fix","text":"<p>Either enable validation or remove the validator:</p> <pre><code>// \u26a0\ufe0f Warning - validator specified but won't run\n[Options(Validator = typeof(MyValidator))]  // ValidateOnStart defaults to false\npublic class MyOptions { }\n\n// \u2705 Option 1: Enable ValidateOnStart\n[Options(Validator = typeof(MyValidator), ValidateOnStart = true)]\npublic class MyOptions { }\n\n// \u2705 Option 2: Remove the unused Validator\n[Options]\npublic class MyOptions { }\n</code></pre>"},{"location":"analyzers/NDLRGEN018/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN018/#code-with-warning","title":"Code with Warning","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n// NDLRGEN018: Validator 'PaymentOptionsValidator' will not run \n//             because ValidateOnStart is false\n[Options(Validator = typeof(PaymentOptionsValidator))]\npublic class PaymentOptions\n{\n    public string MerchantId { get; set; } = \"\";\n}\n\npublic class PaymentOptionsValidator : IOptionsValidator&lt;PaymentOptions&gt;\n{\n    public IEnumerable&lt;ValidationError&gt; Validate(PaymentOptions options)\n    {\n        if (string.IsNullOrEmpty(options.MerchantId))\n            yield return \"MerchantId is required\";\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN018/#fixed-code","title":"Fixed Code","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n// \u2705 ValidateOnStart = true enables the validator\n[Options(Validator = typeof(PaymentOptionsValidator), ValidateOnStart = true)]\npublic class PaymentOptions\n{\n    public string MerchantId { get; set; } = \"\";\n}\n\npublic class PaymentOptionsValidator : IOptionsValidator&lt;PaymentOptions&gt;\n{\n    public IEnumerable&lt;ValidationError&gt; Validate(PaymentOptions options)\n    {\n        if (string.IsNullOrEmpty(options.MerchantId))\n            yield return \"MerchantId is required\";\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN018/#why-this-warning-exists","title":"Why This Warning Exists","text":"<p>Specifying a validator without enabling validation is almost always a mistake:</p> <ul> <li>You wrote validation logic that will never execute</li> <li>Your application won't fail fast on invalid configuration</li> <li>Future maintainers may assume validation is happening</li> </ul>"},{"location":"analyzers/NDLRGEN018/#suppressing-the-warning","title":"Suppressing the Warning","text":"<p>If you intentionally want to specify a validator without running it at startup (e.g., for manual validation later), suppress the warning:</p> <pre><code>#pragma warning disable NDLRGEN018\n[Options(Validator = typeof(MyValidator))]\npublic class MyOptions { }\n#pragma warning restore NDLRGEN018\n</code></pre> <p>Or in <code>.editorconfig</code>:</p> <pre><code>[*.cs]\ndotnet_diagnostic.NDLRGEN018.severity = none\n</code></pre>"},{"location":"analyzers/NDLRGEN018/#see-also","title":"See Also","text":"<ul> <li>NDLRGEN019 - Validation method won't run</li> <li>NDLRGEN014 - Validator type has no validation method</li> <li>Options Documentation</li> </ul>"},{"location":"analyzers/NDLRGEN019/","title":"NDLRGEN019: Validation method won't run","text":""},{"location":"analyzers/NDLRGEN019/#cause","title":"Cause","text":"<p>A <code>ValidateMethod</code> is specified but <code>ValidateOnStart</code> is <code>false</code>, so the validation method will never be invoked.</p>"},{"location":"analyzers/NDLRGEN019/#rule-description","title":"Rule Description","text":"<p>When you specify <code>[Options(ValidateMethod = \"...\")]</code> but don't set <code>ValidateOnStart = true</code>, the validation method exists but is never called. This is likely a configuration mistake.</p> <p>This is a warning because the code is technically valid, but probably not what you intended.</p>"},{"location":"analyzers/NDLRGEN019/#how-to-fix","title":"How to Fix","text":"<p>Either enable validation or remove the ValidateMethod:</p> <pre><code>// \u26a0\ufe0f Warning - method specified but won't run\n[Options(ValidateMethod = \"CheckConfig\")]  // ValidateOnStart defaults to false\npublic class MyOptions\n{\n    public IEnumerable&lt;ValidationError&gt; CheckConfig() { ... }\n}\n\n// \u2705 Option 1: Enable ValidateOnStart\n[Options(ValidateMethod = \"CheckConfig\", ValidateOnStart = true)]\npublic class MyOptions\n{\n    public IEnumerable&lt;ValidationError&gt; CheckConfig() { ... }\n}\n\n// \u2705 Option 2: Remove the unused ValidateMethod\n[Options]\npublic class MyOptions\n{\n    // Method can stay but won't be auto-invoked\n    public IEnumerable&lt;ValidationError&gt; CheckConfig() { ... }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN019/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN019/#code-with-warning","title":"Code with Warning","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n// NDLRGEN019: ValidateMethod 'CheckSettings' will not run \n//             because ValidateOnStart is false\n[Options(ValidateMethod = \"CheckSettings\")]\npublic class FeatureFlags\n{\n    public bool EnableBeta { get; set; }\n    public int MaxUsers { get; set; }\n\n    public IEnumerable&lt;ValidationError&gt; CheckSettings()\n    {\n        if (EnableBeta &amp;&amp; MaxUsers &gt; 100)\n            yield return \"Beta features limited to 100 users\";\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN019/#fixed-code","title":"Fixed Code","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n// \u2705 ValidateOnStart = true enables the validation method\n[Options(ValidateMethod = \"CheckSettings\", ValidateOnStart = true)]\npublic class FeatureFlags\n{\n    public bool EnableBeta { get; set; }\n    public int MaxUsers { get; set; }\n\n    public IEnumerable&lt;ValidationError&gt; CheckSettings()\n    {\n        if (EnableBeta &amp;&amp; MaxUsers &gt; 100)\n            yield return \"Beta features limited to 100 users\";\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN019/#using-convention-based-naming","title":"Using Convention-Based Naming","text":"<p>If you name your method <code>Validate</code> and set <code>ValidateOnStart = true</code>, you don't need to specify <code>ValidateMethod</code>:</p> <pre><code>// Convention: \"Validate\" method is auto-discovered when ValidateOnStart = true\n[Options(ValidateOnStart = true)]\npublic class CacheOptions\n{\n    public int TimeoutSeconds { get; set; }\n\n    public IEnumerable&lt;ValidationError&gt; Validate()\n    {\n        if (TimeoutSeconds &lt;= 0)\n            yield return \"TimeoutSeconds must be positive\";\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN019/#suppressing-the-warning","title":"Suppressing the Warning","text":"<p>If you intentionally want to specify a validation method without running it at startup:</p> <pre><code>#pragma warning disable NDLRGEN019\n[Options(ValidateMethod = \"CheckConfig\")]\npublic class MyOptions { }\n#pragma warning restore NDLRGEN019\n</code></pre>"},{"location":"analyzers/NDLRGEN019/#see-also","title":"See Also","text":"<ul> <li>NDLRGEN018 - Validator won't run</li> <li>NDLRGEN016 - Validation method not found</li> <li>Options Documentation</li> </ul>"},{"location":"analyzers/NDLRGEN020/","title":"NDLRGEN020: [Options] is not compatible with AOT","text":""},{"location":"analyzers/NDLRGEN020/#cause","title":"Cause","text":"<p>A class has the <code>[Options]</code> attribute but is in a project with <code>PublishAot=true</code> or <code>IsAotCompatible=true</code>.</p>"},{"location":"analyzers/NDLRGEN020/#rule-description","title":"Rule Description","text":"<p>The <code>[Options]</code> attribute generates code that calls Microsoft's configuration binding APIs: - <code>Configure&lt;T&gt;()</code> - <code>BindConfiguration()</code> - <code>ValidateDataAnnotations()</code></p> <p>These APIs use reflection to bind configuration values to properties at runtime. They are marked with <code>[RequiresDynamicCode]</code> and <code>[RequiresUnreferencedCode]</code>, making them incompatible with: - Native AOT - No JIT compiler to generate code at runtime - Trimming - Reflection targets may be trimmed away</p>"},{"location":"analyzers/NDLRGEN020/#how-to-fix","title":"How to Fix","text":"<p>You have two options:</p>"},{"location":"analyzers/NDLRGEN020/#option-1-remove-options-from-aot-projects","title":"Option 1: Remove [Options] from AOT Projects","text":"<p>If you're building a plugin or library that must be AOT-compatible, don't use <code>[Options]</code>:</p> <pre><code>// \u274c Won't work in AOT\n[Options]\npublic class CacheSettings\n{\n    public int TimeoutSeconds { get; set; }\n}\n\n// \u2705 Manual configuration binding\npublic class CacheSettings\n{\n    public int TimeoutSeconds { get; set; }\n\n    public static CacheSettings FromConfiguration(IConfiguration config)\n    {\n        return new CacheSettings\n        {\n            TimeoutSeconds = config.GetValue&lt;int&gt;(\"Cache:TimeoutSeconds\")\n        };\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN020/#option-2-disable-aot-for-the-project","title":"Option 2: Disable AOT for the Project","text":"<p>If you need <code>[Options]</code> functionality, disable AOT:</p> <pre><code>&lt;PropertyGroup&gt;\n  &lt;!-- Remove or set to false --&gt;\n  &lt;PublishAot&gt;false&lt;/PublishAot&gt;\n  &lt;IsAotCompatible&gt;false&lt;/IsAotCompatible&gt;\n&lt;/PropertyGroup&gt;\n</code></pre>"},{"location":"analyzers/NDLRGEN020/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN020/#code-with-error","title":"Code with Error","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n// In a project with &lt;PublishAot&gt;true&lt;/PublishAot&gt;\n\n// NDLRGEN020: Type 'DatabaseOptions' has [Options] attribute but is in an \n//             AOT-enabled project\n[Options]\npublic class DatabaseOptions\n{\n    public string ConnectionString { get; set; } = \"\";\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN020/#fixed-code-manual-binding","title":"Fixed Code (Manual Binding)","text":"<pre><code>// Remove [Options] and bind manually\npublic class DatabaseOptions\n{\n    public string ConnectionString { get; set; } = \"\";\n}\n\n// In your startup code:\npublic static class ServiceRegistration\n{\n    public static void RegisterOptions(IServiceCollection services, IConfiguration config)\n    {\n        var dbOptions = new DatabaseOptions\n        {\n            ConnectionString = config[\"Database:ConnectionString\"] ?? \"\"\n        };\n        services.AddSingleton(Microsoft.Extensions.Options.Options.Create(dbOptions));\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN020/#why-this-limitation-exists","title":"Why This Limitation Exists","text":"<p>Microsoft's Configuration Binding Generator (<code>&lt;EnableConfigurationBindingGenerator&gt;</code>) uses C# interceptors to replace reflection-based calls with compile-time generated code. However:</p> <ol> <li>Interceptors can only intercept calls in hand-written source code</li> <li>Needlr's <code>[Options]</code> generates the <code>Configure&lt;T&gt;()</code> calls in <code>TypeRegistry.g.cs</code></li> <li>One source generator cannot intercept another's output</li> </ol> <p>Therefore, the reflection-based calls cannot be replaced with AOT-safe alternatives.</p>"},{"location":"analyzers/NDLRGEN020/#future-considerations","title":"Future Considerations","text":"<p>A future version of Needlr may generate AOT-compatible binding code directly, similar to Microsoft's approach. Until then, manual configuration binding is required for AOT projects.</p>"},{"location":"analyzers/NDLRGEN020/#affected-project-properties","title":"Affected Project Properties","text":"<p>This error is triggered when either of these MSBuild properties is <code>true</code>:</p> Property Purpose <code>PublishAot</code> Enables Native AOT publishing <code>IsAotCompatible</code> Marks a library as AOT-compatible"},{"location":"analyzers/NDLRGEN020/#see-also","title":"See Also","text":"<ul> <li>Microsoft Docs: Native AOT Deployment</li> <li>Microsoft Docs: Configuration Binding Generator</li> <li>Options Documentation</li> </ul>"},{"location":"analyzers/NDLRGEN021/","title":"NDLRGEN021: Positional record must be partial for [Options]","text":""},{"location":"analyzers/NDLRGEN021/#cause","title":"Cause","text":"<p>A positional record (a record with primary constructor parameters) has the <code>[Options]</code> attribute but is not declared as <code>partial</code>.</p>"},{"location":"analyzers/NDLRGEN021/#rule-description","title":"Rule Description","text":"<p>Positional records like <code>record Foo(string Bar, int Baz)</code> do not have parameterless constructors. Microsoft's configuration binder uses <code>Activator.CreateInstance()</code> to instantiate options types, which requires a parameterless constructor.</p> <p>When a positional record is declared as <code>partial</code>, Needlr's source generator emits a parameterless constructor that chains to the primary constructor with default values. This enables configuration binding to work.</p> <p>Non-partial records cannot be extended by source generators, so configuration binding will fail at runtime with a <code>MissingMethodException</code>.</p>"},{"location":"analyzers/NDLRGEN021/#how-to-fix","title":"How to Fix","text":"<p>Add the <code>partial</code> modifier to the positional record:</p> <pre><code>// \u274c Before: Will fail at runtime\n[Options(\"Database\")]\npublic record DatabaseConfig(string Host, int Port);\n\n// \u2705 After: Generator creates parameterless constructor\n[Options(\"Database\")]\npublic partial record DatabaseConfig(string Host, int Port);\n</code></pre> <p>Alternatively, use a record with init-only properties instead of positional parameters:</p> <pre><code>// \u2705 Alternative: Init-only properties have parameterless constructor\n[Options(\"Database\")]\npublic record DatabaseConfig\n{\n    public string Host { get; init; } = \"\";\n    public int Port { get; init; } = 5432;\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN021/#generated-code","title":"Generated Code","text":"<p>For a partial positional record, Needlr generates:</p> <pre><code>// User code:\n[Options(\"Redis\")]\npublic partial record RedisConfig(string Host, int Port);\n\n// Generated code (OptionsConstructors.g.cs):\npublic partial record RedisConfig\n{\n    public RedisConfig() : this(string.Empty, default) { }\n}\n</code></pre> <p>The generated constructor uses: - <code>string.Empty</code> for string parameters - <code>default</code> for value types (0 for int, false for bool, etc.) - <code>default!</code> for other reference types</p>"},{"location":"analyzers/NDLRGEN021/#when-to-suppress","title":"When to Suppress","text":"<p>Suppress this warning only if you are manually providing a parameterless constructor or if you are not using the record with configuration binding:</p> <pre><code>#pragma warning disable NDLRGEN021\n[Options(\"Custom\")]\npublic record CustomConfig(string Value)\n{\n    public CustomConfig() : this(\"default-value\") { }\n}\n#pragma warning restore NDLRGEN021\n</code></pre>"},{"location":"analyzers/NDLRGEN021/#see-also","title":"See Also","text":"<ul> <li>Options Binding</li> <li>NDLRGEN020 - Options not compatible with AOT</li> </ul>"},{"location":"analyzers/NDLRGEN022/","title":"NDLRGEN022: Disposable captive dependency detected","text":"Property Value Diagnostic ID NDLRGEN022 Severity Error Category NexusLabs.Needlr.Generators Default Enabled"},{"location":"analyzers/NDLRGEN022/#summary","title":"Summary","text":"<p>A longer-lived service captures a shorter-lived service that implements <code>IDisposable</code> or <code>IAsyncDisposable</code>. This is a \"captive dependency\" anti-pattern that can cause <code>ObjectDisposedException</code> at runtime.</p>"},{"location":"analyzers/NDLRGEN022/#description","title":"Description","text":"<p>When a Singleton or Scoped service has a constructor dependency on a service with a shorter lifetime (Scoped or Transient respectively) that implements <code>IDisposable</code>, the disposable will be disposed when its scope ends while the consuming service continues to hold a reference.</p> <p>This diagnostic uses Needlr's inferred lifetimes from convention-based discovery, not just explicit attributes. This means it works for the majority of Needlr users who rely on automatic lifetime inference.</p>"},{"location":"analyzers/NDLRGEN022/#lifetime-violations-detected","title":"Lifetime Violations Detected","text":"Consumer Lifetime Dependency Lifetime Violation? Singleton Scoped \u2705 Yes Singleton Transient \u2705 Yes Scoped Transient \u2705 Yes Singleton Singleton \u274c No Scoped Scoped \u274c No Scoped Singleton \u274c No Transient Any \u274c No"},{"location":"analyzers/NDLRGEN022/#related-diagnostic","title":"Related Diagnostic","text":"<p>NDLRCOR012 is a standalone Roslyn analyzer that performs the same check but only when both types have explicit lifetime attributes (<code>[Singleton]</code>, <code>[Scoped]</code>, <code>[Transient]</code>). NDLRGEN022 is more comprehensive because it uses Needlr's inferred lifetimes.</p>"},{"location":"analyzers/NDLRGEN022/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN022/#violation","title":"\u274c Violation","text":"<pre><code>[Scoped]\npublic class DbContext : IDisposable\n{\n    public void Dispose() { }\n}\n\n[Singleton]\npublic class CacheService\n{\n    private readonly DbContext _context;\n\n    // NDLRGEN022: CacheService (Singleton) depends on DbContext (Scoped)\n    // which implements IDisposable\n    public CacheService(DbContext context) =&gt; _context = context;\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN022/#fix-use-factory-pattern","title":"\u2705 Fix: Use Factory Pattern","text":"<pre><code>[Singleton]\npublic class CacheService\n{\n    private readonly Func&lt;DbContext&gt; _contextFactory;\n\n    public CacheService(Func&lt;DbContext&gt; contextFactory) =&gt; _contextFactory = contextFactory;\n\n    public void DoWork()\n    {\n        using var context = _contextFactory();\n        // Use context within its proper scope\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN022/#fix-use-iservicescopefactory","title":"\u2705 Fix: Use IServiceScopeFactory","text":"<pre><code>[Singleton]\npublic class CacheService\n{\n    private readonly IServiceScopeFactory _scopeFactory;\n\n    public CacheService(IServiceScopeFactory scopeFactory) =&gt; _scopeFactory = scopeFactory;\n\n    public void DoWork()\n    {\n        using var scope = _scopeFactory.CreateScope();\n        var context = scope.ServiceProvider.GetRequiredService&lt;DbContext&gt;();\n        // Use context within its proper scope\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN022/#safe-patterns-not-flagged","title":"Safe Patterns (Not Flagged)","text":"<p>The diagnostic recognizes these factory patterns and does not flag them:</p> <ul> <li><code>Func&lt;T&gt;</code> - Creates new instances on demand</li> <li><code>Lazy&lt;T&gt;</code> - Deferred creation</li> <li><code>IServiceScopeFactory</code> - Creates new scopes</li> <li><code>IServiceProvider</code> - Dynamic service resolution</li> </ul>"},{"location":"analyzers/NDLRGEN022/#how-lifetimes-are-determined","title":"How Lifetimes Are Determined","text":"<p>NDLRGEN022 uses Needlr's convention-based lifetime inference:</p> <ol> <li>Explicit attributes (<code>[Singleton]</code>, <code>[Scoped]</code>, <code>[Transient]</code>) take precedence</li> <li>Hosted services (<code>BackgroundService</code>, <code>IHostedService</code>) are always Singleton</li> <li>Injectable types with parameterless or all-injectable constructors default to Singleton</li> </ol> <p>For detailed information about lifetime inference, see the Needlr documentation.</p>"},{"location":"analyzers/NDLRGEN022/#suppression","title":"Suppression","text":"<p>To suppress this diagnostic:</p> <pre><code>#pragma warning disable NDLRGEN022\n[Singleton]\npublic class KnownCaptiveDependency\n{\n    public KnownCaptiveDependency(ScopedDisposable dep) { }\n}\n#pragma warning restore NDLRGEN022\n</code></pre>"},{"location":"analyzers/NDLRGEN022/#see-also","title":"See Also","text":"<ul> <li>NDLRCOR012 - Standalone analyzer for explicit attributes only</li> <li>Captive Dependency anti-pattern</li> </ul>"},{"location":"analyzers/NDLRSIG001/","title":"NDLRSIG001: HubPath must be a constant","text":""},{"location":"analyzers/NDLRSIG001/#cause","title":"Cause","text":"<p>The <code>hubPath</code> parameter of <code>HubPathAttribute</code> is not a compile-time constant expression.</p>"},{"location":"analyzers/NDLRSIG001/#rule-description","title":"Rule Description","text":"<p>SignalR hub paths must be known at compile time for proper route registration and AOT compatibility. Using non-constant values (like static fields or method calls) prevents the source generator from properly analyzing and generating the hub registration code.</p>"},{"location":"analyzers/NDLRSIG001/#example","title":"Example","text":""},{"location":"analyzers/NDLRSIG001/#incorrect","title":"Incorrect","text":"<pre><code>public static class HubPaths\n{\n    public static string ChatHub = \"/chat\"; // Not const!\n}\n\n[HubPath(HubPaths.ChatHub, typeof(ChatHub))] // NDLRSIG001\npublic class ChatHubRegistration : ISignalRHub { }\n</code></pre>"},{"location":"analyzers/NDLRSIG001/#correct","title":"Correct","text":"<pre><code>public static class HubPaths\n{\n    public const string ChatHub = \"/chat\"; // const is OK\n}\n\n[HubPath(HubPaths.ChatHub, typeof(ChatHub))]\npublic class ChatHubRegistration : ISignalRHub { }\n\n// Or use a string literal directly\n[HubPath(\"/chat\", typeof(ChatHub))]\npublic class ChatHubRegistration : ISignalRHub { }\n</code></pre>"},{"location":"analyzers/NDLRSIG001/#how-to-fix","title":"How to Fix","text":"<ol> <li>Change the hub path to a <code>const</code> string field</li> <li>Use a string literal directly in the attribute</li> <li>Use <code>nameof()</code> if deriving the path from a type name</li> </ol>"},{"location":"analyzers/NDLRSIG001/#when-to-suppress","title":"When to Suppress","text":"<p>This warning should not be suppressed. Non-constant hub paths will cause compilation errors in the C# compiler itself (CS0182).</p>"},{"location":"analyzers/NDLRSIG001/#see-also","title":"See Also","text":"<ul> <li>SignalR Integration</li> </ul>"},{"location":"analyzers/NDLRSIG002/","title":"NDLRSIG002: HubType must be a typeof expression","text":""},{"location":"analyzers/NDLRSIG002/#cause","title":"Cause","text":"<p>The <code>hubType</code> parameter of <code>HubPathAttribute</code> is not a <code>typeof()</code> expression.</p>"},{"location":"analyzers/NDLRSIG002/#rule-description","title":"Rule Description","text":"<p>SignalR hub type references must use the <code>typeof()</code> operator for proper type resolution at compile time. This ensures AOT compatibility and allows the source generator to properly analyze the hub type.</p>"},{"location":"analyzers/NDLRSIG002/#example","title":"Example","text":""},{"location":"analyzers/NDLRSIG002/#incorrect","title":"Incorrect","text":"<pre><code>[HubPath(\"/chat\", someTypeVariable)] // NDLRSIG002\npublic class ChatHubRegistration : ISignalRHub { }\n</code></pre>"},{"location":"analyzers/NDLRSIG002/#correct","title":"Correct","text":"<pre><code>[HubPath(\"/chat\", typeof(ChatHub))]\npublic class ChatHubRegistration : ISignalRHub { }\n</code></pre>"},{"location":"analyzers/NDLRSIG002/#how-to-fix","title":"How to Fix","text":"<p>Always use <code>typeof(YourHubClass)</code> for the hub type parameter:</p> <pre><code>[HubPath(\"/notifications\", typeof(NotificationHub))]\npublic class NotificationHubRegistration : ISignalRHub { }\n</code></pre>"},{"location":"analyzers/NDLRSIG002/#when-to-suppress","title":"When to Suppress","text":"<p>This warning should not be suppressed. Non-typeof expressions will cause compilation errors in the C# compiler itself (CS0182).</p>"},{"location":"analyzers/NDLRSIG002/#see-also","title":"See Also","text":"<ul> <li>SignalR Integration</li> <li>NDLRSIG001: HubPath must be a constant</li> </ul>"}]}