{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Needlr","text":"<p>Opinionated fluent dependency injection for .NET with source generation.</p> <p> </p>"},{"location":"#what-is-needlr","title":"What is Needlr?","text":"<p>Needlr is a source-generation-first dependency injection library for .NET that provides automatic service registration through a simple, discoverable API. It's designed to minimize boilerplate code by automatically registering types from scanned assemblies.</p> <p>Source Generation First</p> <p>Needlr prioritizes compile-time source generation for AOT compatibility and optimal performance. Both source-gen (<code>.UsingSourceGen()</code>) and reflection (<code>.UsingReflection()</code>) require explicit opt-in\u2014source-gen is recommended for most scenarios.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Source Generation First - Compile-time type discovery for AOT/trimming compatibility</li> <li>Automatic Service Discovery - Automatically registers services from assemblies using conventions</li> <li>Fluent API - Chain-able configuration methods for clean, readable setup</li> <li>ASP.NET Core Integration - Seamless web application creation and configuration</li> <li>Plugin System - Extensible architecture for modular applications</li> <li>Decorator Pattern Support - Automatic decorator wiring with <code>[DecoratorFor&lt;T&gt;]</code> attribute</li> <li>Analyzers &amp; Diagnostics - Catch DI issues at compile-time, not runtime</li> <li>AI Integrations - First-class support for Microsoft Agent Framework and Semantic Kernel</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<p>See the Getting Started guide for full package requirements. Quick overview:</p> Source Generation (Recommended)Reflection <pre><code>&lt;PackageReference Include=\"NexusLabs.Needlr.Injection\" /&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.Injection.SourceGen\" /&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.Generators\" OutputItemType=\"Analyzer\" ReferenceOutputAssembly=\"false\" /&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.Generators.Attributes\" /&gt;\n&lt;!-- For ASP.NET Core: NexusLabs.Needlr.AspNet --&gt;\n</code></pre> <pre><code>&lt;PackageReference Include=\"NexusLabs.Needlr.Injection\" /&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.Injection.Reflection\" /&gt;\n&lt;!-- For ASP.NET Core: NexusLabs.Needlr.AspNet --&gt;\n</code></pre>"},{"location":"#source-generation-recommended","title":"Source Generation (Recommended)","text":"<pre><code>using NexusLabs.Needlr.AspNet;\nusing NexusLabs.Needlr.Injection;\nusing NexusLabs.Needlr.Injection.SourceGen;\n\nvar app = new Syringe()\n    .UsingSourceGen()\n    .CreateWebApplication(args);\n\napp.Run();\n</code></pre>"},{"location":"#reflection","title":"Reflection","text":"<pre><code>using NexusLabs.Needlr.AspNet;\nusing NexusLabs.Needlr.Injection;\nusing NexusLabs.Needlr.Injection.Reflection;\n\nvar app = new Syringe()\n    .UsingReflection()\n    .CreateWebApplication(args);\n\napp.Run();\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li> <p> Getting Started</p> <p>Step-by-step guide to set up Needlr in your project</p> <p> Getting Started</p> </li> <li> <p> Core Concepts</p> <p>Understand the architecture and design principles</p> <p> Core Concepts</p> </li> <li> <p> Features</p> <p>Explore hosted services, keyed services, options, and more</p> <p> Hosted Services</p> </li> <li> <p> Analyzers</p> <p>Compile-time diagnostics to catch DI issues early</p> <p> Analyzers</p> </li> </ul>"},{"location":"advanced-usage/","title":"Advanced Usage","text":"<p>This guide covers advanced scenarios and techniques for using Needlr in complex applications.</p> <p>Note: Many advanced features require reflection. If you're building an AOT application,  stick to the source-generation patterns described in the Getting Started guide.</p>"},{"location":"advanced-usage/#custom-type-registrars","title":"Custom Type Registrars","text":""},{"location":"advanced-usage/#implementing-ityperegistrar","title":"Implementing ITypeRegistrar","text":"<p>Create custom registration logic by implementing <code>ITypeRegistrar</code>. This is typically used with reflection:</p> <pre><code>using Microsoft.Extensions.DependencyInjection;\nusing NexusLabs.Needlr.Injection;\nusing NexusLabs.Needlr.Injection.Reflection;\n\npublic class ConventionBasedTypeRegistrar : ITypeRegistrar\n{\n    public void RegisterTypes(\n        IServiceCollection services,\n        IEnumerable&lt;Type&gt; types,\n        ILogger logger)\n    {\n        foreach (var type in types)\n        {\n            // Register repositories as scoped\n            if (type.Name.EndsWith(\"Repository\"))\n            {\n                var interfaces = type.GetInterfaces();\n                foreach (var @interface in interfaces)\n                {\n                    services.AddScoped(@interface, type);\n                    logger.LogDebug($\"Registered {type.Name} as {@interface.Name} (Scoped)\");\n                }\n            }\n            // Register services as transient\n            else if (type.Name.EndsWith(\"Service\"))\n            {\n                var interfaces = type.GetInterfaces();\n                foreach (var @interface in interfaces)\n                {\n                    services.AddTransient(@interface, type);\n                    logger.LogDebug($\"Registered {type.Name} as {@interface.Name} (Transient)\");\n                }\n            }\n            // Register singletons for specific patterns\n            else if (type.GetInterfaces().Any(i =&gt; i.Name == \"ISingleton\"))\n            {\n                services.AddSingleton(type);\n                logger.LogDebug($\"Registered {type.Name} as Singleton\");\n            }\n        }\n    }\n}\n\n// Usage (requires reflection strategy)\nvar serviceProvider = new Syringe()\n    .UsingReflection()\n    .UsingTypeRegistrar(new ConventionBasedTypeRegistrar())\n    .BuildServiceProvider();\n</code></pre>"},{"location":"advanced-usage/#custom-type-filterers","title":"Custom Type Filterers","text":""},{"location":"advanced-usage/#implementing-itypefilterer","title":"Implementing ITypeFilterer","text":"<p>Control which types are eligible for registration:</p> <pre><code>public class NamespaceTypeFilterer : ITypeFilterer\n{\n    private readonly string[] _allowedNamespaces;\n\n    public NamespaceTypeFilterer(params string[] allowedNamespaces)\n    {\n        _allowedNamespaces = allowedNamespaces;\n    }\n\n    public IEnumerable&lt;Type&gt; Filter(IEnumerable&lt;Type&gt; types)\n    {\n        return types.Where(type =&gt;\n        {\n            // Skip if no namespace\n            if (type.Namespace == null)\n                return false;\n\n            // Check if in allowed namespaces\n            var isAllowed = _allowedNamespaces.Any(ns =&gt; \n                type.Namespace.StartsWith(ns));\n\n            // Also exclude test classes\n            var isTest = type.Name.EndsWith(\"Test\") || \n                         type.Name.EndsWith(\"Tests\");\n\n            return isAllowed &amp;&amp; !isTest;\n        });\n    }\n}\n\n// Usage (requires reflection strategy)\nvar serviceProvider = new Syringe()\n    .UsingReflection()\n    .UsingTypeFilterer(new NamespaceTypeFilterer(\n        \"MyCompany.Core\",\n        \"MyCompany.Services\",\n        \"MyCompany.Data\"))\n    .BuildServiceProvider();\n</code></pre>"},{"location":"advanced-usage/#chaining-type-filterers","title":"Chaining Type Filterers","text":"<p>Use <code>TypeFilterDecorator</code> to chain multiple filters:</p> <pre><code>public class CompositeFilterer : ITypeFilterer\n{\n    private readonly ITypeFilterer[] _filters;\n\n    public CompositeFilterer(params ITypeFilterer[] filters)\n    {\n        _filters = filters;\n    }\n\n    public IEnumerable&lt;Type&gt; Filter(IEnumerable&lt;Type&gt; types)\n    {\n        var result = types;\n        foreach (var filter in _filters)\n        {\n            result = filter.Filter(result);\n        }\n        return result;\n    }\n}\n\n// Usage (requires reflection strategy)\nvar serviceProvider = new Syringe()\n    .UsingReflection()\n    .UsingTypeFilterer(new CompositeFilterer(\n        new ReflectionTypeFilterer(),\n        new NamespaceTypeFilterer(\"MyCompany\"),\n        new AttributeTypeFilterer&lt;ObsoleteAttribute&gt;(exclude: true)))\n    .BuildServiceProvider();\n</code></pre>"},{"location":"advanced-usage/#complex-decorator-patterns","title":"Complex Decorator Patterns","text":""},{"location":"advanced-usage/#nested-decorators-with-attributes-recommended","title":"Nested Decorators with Attributes (Recommended)","text":"<p>The simplest way to apply multiple decorators is using the <code>[DecoratorFor&lt;T&gt;]</code> attribute:</p> <pre><code>// Base service - registered automatically\npublic class DataService : IDataService\n{\n    public async Task&lt;Data&gt; GetDataAsync()\n    {\n        return await FetchFromDatabase();\n    }\n}\n\n// Caching decorator - Order 1 means closest to original\n[DecoratorFor&lt;IDataService&gt;(Order = 1)]\npublic class CachingDataService : IDataService\n{\n    private readonly IDataService _inner;\n    private readonly IMemoryCache _cache;\n\n    public CachingDataService(IDataService inner, IMemoryCache cache)\n    {\n        _inner = inner;\n        _cache = cache;\n    }\n\n    public async Task&lt;Data&gt; GetDataAsync()\n    {\n        return await _cache.GetOrCreateAsync(\"data\", \n            async entry =&gt; await _inner.GetDataAsync());\n    }\n}\n\n// Logging decorator - Order 2 wraps the caching decorator\n[DecoratorFor&lt;IDataService&gt;(Order = 2)]\npublic class LoggingDataService : IDataService\n{\n    private readonly IDataService _inner;\n    private readonly ILogger&lt;LoggingDataService&gt; _logger;\n\n    public LoggingDataService(IDataService inner, ILogger&lt;LoggingDataService&gt; logger)\n    {\n        _inner = inner;\n        _logger = logger;\n    }\n\n    public async Task&lt;Data&gt; GetDataAsync()\n    {\n        _logger.LogInformation(\"Fetching data...\");\n        var data = await _inner.GetDataAsync();\n        _logger.LogInformation($\"Fetched {data.Count} items\");\n        return data;\n    }\n}\n\n// No plugin needed! Resolution produces:\n// LoggingDataService \u2192 CachingDataService \u2192 DataService\n</code></pre>"},{"location":"advanced-usage/#nested-decorators-manual","title":"Nested Decorators (Manual)","text":"<p>For more control, apply decorators manually in a plugin:</p> <pre><code>// Base service\n[DoNotAutoRegister]\npublic class DataService : IDataService\n{\n    public async Task&lt;Data&gt; GetDataAsync()\n    {\n        // Fetch from database\n        return await FetchFromDatabase();\n    }\n}\n\n// Caching decorator\n[DoNotAutoRegister]\npublic class CachingDataService : IDataService\n{\n    private readonly IDataService _inner;\n    private readonly IMemoryCache _cache;\n\n    public CachingDataService(IDataService inner, IMemoryCache cache)\n    {\n        _inner = inner;\n        _cache = cache;\n    }\n\n    public async Task&lt;Data&gt; GetDataAsync()\n    {\n        return await _cache.GetOrCreateAsync(\"data\", \n            async entry =&gt; await _inner.GetDataAsync());\n    }\n}\n\n// Logging decorator\n[DoNotAutoRegister]\npublic class LoggingDataService : IDataService\n{\n    private readonly IDataService _inner;\n    private readonly ILogger&lt;LoggingDataService&gt; _logger;\n\n    public LoggingDataService(IDataService inner, ILogger&lt;LoggingDataService&gt; logger)\n    {\n        _inner = inner;\n        _logger = logger;\n    }\n\n    public async Task&lt;Data&gt; GetDataAsync()\n    {\n        _logger.LogInformation(\"Fetching data...\");\n        var data = await _inner.GetDataAsync();\n        _logger.LogInformation($\"Fetched {data.Count} items\");\n        return data;\n    }\n}\n\n// Registration plugin\npublic class DataServicePlugin : IServiceCollectionPlugin\n{\n    public void Configure(ServiceCollectionPluginOptions options)\n    {\n        // Register base service\n        options.Services.AddScoped&lt;DataService&gt;();\n\n        // Apply decorators in order (innermost to outermost)\n        options.Services.AddScoped&lt;IDataService&gt;(sp =&gt;\n        {\n            IDataService service = sp.GetRequiredService&lt;DataService&gt;();\n            service = new CachingDataService(service, sp.GetRequiredService&lt;IMemoryCache&gt;());\n            service = new LoggingDataService(service, sp.GetRequiredService&lt;ILogger&lt;LoggingDataService&gt;&gt;());\n            return service;\n        });\n    }\n}\n</code></pre>"},{"location":"advanced-usage/#conditional-decorators","title":"Conditional Decorators","text":"<p>Apply decorators based on configuration:</p> <pre><code>public class ConditionalDecoratorPlugin : IServiceCollectionPlugin\n{\n    public void Configure(ServiceCollectionPluginOptions options)\n    {\n        options.Services.AddScoped&lt;BaseService&gt;();\n\n        options.Services.AddScoped&lt;IService&gt;(sp =&gt;\n        {\n            IService service = sp.GetRequiredService&lt;BaseService&gt;();\n\n            var config = sp.GetRequiredService&lt;IConfiguration&gt;();\n\n            if (config.GetValue&lt;bool&gt;(\"Features:EnableCaching\"))\n            {\n                service = new CachingDecorator(service, sp.GetRequiredService&lt;IMemoryCache&gt;());\n            }\n\n            if (config.GetValue&lt;bool&gt;(\"Features:EnableLogging\"))\n            {\n                service = new LoggingDecorator(service, sp.GetRequiredService&lt;ILogger&lt;LoggingDecorator&gt;&gt;());\n            }\n\n            if (config.GetValue&lt;bool&gt;(\"Features:EnableMetrics\"))\n            {\n                service = new MetricsDecorator(service, sp.GetRequiredService&lt;IMetricsCollector&gt;());\n            }\n\n            return service;\n        });\n    }\n}\n</code></pre>"},{"location":"advanced-usage/#post-plugin-registration-callbacks","title":"Post-Plugin Registration Callbacks","text":"<p>The <code>UsingPostPluginRegistrationCallback</code> method provides a way to register services after all plugins have been processed. This is available on both the <code>Syringe</code> class and <code>CreateWebApplicationOptions</code>.</p>"},{"location":"advanced-usage/#using-with-syringe","title":"Using with Syringe","text":"<p>Register services directly on the Syringe instance:</p> <pre><code>var serviceProvider = new Syringe()\n    .UsingPostPluginRegistrationCallback(services =&gt;\n    {\n        // Override or add services after plugins\n        services.AddSingleton&lt;ICustomService, CustomService&gt;();\n        services.Configure&lt;MyOptions&gt;(options =&gt; \n        {\n            options.EnableFeature = true;\n        });\n    })\n    .UsingPostPluginRegistrationCallback(services =&gt;\n    {\n        // You can chain multiple callbacks\n        services.AddScoped&lt;IAnotherService, AnotherService&gt;();\n    })\n    .BuildServiceProvider();\n</code></pre> <p>You can also use the plural overload <code>UsingPostPluginRegistrationCallbacks</code> to pass in multiple callbacks.</p>"},{"location":"advanced-usage/#using-with-createwebapplicationoptions","title":"Using with CreateWebApplicationOptions","text":"<p>For web applications, add callbacks through the options using the fluent extension methods:</p> <pre><code>var webApplication = new Syringe()\n    .ForWebApplication()\n    .UsingOptions(() =&gt; CreateWebApplicationOptions.Default\n        .UsingPostPluginRegistrationCallback(services =&gt;\n        {\n            services.AddAuthentication();\n            services.AddAuthorization();\n        })\n        .UsingPostPluginRegistrationCallback(services =&gt;\n        {\n            // Configure after authentication is added\n            services.Configure&lt;JwtBearerOptions&gt;(options =&gt;\n            {\n                options.Authority = \"https://auth.example.com\";\n            });\n        }))\n    .BuildWebApplication();\n</code></pre> <p>You can also use the plural overload to add multiple callbacks at once:</p> <pre><code>var webApplication = new Syringe()\n    .ForWebApplication()\n    .UsingOptions(() =&gt; CreateWebApplicationOptions.Default\n        .UsingPostPluginRegistrationCallbacks(\n            services =&gt; services.AddAuthentication(),\n            services =&gt; services.AddAuthorization(),\n            services =&gt; services.AddAntiforgery()))\n    .BuildWebApplication();\n</code></pre>"},{"location":"advanced-usage/#common-use-cases","title":"Common Use Cases","text":"<p>Post-plugin registration callbacks are particularly useful for:</p> <ol> <li>Overriding Plugin Registrations: Replace a service registered by a plugin with a custom implementation</li> <li>Conditional Registration: Add services based on configuration or environment</li> <li>Testing: Override services with mocks or test doubles</li> </ol> <p>Example of overriding a plugin registration:</p> <pre><code>var syringe = new Syringe()\n    .UsingPostPluginRegistrationCallback(services =&gt;\n    {\n        // Remove the default implementation registered by a plugin\n        var descriptor = services.FirstOrDefault(d =&gt; d.ServiceType == typeof(IEmailService));\n        if (descriptor != null)\n        {\n            services.Remove(descriptor);\n        }\n\n        // Add custom implementation\n        services.AddSingleton&lt;IEmailService, CustomEmailService&gt;();\n    });\n</code></pre>"},{"location":"advanced-usage/#custom-assembly-providers","title":"Custom Assembly Providers","text":""},{"location":"advanced-usage/#implementing-iassemblyprovider","title":"Implementing IAssemblyProvider","text":"<p>Create custom assembly discovery logic:</p> <pre><code>public class PluginAssemblyProvider : IAssemblyProvider\n{\n    private readonly string _pluginDirectory;\n\n    public PluginAssemblyProvider(string pluginDirectory)\n    {\n        _pluginDirectory = pluginDirectory;\n    }\n\n    public IEnumerable&lt;Assembly&gt; GetAssemblies()\n    {\n        var assemblies = new List&lt;Assembly&gt;();\n\n        // Load assemblies from plugin directory\n        if (Directory.Exists(_pluginDirectory))\n        {\n            var pluginFiles = Directory.GetFiles(_pluginDirectory, \"*.dll\");\n            foreach (var file in pluginFiles)\n            {\n                try\n                {\n                    var assembly = Assembly.LoadFrom(file);\n                    assemblies.Add(assembly);\n                }\n                catch (Exception ex)\n                {\n                    // Log and continue\n                    Console.WriteLine($\"Failed to load {file}: {ex.Message}\");\n                }\n            }\n        }\n\n        // Also include current domain assemblies\n        assemblies.AddRange(AppDomain.CurrentDomain.GetAssemblies());\n\n        return assemblies.Distinct();\n    }\n}\n\n// Usage (requires reflection strategy for dynamic assembly loading)\nvar serviceProvider = new Syringe()\n    .UsingReflection()\n    .UsingAssemblyProvider(new PluginAssemblyProvider(\"./plugins\"))\n    .BuildServiceProvider();\n</code></pre>"},{"location":"advanced-usage/#advanced-web-application-configuration","title":"Advanced Web Application Configuration","text":""},{"location":"advanced-usage/#using-configuration-callback","title":"Using Configuration Callback","text":"<p>The <code>UsingConfigurationCallback</code> method provides fine-grained control over the WebApplicationBuilder configuration:</p> <pre><code>var webApplication = new Syringe()\n    .UsingSourceGen()  // or .UsingReflection()\n    .ForWebApplication()\n    .UsingConfigurationCallback((builder, options) =&gt;\n    {\n        // Conditional configuration based on environment\n        if (builder.Environment.IsEnvironment(\"Test\"))\n        {\n            // Test-specific configuration\n            builder.Configuration.AddJsonFile(\"appsettings.Test.json\", optional: false);\n        }\n        else\n        {\n            // Production configuration\n            builder.Configuration\n                .AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true)\n                .AddJsonFile($\"appsettings.{builder.Environment.EnvironmentName}.json\", \n                    optional: true, reloadOnChange: true);\n        }\n\n        // Add environment variables with custom prefix\n        builder.Configuration.AddEnvironmentVariables(\"MYAPP_\");\n\n        // Override with in-memory configuration for testing\n        if (builder.Environment.IsDevelopment())\n        {\n            builder.Configuration.AddInMemoryCollection(new Dictionary&lt;string, string?&gt;\n            {\n                [\"DebugMode\"] = \"true\",\n                [\"DetailedErrors\"] = \"true\"\n            });\n        }\n\n        // Configure services before plugin registration\n        builder.Services.Configure&lt;JsonOptions&gt;(opts =&gt;\n        {\n            opts.SerializerOptions.PropertyNamingPolicy = JsonNamingPolicy.CamelCase;\n        });\n\n        // Configure Kestrel\n        builder.WebHost.ConfigureKestrel(serverOptions =&gt;\n        {\n            serverOptions.Limits.MaxRequestBodySize = 50 * 1024 * 1024; // 50MB\n        });\n    })\n    .BuildWebApplication();\n</code></pre>"},{"location":"advanced-usage/#custom-web-application-factory","title":"Custom Web Application Factory","text":"<pre><code>public class CustomWebApplicationFactory : IWebApplicationFactory\n{\n    public WebApplication Create(\n        CreateWebApplicationOptions options,\n        Func&lt;WebApplicationBuilder&gt; createWebApplicationBuilderCallback)\n    {\n        var builder = createWebApplicationBuilderCallback();\n\n        // Custom Kestrel configuration\n        builder.WebHost.ConfigureKestrel(serverOptions =&gt;\n        {\n            serverOptions.ListenAnyIP(5000, listenOptions =&gt;\n            {\n                listenOptions.Protocols = HttpProtocols.Http2;\n            });\n\n            serverOptions.ListenAnyIP(5001, listenOptions =&gt;\n            {\n                listenOptions.UseHttps();\n                listenOptions.Protocols = HttpProtocols.Http1AndHttp2;\n            });\n        });\n\n        // Custom service configuration\n        builder.Services.Configure&lt;KestrelServerOptions&gt;(options =&gt;\n        {\n            options.AllowSynchronousIO = true;\n        });\n\n        // Add custom configuration sources\n        builder.Configuration.AddJsonFile(\"custom-settings.json\", optional: true);\n        builder.Configuration.AddEnvironmentVariables(\"MYAPP_\");\n\n        // Custom logging\n        builder.Logging.ClearProviders();\n        builder.Logging.AddConsole();\n        builder.Logging.AddDebug();\n\n        var app = builder.Build();\n\n        // Custom middleware pipeline\n        if (app.Environment.IsDevelopment())\n        {\n            app.UseDeveloperExceptionPage();\n        }\n        else\n        {\n            app.UseExceptionHandler(\"/error\");\n            app.UseHsts();\n        }\n\n        app.UseHttpsRedirection();\n        app.UseResponseCompression();\n\n        return app;\n    }\n}\n\n// Usage\nvar webApp = new Syringe()\n    .ForWebApplication()\n    .UsingWebApplicationFactory&lt;CustomWebApplicationFactory&gt;()\n    .BuildWebApplication();\n</code></pre>"},{"location":"advanced-usage/#combining-configuration-methods","title":"Combining Configuration Methods","text":"<p>You can combine multiple configuration methods for maximum flexibility:</p> <pre><code>// With reflection and Scrutor\nvar webApp = new Syringe()\n    .UsingReflection()\n    .UsingScrutorTypeRegistrar()\n    .UsingAssemblyProvider(builder =&gt; builder\n        .MatchingAssemblies(x =&gt; x.Contains(\"MyApp\"))\n        .UseLibTestEntryOrdering()\n        .Build())\n    .ForWebApplication()\n    .UsingOptions(() =&gt; CreateWebApplicationOptions\n        .Default\n        .UsingStartupConsoleLogger()\n        .UsingApplicationName(\"MyApp\"))\n    .UsingConfigurationCallback((builder, options) =&gt;\n    {\n        // Fine-tune the configuration\n        builder.Configuration.SetBasePath(AppContext.BaseDirectory);\n        builder.Configuration.AddUserSecrets&lt;Program&gt;();\n\n        // Add services that plugins might depend on\n        builder.Services.AddSingleton&lt;IConfigurationValidator, ConfigurationValidator&gt;();\n    })\n    .BuildWebApplication();\n\n// With source generation\nvar webApp = new Syringe()\n    .UsingSourceGen()\n    .UsingAssemblyProvider(builder =&gt; builder\n        .MatchingAssemblies(x =&gt; x.Contains(\"MyApp\"))\n        .Build())\n    .ForWebApplication()\n    .UsingOptions(() =&gt; CreateWebApplicationOptions\n        .Default\n        .UsingStartupConsoleLogger())\n    .BuildWebApplication();\n</code></pre>"},{"location":"advanced-usage/#delayed-resolution","title":"Delayed Resolution","text":""},{"location":"advanced-usage/#lazy-service-resolution","title":"Lazy Service Resolution","text":"<pre><code>public class LazyServicePlugin : IServiceCollectionPlugin\n{\n    public void Configure(ServiceCollectionPluginOptions options)\n    {\n        // Register lazy wrapper for expensive services\n        options.Services.AddSingleton&lt;Lazy&lt;IExpensiveService&gt;&gt;(sp =&gt;\n            new Lazy&lt;IExpensiveService&gt;(() =&gt; \n                sp.GetRequiredService&lt;IExpensiveService&gt;()));\n\n        // Register the actual expensive service\n        options.Services.AddSingleton&lt;IExpensiveService, ExpensiveService&gt;();\n    }\n}\n\n// Usage in a consumer\npublic class ServiceConsumer\n{\n    private readonly Lazy&lt;IExpensiveService&gt; _expensiveService;\n\n    public ServiceConsumer(Lazy&lt;IExpensiveService&gt; expensiveService)\n    {\n        _expensiveService = expensiveService;\n    }\n\n    public void UseServiceIfNeeded(bool condition)\n    {\n        if (condition)\n        {\n            // Service is only instantiated when actually needed\n            _expensiveService.Value.DoExpensiveWork();\n        }\n    }\n}\n</code></pre>"},{"location":"advanced-usage/#testing-strategies","title":"Testing Strategies","text":""},{"location":"advanced-usage/#integration-testing-with-custom-configuration","title":"Integration Testing with Custom Configuration","text":"<pre><code>public class IntegrationTestBase\n{\n    protected IServiceProvider CreateServiceProvider(\n        Action&lt;Syringe&gt; configureSyringe = null)\n    {\n        var syringe = new Syringe()\n            .UsingReflection()  // Reflection often useful for testing flexibility\n            .UsingAssemblyProvider(builder =&gt; builder\n                .MatchingAssemblies(x =&gt; x.Contains(\"MyApp\"))\n                .Build())\n            .UsingConfiguration(config =&gt; config\n                .AddJsonFile(\"appsettings.test.json\")\n                .AddEnvironmentVariables(\"TEST_\"));\n\n        configureSyringe?.Invoke(syringe);\n\n        return syringe.BuildServiceProvider();\n    }\n}\n\npublic class ServiceIntegrationTests : IntegrationTestBase\n{\n    [Fact]\n    public void Service_WithTestConfiguration_WorksCorrectly()\n    {\n        // Arrange\n        var serviceProvider = CreateServiceProvider(syringe =&gt;\n            syringe.UsingPostPluginRegistrationCallback(services =&gt;\n            {\n                // Override specific services for testing\n                services.AddSingleton&lt;IExternalService, MockExternalService&gt;();\n            }));\n\n        // Act\n        var service = serviceProvider.GetRequiredService&lt;IMyService&gt;();\n        var result = service.DoWork();\n\n        // Assert\n        Assert.NotNull(result);\n    }\n}\n</code></pre>"},{"location":"advanced-usage/#troubleshooting","title":"Troubleshooting","text":""},{"location":"advanced-usage/#debugging-service-registration","title":"Debugging Service Registration","text":"<pre><code>public class DiagnosticPlugin : IPostBuildServiceCollectionPlugin\n{\n    public void Configure(PostBuildServiceCollectionPluginOptions options)\n    {\n        var services = options.Services;\n\n        // Log all registered services\n        foreach (var service in services)\n        {\n            options.Logger.LogDebug(\n                $\"Service: {service.ServiceType.Name}, \" +\n                $\"Implementation: {service.ImplementationType?.Name ?? \"Factory\"}, \" +\n                $\"Lifetime: {service.Lifetime}\");\n        }\n\n        // Verify critical services\n        var criticalServices = new[]\n        {\n            typeof(IConfiguration),\n            typeof(ILogger&lt;&gt;),\n            typeof(IServiceProvider)\n        };\n\n        foreach (var serviceType in criticalServices)\n        {\n            var service = options.ServiceProvider.GetService(serviceType);\n            if (service == null)\n            {\n                options.Logger.LogWarning($\"Critical service not registered: {serviceType.Name}\");\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"advanced-usage/#multi-project-solutions-with-source-generation","title":"Multi-Project Solutions with Source Generation","text":"<p>When using source generation with solutions containing many plugin projects, each project with internal types needs its own <code>[GenerateTypeRegistry]</code> attribute. For large solutions, you can use MSBuild conventions to reduce boilerplate.</p>"},{"location":"advanced-usage/#using-directorybuildprops","title":"Using Directory.Build.props","text":"<p>Create a <code>Directory.Build.props</code> file at your solution root to automatically generate a source file with the attribute for projects matching a naming convention:</p> <pre><code>&lt;!-- Directory.Build.props --&gt;\n&lt;Project&gt;\n\n  &lt;!-- Enable auto-generation for projects matching naming patterns --&gt;\n  &lt;PropertyGroup&gt;\n    &lt;NeedlrAutoGenerate Condition=\"$(MSBuildProjectName.EndsWith('.Plugin'))\"&gt;true&lt;/NeedlrAutoGenerate&gt;\n    &lt;NeedlrAutoGenerate Condition=\"$(MSBuildProjectName.EndsWith('.Plugins'))\"&gt;true&lt;/NeedlrAutoGenerate&gt;\n    &lt;NeedlrAutoGenerate Condition=\"$(MSBuildProjectName.EndsWith('Plugin'))\"&gt;true&lt;/NeedlrAutoGenerate&gt;\n  &lt;/PropertyGroup&gt;\n\n  &lt;!-- Or match by prefix --&gt;\n  &lt;PropertyGroup&gt;\n    &lt;NeedlrAutoGenerate Condition=\"$(MSBuildProjectName.StartsWith('MyCompany.'))\"&gt;true&lt;/NeedlrAutoGenerate&gt;\n  &lt;/PropertyGroup&gt;\n\n  &lt;!-- Set namespace prefix to project name by default --&gt;\n  &lt;PropertyGroup Condition=\"'$(NeedlrAutoGenerate)' == 'true'\"&gt;\n    &lt;NeedlrNamespacePrefix Condition=\"'$(NeedlrNamespacePrefix)' == ''\"&gt;$(MSBuildProjectName)&lt;/NeedlrNamespacePrefix&gt;\n  &lt;/PropertyGroup&gt;\n\n&lt;/Project&gt;\n</code></pre> <p>Then create a <code>Directory.Build.targets</code> file to generate the attribute:</p> <pre><code>&lt;!-- Directory.Build.targets --&gt;\n&lt;Project&gt;\n\n  &lt;Target Name=\"NeedlrGenerateTypeRegistryAttribute\" \n          BeforeTargets=\"CoreCompile\"\n          Condition=\"'$(NeedlrAutoGenerate)' == 'true'\"&gt;\n\n    &lt;PropertyGroup&gt;\n      &lt;_NeedlrGeneratedFile&gt;$(IntermediateOutputPath)NeedlrGeneratedTypeRegistry.g.cs&lt;/_NeedlrGeneratedFile&gt;\n    &lt;/PropertyGroup&gt;\n\n    &lt;WriteLinesToFile\n      File=\"$(_NeedlrGeneratedFile)\"\n      Lines=\"// Auto-generated by Directory.Build.targets;[assembly: NexusLabs.Needlr.Generators.GenerateTypeRegistry(IncludeNamespacePrefixes = new[] { &amp;quot;$(NeedlrNamespacePrefix)&amp;quot; })]\"\n      Overwrite=\"true\" /&gt;\n\n    &lt;ItemGroup&gt;\n      &lt;Compile Include=\"$(_NeedlrGeneratedFile)\" /&gt;\n    &lt;/ItemGroup&gt;\n\n  &lt;/Target&gt;\n\n&lt;/Project&gt;\n</code></pre>"},{"location":"advanced-usage/#solution-structure-example","title":"Solution Structure Example","text":"<pre><code>MySolution/\n\u251c\u2500\u2500 Directory.Build.props           # Naming convention rules\n\u251c\u2500\u2500 Directory.Build.targets         # Auto-generates attribute\n\u251c\u2500\u2500 MyCompany.App/                  # Host - explicit [GenerateTypeRegistry]\n\u2502   \u2514\u2500\u2500 GeneratorAssemblyInfo.cs    # Custom namespace prefixes\n\u251c\u2500\u2500 MyCompany.Auth.Plugin/          # Auto-generates \u2713\n\u251c\u2500\u2500 MyCompany.Caching.Plugin/       # Auto-generates \u2713\n\u251c\u2500\u2500 MyCompany.Logging.Plugin/       # Auto-generates \u2713\n\u2514\u2500\u2500 ... more plugins                # All auto-generate \u2713\n</code></pre>"},{"location":"advanced-usage/#opting-out-specific-projects","title":"Opting Out Specific Projects","text":"<p>To exclude a specific project from auto-generation, add to its <code>.csproj</code>:</p> <pre><code>&lt;PropertyGroup&gt;\n  &lt;NeedlrAutoGenerate&gt;false&lt;/NeedlrAutoGenerate&gt;\n&lt;/PropertyGroup&gt;\n</code></pre>"},{"location":"advanced-usage/#custom-namespace-prefix-per-project","title":"Custom Namespace Prefix Per Project","text":"<p>Override the default namespace prefix in a specific project:</p> <pre><code>&lt;PropertyGroup&gt;\n  &lt;NeedlrNamespacePrefix&gt;MyCompany.CustomNamespace&lt;/NeedlrNamespacePrefix&gt;\n&lt;/PropertyGroup&gt;\n</code></pre>"},{"location":"advanced-usage/#why-this-matters","title":"Why This Matters","text":"<p>When plugin projects contain internal types, the host application's generator cannot access them. Each plugin must generate its own type registry. Without the MSBuild convention approach, you would need to manually add <code>[GenerateTypeRegistry]</code> to every plugin project.</p> <p>The generator emits error <code>NDLRGEN002</code> if it detects internal plugin types in a referenced assembly without <code>[GenerateTypeRegistry]</code>, helping you identify projects that need the attribute.</p>"},{"location":"advanced-usage/#assembly-loading-control","title":"Assembly Loading Control","text":""},{"location":"advanced-usage/#automatic-assembly-loading","title":"Automatic Assembly Loading","text":"<p>When using source generation, Needlr automatically discovers all referenced assemblies that have <code>[GenerateTypeRegistry]</code> and ensures they are loaded at startup. This is critical because:</p> <ul> <li>Module initializers only run when an assembly is loaded - If your code never directly references a type from an assembly, that assembly never loads</li> <li>Transitive dependencies - Plugin assemblies referenced by your project but never directly used in code would be invisible to the type registry</li> </ul> <p>Needlr solves this by generating a <code>ForceLoadReferencedAssemblies()</code> method that uses <code>typeof()</code> to force assembly loading:</p> <pre><code>// Generated in NeedlrSourceGenBootstrap.g.cs\n[MethodImpl(MethodImplOptions.NoInlining)]\nprivate static void ForceLoadReferencedAssemblies()\n{\n    _ = typeof(global::MyApp.Features.Logging.Generated.TypeRegistry).Assembly;\n    _ = typeof(global::MyApp.Features.Scheduling.Generated.TypeRegistry).Assembly;\n    // ... all discovered assemblies with [GenerateTypeRegistry]\n}\n</code></pre> <p>This is fully AOT-compatible - <code>typeof()</code> is resolved at compile time.</p>"},{"location":"advanced-usage/#controlling-assembly-load-order-with-needlrassemblyorder","title":"Controlling Assembly Load Order with [NeedlrAssemblyOrder]","text":"<p>By default, referenced assemblies are loaded in alphabetical order. If you need specific assemblies to load before or after others (e.g., when plugins have dependencies on other plugins being registered first), use the <code>[NeedlrAssemblyOrder]</code> attribute:</p> <pre><code>using NexusLabs.Needlr.Generators;\n\n// In your host application's assembly attributes\n[assembly: GenerateTypeRegistry]\n[assembly: NeedlrAssemblyOrder(\n    First = new[] { \"MyApp.Features.Logging\", \"MyApp.Features.Configuration\" },\n    Last = new[] { \"MyApp.Features.Health\" })]\n</code></pre> <p>How ordering works: 1. Assemblies in <code>First</code> are loaded first, in the order specified 2. All other discovered assemblies are loaded alphabetically 3. Assemblies in <code>Last</code> are loaded last, in the order specified</p> <p>Example scenario: Your <code>AuthenticationPlugin</code> needs <code>ILogger</code> which is registered by <code>LoggingPlugin</code>:</p> <pre><code>[assembly: GenerateTypeRegistry]\n[assembly: NeedlrAssemblyOrder(\n    First = new[] { \"MyApp.Features.Logging\" })]  // Logging loads first\n\nnamespace MyApp.Bootstrap;\n\npublic class Startup\n{\n    // AuthenticationPlugin can now safely depend on ILogger being registered\n}\n</code></pre>"},{"location":"advanced-usage/#when-you-dont-need-assembly-order","title":"When You Don't Need Assembly Order","text":"<p>You typically don't need <code>[NeedlrAssemblyOrder]</code> when:</p> <ul> <li>Plugins don't have inter-dependencies during registration</li> <li>You're using the default registration which handles most scenarios</li> <li>All plugin configuration happens at runtime (not during registration)</li> </ul> <p>You DO need <code>[NeedlrAssemblyOrder]</code> when:</p> <ul> <li>A plugin's <code>Configure()</code> method calls <code>GetRequiredService&lt;T&gt;()</code> and <code>T</code> is registered by another plugin</li> <li>You have strict initialization order requirements</li> <li>Debugging issues where plugins fail because their dependencies aren't registered yet</li> </ul>"},{"location":"advanced-usage/#working-with-other-source-generators","title":"Working with Other Source Generators","text":"<p>When using Needlr with other source generators that modify your types (such as generators that add constructors to partial classes), you may encounter scenarios where Needlr's generator cannot see the constructor that will be added by another generator.</p>"},{"location":"advanced-usage/#the-problem","title":"The Problem","text":"<p>Source generators in .NET run in isolation - they cannot see each other's output. If you have a partial class like:</p> <pre><code>// Your code - another generator will add a constructor\n[CacheProvider(\"EngageFeed\")]  // Triggers CacheProviderGenerator\npublic partial class EngageFeedCacheProvider { }\n\n// CacheProviderGenerator produces:\npublic sealed partial class EngageFeedCacheProvider(ICacheProvider _cacheProvider) { }\n</code></pre> <p>Needlr's generator sees only your original declaration without the constructor, so it would generate an incorrect factory:</p> <pre><code>// Wrong! Missing the ICacheProvider dependency\nsp =&gt; new EngageFeedCacheProvider()\n</code></pre>"},{"location":"advanced-usage/#solution-the-defertocontainer-attribute","title":"Solution: The DeferToContainer Attribute","text":"<p>Use <code>[DeferToContainer]</code> to explicitly declare the constructor parameter types that another generator will add. Needlr will use these types to generate the correct factory:</p> <pre><code>using NexusLabs.Needlr;\n\n// Declare the expected constructor parameters\n[DeferToContainer(typeof(ICacheProvider))]\n[CacheProvider(\"EngageFeed\")]\npublic partial class EngageFeedCacheProvider { }\n</code></pre> <p>Needlr now generates the correct factory:</p> <pre><code>// Correct! Resolves ICacheProvider from the container\nsp =&gt; new EngageFeedCacheProvider(\n    sp.GetRequiredService&lt;ICacheProvider&gt;())\n</code></pre>"},{"location":"advanced-usage/#multiple-dependencies","title":"Multiple Dependencies","text":"<p>You can declare multiple constructor parameters in order:</p> <pre><code>[DeferToContainer(\n    typeof(ICacheProvider), \n    typeof(ILogger&lt;EngageFeedCacheProvider&gt;),\n    typeof(IOptions&lt;CacheOptions&gt;))]\n[CacheProvider(\"EngageFeed\")]\npublic partial class EngageFeedCacheProvider { }\n</code></pre> <p>This generates:</p> <pre><code>sp =&gt; new EngageFeedCacheProvider(\n    sp.GetRequiredService&lt;ICacheProvider&gt;(),\n    sp.GetRequiredService&lt;ILogger&lt;EngageFeedCacheProvider&gt;&gt;(),\n    sp.GetRequiredService&lt;IOptions&lt;CacheOptions&gt;&gt;())\n</code></pre>"},{"location":"advanced-usage/#parameterless-constructor-override","title":"Parameterless Constructor Override","text":"<p>Use <code>[DeferToContainer]</code> without parameters if the other generator will add a parameterless constructor or you want to ensure Needlr doesn't inspect the actual constructors:</p> <pre><code>[DeferToContainer]  // Empty - no constructor parameters\n[SomeOtherGeneratorAttribute]\npublic partial class SimpleService { }\n</code></pre>"},{"location":"advanced-usage/#compile-time-validation","title":"Compile-Time Validation","text":"<p>If the declared parameter types don't match the actual generated constructor, the build will fail with a compile error. This provides compile-time safety - you'll know immediately if the other generator changes its output.</p>"},{"location":"advanced-usage/#critical-the-attribute-must-be-in-your-original-source","title":"\u26a0\ufe0f Critical: The Attribute Must Be in Your Original Source","text":"<p>The <code>[DeferToContainer]</code> attribute MUST be placed on your original partial class declaration - NOT in generated code.</p> <p>Source generators run in isolation and cannot see output from other generators. If another generator adds <code>[DeferToContainer]</code> to its generated output, Needlr's generator will never see it.</p> <pre><code>// \u274c WRONG - Placing attribute in generated code doesn't work!\n// CacheProviderGenerator.g.cs (GENERATED FILE)\n[DeferToContainer(typeof(ICacheProvider))]  // Needlr can't see this!\npublic sealed partial class EngageFeedCacheProvider(ICacheProvider _cacheProvider) { }\n\n// \u2705 CORRECT - Place attribute in your original source file\n// EngageFeedCacheProvider.cs (YOUR FILE)\n[DeferToContainer(typeof(ICacheProvider))]  // Needlr sees this!\n[CacheProvider(\"EngageFeed\")]\npublic partial class EngageFeedCacheProvider { }\n</code></pre> <p>The analyzer <code>NDLRCOR003</code> will detect and report an error if it finds <code>[DeferToContainer]</code> in generated code. See the NDLRCOR003 documentation for more details.</p>"},{"location":"advanced-usage/#when-to-use-defertocontainer","title":"When to Use DeferToContainer","text":"<p>Use <code>[DeferToContainer]</code> when:</p> <ol> <li>Another source generator adds a constructor to your partial class</li> <li>The constructor has dependencies that need to be resolved from DI</li> <li>You're using source generation (<code>.UsingSourceGen()</code>) - reflection-based discovery doesn't have this limitation</li> </ol> <p>You do NOT need <code>[DeferToContainer]</code> when:</p> <ol> <li>Using <code>.UsingReflection()</code> - it discovers constructors at runtime</li> <li>Your class has an explicit constructor in your source code</li> <li>The other generator doesn't add constructor parameters</li> </ol>"},{"location":"advanced-usage/#example-fusioncache-integration","title":"Example: FusionCache Integration","text":"<p>Here's a complete example integrating with a hypothetical <code>CacheProviderGenerator</code>:</p> <pre><code>// In your cache providers project\nnamespace MyApp.Caching;\n\npublic interface ICacheProvider { }\n\n// The CacheProviderGenerator will add:\n// public sealed partial class EngageFeedCacheProvider(ICacheProvider _cacheProvider)\n\n[DeferToContainer(typeof(ICacheProvider))]\n[CacheProvider(\"EngageFeed\")]\npublic partial class EngageFeedCacheProvider { }\n\n[DeferToContainer(typeof(ICacheProvider), typeof(ILogger&lt;UserProfileCacheProvider&gt;))]\n[CacheProvider(\"UserProfile\")]\npublic partial class UserProfileCacheProvider { }\n</code></pre> <pre><code>// In your host application\nvar app = new Syringe()\n    .UsingSourceGen()\n    .ForWebApplication()\n    .BuildWebApplication();\n\n// Both cache providers are correctly registered with their dependencies resolved\n</code></pre>"},{"location":"advanced-usage/#debugging-service-registrations","title":"Debugging Service Registrations","text":"<p>Needlr provides diagnostic tools to help you understand and debug your service registrations.</p>"},{"location":"advanced-usage/#dumping-all-registrations","title":"Dumping All Registrations","text":"<p>Use the <code>Dump()</code> extension method to get a formatted view of all registrations:</p> <pre><code>using NexusLabs.Needlr;\n\nvar services = new ServiceCollection();\nservices.AddTransient&lt;IMyService, MyService&gt;();\nservices.AddSingleton&lt;ICache, MemoryCache&gt;();\nservices.AddScoped&lt;IDbContext, AppDbContext&gt;();\n\n// Dump all registrations to console\nConsole.WriteLine(services.Dump());\n</code></pre> <p>Output: <pre><code>\u2550\u2550\u2550 Service Registrations (3 registrations) \u2550\u2550\u2550\n\n\u250c\u2500 ICache\n\u2502  Lifetime: Singleton\n\u2502  Implementation: MemoryCache\n\u2514\u2500\n\n\u250c\u2500 IDbContext\n\u2502  Lifetime: Scoped\n\u2502  Implementation: AppDbContext\n\u2514\u2500\n\n\u250c\u2500 IMyService\n\u2502  Lifetime: Transient\n\u2502  Implementation: MyService\n\u2514\u2500\n</code></pre></p>"},{"location":"advanced-usage/#filtering-and-grouping","title":"Filtering and Grouping","text":"<p>Use <code>DumpOptions</code> to filter and organize the output:</p> <pre><code>// Only show singletons\nConsole.WriteLine(services.Dump(new DumpOptions \n{ \n    LifetimeFilter = ServiceLifetime.Singleton \n}));\n\n// Group by lifetime\nConsole.WriteLine(services.Dump(new DumpOptions \n{ \n    GroupByLifetime = true \n}));\n\n// Filter by service type\nConsole.WriteLine(services.Dump(new DumpOptions \n{ \n    ServiceTypeFilter = t =&gt; t.Namespace?.Contains(\"MyApp\") == true \n}));\n</code></pre>"},{"location":"advanced-usage/#detailed-registration-info","title":"Detailed Registration Info","text":"<p>Get detailed information about a specific registration:</p> <pre><code>var registrations = services.GetServiceRegistrations();\nforeach (var reg in registrations)\n{\n    Console.WriteLine(reg.ToDetailedString());\n}\n</code></pre>"},{"location":"advanced-usage/#dumping-from-serviceprovider","title":"Dumping from ServiceProvider","text":"<p>You can also dump from a built service provider (requires <code>IServiceCollection</code> to be registered):</p> <pre><code>var provider = new Syringe()\n    .UsingSourceGen()\n    .BuildServiceProvider();\n\n// Needlr automatically registers IServiceCollection, so Dump() works\nConsole.WriteLine(provider.Dump());\n</code></pre>"},{"location":"advanced-usage/#container-verification","title":"Container Verification","text":"<p>Needlr provides verification APIs to detect common configuration issues at startup.</p>"},{"location":"advanced-usage/#detecting-lifetime-mismatches","title":"Detecting Lifetime Mismatches","text":"<p>A lifetime mismatch (also called \"captive dependency\") occurs when a longer-lived service depends on a shorter-lived service. For example, a Singleton that depends on a Scoped service will \"capture\" that scoped instance, causing it to live for the entire application lifetime instead of the intended scope.</p> <pre><code>using NexusLabs.Needlr;\n\nvar services = new ServiceCollection();\nservices.AddScoped&lt;IDbContext, AppDbContext&gt;();        // Scoped\nservices.AddSingleton&lt;ICacheService, CacheService&gt;();  // Singleton depends on IDbContext\n\n// Detect mismatches\nvar mismatches = services.DetectLifetimeMismatches();\n\nforeach (var mismatch in mismatches)\n{\n    Console.WriteLine(mismatch.ToDetailedString());\n}\n</code></pre> <p>Output: <pre><code>\u250c\u2500 Lifetime Mismatch\n\u2502  ICacheService (Singleton)\n\u2502    \u2514\u2500 depends on \u2500\u25b6 IDbContext (Scoped)\n\u2502\n\u2502  Problem: Singleton service will capture Scoped dependency\n\u2502  Fix: Change ICacheService to Scoped,\n\u2502       or change IDbContext to Singleton,\n\u2502       or inject IServiceScopeFactory instead.\n\u2514\u2500\n</code></pre></p>"},{"location":"advanced-usage/#lifetime-hierarchy","title":"Lifetime Hierarchy","text":"<p>From longest to shortest lifetime: 1. Singleton - Lives for entire application lifetime 2. Scoped - Lives for the scope/request lifetime 3. Transient - New instance every time</p> <p>A mismatch is detected when a service depends on another with a shorter lifetime:</p> <ul> <li>\u274c Singleton \u2192 Scoped (mismatch)</li> <li>\u274c Singleton \u2192 Transient (mismatch)</li> <li>\u274c Scoped \u2192 Transient (mismatch)</li> <li>\u2705 Scoped \u2192 Singleton (ok)</li> <li>\u2705 Transient \u2192 anything (ok)</li> </ul>"},{"location":"advanced-usage/#automatic-verification-with-verify","title":"Automatic Verification with Verify()","text":"<p>Use the <code>Verify()</code> extension method to automatically detect and handle issues:</p> <pre><code>// Throws ContainerVerificationException on issues (strict mode)\nservices.Verify(VerificationOptions.Strict);\n\n// Warns to console but doesn't throw (default behavior)\nservices.Verify();\n\n// Disable verification (silent mode)\nservices.Verify(VerificationOptions.Disabled);\n\n// Custom configuration\nservices.Verify(new VerificationOptions\n{\n    LifetimeMismatchBehavior = VerificationBehavior.Throw,\n    CircularDependencyBehavior = VerificationBehavior.Warn,\n    IssueReporter = issue =&gt; logger.LogWarning(issue.Message)\n});\n</code></pre>"},{"location":"advanced-usage/#getting-detailed-diagnostics","title":"Getting Detailed Diagnostics","text":"<p>Use <code>VerifyWithDiagnostics()</code> to get a result object instead of throwing:</p> <pre><code>var result = services.VerifyWithDiagnostics();\n\nif (!result.IsValid)\n{\n    Console.WriteLine(result.ToDetailedReport());\n    // \u274c Container verification found 2 issue(s):\n    // \n    // [LifetimeMismatch] Lifetime mismatch: ICacheService (Singleton) depends on IDbContext (Scoped)\n    // ...\n}\n\n// Or throw if needed\nresult.ThrowIfInvalid();\n</code></pre>"},{"location":"advanced-usage/#compile-time-detection","title":"Compile-Time Detection","text":"<p>Needlr includes Roslyn analyzers that detect issues at compile time:</p> <ul> <li>NDLRCOR005: Lifetime mismatch warnings</li> <li>NDLRCOR006: Circular dependency errors</li> </ul> <p>These analyzers work with Needlr's registration attributes (<code>[Singleton]</code>, <code>[Scoped]</code>, <code>[Transient]</code>, <code>[RegisterAs]</code>).</p>"},{"location":"ai-integrations/","title":"AI Integrations","text":"<p>Needlr provides first-class integrations for AI agent frameworks, taking care of function discovery, DI wiring, and factory lifecycle so that you focus on writing agent logic rather than plumbing.</p> <p>Two integrations are supported:</p> <ul> <li>Microsoft Agent Framework (<code>NexusLabs.Needlr.AgentFramework</code>) \u2014 for <code>[AgentFunction]</code>-annotated tools wired into <code>AIAgent</code> instances via <code>Microsoft.Extensions.AI</code></li> <li>Semantic Kernel (<code>NexusLabs.Needlr.SemanticKernel</code>) \u2014 for <code>[KernelFunction]</code>-annotated plugin classes wired into a <code>Kernel</code> via <code>Microsoft.SemanticKernel</code></li> </ul> <p>Both integrations follow the same two-layer architecture that is explained below.</p>"},{"location":"ai-integrations/#the-two-layer-model","title":"The Two-Layer Model","text":"<p>Understanding what Needlr owns vs. what the upstream framework owns is the key to understanding which parts are AOT-compatible and which are not.</p>"},{"location":"ai-integrations/#layer-1-discovery-needlr","title":"Layer 1 \u2014 Discovery (Needlr)","text":"<p>What: Identifying which types in an assembly contain annotated methods.</p> <p>For MAF this means finding classes with <code>[AgentFunction]</code> methods. For SK this means finding classes with <code>[KernelFunction]</code> methods. This is purely a type-collection step \u2014 no instances are created, no schemas are built.</p> <p>Needlr provides two paths for this layer:</p> Path How AOT safe? Source generation At compile time, a Roslyn generator scans for the attribute and emits a static <code>IReadOnlyList&lt;Type&gt;</code> \u2705 Yes Reflection At runtime, assemblies are scanned for the attribute \u274c No (<code>[RequiresUnreferencedCode]</code>) <p>The reflection overloads (<code>AddAgentFunctionsFromAssemblies()</code>, <code>AddSemanticKernelPluginsFromAssemblies()</code>, etc.) are annotated with <code>[RequiresUnreferencedCode]</code> and <code>[RequiresDynamicCode]</code> to surface this at the call site.</p>"},{"location":"ai-integrations/#layer-2-instantiation-upstream-framework","title":"Layer 2 \u2014 Instantiation (upstream framework)","text":"<p>What: Taking the discovered types and turning them into actual tool objects with JSON schemas that the LLM understands.</p> <p>For MAF this is <code>AIFunctionFactory.Create(MethodInfo, target)</code> from <code>Microsoft.Extensions.AI</code>. For SK this is <code>KernelPlugin.CreateFromObject(instance)</code> from <code>Microsoft.SemanticKernel</code>. Both use reflection internally to build JSON schemas from method signatures.</p> <p>This layer is not controlled by Needlr. Both MAF and SK use reflection here regardless of which Needlr discovery path you choose. Neither <code>Microsoft.Extensions.AI</code> nor <code>Microsoft.SemanticKernel</code> are fully AOT-safe for tool/plugin schema generation at this time.</p>"},{"location":"ai-integrations/#what-this-means-in-practice","title":"What this means in practice","text":"<p>If you use the source gen path, you eliminate reflection from Layer 1 (Needlr's responsibility). You do not eliminate reflection from Layer 2 (the upstream framework's responsibility). The practical effect is:</p> <ul> <li>No <code>[RequiresUnreferencedCode]</code> warnings from Needlr's own code</li> <li>Faster startup (no runtime assembly scanning)</li> <li>The upstream framework may still emit its own reflection-related warnings</li> </ul> <p>If full AOT support is important to you, watch the upstream framework's own AOT roadmap \u2014 Needlr will update its Layer 1 surface to match as those paths become available.</p>"},{"location":"ai-integrations/#microsoft-agent-framework","title":"Microsoft Agent Framework","text":""},{"location":"ai-integrations/#packages","title":"Packages","text":"<pre><code>&lt;!-- Runtime --&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.AgentFramework\" /&gt;\n\n&lt;!-- Source generator (add as analyzer \u2014 no runtime dep) --&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.AgentFramework.Generators\"\n                  OutputItemType=\"Analyzer\"\n                  ReferenceOutputAssembly=\"false\" /&gt;\n</code></pre>"},{"location":"ai-integrations/#quick-start","title":"Quick start","text":"<pre><code>using NexusLabs.Needlr.AgentFramework;\nusing NexusLabs.Needlr.Injection;\nusing NexusLabs.Needlr.Injection.Reflection;\n\ninternal sealed class WeatherTools\n{\n    [AgentFunction]\n    [Description(\"Gets the current temperature for a city.\")]\n    public string GetTemperature(string city) =&gt; $\"22\u00b0C in {city}\";\n}\n\nvar agentFactory = new Syringe()\n    .UsingReflection()\n    .UsingAgentFramework(af =&gt; af\n        .UsingChatClient(sp =&gt; sp.GetRequiredService&lt;IChatClient&gt;())\n        .AddAgentFunctionsFromAssemblies())   // reflection path\n    .BuildServiceProvider(configuration)\n    .GetRequiredService&lt;IAgentFactory&gt;();\n\nvar agent = agentFactory.CreateAgent(opts =&gt;\n{\n    opts.Instructions = \"You are a helpful weather assistant.\";\n    opts.FunctionTypes = [typeof(WeatherTools)];\n});\n</code></pre>"},{"location":"ai-integrations/#source-gen-path-recommended","title":"Source gen path (recommended)","text":"<p>When <code>NexusLabs.Needlr.AgentFramework.Generators</code> is referenced as an analyzer, it runs at compile time and emits a class in your assembly's namespace:</p> <pre><code>// Generated: AgentFrameworkFunctionRegistry.g.cs\nnamespace YourAssemblyName.Generated;\n\npublic static class AgentFrameworkFunctionRegistry\n{\n    public static IReadOnlyList&lt;Type&gt; AllFunctionTypes { get; } = new Type[]\n    {\n        typeof(WeatherTools),\n        // ... all other types with [AgentFunction] methods\n    };\n}\n</code></pre> <p>Pass this to <code>AddAgentFunctionsFromGenerated</code> instead of the assembly scanning overload:</p> <pre><code>.UsingAgentFramework(af =&gt; af\n    .UsingChatClient(sp =&gt; sp.GetRequiredService&lt;IChatClient&gt;())\n    .AddAgentFunctionsFromGenerated(\n        YourAssemblyName.Generated.AgentFrameworkFunctionRegistry.AllFunctionTypes))\n</code></pre> <p><code>AddAgentFunctionsFromGenerated</code> carries no <code>[RequiresUnreferencedCode]</code> annotation \u2014 it is the AOT-safe discovery path.</p>"},{"location":"ai-integrations/#per-agent-tool-scoping","title":"Per-agent tool scoping","text":"<p>Multiple agents can be created from the same <code>IAgentFactory</code>, each with a tailored subset of the registered tools:</p> <pre><code>// Agent 1: geography tools only\nvar geographyAgent = agentFactory.CreateAgent(opts =&gt;\n{\n    opts.Instructions = \"You are a geography expert.\";\n    opts.FunctionTypes = [typeof(GeographyFunctions)];\n});\n\n// Agent 2: no tools (pure reasoning)\nvar writerAgent = agentFactory.CreateAgent(opts =&gt;\n{\n    opts.Instructions = \"You are a technical writer.\";\n    opts.FunctionTypes = [];\n});\n\n// Agent 3: all registered tools (default when FunctionTypes is null)\nvar generalAgent = agentFactory.CreateAgent();\n</code></pre> <p><code>FunctionTypes = null</code> means all registered types are available. <code>FunctionTypes = []</code> means no tools.</p>"},{"location":"ai-integrations/#semantic-kernel","title":"Semantic Kernel","text":""},{"location":"ai-integrations/#packages_1","title":"Packages","text":"<pre><code>&lt;!-- Runtime --&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.SemanticKernel\" /&gt;\n\n&lt;!-- Source generator (add as analyzer \u2014 no runtime dep) --&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.SemanticKernel.Generators\"\n                  OutputItemType=\"Analyzer\"\n                  ReferenceOutputAssembly=\"false\" /&gt;\n</code></pre>"},{"location":"ai-integrations/#quick-start_1","title":"Quick start","text":"<pre><code>using NexusLabs.Needlr.Injection;\nusing NexusLabs.Needlr.Injection.Reflection;\nusing NexusLabs.Needlr.SemanticKernel;\n\ninternal sealed class WeatherPlugin\n{\n    [KernelFunction]\n    [Description(\"Gets the current temperature for a city.\")]\n    public string GetTemperature(string city) =&gt; $\"22\u00b0C in {city}\";\n}\n\nvar kernelFactory = new Syringe()\n    .UsingReflection()\n    .UsingSemanticKernel(sk =&gt; sk\n        .Configure(opts =&gt; opts.KernelBuilderFactory = sp =&gt;\n            Kernel.CreateBuilder()\n                .AddAzureOpenAIChatCompletion(deploymentName, endpoint, apiKey))\n        .AddSemanticKernelPluginsFromAssemblies())   // reflection path\n    .BuildServiceProvider(configuration)\n    .GetRequiredService&lt;IKernelFactory&gt;();\n\nvar kernel = kernelFactory.CreateKernel();\nvar result = await kernel.InvokePromptAsync(\"What is the weather today?\");\n</code></pre>"},{"location":"ai-integrations/#source-gen-path-recommended_1","title":"Source gen path (recommended)","text":"<p>When <code>NexusLabs.Needlr.SemanticKernel.Generators</code> is referenced as an analyzer, it emits a compile-time registry:</p> <pre><code>// Generated: SemanticKernelPlugins.g.cs\nnamespace YourAssemblyName.Generated;\n\npublic static class KernelPluginRegistry\n{\n    public static IReadOnlyList&lt;(Type PluginType, bool IsStatic)&gt; Entries { get; } = new (Type, bool)[]\n    {\n        (typeof(WeatherPlugin), false),\n        // ...\n    };\n}\n</code></pre> <p>Pass this to <code>AddSemanticKernelPluginsFromGenerated</code>:</p> <pre><code>.UsingSemanticKernel(sk =&gt; sk\n    .Configure(opts =&gt; opts.KernelBuilderFactory = sp =&gt; ...)\n    .AddSemanticKernelPluginsFromGenerated(\n        YourAssemblyName.Generated.KernelPluginRegistry.Entries))\n</code></pre>"},{"location":"ai-integrations/#multi-agent-orchestration","title":"Multi-Agent Orchestration","text":"<p>Needlr extends the IoC principle from the tool layer upward to the agent and topology layers. Agents are declared as plain C# classes with attributes; Needlr discovers them, builds the workflow graph, and emits source-generated factory methods. Adding a new agent role means adding a class, not editing orchestration wiring.</p>"},{"location":"ai-integrations/#packages_2","title":"Packages","text":"<pre><code>&lt;!-- Runtime: agents, workflows, termination conditions --&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.AgentFramework\" /&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.AgentFramework.Workflows\" /&gt;\n\n&lt;!-- Source generator (analyzer \u2014 no runtime dep) --&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.AgentFramework.Generators\"\n                  OutputItemType=\"Analyzer\"\n                  ReferenceOutputAssembly=\"false\" /&gt;\n\n&lt;!-- Roslyn analyzers (optional but recommended) --&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.AgentFramework.Analyzers\"\n                  OutputItemType=\"Analyzer\"\n                  ReferenceOutputAssembly=\"false\" /&gt;\n</code></pre>"},{"location":"ai-integrations/#declaring-agents","title":"Declaring agents","text":"<p>The <code>[NeedlrAiAgent]</code> attribute marks a class as a registered agent. It accepts <code>Instructions</code>, <code>Description</code>, <code>FunctionTypes</code>, and <code>FunctionGroups</code> to configure the agent's identity and tool access.</p> <pre><code>[NeedlrAiAgent(\n    Instructions = \"You are a geography expert. Answer questions about countries and cities.\",\n    Description  = \"Handles geographic queries\")]\npublic class GeographyAgent { }\n\n[NeedlrAiAgent(\n    Instructions = \"You are a travel writer. Produce engaging summaries.\",\n    FunctionGroups = [\"travel\"])]           // scoped to the \"travel\" function group\npublic class TravelWriterAgent { }\n\n[NeedlrAiAgent(\n    Instructions = \"You triage requests and route them.\",\n    FunctionTypes = [])]                    // empty array \u2192 no tools (pure routing)\npublic class TriageAgent { }\n</code></pre> <p>Needle discovers all <code>[NeedlrAiAgent]</code> classes in the compilation and emits a static agent registry at build time.</p>"},{"location":"ai-integrations/#function-groups","title":"Function groups","text":"<p><code>[AgentFunctionGroup]</code> buckets related tool methods under a named group. Agents reference groups by name via <code>FunctionGroups</code>, keeping tool scoping declarative and typo-detectable (NDLRMAF005).</p> <pre><code>[AgentFunctionGroup(\"geography\")]\ninternal sealed class GeographyFunctions\n{\n    [AgentFunction]\n    [Description(\"Returns countries the user has lived in.\")]\n    public IReadOnlyList&lt;string&gt; GetCountriesLived() =&gt; [\"Canada\", \"USA\"];\n\n    [AgentFunction]\n    [Description(\"Returns the user's favourite cities.\")]\n    public IReadOnlyList&lt;string&gt; GetFavoriteCities() =&gt; [\"Toronto\", \"New York\"];\n}\n</code></pre> <p>Scoping rules:</p> <code>FunctionTypes</code> <code>FunctionGroups</code> Tools agent receives <code>null</code> <code>null</code> All registered types (default) <code>[]</code> (empty) \u2014 No tools <code>[typeof(T)]</code> \u2014 Only <code>T</code> \u2014 <code>[\"group\"]</code> All types in the named group"},{"location":"ai-integrations/#topology-types","title":"Topology types","text":"<p>Needlr supports three topology patterns. Each is declared with attributes; the source generator emits a corresponding typed factory method on <code>IWorkflowFactory</code>.</p>"},{"location":"ai-integrations/#handoff","title":"Handoff","text":"<p>One agent handles a request and optionally routes it to another agent when a condition is met. The routing decision is made by the LLM at runtime; the <code>When</code> parameter describes the condition as a natural language hint for the model.</p> <pre><code>[NeedlrAiAgent(Instructions = \"Triage the request and hand off.\")]\n[AgentHandoffsTo(typeof(GeographyAgent), When = \"The question is about geography\")]\n[AgentHandoffsTo(typeof(TravelWriterAgent), When = \"The question is about travel writing\")]\npublic class TriageAgent { }\n</code></pre> <p>Generator emits: <code>factory.CreateTriageAgentHandoffWorkflow()</code></p>"},{"location":"ai-integrations/#group-chat","title":"Group chat","text":"<p>Multiple agents collaborate in a shared round-robin conversation. All participants are peers; the workflow runs for up to <code>maxIterations</code> turns unless a termination condition triggers earlier.</p> <pre><code>[NeedlrAiAgent(Instructions = \"Review code for correctness.\")]\n[AgentGroupChatMember(\"code-review\")]\npublic class ReviewerAgent { }\n\n[NeedlrAiAgent(Instructions = \"Author code changes based on review feedback.\")]\n[AgentGroupChatMember(\"code-review\")]\npublic class AuthorAgent { }\n</code></pre> <p>Generator emits: <code>factory.CreateCodeReviewGroupChatWorkflow()</code></p> <p>A group chat requires at least two members (NDLRMAF002).</p>"},{"location":"ai-integrations/#sequential-pipeline","title":"Sequential pipeline","text":"<p>Agents run in a fixed order, each receiving the prior agent's output. Use <code>Order</code> to control the sequence.</p> <pre><code>[NeedlrAiAgent(Instructions = \"Extract key facts from the source material.\")]\n[AgentSequenceMember(\"content-pipeline\", Order = 1)]\npublic class ContentExtractorAgent { }\n\n[NeedlrAiAgent(Instructions = \"Enrich the extracted facts with examples.\")]\n[AgentSequenceMember(\"content-pipeline\", Order = 2)]\npublic class ContentEnricherAgent { }\n\n[NeedlrAiAgent(Instructions = \"Publish the enriched content.\")]\n[AgentSequenceMember(\"content-pipeline\", Order = 3)]\npublic class ContentPublisherAgent { }\n</code></pre> <p>Generator emits: <code>factory.CreateContentPipelineSequentialWorkflow()</code></p>"},{"location":"ai-integrations/#running-workflows","title":"Running workflows","text":"<p>Obtain an <code>IWorkflowFactory</code> from DI and use the generated extension methods. The factory resolves and wires agents automatically.</p> <pre><code>var factory = serviceProvider.GetRequiredService&lt;IWorkflowFactory&gt;();\n\nvar workflow = factory.CreateTriageAgentHandoffWorkflow();\nvar responses = await workflow.RunAsync(\"Which countries has Nick visited?\");\n// responses: IReadOnlyDictionary&lt;string, string&gt; (agentId \u2192 text)\n</code></pre> <p><code>RunAsync</code> is an extension method from <code>NexusLabs.Needlr.AgentFramework.Workflows</code> that wraps the underlying MAF streaming execution.</p>"},{"location":"ai-integrations/#termination-conditions","title":"Termination conditions","text":"<p>Termination conditions let you stop a workflow early when a content-based criterion is met. Two layers are available:</p> <p>Layer 1 \u2014 group chat (per-agent, fires before the next turn): <code>[AgentTerminationCondition]</code> on a group chat member. The condition is evaluated inside MAF's group chat loop after each agent response. When it triggers, the current turn is the last one \u2014 the next agent is never called.</p> <pre><code>[AgentGroupChatMember(\"code-review\")]\n[AgentTerminationCondition(typeof(KeywordTerminationCondition), \"APPROVED\")]\npublic class ReviewerAgent { }\n</code></pre> <p>Layer 2 \u2014 workflow-level (fires after a response is fully emitted): <code>[WorkflowRunTerminationCondition]</code> on any agent. The condition is evaluated in Needlr's <code>RunAsync</code> event loop after the agent's complete response is received. Works for all topology types; for group chat, prefer Layer 1 (NDLRMAF011).</p> <pre><code>[AgentSequenceMember(\"content-pipeline\", Order = 1)]\n[WorkflowRunTerminationCondition(typeof(KeywordTerminationCondition), \"EXTRACTION_FAILED\")]\npublic class ContentExtractorAgent { }\n</code></pre> <p>When an agent carries <code>[WorkflowRunTerminationCondition]</code>, the generator emits a paired <code>Run*Async</code> method that packages creation and execution together with the declared conditions already wired in:</p> <pre><code>// Generated Run*Async bundles conditions automatically\nvar responses = await factory.RunContentPipelineSequentialWorkflowAsync(message);\n</code></pre> <p>Built-in conditions: <code>KeywordTerminationCondition</code>, <code>RegexTerminationCondition</code>. Custom conditions implement <code>IWorkflowTerminationCondition</code>.</p>"},{"location":"ai-integrations/#topology-graph-diagnostic","title":"Topology graph diagnostic","text":"<p>Set <code>NeedlrDiagnostics=true</code> in the agent class library's project properties to emit a Mermaid diagram of the agent topology at build time:</p> <pre><code>&lt;PropertyGroup&gt;\n  &lt;NeedlrDiagnostics&gt;true&lt;/NeedlrDiagnostics&gt;\n&lt;/PropertyGroup&gt;\n</code></pre> <p>The diagram is written to <code>bin/{Configuration}/{TFM}/NeedlrDiagnostics/AgentTopologyGraph.md</code> and visualises all declared handoff, group chat, and sequential topologies in the compilation.</p>"},{"location":"ai-integrations/#philosophy-ioc-for-ai-components","title":"Philosophy: IoC for AI Components","text":"<p>Needlr applies the same inversion-of-control principle to AI components that a DI container applies to services. Rather than manually creating tool objects and passing them to an agent, you declare what a method is (<code>[AgentFunction]</code> / <code>[KernelFunction]</code>) and Needlr assembles the tools automatically. The component declares itself; the framework wires it.</p> <p>This principle now applies at three layers:</p> <ul> <li>Tool layer: methods are discovered, schema-built, and injected into the right agent or kernel instance</li> <li>Agent layer: agent definitions (instructions, tool groups, name) are declared as types, auto-discovered, and instantiated from the registry \u2014 the same pattern <code>[AgentFunction]</code> establishes, one level up</li> <li>Topology layer: relationships between agents are declared as attributes; Needlr builds the orchestration graph and emits typed factory methods automatically</li> </ul> <p>Adding a new agent role to a system means adding a class. Adding it to a topology means adding an attribute. The orchestration wiring is owned by the framework, not the application \u2014 the same promise Needlr delivers for services.</p>"},{"location":"articles/","title":"Articles &amp; Blog Posts","text":"<p>Blog posts and articles about Needlr from Dev Leader.</p> <p>Stay Updated</p> <p>Follow the Needlr tag on Dev Leader for the latest articles.</p> <p></p>"},{"location":"articles/#weekly-recap-microsoft-agent-framework-semantic-kernel-and-builder-patterns-in-c-feb-2026","title":"Weekly Recap: Microsoft Agent Framework, Semantic Kernel, and Builder Patterns in C# [Feb 2026]","text":"<p>Published: March 01, 2026</p> <p>This week covers the Microsoft Agent Framework in C# -- from core AIAgent abstractions to AgentSessions and function tools -- plus Semantic Kernel agents and plugins, Builder pattern deep dives, and GitHub Copilot SDK development. Also included: new videos on software engineering planning and hiring insights.</p> <p>Tags: <code>.NET</code>, <code>AI</code>, <code>AI agents</code>, <code>AI orchestration</code>, <code>AgentGroupChat</code></p> <p></p>"},{"location":"articles/#assembly-scanning-in-needlr-filtering-and-organizing-type-discovery","title":"Assembly Scanning in Needlr: Filtering and Organizing Type Discovery","text":"<p>Published: February 23, 2026</p> <p>Learn how to control assembly scanning in Needlr, including filtering assemblies, controlling which types get discovered, and organizing type registration in .NET applications.</p> <p>Tags: <code>assembly scanning</code>, <code>dependency injection</code>, <code>type filtering</code>, <code>.NET</code>, <code>assembly providers</code></p> <p></p>"},{"location":"articles/#hosted-services-with-needlr-background-workers-and-lifecycle-management","title":"Hosted Services with Needlr: Background Workers and Lifecycle Management","text":"<p>Published: February 21, 2026</p> <p>Learn how to use hosted services and background workers with Needlr, including automatic discovery of IHostedService and BackgroundService implementations.</p> <p>Tags: <code>hosted services</code>, <code>background workers</code>, <code>IHostedService</code>, <code>BackgroundService</code>, <code>.NET</code></p> <p></p>"},{"location":"articles/#keyed-services-in-needlr-managing-multiple-implementations","title":"Keyed Services in Needlr: Managing Multiple Implementations","text":"<p>Published: February 19, 2026</p> <p>Learn how to use keyed services in Needlr to register and resolve multiple implementations of the same interface using .NET 8's keyed service support.</p> <p>Tags: <code>keyed services</code>, <code>dependency injection</code>, <code>multiple implementations</code>, <code>.NET 8</code>, <code>C#</code></p> <p></p>"},{"location":"articles/#decorator-pattern-in-c-with-needlr-adding-cross-cutting-concerns","title":"Decorator Pattern in C# with Needlr: Adding Cross-Cutting Concerns","text":"<p>Published: February 17, 2026</p> <p>Learn how to implement the decorator pattern in C# using Needlr's automatic decorator discovery, including the DecoratorFor attribute and manual decorator wiring.</p> <p>Tags: <code>decorator pattern</code>, <code>C#</code>, <code>dependency injection</code>, <code>cross-cutting concerns</code>, <code>DecoratorFor attribute</code></p> <p></p>"},{"location":"articles/#plugin-architecture-with-needlr-in-net-building-modular-applications","title":"Plugin Architecture with Needlr in .NET: Building Modular Applications","text":"<p>Published: February 15, 2026</p> <p>Learn how to build modular .NET applications using Needlr's plugin system, including IServiceCollectionPlugin, IWebApplicationPlugin, and automatic plugin discovery.</p> <p>Tags: <code>plugin architecture</code>, <code>modular applications</code>, <code>.NET</code>, <code>dependency injection</code>, <code>IServiceCollectionPlugin</code></p> <p></p>"},{"location":"articles/#aspnet-core-with-needlr-simplified-web-application-setup","title":"ASP.NET Core with Needlr: Simplified Web Application Setup","text":"<p>Published: February 13, 2026</p> <p>Learn how to set up ASP.NET Core web applications with Needlr for dependency injection, including ForWebApplication, minimal APIs, and middleware configuration.</p> <p>Tags: <code>ASP.NET Core</code>, <code>dependency injection</code>, <code>web applications</code>, <code>minimal APIs</code>, <code>.NET</code></p> <p></p>"},{"location":"articles/#the-syringe-class-needlrs-fluent-api-explained","title":"The Syringe Class: Needlr's Fluent API Explained","text":"<p>Published: February 11, 2026</p> <p>Deep dive into Needlr's Syringe class and its fluent API for configuring dependency injection, discovery strategies, and type registration in C#.</p> <p>Tags: <code>Syringe class</code>, <code>fluent API</code>, <code>dependency injection</code>, <code>C#</code>, <code>.NET</code></p> <p></p>"},{"location":"articles/#automatic-service-discovery-in-c-with-needlr-how-it-works","title":"Automatic Service Discovery in C# with Needlr: How It Works","text":"<p>Published: February 09, 2026</p> <p>Learn how Needlr's automatic service discovery works in C# with convention-based registration, type scanning, and the DoNotAutoRegister attribute for .NET applications.</p> <p>Tags: <code>automatic service discovery</code>, <code>dependency injection</code>, <code>C#</code>, <code>convention-based registration</code>, <code>.NET</code></p> <p></p>"},{"location":"articles/#source-generation-vs-reflection-in-needlr-choosing-the-right-approach","title":"Source Generation vs Reflection in Needlr: Choosing the Right Approach","text":"<p>Published: February 07, 2026</p> <p>Compare Needlr's source generation and reflection strategies for dependency injection in C# to choose the right approach for AOT, performance, and flexibility.</p> <p>Tags: <code>source generation</code>, <code>reflection</code>, <code>dependency injection</code>, <code>C#</code>, <code>AOT</code></p> <p></p>"},{"location":"articles/#getting-started-with-needlr-fluent-di-for-net-applications","title":"Getting Started with Needlr: Fluent DI for .NET Applications","text":"<p>Published: February 05, 2026</p> <p>Learn how to install and configure Needlr for dependency injection in .NET with step-by-step setup, NuGet packages, and your first fluent DI application.</p> <p>Tags: <code>dependency injection</code>, <code>.NET</code>, <code>getting started</code>, <code>C#</code>, <code>IServiceCollection</code></p> <p></p>"},{"location":"articles/#automatic-dependency-injection-in-c-the-complete-guide-to-needlr","title":"Automatic Dependency Injection in C#: The Complete Guide to Needlr","text":"<p>Published: February 03, 2026</p> <p>Learn how Needlr simplifies dependency injection in C# with automatic service discovery, source generation, and a fluent API for .NET applications.</p> <p>Tags: <code>dependency injection</code>, <code>C#</code>, <code>source generation</code>, <code>.NET</code>, <code>IServiceCollection</code></p> <p>This page is automatically generated from the Dev Leader blog.</p>"},{"location":"benchmarks/","title":"Benchmarks","text":"<p>Performance comparison between source-generated and reflection-based dependency injection.</p> <p>Key Takeaway</p> <p>Source generation provides faster container build times compared to reflection. Service resolution performance is identical once the container is built.</p>"},{"location":"benchmarks/#summary","title":"Summary","text":"<p>Loading benchmark results...</p>"},{"location":"benchmarks/#running-benchmarks-locally","title":"Running Benchmarks Locally","text":"<pre><code>cd src/NexusLabs.Needlr.Benchmarks\ndotnet run -c Release -- --filter '*Build*'\n</code></pre> <p>To run all benchmarks:</p> <pre><code>dotnet run -c Release -- --filter '*'\n</code></pre>"},{"location":"benchmarks/#ci-integration","title":"CI Integration","text":"<p>Benchmarks run automatically:</p> <ul> <li>Weekly: Every Sunday at 3am UTC (if code has changed)</li> <li>On-demand: Via workflow dispatch</li> </ul> <p>Results are published to this page after each run.</p>"},{"location":"benchmarks/#methodology","title":"Methodology","text":"<p>All benchmarks use BenchmarkDotNet with:</p> <ul> <li>ShortRun job: 3 warmup iterations, 3 target iterations</li> <li>Memory diagnostics: Tracks allocations per operation</li> <li>Baseline comparison: Reflection is always the baseline</li> </ul> <p>Each benchmark class follows strict rules:</p> <ol> <li>One baseline per class (reflection approach)</li> <li>All methods in a class compare the same scenario</li> <li>Benchmark methods contain only what needs to be measured</li> </ol>"},{"location":"breadcrumbs/","title":"Breadcrumb Documentation","text":"<p>Needlr's source generator can include helpful documentation comments (breadcrumbs) in generated code to help developers understand why and how code was generated. This is particularly useful for debugging, learning, and working with AI assistants.</p>"},{"location":"breadcrumbs/#overview","title":"Overview","text":"<p>Breadcrumbs are self-documenting comments embedded in generated source code that explain:</p> <ul> <li>What triggered the code generation</li> <li>Source file locations of discovered types</li> <li>Lifetime configurations (Singleton, Scoped, Transient)</li> <li>Interceptor chains and their execution order</li> <li>Decorator chains and their order</li> </ul>"},{"location":"breadcrumbs/#breadcrumb-levels","title":"Breadcrumb Levels","text":"<p>Needlr supports three breadcrumb levels:</p> Level Description Use Case <code>None</code> Only <code>// &lt;auto-generated/&gt;</code> header Production builds where file size matters <code>Minimal</code> Brief inline comments (default) Normal development <code>Verbose</code> Full context boxes with source paths Debugging or learning how generation works"},{"location":"breadcrumbs/#configuration","title":"Configuration","text":"<p>Set the breadcrumb level using the <code>NeedlrBreadcrumbLevel</code> MSBuild property.</p>"},{"location":"breadcrumbs/#per-project-configuration","title":"Per-Project Configuration","text":"<p>In your <code>.csproj</code> file:</p> <pre><code>&lt;PropertyGroup&gt;\n  &lt;NeedlrBreadcrumbLevel&gt;Verbose&lt;/NeedlrBreadcrumbLevel&gt;\n&lt;/PropertyGroup&gt;\n</code></pre>"},{"location":"breadcrumbs/#solution-wide-configuration","title":"Solution-Wide Configuration","text":"<p>In a <code>Directory.Build.props</code> file at your solution root:</p> <pre><code>&lt;Project&gt;\n  &lt;PropertyGroup&gt;\n    &lt;NeedlrBreadcrumbLevel&gt;Verbose&lt;/NeedlrBreadcrumbLevel&gt;\n  &lt;/PropertyGroup&gt;\n\n  &lt;!-- Import Needlr generator props --&gt;\n  &lt;Import Project=\"$(MSBuildThisFileDirectory)../packages/nexuslabs.needlr.generators/*/build/NexusLabs.Needlr.Generators.props\" \n          Condition=\"Exists('$(MSBuildThisFileDirectory)../packages/nexuslabs.needlr.generators')\" /&gt;\n&lt;/Project&gt;\n</code></pre>"},{"location":"breadcrumbs/#inheritance-and-overrides","title":"Inheritance and Overrides","text":"<p>Child projects automatically inherit the breadcrumb level from parent <code>Directory.Build.props</code> files. Individual projects can override the inherited setting:</p> <pre><code>Solution/\n\u251c\u2500\u2500 Directory.Build.props          # Sets NeedlrBreadcrumbLevel=Minimal (inherited by all)\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 MyApp/\n\u2502   \u2502   \u2514\u2500\u2500 MyApp.csproj           # Inherits Minimal\n\u2502   \u2514\u2500\u2500 MyApp.Debug/\n\u2502       \u2514\u2500\u2500 MyApp.Debug.csproj     # Can override to Verbose\n</code></pre>"},{"location":"breadcrumbs/#output-examples","title":"Output Examples","text":""},{"location":"breadcrumbs/#none-level","title":"None Level","text":"<pre><code>// &lt;auto-generated/&gt;\n#nullable enable\n\nusing System;\nusing System.Collections.Generic;\n\nnamespace MyApp.Generated\n{\n    public static class TypeRegistry\n    {\n        private static readonly InjectableTypeInfo[] _types = new InjectableTypeInfo[]\n        {\n            new InjectableTypeInfo(typeof(global::MyApp.MyService), new Type[] { typeof(global::MyApp.IMyService) }, InjectableLifetime.Singleton),\n        };\n        // ... rest of generated code\n    }\n}\n</code></pre>"},{"location":"breadcrumbs/#minimal-level-default","title":"Minimal Level (Default)","text":"<pre><code>// &lt;auto-generated/&gt;\n#nullable enable\n\nusing System;\nusing System.Collections.Generic;\n\nnamespace MyApp.Generated\n{\n    public static class TypeRegistry\n    {\n        // Injectable types discovered in this assembly\n        private static readonly InjectableTypeInfo[] _types = new InjectableTypeInfo[]\n        {\n            // MyService -&gt; IMyService (Singleton)\n            new InjectableTypeInfo(typeof(global::MyApp.MyService), new Type[] { typeof(global::MyApp.IMyService) }, InjectableLifetime.Singleton),\n        };\n        // ... rest of generated code\n    }\n}\n</code></pre>"},{"location":"breadcrumbs/#verbose-level","title":"Verbose Level","text":"<pre><code>// &lt;auto-generated/&gt;\n// \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n// Needlr Type Registry\n// Assembly: MyApp\n// Breadcrumb Level: Verbose\n// \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n#nullable enable\n\nusing System;\nusing System.Collections.Generic;\n\nnamespace MyApp.Generated\n{\n    public static class TypeRegistry\n    {\n        // \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        // \u2502 Injectable Types                                                        \u2502\n        // \u2502 Total types discovered: 1                                               \u2502\n        // \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        private static readonly InjectableTypeInfo[] _types = new InjectableTypeInfo[]\n        {\n            // \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            // \u2502 Type: MyService                                                         \u2502\n            // \u2502 Source: Services/MyService.cs                                           \u2502\n            // \u2502 Implements: IMyService                                                  \u2502\n            // \u2502 Lifetime: Singleton                                                     \u2502\n            // \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            new InjectableTypeInfo(typeof(global::MyApp.MyService), new Type[] { typeof(global::MyApp.IMyService) }, InjectableLifetime.Singleton),\n        };\n        // ... rest of generated code\n    }\n}\n</code></pre>"},{"location":"breadcrumbs/#interceptor-proxy-documentation","title":"Interceptor Proxy Documentation","text":"<p>When using interceptors, verbose breadcrumbs provide detailed information about proxy classes:</p> <pre><code>// \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n// \u2502 Interceptor Proxy: OrderService                                         \u2502\n// \u2502 Source: Services/OrderService.cs                                        \u2502\n// \u2502 Target Interface: IOrderService                                         \u2502\n// \u2502 Interceptors (execution order):                                         \u2502\n// \u2502   1. LoggingInterceptor                                                 \u2502\n// \u2502   2. CachingInterceptor                                                 \u2502\n// \u2502   3. ValidationInterceptor                                              \u2502\n// \u2502 Methods proxied: GetOrder, ProcessOrder, GetOrderAsync                  \u2502\n// \u2502 Methods forwarded: ToString, GetHashCode                                \u2502\n// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\npublic sealed class OrderService_InterceptorProxy : IOrderService\n{\n    // ... generated proxy implementation\n}\n</code></pre>"},{"location":"breadcrumbs/#source-path-resolution","title":"Source Path Resolution","text":"<p>Verbose breadcrumbs show source file paths relative to the project directory:</p> Scenario Path Display File in project <code>Services/MyService.cs</code> File in subfolder <code>Domain/Entities/Order.cs</code> External assembly <code>[AssemblyName]</code> Unknown location <code>[unknown]</code>"},{"location":"breadcrumbs/#best-practices","title":"Best Practices","text":"<ol> <li>Development: Use <code>Minimal</code> (default) for day-to-day development</li> <li>Debugging: Switch to <code>Verbose</code> when troubleshooting generated code issues</li> <li>CI/CD: Consider <code>None</code> for release builds to minimize generated file size</li> <li>Learning: Use <code>Verbose</code> when first learning how Needlr's generator works</li> </ol>"},{"location":"breadcrumbs/#configuration-in-cicd","title":"Configuration in CI/CD","text":"<p>You can set the breadcrumb level based on build configuration:</p> <pre><code>&lt;PropertyGroup Condition=\"'$(Configuration)' == 'Release'\"&gt;\n  &lt;NeedlrBreadcrumbLevel&gt;None&lt;/NeedlrBreadcrumbLevel&gt;\n&lt;/PropertyGroup&gt;\n\n&lt;PropertyGroup Condition=\"'$(Configuration)' == 'Debug'\"&gt;\n  &lt;NeedlrBreadcrumbLevel&gt;Verbose&lt;/NeedlrBreadcrumbLevel&gt;\n&lt;/PropertyGroup&gt;\n</code></pre>"},{"location":"breadcrumbs/#troubleshooting","title":"Troubleshooting","text":""},{"location":"breadcrumbs/#breadcrumbs-not-appearing","title":"Breadcrumbs Not Appearing","text":"<ol> <li>Ensure <code>NexusLabs.Needlr.Generators</code> package is referenced</li> <li>Verify the <code>.props</code> file is being imported (check build output)</li> <li>Rebuild the project (breadcrumb level is read at generation time)</li> </ol>"},{"location":"breadcrumbs/#case-sensitivity","title":"Case Sensitivity","text":"<p>The breadcrumb level value is case-insensitive:</p> <ul> <li><code>Verbose</code>, <code>verbose</code>, <code>VERBOSE</code>, <code>VeRbOsE</code> all work the same</li> </ul>"},{"location":"breadcrumbs/#invalid-values","title":"Invalid Values","text":"<p>If an invalid value is specified, Needlr defaults to <code>Minimal</code>:</p> <ul> <li><code>InvalidLevel</code> \u2192 defaults to <code>Minimal</code></li> <li>Empty string \u2192 defaults to <code>Minimal</code></li> <li>Whitespace only \u2192 defaults to <code>Minimal</code></li> </ul>"},{"location":"breadcrumbs/#compile-time-diagnostics","title":"Compile-Time Diagnostics","text":"<p>In addition to inline breadcrumbs, Needlr can generate separate diagnostic files at build time. These files provide higher-level views of your dependency injection configuration without cluttering your generated code.</p>"},{"location":"breadcrumbs/#enabling-diagnostics","title":"Enabling Diagnostics","text":"<p>Add the <code>NeedlrDiagnostics</code> property to your project:</p> <pre><code>&lt;PropertyGroup&gt;\n  &lt;NeedlrDiagnostics&gt;true&lt;/NeedlrDiagnostics&gt;\n&lt;/PropertyGroup&gt;\n</code></pre> <p>This generates three markdown files in your build output folder (e.g., <code>bin/Debug/net10.0/NeedlrDiagnostics/</code>):</p> File Description <code>DependencyGraph.md</code> Mermaid diagram showing service dependencies <code>LifetimeSummary.md</code> Breakdown of Singleton/Scoped/Transient registrations <code>RegistrationIndex.md</code> Complete index of all services, decorators, and plugins"},{"location":"breadcrumbs/#custom-output-path","title":"Custom Output Path","text":"<p>Specify a custom output directory (relative paths are resolved from the project directory):</p> <pre><code>&lt;PropertyGroup&gt;\n  &lt;NeedlrDiagnostics&gt;true&lt;/NeedlrDiagnostics&gt;\n  &lt;NeedlrDiagnosticsPath&gt;docs/diagnostics&lt;/NeedlrDiagnosticsPath&gt;\n&lt;/PropertyGroup&gt;\n</code></pre>"},{"location":"breadcrumbs/#filtering-types","title":"Filtering Types","text":"<p>Filter diagnostics to specific types (comma-separated fully qualified names):</p> <pre><code>&lt;PropertyGroup&gt;\n  &lt;NeedlrDiagnostics&gt;true&lt;/NeedlrDiagnostics&gt;\n  &lt;NeedlrDiagnosticsFilter&gt;MyApp.OrderService,MyApp.PaymentService&lt;/NeedlrDiagnosticsFilter&gt;\n&lt;/PropertyGroup&gt;\n</code></pre>"},{"location":"breadcrumbs/#example-output","title":"Example Output","text":""},{"location":"breadcrumbs/#dependencygraphmd","title":"DependencyGraph.md","text":"<p>The dependency graph now includes rich visualization sections:</p> <pre><code># Needlr Dependency Graph\n\nGenerated: 2026-01-25 10:00:00 UTC\nAssembly: MyApp\n\n## Referenced Plugin Assemblies\n\nTypes from referenced assemblies with `[GenerateTypeRegistry]`:\n\n### MyApp.Plugins\n\n\\`\\`\\`mermaid\ngraph TD\n    subgraph Singleton[\"MyApp.Plugins - Singleton\"]\n        OrderHandler[\"OrderHandler\"]\n        PaymentHandler[\"PaymentHandler\"]\n        Connection{{\"Connection\"}}\n        ConnectionFactory[\"ConnectionFactory\"]\n    end\n    PaymentHandler --&gt; OrderHandler\n    ConnectionFactory -.-&gt;|produces| Connection\n\\`\\`\\`\n\n| Service | Lifetime | Interfaces |\n|---------|----------|------------|\n| OrderHandler | Singleton | IHandler&lt;Order&gt; |\n| PaymentHandler | Singleton | IHandler&lt;Payment&gt; |\n| Connection | Singleton | IConnection |\n| ConnectionFactory | Singleton | IConnectionFactory |\n\n## Service Dependencies\n\n\\`\\`\\`mermaid\ngraph TD\n    subgraph Singleton\n        Logger[\"Logger\"]\n        ConfigService[\"ConfigService\"]\n    end\n    subgraph Scoped\n        OrderService[\"OrderService\"]\n    end\n    OrderService --&gt; Logger\n    OrderService --&gt; ConfigService\n\\`\\`\\`\n\n## Decorator Chains\n\nShows decorator wrapping order from outermost to innermost:\n\n\\`\\`\\`mermaid\ngraph LR\n    CachingDecorator[[\"CachingDecorator\"]] --&gt; LoggingDecorator[[\"LoggingDecorator\"]] --&gt; OrderService[\"OrderService\"]\n\\`\\`\\`\n\n## Keyed Services\n\nGroups services by their `[Keyed]` attribute values:\n\n\\`\\`\\`mermaid\ngraph TD\n    subgraph key_redis[\"redis\"]\n        RedisCache[\"RedisCache\"]\n    end\n    subgraph key_memory[\"memory\"]\n        MemoryCache[\"MemoryCache\"]\n    end\n\\`\\`\\`\n\n## Plugin Assemblies\n\nShows plugins grouped by their source assembly:\n\n\\`\\`\\`mermaid\ngraph TD\n    subgraph asm_MyApp_Plugins[\"MyApp.Plugins\"]\n        OrderPlugin([\"OrderPlugin\"])\n        PaymentPlugin([\"PaymentPlugin\"])\n    end\n\\`\\`\\`\n\n## Factory Services\n\nShows all factory\u2192product relationships from host and referenced assemblies:\n\n\\`\\`\\`mermaid\ngraph LR\n    ConnectionFactory[\"ConnectionFactory\"]\n    Connection{{\"Connection\"}}\n    ConnectionFactory -.-&gt;|produces| Connection\n    HttpClientFactory[\"HttpClientFactory\"]\n    HttpClient{{\"HttpClient\"}}\n    HttpClientFactory -.-&gt;|produces| HttpClient\n\\`\\`\\`\n\n&gt; Note: This section aggregates factories from the host assembly and all referenced plugin assemblies\n&gt; with `[GenerateTypeRegistry]`. Hexagon shapes indicate factory-produced types.\n\n## Interface Mapping\n\nShows interface-to-implementation relationships with dotted edges:\n\n\\`\\`\\`mermaid\ngraph LR\n    IOrderService((\"IOrderService\")) -.-&gt; OrderService[\"OrderService\"]\n    ILogger((\"ILogger\")) -.-&gt; Logger[\"Logger\"]\n\\`\\`\\`\n\n## Complexity Metrics\n\n| Metric | Value |\n|--------|-------|\n| Total Services | 15 |\n| Max Dependency Depth | 4 |\n| Hub Services (\u22653 dependents) | 2 |\n\n**Hub Services:** Logger (8), ConfigService (5)\n\n## Dependency Details\n\n| Service | Lifetime | Dependencies |\n|---------|----------|--------------|\n| Logger | Singleton | - |\n| OrderService | Scoped | ILogger, IConfigService |\n</code></pre>"},{"location":"breadcrumbs/#lifetimesummarymd","title":"LifetimeSummary.md","text":"<pre><code># Needlr Lifetime Summary\n\nGenerated: 2026-01-25 10:00:00 UTC\nAssembly: MyApp\n\n| Lifetime | Count | Percentage |\n|----------|-------|------------|\n| Singleton | 5 | 50.0% |\n| Scoped | 3 | 30.0% |\n| Transient | 2 | 20.0% |\n| **Total** | **10** | **100%** |\n</code></pre>"},{"location":"breadcrumbs/#registrationindexmd","title":"RegistrationIndex.md","text":"<pre><code># Needlr Registration Index\n\nGenerated: 2026-01-25 10:00:00 UTC\nAssembly: MyApp\n\n## Services (10)\n\n| # | Interface | Implementation | Lifetime | Source |\n|---|-----------|----------------|----------|--------|\n| 1 | ILogger | Logger | Singleton | Services/Logger.cs |\n| 2 | IOrderService | OrderService | Scoped | Services/OrderService.cs |\n\n## Decorators (2)\n\n| Service | Decorator Chain |\n|---------|-----------------|\n| IOrderService | LoggingDecorator \u2192 CachingDecorator |\n</code></pre>"},{"location":"breadcrumbs/#configuration-properties-summary","title":"Configuration Properties Summary","text":"Property Default Description <code>NeedlrDiagnostics</code> <code>false</code> Enable diagnostic file generation <code>NeedlrDiagnosticsPath</code> <code>$(OutputPath)NeedlrDiagnostics</code> Output directory (defaults to bin folder) <code>NeedlrDiagnosticsFilter</code> (all) Comma-separated type names to include"},{"location":"breadcrumbs/#analyzer-status","title":"Analyzer Status","text":"<p>When diagnostics are enabled, Needlr also generates <code>AnalyzerStatus.md</code> showing which analyzers are active and their current severity. This provides a single place to understand what compile-time protection is enabled for your project.</p>"},{"location":"breadcrumbs/#example-analyzerstatusmd","title":"Example AnalyzerStatus.md","text":"<pre><code># Needlr Analyzer Status\n\nGenerated: 2026-01-25 10:00:00 UTC\n\n## Active Analyzers\n\n| ID | Name | Status | Default Severity | Description |\n|:---|:-----|:-------|:-----------------|:------------|\n| NDLRCOR001 | Reflection in AOT | \u26aa Conditional | Error | Detects reflection APIs in AOT projects |\n| NDLRCOR005 | Lifetime Mismatch | \u2705 Active | Warning | Detects captive dependencies |\n| NDLRCOR009 | Lazy Resolution | \u2705 Active | Info | Lazy&lt;T&gt; references undiscovered type |\n| NDLRCOR010 | Collection Resolution | \u2705 Active | Info | IEnumerable&lt;T&gt; has no implementations |\n\n## Mode\n\n**Source Generation**: Enabled (GenerateTypeRegistry detected)\n\n## Configuration\n\nAnalyzer severity can be configured via `.editorconfig`:\n\n\\`\\`\\`ini\n# Example: Suppress Lazy resolution warnings\ndotnet_diagnostic.NDLRCOR009.severity = none\n\n# Example: Promote to warning\ndotnet_diagnostic.NDLRCOR009.severity = warning\n\\`\\`\\`\n</code></pre>"},{"location":"breadcrumbs/#understanding-analyzer-status","title":"Understanding Analyzer Status","text":"Status Meaning \u2705 Active Analyzer is running and checking your code \u26aa Conditional Analyzer only activates under certain conditions (e.g., AOT projects) \u274c Disabled Analyzer is disabled via configuration"},{"location":"breadcrumbs/#configuring-analyzers","title":"Configuring Analyzers","text":"<p>Use <code>.editorconfig</code> to adjust analyzer severity:</p> <pre><code># .editorconfig in your project root\n[*.cs]\n\n# Disable resolution validation (if using reflection)\ndotnet_diagnostic.NDLRCOR009.severity = none\ndotnet_diagnostic.NDLRCOR010.severity = none\n\n# Promote lifetime mismatch to error\ndotnet_diagnostic.NDLRCOR005.severity = error\n</code></pre> <p>See Analyzers Documentation for the complete list of available analyzers.</p>"},{"location":"core-concepts/","title":"Core Concepts","text":"<p>This guide explains the fundamental concepts and architecture of Needlr.</p>"},{"location":"core-concepts/#architecture-overview","title":"Architecture Overview","text":"<p>Needlr is built around several key components that work together to provide automatic dependency injection. Needlr is source-generation-first: compile-time discovery is the recommended approach, though both source-gen (<code>.UsingSourceGen()</code>) and reflection (<code>.UsingReflection()</code>) require explicit opt-in.</p> <pre><code>                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                         \u2502   Discovery Strategy    \u2502\n                         \u2502 (.UsingSourceGen() or   \u2502\n                         \u2502  .UsingReflection())    \u2502\n                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                     \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Syringe   \u2502\u2500\u2500\u2500\u2500\u25b6\u2502     Assembly Provider          \u2502\u2500\u2500\u2500\u2500\u25b6\u2502 Type Discovery  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502                                                           \u2502\n       \u25bc                                                           \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502Type Filterer\u2502\u2500\u2500\u2500\u2500\u25b6\u2502 Type Registrar   \u2502\u2500\u2500\u2500\u2500\u25b6\u2502      Service Collection         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502                                                           \u2502\n       \u25bc                                                           \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Plugins   \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502Service Provider \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"core-concepts/#source-generation-vs-reflection","title":"Source Generation vs Reflection","text":"<p>Needlr supports two discovery strategies:</p>"},{"location":"core-concepts/#source-generation-recommended","title":"Source Generation (Recommended)","text":"<p>Uses compile-time code generation to discover and register types:</p> <pre><code>using NexusLabs.Needlr.Injection.SourceGen;\n\nvar syringe = new Syringe()\n    .UsingSourceGen();  // Configures all source-gen components\n</code></pre> <p>Benefits:</p> <ul> <li>\u2705 AOT compatible</li> <li>\u2705 Trimming safe</li> <li>\u2705 Faster startup (no runtime scanning)</li> <li>\u2705 Compile-time error detection</li> </ul> <p>Requirements:</p> <ul> <li>Add <code>NexusLabs.Needlr.Generators</code> as an analyzer</li> <li>Add <code>NexusLabs.Needlr.Generators.Attributes</code></li> <li>All types must be known at compile time</li> </ul>"},{"location":"core-concepts/#reflection-dynamic-scenarios","title":"Reflection (Dynamic Scenarios)","text":"<p>Uses runtime reflection to discover and register types:</p> <pre><code>using NexusLabs.Needlr.Injection.Reflection;\n\nvar syringe = new Syringe()\n    .UsingReflection();  // Configures all reflection components\n</code></pre> <p>Benefits:</p> <ul> <li>\u2705 Dynamic plugin loading</li> <li>\u2705 Runtime assembly scanning</li> <li>\u2705 Scrutor integration support</li> </ul> <p>Drawbacks:</p> <ul> <li>\u274c Not AOT compatible</li> <li>\u274c Not trimming safe</li> <li>\u274c Slower startup</li> </ul>"},{"location":"core-concepts/#bundle-auto-fallback","title":"Bundle (Auto-Fallback)","text":"<p>Automatically chooses source-gen if available, falls back to reflection:</p> <pre><code>using NexusLabs.Needlr.Injection.Bundle;\n\nvar syringe = new Syringe()\n    .UsingAutoConfiguration();  // Source-gen preferred, reflection fallback\n</code></pre>"},{"location":"core-concepts/#the-syringe-class","title":"The Syringe Class","text":"<p>The <code>Syringe</code> class is the central configuration point for Needlr. It's an immutable record that creates new instances when configured, following a fluent API pattern.</p>"},{"location":"core-concepts/#key-properties","title":"Key Properties","text":"<ul> <li>TypeRegistrar: Determines how types are registered</li> <li>TypeFilterer: Controls which types get automatically registered</li> <li>AssemblyProvider: Specifies which assemblies to scan</li> <li>PluginFactory: Discovers and creates plugin instances</li> <li>ServiceProviderBuilderFactory: Creates the appropriate service provider builder</li> </ul>"},{"location":"core-concepts/#immutability","title":"Immutability","text":"<p>Each configuration method returns a new <code>Syringe</code> instance:</p> <pre><code>var syringe1 = new Syringe();\nvar syringe2 = syringe1.UsingSourceGen();\n// syringe1 != syringe2 (different instances)\n</code></pre> <p>This pattern helps support the fluent-builder syntax.</p>"},{"location":"core-concepts/#required-configuration","title":"Required Configuration","text":"<p>Unlike earlier versions, you must explicitly configure a discovery strategy:</p> <pre><code>// \u274c This will throw an InvalidOperationException\nvar provider = new Syringe().BuildServiceProvider();\n\n// \u2705 Correct - specify strategy\nvar provider = new Syringe()\n    .UsingSourceGen()\n    .BuildServiceProvider();\n</code></pre>"},{"location":"core-concepts/#assembly-scanning","title":"Assembly Scanning","text":""},{"location":"core-concepts/#assembly-provider","title":"Assembly Provider","text":"<p>The <code>IAssemblyProvider</code> determines which assemblies are scanned for types:</p> <pre><code>var provider = new AssemblyProviderBuilder()\n    .MatchingAssemblies(x =&gt; x.Contains(\"MyApp\"))\n    .UseLibTestEntryOrdering()\n    .Build();\n</code></pre>"},{"location":"core-concepts/#assembly-loaders","title":"Assembly Loaders","text":"<p>Different loaders provide different scanning strategies:</p> <ul> <li>DefaultAssemblyLoader: Scans current domain assemblies</li> <li>AllAssembliesLoader: Scans all loaded assemblies</li> <li>FileMatchAssemblyLoader: Scans assemblies matching file patterns</li> </ul> <p>NOTE: you can provide your own custom loaders.</p>"},{"location":"core-concepts/#assembly-sorters","title":"Assembly Sorters","text":"<p>Control the order in which assemblies are processed:</p> <ul> <li>DefaultAssemblySorter: No specific ordering</li> <li>AlphabeticalAssemblySorter: Alphabetical by name</li> <li>LibTestEntryAssemblySorter: Libraries first, then tests, then entry assembly</li> </ul> <p>NOTE: you can provider your own custom sorters.</p>"},{"location":"core-concepts/#type-registration","title":"Type Registration","text":""},{"location":"core-concepts/#type-registrars","title":"Type Registrars","text":"<p>Type registrars determine how discovered types are registered:</p>"},{"location":"core-concepts/#generatedtyperegistrar-source-generation","title":"GeneratedTypeRegistrar (Source Generation)","text":"<p>Used with source generation strategy:</p> <ul> <li>Types discovered at compile time</li> <li>AOT and trimming compatible</li> <li>No runtime reflection</li> </ul>"},{"location":"core-concepts/#reflectiontyperegistrar-reflection","title":"ReflectionTypeRegistrar (Reflection)","text":"<p>Used with reflection strategy:</p> <ul> <li>Types discovered at runtime</li> <li>Supports dynamic scenarios</li> </ul>"},{"location":"core-concepts/#scrutortyperegistrar-reflection-only","title":"ScrutorTypeRegistrar (Reflection only)","text":"<p>Uses Scrutor library for advanced registration scenarios (requires reflection):</p> <ul> <li>Assembly scanning with filters</li> <li>Decorator pattern support</li> <li>Advanced lifetime management</li> </ul> <p>NOTE: you can provide your own custom type registrars.</p>"},{"location":"core-concepts/#type-filterers","title":"Type Filterers","text":"<p>Control which types are eligible for automatic registration:</p>"},{"location":"core-concepts/#generatedtypefilterer-source-generation","title":"GeneratedTypeFilterer (Source Generation)","text":"<p>For source-gen, filtering is done at compile time based on:</p> <ul> <li>Types with <code>[DoNotAutoRegister]</code> attribute excluded</li> <li>Types with <code>[DoNotInject]</code> attribute excluded</li> <li>Abstract classes and interfaces excluded</li> </ul>"},{"location":"core-concepts/#reflectiontypefilterer-reflection","title":"ReflectionTypeFilterer (Reflection)","text":"<p>For reflection, filters at runtime based on:</p> <ul> <li>Excludes types with <code>[DoNotAutoRegister]</code> attribute</li> <li>Excludes types with <code>[DoNotInject]</code> attribute</li> <li>Excludes abstract classes and interfaces</li> <li>Excludes compiler-generated types</li> </ul>"},{"location":"core-concepts/#custom-type-filterers","title":"Custom Type Filterers","text":"<p>Implement <code>ITypeFilterer</code> for custom filtering logic:</p> <pre><code>public class MyTypeFilterer : ITypeFilterer\n{\n    public IEnumerable&lt;Type&gt; Filter(IEnumerable&lt;Type&gt; types)\n    {\n        return types.Where(t =&gt; \n            !t.Name.EndsWith(\"Test\") &amp;&amp; \n            t.Namespace?.StartsWith(\"MyCompany\") == true);\n    }\n}\n</code></pre> <p>Note: you can provide your own custom type filterers.</p>"},{"location":"core-concepts/#service-collection-population","title":"Service Collection Population","text":"<p>The <code>IServiceCollectionPopulator</code> orchestrates the registration process:</p> <ol> <li>Discovers types from assemblies</li> <li>Applies type filtering</li> <li>Registers types using the configured registrar</li> <li>Executes plugins</li> </ol>"},{"location":"core-concepts/#plugin-system","title":"Plugin System","text":""},{"location":"core-concepts/#plugin-types","title":"Plugin Types","text":""},{"location":"core-concepts/#iservicecollectionplugin","title":"IServiceCollectionPlugin","text":"<p>Configures services during the initial registration phase:</p> <pre><code>public class MyServicePlugin : IServiceCollectionPlugin\n{\n    public void Configure(ServiceCollectionPluginOptions options)\n    {\n        options.Services.AddSingleton&lt;IMyService, MyService&gt;();\n        options.Logger.LogInformation(\"Configured MyService\");\n    }\n}\n</code></pre>"},{"location":"core-concepts/#ipostbuildservicecollectionplugin","title":"IPostBuildServiceCollectionPlugin","text":"<p>Executes after the main service collection is built:</p> <pre><code>public class MyPostBuildPlugin : IPostBuildServiceCollectionPlugin\n{\n    public void Configure(PostBuildServiceCollectionPluginOptions options)\n    {\n        // Access built services\n        var myService = options.Services.GetService&lt;IMyService&gt;();\n        // Additional configuration\n    }\n}\n</code></pre>"},{"location":"core-concepts/#iwebapplicationbuilderplugin","title":"IWebApplicationBuilderPlugin","text":"<p>Configures the WebApplicationBuilder:</p> <pre><code>public class MyBuilderPlugin : IWebApplicationBuilderPlugin\n{\n    public void Configure(WebApplicationBuilderPluginOptions options)\n    {\n        options.Builder.Services.AddCors();\n        options.Builder.Configuration.AddJsonFile(\"custom.json\");\n    }\n}\n</code></pre>"},{"location":"core-concepts/#iwebapplicationplugin","title":"IWebApplicationPlugin","text":"<p>Configures the WebApplication after building:</p> <pre><code>public class MyAppPlugin : IWebApplicationPlugin\n{\n    public void Configure(WebApplicationPluginOptions options)\n    {\n        options.WebApplication.MapGet(\"/health\", () =&gt; \"Healthy\");\n        options.WebApplication.UseCors();\n    }\n}\n</code></pre>"},{"location":"core-concepts/#plugin-discovery","title":"Plugin Discovery","text":"<p>Plugins are automatically discovered and registered:</p> <ul> <li>Scanned from assemblies like other types</li> <li>Sorted by <code>[PluginOrder]</code> attribute (lower values first)</li> <li>Plugins with same order are sorted alphabetically by type name</li> <li>Executed in deterministic order</li> </ul> <pre><code>// Control plugin execution order\n[PluginOrder(-100)]  // Executes first\npublic class InfrastructurePlugin : IServiceCollectionPlugin { }\n\n[PluginOrder(100)]   // Executes last\npublic class ValidationPlugin : IServiceCollectionPlugin { }\n</code></pre> <p>See Plugin Development Guide for full ordering documentation.</p> <p>NOTE: The <code>[DoNotAutoRegister]</code> attribute is used for dynamically discovering  and registering types, but it is not applicable for plugins. In fact, by default, all built-in plugins are marked with this attribute so that they will not be resolvable on the dependency container itself. This attribute is not to control the discoverability of plugins.</p>"},{"location":"core-concepts/#lifetime-management","title":"Lifetime Management","text":""},{"location":"core-concepts/#default-lifetimes","title":"Default Lifetimes","text":"<ul> <li>Singleton: Created once and reused (default for most types in Needlr)</li> <li>Transient: Created each time requested </li> <li>Scoped: Created once per request/scope</li> </ul>"},{"location":"core-concepts/#lifetime-detection","title":"Lifetime Detection","text":"<p>Needlr automatically determines appropriate lifetimes based on:</p> <ul> <li>Type characteristics (stateless vs stateful)</li> <li>Interface implementations</li> <li>Decorator patterns</li> </ul>"},{"location":"core-concepts/#decorator-pattern","title":"Decorator Pattern","text":"<p>Decorators wrap a service to add behavior (logging, caching, retry, etc.) without modifying the original implementation.</p>"},{"location":"core-concepts/#why-explicit-decoratorfort-is-required","title":"Why Explicit <code>[DecoratorFor&lt;T&gt;]</code> Is Required","text":"<p>Needlr requires explicit decorator registration rather than auto-detecting and wiring decorators. Here's why:</p> <p>1. Ordering Ambiguity When multiple decorators exist for the same service, the order matters significantly. <code>Cache(Log(Service))</code> behaves differently than <code>Log(Cache(Service))</code>. Without explicit ordering, Needlr would have to choose arbitrarily, leading to runtime surprises.</p> <p>2. Intent Clarity A class that implements <code>IFoo</code> and takes <code>IFoo</code> in its constructor might be a decorator, but it could also be a fallback wrapper, adapter, or composite meant for manual composition. The pattern is ambiguous.</p> <p>3. Multiple Implementations If you have <code>FooA : IFoo</code> and <code>FooB : IFoo</code>, should a decorator wrap both? Only one? The explicit attribute makes your intent clear.</p> <p>Note: Needlr does auto-detect the decorator pattern to exclude such types from being registered as the interface they decorate (preventing circular dependencies). But wiring the decoration chain requires explicit opt-in.</p>"},{"location":"core-concepts/#automatic-decorators-with-decoratorfort-recommended","title":"Automatic Decorators with <code>[DecoratorFor&lt;T&gt;]</code> (Recommended)","text":"<p>The simplest approach - decorate classes with the attribute and Needlr handles the rest:</p> <pre><code>public interface IService { string GetValue(); }\npublic class ServiceImpl : IService { public string GetValue() =&gt; \"Original\"; }\n\n[DecoratorFor&lt;IService&gt;(Order = 1)]\npublic class LoggingDecorator : IService\n{\n    private readonly IService _inner;\n    public LoggingDecorator(IService inner) =&gt; _inner = inner;\n    public string GetValue()\n    {\n        Console.WriteLine(\"Logging...\");\n        return _inner.GetValue();\n    }\n}\n\n[DecoratorFor&lt;IService&gt;(Order = 2)]\npublic class CachingDecorator : IService\n{\n    private readonly IService _inner;\n    private string? _cached;\n    public CachingDecorator(IService inner) =&gt; _inner = inner;\n    public string GetValue() =&gt; _cached ??= _inner.GetValue();\n}\n</code></pre> <ul> <li>Order property: Lower values are applied first (closest to original)</li> <li>Result chain: CachingDecorator \u2192 LoggingDecorator \u2192 ServiceImpl</li> <li>Works with both source generation and reflection</li> </ul>"},{"location":"core-concepts/#manual-decoration","title":"Manual Decoration","text":"<pre><code>services.AddSingleton&lt;IService, ServiceImpl&gt;();\nservices.AddSingleton&lt;IService&gt;(sp =&gt; \n    new ServiceDecorator(sp.GetRequiredService&lt;ServiceImpl&gt;()));\n</code></pre>"},{"location":"core-concepts/#using-adddecorator-extension","title":"Using AddDecorator Extension","text":"<pre><code>new Syringe()\n    .UsingSourceGen()  // or .UsingReflection()\n    .AddDecorator&lt;IService, ServiceDecorator&gt;()\n    .BuildServiceProvider();\n</code></pre>"},{"location":"core-concepts/#with-scrutor-reflection-only","title":"With Scrutor (Reflection only)","text":"<pre><code>services.Decorate&lt;IService, ServiceDecorator&gt;();\n</code></pre>"},{"location":"core-concepts/#configuration-integration","title":"Configuration Integration","text":""},{"location":"core-concepts/#automatic-iconfiguration","title":"Automatic IConfiguration","text":"<p>Needlr automatically registers <code>IConfiguration</code>:</p> <pre><code>var provider = new Syringe()\n    .UsingSourceGen()  // or .UsingReflection()\n    .UsingConfiguration()  // Adds IConfiguration support\n    .BuildServiceProvider();\n</code></pre>"},{"location":"core-concepts/#web-application-integration","title":"Web Application Integration","text":""},{"location":"core-concepts/#webapplicationsyringe","title":"WebApplicationSyringe","text":"<p>Extends Syringe for web applications:</p> <pre><code>var webApp = new Syringe()\n    .UsingSourceGen()  // or .UsingReflection()\n    .ForWebApplication()  // Returns WebApplicationSyringe\n    .UsingOptions(() =&gt; CreateWebApplicationOptions.Default)\n    .BuildWebApplication();\n</code></pre>"},{"location":"core-concepts/#best-practices","title":"Best Practices","text":""},{"location":"core-concepts/#1-choose-the-right-discovery-strategy","title":"1. Choose the Right Discovery Strategy","text":"<ul> <li>Use Source Generation for AOT, trimmed, or performance-critical apps</li> <li>Use Reflection only when dynamic discovery is required</li> </ul>"},{"location":"core-concepts/#2-use-appropriate-attributes","title":"2. Use Appropriate Attributes","text":"<ul> <li><code>[DoNotAutoRegister]</code>: Exclude from automatic registration</li> <li><code>[DoNotInject]</code>: Prevent dependency injection</li> </ul>"},{"location":"core-concepts/#3-leverage-assembly-filtering","title":"3. Leverage Assembly Filtering","text":"<p>Filter assemblies to improve performance:</p> <pre><code>.UsingAssemblyProvider(builder =&gt; builder\n    .MatchingAssemblies(x =&gt; x.StartsWith(\"MyCompany\"))\n    .Build())\n</code></pre>"},{"location":"core-concepts/#4-order-matters","title":"4. Order Matters","text":"<p>Use assembly ordering for predictable registration order:</p> <pre><code>.UseLibTestEntryOrdering()  // Libraries \u2192 Executables \u2192 Tests\n</code></pre> <p>Or use the expression-based API for custom ordering:</p> <pre><code>.OrderAssemblies(order =&gt; order\n    .By(a =&gt; a.Name.StartsWith(\"Core\"))      // Core assemblies first\n    .ThenBy(a =&gt; a.Name.StartsWith(\"Feature\")) // Then features\n    .ThenBy(a =&gt; a.Name.Contains(\"Tests\")))   // Tests last\n</code></pre>"},{"location":"core-concepts/#5-plugin-organization","title":"5. Plugin Organization","text":"<ul> <li>Group related configuration in plugins</li> <li>Use appropriate plugin types for timing</li> <li>Keep plugins focused and single-purpose</li> </ul>"},{"location":"core-concepts/#6-immutability","title":"6. Immutability","text":"<p>Remember that Syringe is immutable:</p> <pre><code>var configured = new Syringe()\n    .UsingSourceGen()  // or .UsingReflection()\n    .UsingConfiguration();\n// Chain all configuration before building\n</code></pre> <p>Read More on Dev Leader</p> <ul> <li>Source Generation vs Reflection in Needlr: Choosing the Right Approach</li> <li>Automatic Service Discovery in C# with Needlr: How It Works</li> <li>The Syringe Class: Needlr's Fluent API Explained</li> </ul>"},{"location":"coverage/","title":"Code Coverage Report","text":"<p>The detailed code coverage report shows test coverage for all Needlr packages.</p> <p>Coverage Details</p> <p>This report is generated by ReportGenerator from test results.</p> <p>The coverage report shows:</p> <ul> <li>Line Coverage: Percentage of code lines executed during tests</li> <li>Branch Coverage: Percentage of code branches (if/else) tested</li> <li>Method Coverage: Percentage of methods called during tests</li> </ul>"},{"location":"coverage/#view-coverage-report","title":"View Coverage Report","text":"<p>     Open Coverage Report </p> <p>The coverage report opens in a new tab and provides:</p> <ul> <li>Summary of all assemblies</li> <li>Detailed line-by-line coverage</li> <li>Risk hotspots and complexity metrics</li> <li>Historical coverage trends</li> </ul> <p>Coverage report is updated automatically on each push to main.</p>"},{"location":"factories/","title":"Factory Delegates (Source Generation Only)","text":"<p>When a class has constructor parameters that cannot be auto-injected (value types, strings, delegates), Needlr typically excludes it from auto-registration. The <code>[GenerateFactory]</code> attribute solves this by generating factory interfaces and delegates that handle the injectable parameters while letting you provide the runtime parameters.</p>"},{"location":"factories/#basic-usage","title":"Basic Usage","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n// This service has both injectable (ILogger) and runtime (connectionString) parameters\n[GenerateFactory]\npublic sealed class DatabaseConnection\n{\n    /// &lt;summary&gt;\n    /// Creates a new database connection.\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"logger\"&gt;The logger for diagnostics.&lt;/param&gt;\n    /// &lt;param name=\"connectionString\"&gt;The database connection string.&lt;/param&gt;\n    public DatabaseConnection(ILogger&lt;DatabaseConnection&gt; logger, string connectionString)\n    {\n        // ...\n    }\n}\n</code></pre> <p>The source generator creates:</p> <ul> <li><code>IDatabaseConnectionFactory</code> - Interface with <code>Create(string connectionString)</code> method</li> <li><code>Func&lt;string, DatabaseConnection&gt;</code> - Delegate for functional-style creation</li> </ul> <p>Both are registered as Singletons. XML documentation from your constructor parameters is propagated to the factory's <code>Create</code> method for rich IntelliSense.</p>"},{"location":"factories/#resolving-factories","title":"Resolving Factories","text":"<pre><code>// Using the factory interface (recommended for testability)\nvar factory = serviceProvider.GetRequiredService&lt;MyApp.Generated.IDatabaseConnectionFactory&gt;();\nvar prodDb = factory.Create(\"Server=prod;Database=app\");\nvar testDb = factory.Create(\"Server=localhost;Database=test\");\n\n// Using the Func delegate (concise syntax)\nvar createDb = serviceProvider.GetRequiredService&lt;Func&lt;string, DatabaseConnection&gt;&gt;();\nvar db = createDb(\"Server=dev;Database=sandbox\");\n</code></pre>"},{"location":"factories/#generic-factory-for-interface-return-types","title":"Generic Factory for Interface Return Types","text":"<p>Use <code>[GenerateFactory&lt;TInterface&gt;]</code> to have the factory return an interface instead of the concrete type. This enables mocking both the factory and its returned instances:</p> <pre><code>public interface IRequestHandler\n{\n    Guid CorrelationId { get; }\n    string Handle(string request);\n}\n\n[GenerateFactory&lt;IRequestHandler&gt;]\npublic sealed class RequestHandler : IRequestHandler\n{\n    /// &lt;summary&gt;Creates a new request handler.&lt;/summary&gt;\n    /// &lt;param name=\"config\"&gt;Application configuration.&lt;/param&gt;\n    /// &lt;param name=\"correlationId\"&gt;Unique ID for tracing this request.&lt;/param&gt;\n    public RequestHandler(IConfiguration config, Guid correlationId)\n    {\n        CorrelationId = correlationId;\n        // ...\n    }\n\n    // ...\n}\n</code></pre> <p>The generated factory: <pre><code>public interface IRequestHandlerFactory\n{\n    /// &lt;summary&gt;Creates a new instance of RequestHandler.&lt;/summary&gt;\n    /// &lt;param name=\"correlationId\"&gt;Unique ID for tracing this request.&lt;/param&gt;\n    IRequestHandler Create(Guid correlationId);  // Returns interface, not concrete type\n}\n\n// Func also returns the interface\nFunc&lt;Guid, IRequestHandler&gt;\n</code></pre></p>"},{"location":"factories/#multiple-constructors","title":"Multiple Constructors","text":"<p>Each public constructor with runtime parameters gets its own <code>Create()</code> overload:</p> <pre><code>[GenerateFactory]\npublic sealed class ReportGenerator\n{\n    /// &lt;param name=\"timeProvider\"&gt;Time provider for timestamps.&lt;/param&gt;\n    /// &lt;param name=\"title\"&gt;Report title.&lt;/param&gt;\n    public ReportGenerator(ITimeProvider timeProvider, string title) { }\n\n    /// &lt;param name=\"timeProvider\"&gt;Time provider for timestamps.&lt;/param&gt;\n    /// &lt;param name=\"title\"&gt;Report title.&lt;/param&gt;\n    /// &lt;param name=\"maxItems\"&gt;Maximum items to include.&lt;/param&gt;\n    public ReportGenerator(ITimeProvider timeProvider, string title, int maxItems) { }\n}\n</code></pre> <p>Generated interface: <pre><code>public interface IReportGeneratorFactory\n{\n    /// &lt;summary&gt;Creates a new instance of ReportGenerator.&lt;/summary&gt;\n    /// &lt;param name=\"title\"&gt;Report title.&lt;/param&gt;\n    ReportGenerator Create(string title);\n\n    /// &lt;summary&gt;Creates a new instance of ReportGenerator.&lt;/summary&gt;\n    /// &lt;param name=\"title\"&gt;Report title.&lt;/param&gt;\n    /// &lt;param name=\"maxItems\"&gt;Maximum items to include.&lt;/param&gt;\n    ReportGenerator Create(string title, int maxItems);\n}\n</code></pre></p>"},{"location":"factories/#controlling-generation-mode","title":"Controlling Generation Mode","text":"<p>By default, both the <code>Func&lt;&gt;</code> delegate and <code>IFactory</code> interface are generated. Use the <code>Mode</code> property to control this:</p> <pre><code>// Only generate Func&lt;&gt; delegate\n[GenerateFactory(Mode = FactoryGenerationMode.Func)]\npublic class FuncOnlyService { }\n\n// Only generate IFactory interface\n[GenerateFactory(Mode = FactoryGenerationMode.Interface)]\npublic class InterfaceOnlyService { }\n\n// Generate both (default)\n[GenerateFactory(Mode = FactoryGenerationMode.All)]\npublic class BothService { }\n</code></pre>"},{"location":"factories/#parameter-classification","title":"Parameter Classification","text":"<p>Needlr classifies constructor parameters as:</p> <ul> <li>Injectable: Interfaces and classes (resolved from the container)</li> <li>Runtime: Value types, strings, delegates, arrays (must be provided to <code>Create()</code>)</li> </ul> <p>Only constructors with at least one runtime parameter are eligible for factory generation.</p>"},{"location":"factories/#analyzers","title":"Analyzers","text":"<p>Needlr includes analyzers to help with factory usage:</p> Diagnostic Severity Description NDLRGEN003 Warning All parameters are injectable - factory provides no value NDLRGEN004 Warning No parameters are injectable - low value factory NDLRGEN005 Error Generic type T in <code>[GenerateFactory&lt;T&gt;]</code> is not implemented by the class"},{"location":"factories/#namespace","title":"Namespace","text":"<p>Generated factories are placed in <code>{AssemblyName}.Generated</code> namespace:</p> <pre><code>using MyApp.Generated;  // Contains IDatabaseConnectionFactory, IReportGeneratorFactory, etc.\n</code></pre>"},{"location":"factories/#when-to-use-factories","title":"When to Use Factories","text":"<p>Use <code>[GenerateFactory]</code> when:</p> <ul> <li>Your class requires runtime configuration (connection strings, API keys, correlation IDs)</li> <li>You need to create multiple instances with different runtime parameters</li> <li>You want to avoid manual <code>IServiceProvider.GetRequiredService&lt;&gt;()</code> calls in factory methods</li> </ul> <p>Use <code>[GenerateFactory&lt;TInterface&gt;]</code> when:</p> <ul> <li>You want to mock the factory in unit tests</li> <li>You want to mock the returned instances</li> <li>You prefer interface-based dependency injection</li> </ul>"},{"location":"factories/#complete-example","title":"Complete Example","text":"<pre><code>using NexusLabs.Needlr.Generators;\nusing MyApp.Generated;\n\n// Define your service with mixed parameters\n[GenerateFactory]\npublic sealed class EmailSender\n{\n    private readonly ISmtpClient _smtp;\n    private readonly ILogger&lt;EmailSender&gt; _logger;\n\n    public string FromAddress { get; }\n\n    /// &lt;summary&gt;Creates a new email sender.&lt;/summary&gt;\n    /// &lt;param name=\"smtp\"&gt;SMTP client for sending emails.&lt;/param&gt;\n    /// &lt;param name=\"logger\"&gt;Logger for diagnostics.&lt;/param&gt;\n    /// &lt;param name=\"fromAddress\"&gt;The sender email address.&lt;/param&gt;\n    public EmailSender(ISmtpClient smtp, ILogger&lt;EmailSender&gt; logger, string fromAddress)\n    {\n        _smtp = smtp;\n        _logger = logger;\n        FromAddress = fromAddress;\n    }\n\n    public Task SendAsync(string to, string subject, string body) { /* ... */ }\n}\n\n// Use the generated factory\npublic class NotificationService\n{\n    private readonly IEmailSenderFactory _emailFactory;\n\n    public NotificationService(IEmailSenderFactory emailFactory)\n    {\n        _emailFactory = emailFactory;\n    }\n\n    public async Task NotifyUserAsync(User user, string message)\n    {\n        // Create sender with appropriate from address\n        var sender = _emailFactory.Create(\"noreply@myapp.com\");\n        await sender.SendAsync(user.Email, \"Notification\", message);\n    }\n\n    public async Task NotifySupportAsync(string issue)\n    {\n        var sender = _emailFactory.Create(\"support@myapp.com\");\n        await sender.SendAsync(\"team@myapp.com\", \"Support Issue\", issue);\n    }\n}\n</code></pre>"},{"location":"getting-started/","title":"Getting Started with Needlr","text":"<p>Needlr is an opinionated dependency injection library for .NET that simplifies service registration and web application setup through automatic discovery and a fluent API.</p> <p>Needlr is source-generation-first: The recommended approach uses compile-time source generation for AOT compatibility. Both source-gen and reflection require explicit opt-in via <code>.UsingSourceGen()</code> or <code>.UsingReflection()</code>.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Add the Needlr packages to your project. Choose your discovery strategy:</p>"},{"location":"getting-started/#option-1-source-generation-recommended","title":"Option 1: Source Generation (Recommended)","text":"<p>Best for AOT-compiled applications, trimmed deployments, and optimal startup performance:</p> <pre><code>&lt;!-- Core dependency injection --&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.Injection\" /&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.Injection.SourceGen\" /&gt;\n\n&lt;!-- Source generator (runs at compile time) --&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.Generators\" OutputItemType=\"Analyzer\" ReferenceOutputAssembly=\"false\" /&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.Generators.Attributes\" /&gt;\n\n&lt;!-- For ASP.NET Core web applications --&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.AspNet\" /&gt;\n</code></pre>"},{"location":"getting-started/#option-2-reflection-dynamic-scenarios","title":"Option 2: Reflection (Dynamic Scenarios)","text":"<p>For applications that need runtime type discovery or dynamic plugin loading:</p> <pre><code>&lt;!-- Core dependency injection --&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.Injection\" /&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.Injection.Reflection\" /&gt;\n\n&lt;!-- For ASP.NET Core web applications --&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.AspNet\" /&gt;\n\n&lt;!-- Optional: Scrutor-based type registration --&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.Injection.Scrutor\" /&gt;\n</code></pre>"},{"location":"getting-started/#option-3-bundle-auto-fallback","title":"Option 3: Bundle (Auto-Fallback)","text":"<p>Includes both strategies with automatic fallback from source-gen to reflection:</p> <pre><code>&lt;!-- Includes both source-gen and reflection with auto-detection --&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.Injection.Bundle\" /&gt;\n\n&lt;!-- For ASP.NET Core web applications --&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.AspNet\" /&gt;\n</code></pre>"},{"location":"getting-started/#your-first-application","title":"Your First Application","text":""},{"location":"getting-started/#console-application-source-generation","title":"Console Application (Source Generation)","text":"<pre><code>using NexusLabs.Needlr.Injection;\nusing NexusLabs.Needlr.Injection.SourceGen;\nusing Microsoft.Extensions.DependencyInjection;\n\n// Create a service provider with source-gen discovery\nvar serviceProvider = new Syringe()\n    .UsingSourceGen()\n    .BuildServiceProvider();\n\n// Get your service (automatically registered at compile time)\nvar myService = serviceProvider.GetRequiredService&lt;MyService&gt;();\nmyService.DoWork();\n\n// Your service class - automatically discovered by source generator\npublic class MyService\n{\n    public void DoWork()\n    {\n        Console.WriteLine(\"Work is being done!\");\n    }\n}\n</code></pre>"},{"location":"getting-started/#console-application-reflection","title":"Console Application (Reflection)","text":"<pre><code>using NexusLabs.Needlr.Injection;\nusing NexusLabs.Needlr.Injection.Reflection;\nusing Microsoft.Extensions.DependencyInjection;\n\n// Create a service provider with reflection-based discovery\nvar serviceProvider = new Syringe()\n    .UsingReflection()\n    .BuildServiceProvider();\n\n// Get your service (automatically registered at runtime)\nvar myService = serviceProvider.GetRequiredService&lt;MyService&gt;();\nmyService.DoWork();\n</code></pre>"},{"location":"getting-started/#web-application-source-generation","title":"Web Application (Source Generation)","text":"<pre><code>using NexusLabs.Needlr.AspNet;\nusing NexusLabs.Needlr.Injection;\nusing NexusLabs.Needlr.Injection.SourceGen;\n\n// Create and run a web application\nvar webApplication = new Syringe()\n    .UsingSourceGen()\n    .ForWebApplication()\n    .BuildWebApplication();\n\nawait webApplication.RunAsync();\n\n// Add a minimal API endpoint using a plugin\ninternal sealed class HelloWorldPlugin : IWebApplicationPlugin\n{\n    public void Configure(WebApplicationPluginOptions options)\n    {\n        options.WebApplication.MapGet(\"/\", () =&gt; \"Hello, World!\");\n    }\n}\n</code></pre>"},{"location":"getting-started/#web-application-reflection","title":"Web Application (Reflection)","text":"<pre><code>using NexusLabs.Needlr.AspNet;\nusing NexusLabs.Needlr.Injection;\nusing NexusLabs.Needlr.Injection.Reflection;\n\n// Create and run a web application with reflection\nvar webApplication = new Syringe()\n    .UsingReflection()\n    .ForWebApplication()\n    .BuildWebApplication();\n\nawait webApplication.RunAsync();\n</code></pre>"},{"location":"getting-started/#key-concepts","title":"Key Concepts","text":""},{"location":"getting-started/#automatic-registration","title":"Automatic Registration","text":"<p>By default, Needlr automatically registers:</p> <ul> <li>All non-nested non-abstract classes (public and internal) in scanned assemblies</li> <li>Classes as both themselves and their interfaces</li> <li>With Singleton lifetime by default (use <code>[Transient]</code> or <code>[Scoped]</code> attributes to override)</li> </ul> <p>By default, Needlr automatically dots NOT register:</p> <ul> <li>Anything marked with the <code>[DoNotAutoRegister]</code> attribute</li> <li>Record types</li> <li>Nested classes</li> <li>Interfaces or abstract classes</li> <li>Types where the only constructor are non-injectable types (i.e. value types)</li> </ul> <p>NOTE: there are nuances to what is automatically registered to the dependency container by default </p>"},{"location":"getting-started/#the-syringe-class","title":"The Syringe Class","text":"<p>The <code>Syringe</code> class is your entry point for configuring dependency injection. You must configure a discovery strategy:</p> <pre><code>// Source generation (recommended for AOT)\nvar syringe = new Syringe()\n    .UsingSourceGen()\n    .UsingAssemblyProvider(builder =&gt; builder\n        .MatchingAssemblies(x =&gt; x.Contains(\"MyApp\"))\n        .Build());\n\n// Reflection with Scrutor (for dynamic scenarios)\nvar syringe = new Syringe()\n    .UsingReflection()\n    .UsingScrutorTypeRegistrar()\n    .UsingAssemblyProvider(builder =&gt; builder\n        .MatchingAssemblies(x =&gt; x.Contains(\"MyApp\"))\n        .Build());\n</code></pre>"},{"location":"getting-started/#preventing-auto-registration","title":"Preventing Auto-Registration","text":"<p>Use the <code>[DoNotAutoRegister]</code> attribute to exclude types:</p> <pre><code>[DoNotAutoRegister]\npublic class ManuallyRegisteredService\n{\n    // This won't be automatically registered\n}\n</code></pre>"},{"location":"getting-started/#controlling-interface-registration","title":"Controlling Interface Registration","text":"<p>By default, classes are registered as all their interfaces. Use <code>[RegisterAs&lt;T&gt;]</code> for explicit control:</p> <pre><code>public interface IReader { }\npublic interface IWriter { }\npublic interface ILogger { }\n\n// Only registered as IReader, not IWriter or ILogger\n[RegisterAs&lt;IReader&gt;]\npublic class FileService : IReader, IWriter, ILogger { }\n</code></pre> <p>See RegisterAs Documentation for more details.</p>"},{"location":"getting-started/#configuration-options","title":"Configuration Options","text":""},{"location":"getting-started/#source-generation-configuration","title":"Source Generation Configuration","text":"<pre><code>using NexusLabs.Needlr.Injection.SourceGen;\n\nvar serviceProvider = new Syringe()\n    .UsingSourceGen()\n    .BuildServiceProvider();\n</code></pre>"},{"location":"getting-started/#reflection-configuration","title":"Reflection Configuration","text":"<pre><code>using NexusLabs.Needlr.Injection.Reflection;\n\nvar serviceProvider = new Syringe()\n    .UsingReflection()\n    .BuildServiceProvider();\n</code></pre>"},{"location":"getting-started/#auto-configuration-bundle","title":"Auto-Configuration (Bundle)","text":"<pre><code>using NexusLabs.Needlr.Injection.Bundle;\n\nvar serviceProvider = new Syringe()\n    .UsingAutoConfiguration()  // Tries source-gen first, falls back to reflection\n    .BuildServiceProvider();\n</code></pre>"},{"location":"getting-started/#custom-assembly-scanning","title":"Custom Assembly Scanning","text":"<pre><code>var serviceProvider = new Syringe()\n    .UsingSourceGen()  // or .UsingReflection()\n    .UsingAssemblyProvider(builder =&gt; builder\n        .MatchingAssemblies(x =&gt; \n            x.Contains(\"MyCompany\") || \n            x.Contains(\"MyApp\"))\n        .UseLibTestEntryOrdering()  // Sort assemblies appropriately\n        .Build())\n    .BuildServiceProvider();\n</code></pre>"},{"location":"getting-started/#web-application-options","title":"Web Application Options","text":""},{"location":"getting-started/#source-generation-web-application","title":"Source Generation Web Application","text":"<pre><code>using NexusLabs.Needlr.Injection.SourceGen;\n\nvar webApplication = new Syringe()\n    .UsingSourceGen()\n    .ForWebApplication()\n    .BuildWebApplication();\n</code></pre>"},{"location":"getting-started/#reflection-web-application","title":"Reflection Web Application","text":"<pre><code>using NexusLabs.Needlr.Injection.Reflection;\n\nvar webApplication = new Syringe()\n    .UsingReflection()\n    .ForWebApplication()\n    .BuildWebApplication();\n</code></pre>"},{"location":"getting-started/#with-custom-options","title":"With Custom Options","text":"<pre><code>var webApplication = new Syringe()\n    .UsingSourceGen()  // or .UsingReflection()\n    .ForWebApplication()\n    .UsingOptions(() =&gt; CreateWebApplicationOptions\n        .Default\n        .UsingStartupConsoleLogger()\n        .UsingApplicationName(\"MyApp\"))\n    .BuildWebApplication();\n</code></pre>"},{"location":"getting-started/#with-configuration-callback","title":"With Configuration Callback","text":"<p>The <code>UsingConfigurationCallback</code> method allows you to customize the WebApplicationBuilder before the application is built:</p> <pre><code>var webApplication = new Syringe()\n    .UsingSourceGen()  // or .UsingReflection()\n    .ForWebApplication()\n    .UsingConfigurationCallback((builder, options) =&gt;\n    {\n        // Customize configuration sources\n        builder.Configuration\n            .SetBasePath(AppContext.BaseDirectory)\n            .AddJsonFile(\"appsettings.local.json\", optional: true)\n            .AddEnvironmentVariables(\"MYAPP_\");\n\n        // Add services before plugin registration\n        builder.Services.AddSingleton&lt;ICustomService, CustomService&gt;();\n\n        // Configure logging\n        builder.Logging.AddConsole();\n        builder.Logging.SetMinimumLevel(LogLevel.Debug);\n    })\n    .BuildWebApplication();\n</code></pre>"},{"location":"getting-started/#with-web-application-factory","title":"With Web Application Factory","text":"<pre><code>var webApplication = new Syringe()\n    .UsingSourceGen()  // or .UsingReflection()\n    .ForWebApplication()\n    .UsingWebApplicationFactory&lt;CustomWebApplicationFactory&gt;()\n    .BuildWebApplication();\n</code></pre>"},{"location":"getting-started/#choosing-source-generation-vs-reflection","title":"Choosing Source Generation vs Reflection","text":"Feature Source Generation Reflection AOT Compatible \u2705 Yes \u274c No Trimming Safe \u2705 Yes \u274c No Startup Performance \u2705 Faster \u26a0\ufe0f Slower Dynamic Plugin Loading \u274c No \u2705 Yes Runtime Assembly Scanning \u274c No \u2705 Yes Scrutor Support \u274c No \u2705 Yes <p>Use Source Generation when:</p> <ul> <li>Building AOT-compiled applications</li> <li>Targeting trimmed/self-contained deployments</li> <li>You want faster startup times</li> <li>All plugins are known at compile time</li> </ul> <p>Use Reflection when:</p> <ul> <li>Loading plugins dynamically at runtime</li> <li>Scanning assemblies not known at compile time</li> <li>Using Scrutor for advanced registration patterns</li> </ul>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Core Concepts for deeper understanding</li> <li>Explore Plugin Development to extend functionality</li> <li>Discover Factory Delegates for types with runtime parameters</li> <li>Read about Interceptors for cross-cutting concerns</li> <li>See Advanced Usage for complex scenarios</li> </ul> <p>Read More on Dev Leader</p> <ul> <li>Getting Started with Needlr: Fluent DI for .NET Applications</li> <li>Automatic Dependency Injection in C#: The Complete Guide to Needlr</li> </ul>"},{"location":"hosted-services/","title":"Hosted Service Auto-Discovery","text":"<p>Needlr automatically discovers and registers classes that inherit from <code>BackgroundService</code> or implement <code>IHostedService</code>. No additional attributes are required.</p>"},{"location":"hosted-services/#how-it-works","title":"How It Works","text":"<p>When you use <code>[GenerateTypeRegistry]</code>, Needlr scans for:</p> <ol> <li>Classes inheriting from <code>Microsoft.Extensions.Hosting.BackgroundService</code></li> <li>Classes directly implementing <code>Microsoft.Extensions.Hosting.IHostedService</code></li> </ol> <p>These are automatically registered with the dual-registration pattern:</p> <pre><code>// Generated code:\nservices.AddSingleton&lt;MyWorkerService&gt;();\nservices.AddSingleton&lt;IHostedService&gt;(sp =&gt; sp.GetRequiredService&lt;MyWorkerService&gt;());\n</code></pre> <p>This pattern allows:</p> <ul> <li>Resolving by concrete type (<code>MyWorkerService</code>)</li> <li>Resolution via <code>IHostedService</code> for the host to start/stop</li> <li>Decorators to be applied via <code>IHostedService</code></li> </ul>"},{"location":"hosted-services/#automatic-startup","title":"Automatic Startup","text":"<p>When using <code>.ForWebApplication()</code> or <code>.ForHost()</code> to build a <code>WebApplication</code> or <code>IHost</code>, your discovered hosted services will automatically start when you call <code>StartAsync()</code> or <code>RunAsync()</code>:</p> <pre><code>var app = new Syringe()\n    .UsingSourceGen()\n    .ForWebApplication()\n    .BuildWebApplication();\n\n// Your hosted services start here\nawait app.RunAsync();\n</code></pre> <p>The .NET host runtime handles starting all <code>IHostedService</code> registrations, including your auto-discovered background services. They will also be stopped when the application shuts down.</p>"},{"location":"hosted-services/#basic-example","title":"Basic Example","text":"<pre><code>// Just inherit from BackgroundService - no attributes needed\npublic sealed class OrderProcessingWorker : BackgroundService\n{\n    private readonly IOrderQueue _orderQueue;\n\n    public OrderProcessingWorker(IOrderQueue orderQueue)\n    {\n        _orderQueue = orderQueue;\n    }\n\n    protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n    {\n        while (!stoppingToken.IsCancellationRequested)\n        {\n            var order = await _orderQueue.DequeueAsync(stoppingToken);\n            // Process order...\n        }\n    }\n}\n</code></pre>"},{"location":"hosted-services/#excluding-a-hosted-service","title":"Excluding a Hosted Service","text":"<p>Use <code>[DoNotAutoRegister]</code> to prevent auto-discovery:</p> <pre><code>[DoNotAutoRegister]\npublic sealed class ManuallyRegisteredWorker : BackgroundService\n{\n    protected override Task ExecuteAsync(CancellationToken stoppingToken) \n        =&gt; Task.CompletedTask;\n}\n</code></pre>"},{"location":"hosted-services/#decorating-hosted-services","title":"Decorating Hosted Services","text":"<p>You can apply decorators to all hosted services using <code>[DecoratorFor&lt;IHostedService&gt;]</code>:</p> <pre><code>[DecoratorFor&lt;IHostedService&gt;(Order = 0)]\npublic sealed class TimingHostedServiceDecorator : IHostedService\n{\n    private readonly IHostedService _inner;\n    private readonly ILogger&lt;TimingHostedServiceDecorator&gt; _logger;\n\n    public TimingHostedServiceDecorator(\n        IHostedService inner, \n        ILogger&lt;TimingHostedServiceDecorator&gt; logger)\n    {\n        _inner = inner;\n        _logger = logger;\n    }\n\n    public async Task StartAsync(CancellationToken cancellationToken)\n    {\n        var sw = Stopwatch.StartNew();\n        await _inner.StartAsync(cancellationToken);\n        _logger.LogInformation(\"Started {Type} in {Elapsed}ms\", \n            _inner.GetType().Name, sw.ElapsedMilliseconds);\n    }\n\n    public Task StopAsync(CancellationToken cancellationToken) \n        =&gt; _inner.StopAsync(cancellationToken);\n}\n</code></pre>"},{"location":"hosted-services/#multi-level-decoration","title":"Multi-Level Decoration","text":"<p>Multiple decorators can be stacked using the <code>Order</code> property:</p> <pre><code>[DecoratorFor&lt;IHostedService&gt;(Order = 0)]  // Innermost (closest to service)\npublic sealed class TrackerDecorator : IHostedService { ... }\n\n[DecoratorFor&lt;IHostedService&gt;(Order = 1)]\npublic sealed class LoggingDecorator : IHostedService { ... }\n\n[DecoratorFor&lt;IHostedService&gt;(Order = 2)]  // Outermost\npublic sealed class MetricsDecorator : IHostedService { ... }\n</code></pre> <p>Resolution order: <code>MetricsDecorator \u2192 LoggingDecorator \u2192 TrackerDecorator \u2192 ActualService</code></p>"},{"location":"hosted-services/#resolution-behavior","title":"Resolution Behavior","text":"<pre><code>var provider = new Syringe()\n    .UsingSourceGen()\n    .BuildServiceProvider();\n\n// Concrete resolution - NOT decorated\nvar worker = provider.GetRequiredService&lt;OrderProcessingWorker&gt;();\n\n// Interface resolution - decorated\nvar hostedServices = provider.GetServices&lt;IHostedService&gt;();\n// Each IHostedService is wrapped by all applicable decorators\n</code></pre>"},{"location":"hosted-services/#discovery-rules","title":"Discovery Rules","text":"<p>A type is discovered as a hosted service if:</p> <ul> <li>\u2705 Inherits from <code>BackgroundService</code> OR implements <code>IHostedService</code></li> <li>\u2705 Is a concrete class (not abstract)</li> <li>\u2705 Is accessible (public, or internal in the current assembly)</li> <li>\u274c Does NOT have <code>[DoNotAutoRegister]</code></li> <li>\u274c Does NOT have <code>[DecoratorFor&lt;IHostedService&gt;]</code> (decorators are not services)</li> </ul>"},{"location":"hosted-services/#notes","title":"Notes","text":"<ul> <li>Hosted services are always registered as Singleton lifetime</li> <li>Decorators with <code>[DecoratorFor&lt;IHostedService&gt;]</code> are excluded from hosted service discovery to prevent circular dependencies</li> <li>Works with both source-gen and reflection paths</li> </ul> <p>Read More on Dev Leader</p> <ul> <li>Hosted Services with Needlr: Background Workers and Lifecycle Management</li> </ul>"},{"location":"interceptors/","title":"Interceptors","text":"<p>Interceptors provide a powerful way to add cross-cutting concerns to your services without modifying their implementation. Unlike decorators, which require implementing every method of an interface, interceptors handle method invocations with a single implementation that works across any service.</p> <p>Note: Interceptors are a source-generation only feature. They are not available with reflection-based registration.</p>"},{"location":"interceptors/#quick-start","title":"Quick Start","text":""},{"location":"interceptors/#1-create-an-interceptor","title":"1. Create an Interceptor","text":"<pre><code>using NexusLabs.Needlr;\n\npublic class LoggingInterceptor : IMethodInterceptor\n{\n    private readonly ILogger _logger;\n\n    public LoggingInterceptor(ILogger&lt;LoggingInterceptor&gt; logger)\n    {\n        _logger = logger;\n    }\n\n    public async ValueTask&lt;object?&gt; InterceptAsync(IMethodInvocation invocation)\n    {\n        _logger.LogInformation(\"Calling {Method}\", invocation.Method.Name);\n\n        try\n        {\n            var result = await invocation.ProceedAsync();\n            _logger.LogInformation(\"{Method} completed\", invocation.Method.Name);\n            return result;\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"{Method} failed\", invocation.Method.Name);\n            throw;\n        }\n    }\n}\n</code></pre>"},{"location":"interceptors/#2-apply-to-a-service","title":"2. Apply to a Service","text":"<pre><code>[Intercept&lt;LoggingInterceptor&gt;]\npublic class OrderService : IOrderService\n{\n    public Order GetOrder(int id) =&gt; /* ... */;\n    public Task&lt;Order&gt; CreateOrderAsync(CreateOrderRequest request) =&gt; /* ... */;\n    public void CancelOrder(int orderId) =&gt; /* ... */;\n}\n</code></pre>"},{"location":"interceptors/#3-use-the-service","title":"3. Use the Service","text":"<pre><code>var provider = new Syringe()\n    .UsingSourceGen()\n    .BuildServiceProvider();\n\nvar orderService = provider.GetRequiredService&lt;IOrderService&gt;();\norderService.GetOrder(123);  // Logging interceptor wraps this call\n</code></pre>"},{"location":"interceptors/#interceptors-vs-decorators","title":"Interceptors vs Decorators","text":"Feature Decorator Interceptor Implementation One class per service One class for any service Method handling Implement every interface method Single <code>InterceptAsync</code> handles all Apply to One service type Any service with <code>[Intercept]</code> Best for Service-specific behavior Cross-cutting concerns Reflection support Yes No (source-gen only)"},{"location":"interceptors/#when-to-use-each","title":"When to Use Each","text":"<p>Use Decorators when:</p> <ul> <li>You need different behavior for different methods</li> <li>You're modifying only one service type</li> <li>You need reflection support</li> </ul> <p>Use Interceptors when:</p> <ul> <li>The same logic applies to all methods (logging, timing, caching)</li> <li>You want to reuse the same interceptor across many services</li> <li>You're using source generation</li> </ul>"},{"location":"interceptors/#class-level-vs-method-level-interceptors","title":"Class-Level vs Method-Level Interceptors","text":""},{"location":"interceptors/#class-level-all-methods","title":"Class-Level (All Methods)","text":"<p>Apply to all methods of a service:</p> <pre><code>[Intercept&lt;TimingInterceptor&gt;]\n[Intercept&lt;LoggingInterceptor&gt;]\npublic class ProductService : IProductService\n{\n    public Product GetProduct(int id) =&gt; /* ... */;     // Both interceptors run\n    public void UpdateProduct(Product p) =&gt; /* ... */;  // Both interceptors run\n}\n</code></pre>"},{"location":"interceptors/#method-level-selective","title":"Method-Level (Selective)","text":"<p>Apply to specific methods only:</p> <pre><code>public class CalculatorService : ICalculatorService\n{\n    public int Add(int a, int b) =&gt; a + b;  // No interceptor (direct call)\n\n    [Intercept&lt;TimingInterceptor&gt;]\n    public int Multiply(int a, int b)       // Only TimingInterceptor\n    {\n        Thread.Sleep(100);  // Expensive operation\n        return a * b;\n    }\n\n    [Intercept&lt;TimingInterceptor&gt;]\n    [Intercept&lt;CachingInterceptor&gt;]\n    public int Divide(int a, int b)         // Both interceptors\n    {\n        return a / b;\n    }\n}\n</code></pre>"},{"location":"interceptors/#interceptor-ordering","title":"Interceptor Ordering","text":"<p>When multiple interceptors are applied, use the <code>Order</code> property to control execution order:</p> <pre><code>[Intercept&lt;TimingInterceptor&gt;(Order = 1)]    // Runs first (outermost)\n[Intercept&lt;CachingInterceptor&gt;(Order = 2)]   // Runs second (inner)\npublic class DataService : IDataService { }\n</code></pre> <p>Execution flow: <pre><code>TimingInterceptor.InterceptAsync\n    \u2192 CachingInterceptor.InterceptAsync\n        \u2192 DataService.GetData (actual method)\n    \u2190 CachingInterceptor returns\n\u2190 TimingInterceptor returns\n</code></pre></p> <p>Lower <code>Order</code> values run first and are the outermost wrapper.</p>"},{"location":"interceptors/#imethodinvocation-interface","title":"IMethodInvocation Interface","text":"<p>The <code>IMethodInvocation</code> interface provides context about the intercepted call:</p> <pre><code>public interface IMethodInvocation\n{\n    object Target { get; }           // The service instance\n    MethodInfo Method { get; }       // Method being called\n    object?[] Arguments { get; }     // Arguments (can be modified)\n    Type[] GenericArguments { get; } // Generic type arguments (if any)\n\n    ValueTask&lt;object?&gt; ProceedAsync();  // Continue to next interceptor or target\n}\n</code></pre>"},{"location":"interceptors/#accessing-method-information","title":"Accessing Method Information","text":"<pre><code>public async ValueTask&lt;object?&gt; InterceptAsync(IMethodInvocation invocation)\n{\n    // Get the service type\n    var serviceType = invocation.Target.GetType().Name;\n\n    // Get method name\n    var methodName = invocation.Method.Name;\n\n    // Get arguments\n    var args = string.Join(\", \", invocation.Arguments);\n\n    Console.WriteLine($\"Calling {serviceType}.{methodName}({args})\");\n\n    return await invocation.ProceedAsync();\n}\n</code></pre>"},{"location":"interceptors/#modifying-arguments","title":"Modifying Arguments","text":"<pre><code>public async ValueTask&lt;object?&gt; InterceptAsync(IMethodInvocation invocation)\n{\n    // Modify the first argument before calling\n    if (invocation.Arguments.Length &gt; 0 &amp;&amp; invocation.Arguments[0] is string s)\n    {\n        invocation.Arguments[0] = s.ToUpperInvariant();\n    }\n\n    return await invocation.ProceedAsync();\n}\n</code></pre>"},{"location":"interceptors/#modifying-return-values","title":"Modifying Return Values","text":"<pre><code>public async ValueTask&lt;object?&gt; InterceptAsync(IMethodInvocation invocation)\n{\n    var result = await invocation.ProceedAsync();\n\n    // Wrap the result\n    if (result is string s)\n    {\n        return $\"[Modified] {s}\";\n    }\n\n    return result;\n}\n</code></pre>"},{"location":"interceptors/#common-interceptor-patterns","title":"Common Interceptor Patterns","text":""},{"location":"interceptors/#timing-interceptor","title":"Timing Interceptor","text":"<pre><code>public class TimingInterceptor : IMethodInterceptor\n{\n    private readonly ILogger _logger;\n\n    public TimingInterceptor(ILogger&lt;TimingInterceptor&gt; logger) =&gt; _logger = logger;\n\n    public async ValueTask&lt;object?&gt; InterceptAsync(IMethodInvocation invocation)\n    {\n        var sw = Stopwatch.StartNew();\n\n        try\n        {\n            return await invocation.ProceedAsync();\n        }\n        finally\n        {\n            _logger.LogInformation(\n                \"{Type}.{Method} completed in {Elapsed}ms\",\n                invocation.Target.GetType().Name,\n                invocation.Method.Name,\n                sw.ElapsedMilliseconds);\n        }\n    }\n}\n</code></pre>"},{"location":"interceptors/#caching-interceptor","title":"Caching Interceptor","text":"<pre><code>public class CachingInterceptor : IMethodInterceptor\n{\n    private readonly ConcurrentDictionary&lt;string, object?&gt; _cache = new();\n\n    public async ValueTask&lt;object?&gt; InterceptAsync(IMethodInvocation invocation)\n    {\n        var cacheKey = BuildCacheKey(invocation);\n\n        if (_cache.TryGetValue(cacheKey, out var cached))\n        {\n            return cached;\n        }\n\n        var result = await invocation.ProceedAsync();\n        _cache[cacheKey] = result;\n        return result;\n    }\n\n    private static string BuildCacheKey(IMethodInvocation invocation)\n    {\n        var args = string.Join(\",\", invocation.Arguments.Select(a =&gt; a?.ToString() ?? \"null\"));\n        return $\"{invocation.Target.GetType().Name}.{invocation.Method.Name}({args})\";\n    }\n}\n</code></pre>"},{"location":"interceptors/#retry-interceptor","title":"Retry Interceptor","text":"<pre><code>public class RetryInterceptor : IMethodInterceptor\n{\n    private readonly ILogger _logger;\n\n    public RetryInterceptor(ILogger&lt;RetryInterceptor&gt; logger) =&gt; _logger = logger;\n\n    public async ValueTask&lt;object?&gt; InterceptAsync(IMethodInvocation invocation)\n    {\n        const int maxRetries = 3;\n\n        for (var attempt = 1; attempt &lt;= maxRetries; attempt++)\n        {\n            try\n            {\n                return await invocation.ProceedAsync();\n            }\n            catch (Exception ex) when (attempt &lt; maxRetries)\n            {\n                _logger.LogWarning(ex, \n                    \"Attempt {Attempt}/{Max} failed for {Method}, retrying...\",\n                    attempt, maxRetries, invocation.Method.Name);\n\n                await Task.Delay(TimeSpan.FromSeconds(Math.Pow(2, attempt)));\n            }\n        }\n\n        throw new InvalidOperationException(\"Should not reach here\");\n    }\n}\n</code></pre>"},{"location":"interceptors/#validation-interceptor","title":"Validation Interceptor","text":"<pre><code>public class ValidationInterceptor : IMethodInterceptor\n{\n    public async ValueTask&lt;object?&gt; InterceptAsync(IMethodInvocation invocation)\n    {\n        // Validate all arguments\n        foreach (var arg in invocation.Arguments)\n        {\n            if (arg is null)\n            {\n                throw new ArgumentNullException(\n                    $\"Null argument passed to {invocation.Method.Name}\");\n            }\n        }\n\n        return await invocation.ProceedAsync();\n    }\n}\n</code></pre>"},{"location":"interceptors/#interceptor-dependencies","title":"Interceptor Dependencies","text":"<p>Interceptors are registered as services and can have their own dependencies:</p> <pre><code>public class AuditInterceptor : IMethodInterceptor\n{\n    private readonly IAuditService _audit;\n    private readonly ICurrentUser _user;\n\n    public AuditInterceptor(IAuditService audit, ICurrentUser user)\n    {\n        _audit = audit;\n        _user = user;\n    }\n\n    public async ValueTask&lt;object?&gt; InterceptAsync(IMethodInvocation invocation)\n    {\n        await _audit.LogAsync(new AuditEntry\n        {\n            User = _user.Id,\n            Action = invocation.Method.Name,\n            Timestamp = DateTime.UtcNow\n        });\n\n        return await invocation.ProceedAsync();\n    }\n}\n</code></pre>"},{"location":"interceptors/#auto-registration-exclusion","title":"Auto-Registration Exclusion","text":"<p>Interceptors are automatically excluded from Needlr's auto-registration because they implement <code>IMethodInterceptor</code>, which is marked with <code>[DoNotAutoRegister]</code>. This is by design\u2014interceptors are resolved by the generated proxy, not by user code.</p> <p>You do not need to add <code>[DoNotAutoRegister]</code> to your interceptor classes.</p>"},{"location":"interceptors/#limitations","title":"Limitations","text":"<ol> <li> <p>Source-generation only: Interceptors are not available with reflection-based registration.</p> </li> <li> <p>Interface-based: The intercepted service must implement at least one interface. The proxy is registered for the interface, not the concrete type.</p> </li> <li> <p>Generic methods: Generic methods are not currently supported for interception.</p> </li> <li> <p>Async overhead: All interception goes through <code>ValueTask&lt;object?&gt;</code>, so there's boxing overhead for value types and sync methods pay the async state machine cost.</p> </li> </ol>"},{"location":"interceptors/#analyzers","title":"Analyzers","text":"<p>Needlr provides analyzers to catch common interceptor mistakes at compile time:</p> Rule ID Severity Description NDLRCOR007 Error Intercept type must implement IMethodInterceptor NDLRCOR008 Warning [Intercept] applied to class without interfaces"},{"location":"interceptors/#see-also","title":"See Also","text":"<ul> <li>Open Generic Decorators - For service-specific wrapping</li> <li>Getting Started - Source generation setup</li> <li>Example: AotSourceGenConsoleApp - Working interceptor examples</li> </ul>"},{"location":"keyed-services/","title":"Keyed Services","text":"<p>Keyed services allow multiple implementations of the same interface to be registered with different keys, enabling consumers to resolve specific implementations.</p>"},{"location":"keyed-services/#registering-keyed-services","title":"Registering Keyed Services","text":"<p>Use the <code>[Keyed]</code> attribute to register a service with a specific key:</p> <pre><code>public interface ICacheProvider\n{\n    string Name { get; }\n}\n\n[Keyed(\"redis\")]\npublic sealed class RedisCacheProvider : ICacheProvider\n{\n    public string Name =&gt; \"redis\";\n}\n\n[Keyed(\"memory\")]\npublic sealed class MemoryCacheProvider : ICacheProvider\n{\n    public string Name =&gt; \"memory\";\n}\n</code></pre> <p>This generates registrations equivalent to:</p> <pre><code>services.AddKeyedSingleton&lt;ICacheProvider, RedisCacheProvider&gt;(\"redis\");\nservices.AddKeyedSingleton&lt;ICacheProvider, MemoryCacheProvider&gt;(\"memory\");\n</code></pre>"},{"location":"keyed-services/#consuming-keyed-services","title":"Consuming Keyed Services","text":"<p>Use the <code>[FromKeyedServices]</code> attribute (from <code>Microsoft.Extensions.DependencyInjection</code>) on constructor parameters to resolve keyed services:</p> <pre><code>public sealed class CacheManager\n{\n    private readonly ICacheProvider _primaryCache;\n    private readonly ICacheProvider _fallbackCache;\n\n    public CacheManager(\n        [FromKeyedServices(\"redis\")] ICacheProvider primaryCache,\n        [FromKeyedServices(\"memory\")] ICacheProvider fallbackCache)\n    {\n        _primaryCache = primaryCache;\n        _fallbackCache = fallbackCache;\n    }\n}\n</code></pre>"},{"location":"keyed-services/#mixing-keyed-and-regular-dependencies","title":"Mixing Keyed and Regular Dependencies","text":"<p>You can combine keyed and regular (unkeyed) dependencies in the same constructor:</p> <pre><code>public sealed class OrderService\n{\n    public OrderService(\n        [FromKeyedServices(\"primary\")] IPaymentProcessor processor,\n        ILogger&lt;OrderService&gt; logger)  // Regular dependency\n    {\n        // ...\n    }\n}\n</code></pre>"},{"location":"keyed-services/#registering-via-plugin","title":"Registering via Plugin","text":"<p>For more complex registration scenarios, use <code>IServiceCollectionPlugin</code>:</p> <pre><code>public sealed class PaymentServicesPlugin : IServiceCollectionPlugin\n{\n    public void Configure(ServiceCollectionPluginOptions options)\n    {\n        options.Services.AddKeyedSingleton&lt;IPaymentProcessor, StripeProcessor&gt;(\"stripe\");\n        options.Services.AddKeyedSingleton&lt;IPaymentProcessor, PayPalProcessor&gt;(\"paypal\");\n    }\n}\n</code></pre>"},{"location":"keyed-services/#notes","title":"Notes","text":"<ul> <li><code>[Keyed]</code> can be applied multiple times to register the same class with different keys</li> <li>Keyed services respect the same lifetime rules as regular services</li> <li>The key is a string value passed to <code>[FromKeyedServices(\"key\")]</code> when resolving</li> <li>This feature requires .NET 8+ (where keyed services were introduced)</li> <li>Both source-gen and reflection paths support keyed services</li> </ul> <p>Read More on Dev Leader</p> <ul> <li>Keyed Services in Needlr: Managing Multiple Implementations</li> </ul>"},{"location":"open-generic-decorators/","title":"Open Generic Decorators","text":"<p>Open generic decorators allow you to define a single decorator class that automatically wraps all closed implementations of an open generic interface. This is a source-generation-only feature.</p>"},{"location":"open-generic-decorators/#overview","title":"Overview","text":"<p>When you have a generic interface like <code>IHandler&lt;T&gt;</code> with multiple implementations (<code>OrderHandler : IHandler&lt;Order&gt;</code>, <code>PaymentHandler : IHandler&lt;Payment&gt;</code>, etc.), you typically want to apply cross-cutting concerns (logging, validation, metrics) to all of them.</p> <p>With <code>[OpenDecoratorFor]</code>, you define the decorator once and Needlr generates the decorator registrations for every closed implementation at compile time.</p>"},{"location":"open-generic-decorators/#basic-usage","title":"Basic Usage","text":"<pre><code>using NexusLabs.Needlr;\nusing NexusLabs.Needlr.Generators;\n\n// Define your open generic interface\npublic interface IHandler&lt;T&gt;\n{\n    Task HandleAsync(T message);\n}\n\n// Define concrete handlers\n[Singleton]\npublic class OrderHandler : IHandler&lt;Order&gt;\n{\n    public Task HandleAsync(Order message) { /* ... */ }\n}\n\n[Singleton]\npublic class PaymentHandler : IHandler&lt;Payment&gt;\n{\n    public Task HandleAsync(Payment message) { /* ... */ }\n}\n\n// Define an open generic decorator\n[OpenDecoratorFor(typeof(IHandler&lt;&gt;))]\npublic class LoggingDecorator&lt;T&gt; : IHandler&lt;T&gt;\n{\n    private readonly IHandler&lt;T&gt; _inner;\n    private readonly ILogger&lt;LoggingDecorator&lt;T&gt;&gt; _logger;\n\n    public LoggingDecorator(IHandler&lt;T&gt; inner, ILogger&lt;LoggingDecorator&lt;T&gt;&gt; logger)\n    {\n        _inner = inner;\n        _logger = logger;\n    }\n\n    public async Task HandleAsync(T message)\n    {\n        _logger.LogInformation(\"Handling {MessageType}\", typeof(T).Name);\n        await _inner.HandleAsync(message);\n        _logger.LogInformation(\"Handled {MessageType}\", typeof(T).Name);\n    }\n}\n</code></pre>"},{"location":"open-generic-decorators/#what-gets-generated","title":"What Gets Generated","text":"<p>At compile time, Needlr discovers all closed implementations of <code>IHandler&lt;T&gt;</code> and generates decorator registrations for each:</p> <pre><code>// Generated code (simplified)\nservices.AddDecorator&lt;IHandler&lt;Order&gt;, LoggingDecorator&lt;Order&gt;&gt;();\nservices.AddDecorator&lt;IHandler&lt;Payment&gt;, LoggingDecorator&lt;Payment&gt;&gt;();\n</code></pre>"},{"location":"open-generic-decorators/#ordering-multiple-decorators","title":"Ordering Multiple Decorators","text":"<p>Use the <code>Order</code> property to control decorator application order (lower = closer to the original service):</p> <pre><code>[OpenDecoratorFor(typeof(IHandler&lt;&gt;), Order = 1)]\npublic class LoggingDecorator&lt;T&gt; : IHandler&lt;T&gt; { /* ... */ }\n\n[OpenDecoratorFor(typeof(IHandler&lt;&gt;), Order = 2)]\npublic class MetricsDecorator&lt;T&gt; : IHandler&lt;T&gt; { /* ... */ }\n\n// Result chain: MetricsDecorator \u2192 LoggingDecorator \u2192 Handler\n</code></pre>"},{"location":"open-generic-decorators/#multi-parameter-generics","title":"Multi-Parameter Generics","text":"<p>Open generic decorators work with interfaces that have multiple type parameters:</p> <pre><code>public interface IRequestHandler&lt;TRequest, TResponse&gt;\n{\n    TResponse Handle(TRequest request);\n}\n\n[OpenDecoratorFor(typeof(IRequestHandler&lt;,&gt;))]\npublic class ValidationDecorator&lt;TRequest, TResponse&gt; : IRequestHandler&lt;TRequest, TResponse&gt;\n{\n    private readonly IRequestHandler&lt;TRequest, TResponse&gt; _inner;\n\n    public ValidationDecorator(IRequestHandler&lt;TRequest, TResponse&gt; inner) =&gt; _inner = inner;\n\n    public TResponse Handle(TRequest request)\n    {\n        Validate(request);\n        return _inner.Handle(request);\n    }\n}\n</code></pre>"},{"location":"open-generic-decorators/#comparison-with-decoratorfort","title":"Comparison with <code>[DecoratorFor&lt;T&gt;]</code>","text":"Feature <code>[DecoratorFor&lt;T&gt;]</code> <code>[OpenDecoratorFor]</code> Supports closed types \u2705 \u274c Supports open generics \u274c \u2705 Works with reflection \u2705 \u274c Works with source-gen \u2705 \u2705 Attribute location <code>NexusLabs.Needlr</code> <code>NexusLabs.Needlr.Generators</code> <p>Use <code>[DecoratorFor&lt;T&gt;]</code> when:</p> <ul> <li>You're decorating a specific closed type (e.g., <code>IOrderService</code>)</li> <li>You need reflection path compatibility</li> </ul> <p>Use <code>[OpenDecoratorFor]</code> when:</p> <ul> <li>You want to decorate all implementations of a generic interface</li> <li>You're using source generation (required)</li> <li>You want compile-time expansion</li> </ul>"},{"location":"open-generic-decorators/#validation","title":"Validation","text":"<p>Needlr provides compile-time analyzers to catch configuration errors:</p> Diagnostic Description NDLRGEN006 Type argument must be an open generic interface NDLRGEN007 Decorator class must be an open generic with matching arity NDLRGEN008 Decorator must implement the interface it decorates"},{"location":"open-generic-decorators/#example-errors","title":"Example Errors","text":"<pre><code>// NDLRGEN006: Must use typeof(IHandler&lt;&gt;), not typeof(IHandler&lt;string&gt;)\n[OpenDecoratorFor(typeof(IHandler&lt;string&gt;))]  // \u274c Error\npublic class BadDecorator&lt;T&gt; : IHandler&lt;T&gt; { }\n\n// NDLRGEN007: Decorator must be generic with same parameter count\n[OpenDecoratorFor(typeof(IHandler&lt;&gt;))]\npublic class BadDecorator : IHandler&lt;string&gt; { }  // \u274c Error - not generic\n\n// NDLRGEN008: Decorator must implement the interface\n[OpenDecoratorFor(typeof(IHandler&lt;&gt;))]\npublic class BadDecorator&lt;T&gt; { }  // \u274c Error - doesn't implement IHandler&lt;T&gt;\n</code></pre>"},{"location":"open-generic-decorators/#namespace-import","title":"Namespace Import","text":"<p>The <code>[OpenDecoratorFor]</code> attribute is in the <code>NexusLabs.Needlr.Generators</code> namespace:</p> <pre><code>using NexusLabs.Needlr.Generators;\n</code></pre> <p>This is intentional - it signals that the feature is source-generation-only.</p>"},{"location":"open-generic-decorators/#common-patterns","title":"Common Patterns","text":""},{"location":"open-generic-decorators/#cqrs-commandquery-decorators","title":"CQRS Command/Query Decorators","text":"<pre><code>public interface ICommandHandler&lt;TCommand&gt; where TCommand : ICommand\n{\n    Task HandleAsync(TCommand command, CancellationToken ct);\n}\n\npublic interface IQueryHandler&lt;TQuery, TResult&gt; where TQuery : IQuery&lt;TResult&gt;\n{\n    Task&lt;TResult&gt; HandleAsync(TQuery query, CancellationToken ct);\n}\n\n// Apply validation to all commands\n[OpenDecoratorFor(typeof(ICommandHandler&lt;&gt;), Order = 1)]\npublic class ValidationDecorator&lt;T&gt; : ICommandHandler&lt;T&gt; where T : ICommand\n{\n    private readonly ICommandHandler&lt;T&gt; _inner;\n    private readonly IValidator&lt;T&gt; _validator;\n\n    public ValidationDecorator(ICommandHandler&lt;T&gt; inner, IValidator&lt;T&gt; validator)\n    {\n        _inner = inner;\n        _validator = validator;\n    }\n\n    public async Task HandleAsync(T command, CancellationToken ct)\n    {\n        await _validator.ValidateAndThrowAsync(command, ct);\n        await _inner.HandleAsync(command, ct);\n    }\n}\n</code></pre>"},{"location":"open-generic-decorators/#retryresilience-patterns","title":"Retry/Resilience Patterns","text":"<pre><code>[OpenDecoratorFor(typeof(IHandler&lt;&gt;), Order = 0)]  // Outermost\npublic class RetryDecorator&lt;T&gt; : IHandler&lt;T&gt;\n{\n    private readonly IHandler&lt;T&gt; _inner;\n    private readonly IAsyncPolicy _policy;\n\n    public RetryDecorator(IHandler&lt;T&gt; inner, IAsyncPolicy policy)\n    {\n        _inner = inner;\n        _policy = policy;\n    }\n\n    public Task HandleAsync(T message) =&gt; \n        _policy.ExecuteAsync(() =&gt; _inner.HandleAsync(message));\n}\n</code></pre>"},{"location":"open-generic-decorators/#limitations","title":"Limitations","text":"<ol> <li>Source-generation only: This feature is not available in the reflection path</li> <li>Compile-time discovery: Only implementations visible at compile time are decorated</li> <li>Same assembly or referenced assemblies: Implementations must be discoverable by the source generator</li> </ol> <p>Read More on Dev Leader</p> <ul> <li>Decorator Pattern in C# with Needlr: Adding Cross-Cutting Concerns</li> </ul>"},{"location":"options/","title":"Options Binding","text":"<p>The <code>[Options]</code> attribute provides automatic configuration binding for your options classes, integrating with Microsoft's Options pattern.</p>"},{"location":"options/#quick-start","title":"Quick Start","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n[Options]\npublic class CacheSettings\n{\n    public int TimeoutSeconds { get; set; } = 300;\n    public int MaxItems { get; set; } = 1000;\n}\n</code></pre> <pre><code>// appsettings.json\n{\n  \"CacheSettings\": {\n    \"TimeoutSeconds\": 600,\n    \"MaxItems\": 5000\n  }\n}\n</code></pre> <p>The generator automatically: 1. Binds your options class to the configuration section 2. Registers it with the DI container 3. Makes it available via <code>IOptions&lt;CacheSettings&gt;</code>, <code>IOptionsSnapshot&lt;CacheSettings&gt;</code>, or <code>IOptionsMonitor&lt;CacheSettings&gt;</code></p>"},{"location":"options/#section-name","title":"Section Name","text":""},{"location":"options/#convention-based-default","title":"Convention-Based (Default)","text":"<p>By default, the section name is inferred from the class name:</p> Class Name Section Name <code>CacheSettings</code> <code>CacheSettings</code> <code>DatabaseOptions</code> <code>DatabaseOptions</code> <code>SmtpConfiguration</code> <code>SmtpConfiguration</code>"},{"location":"options/#explicit-section-name","title":"Explicit Section Name","text":"<p>Specify a custom section name:</p> <pre><code>[Options(\"MyApp:Database\")]\npublic class DatabaseOptions\n{\n    public string ConnectionString { get; set; } = \"\";\n}\n</code></pre> <pre><code>{\n  \"MyApp\": {\n    \"Database\": {\n      \"ConnectionString\": \"Server=...\"\n    }\n  }\n}\n</code></pre>"},{"location":"options/#named-options","title":"Named Options","text":"<p>For multiple configurations of the same type, use named options:</p> <pre><code>[Options(\"Databases:Primary\", Name = \"Primary\")]\npublic class DatabaseOptions\n{\n    public string ConnectionString { get; set; } = \"\";\n}\n\n[Options(\"Databases:Replica\", Name = \"Replica\")]\npublic class ReplicaDatabaseOptions : DatabaseOptions { }\n</code></pre> <p>Retrieve named options using <code>IOptionsSnapshot&lt;T&gt;</code> or <code>IOptionsMonitor&lt;T&gt;</code>:</p> <pre><code>public class MyService\n{\n    public MyService(IOptionsSnapshot&lt;DatabaseOptions&gt; options)\n    {\n        var primary = options.Get(\"Primary\");\n        var replica = options.Get(\"Replica\");\n    }\n}\n</code></pre>"},{"location":"options/#validation","title":"Validation","text":""},{"location":"options/#data-annotations","title":"Data Annotations","text":"<p>Use standard <code>System.ComponentModel.DataAnnotations</code> attributes:</p> <pre><code>using System.ComponentModel.DataAnnotations;\n\n[Options(ValidateOnStart = true)]\npublic class ApiSettings\n{\n    [Required]\n    public string ApiKey { get; set; } = \"\";\n\n    [Range(1, 300)]\n    public int TimeoutSeconds { get; set; } = 30;\n\n    [Url]\n    public string BaseUrl { get; set; } = \"\";\n}\n</code></pre> <p>When <code>ValidateOnStart = true</code>, the application will fail to start if validation fails.</p>"},{"location":"options/#custom-validation-method","title":"Custom Validation Method","text":"<p>Add a <code>Validate()</code> method to your options class:</p> <pre><code>[Options(ValidateOnStart = true)]\npublic class StripeOptions\n{\n    public string ApiKey { get; set; } = \"\";\n    public bool IsProduction { get; set; }\n\n    // Convention: method named \"Validate\" is auto-discovered\n    public IEnumerable&lt;ValidationError&gt; Validate()\n    {\n        if (IsProduction &amp;&amp; !ApiKey.StartsWith(\"sk_live_\"))\n            yield return \"Production requires a live API key\";\n\n        if (!IsProduction &amp;&amp; !ApiKey.StartsWith(\"sk_test_\"))\n            yield return \"Test mode requires a test API key\";\n    }\n}\n</code></pre>"},{"location":"options/#custom-method-name","title":"Custom Method Name","text":"<p>Use a different method name with <code>ValidateMethod</code>:</p> <pre><code>[Options(ValidateOnStart = true, ValidateMethod = nameof(CheckConfiguration))]\npublic class EmailOptions\n{\n    public string SmtpHost { get; set; } = \"\";\n\n    public IEnumerable&lt;ValidationError&gt; CheckConfiguration()\n    {\n        if (string.IsNullOrEmpty(SmtpHost))\n            yield return \"SMTP host is required\";\n    }\n}\n</code></pre>"},{"location":"options/#external-validator","title":"External Validator","text":"<p>Delegate validation to a separate class:</p> <pre><code>[Options(ValidateOnStart = true, Validator = typeof(PaymentOptionsValidator))]\npublic class PaymentOptions\n{\n    public string MerchantId { get; set; } = \"\";\n    public decimal MinAmount { get; set; }\n    public decimal MaxAmount { get; set; }\n}\n\npublic class PaymentOptionsValidator : IOptionsValidator&lt;PaymentOptions&gt;\n{\n    public IEnumerable&lt;ValidationError&gt; Validate(PaymentOptions options)\n    {\n        if (string.IsNullOrEmpty(options.MerchantId))\n            yield return \"MerchantId is required\";\n\n        if (options.MinAmount &gt;= options.MaxAmount)\n            yield return \"MinAmount must be less than MaxAmount\";\n    }\n}\n</code></pre>"},{"location":"options/#fluentvalidation-integration","title":"FluentValidation Integration","text":"<p>If you're using FluentValidation, validators are automatically discovered:</p> <pre><code>[Options(\"Database\", ValidateOnStart = true, Validator = typeof(DatabaseOptionsValidator))]\npublic class DatabaseOptions\n{\n    public string ConnectionString { get; set; } = \"\";\n    public int MaxPoolSize { get; set; } = 100;\n}\n\npublic class DatabaseOptionsValidator : AbstractValidator&lt;DatabaseOptions&gt;\n{\n    public DatabaseOptionsValidator()\n    {\n        RuleFor(x =&gt; x.ConnectionString)\n            .NotEmpty()\n            .WithMessage(\"Connection string is required\");\n\n        RuleFor(x =&gt; x.MaxPoolSize)\n            .InclusiveBetween(1, 1000);\n    }\n}\n</code></pre> <p>For more details on FluentValidation integration, see the Advanced Usage guide.</p>"},{"location":"options/#attribute-properties","title":"Attribute Properties","text":"Property Type Default Description <code>SectionName</code> <code>string?</code> Class name Configuration section to bind <code>Name</code> <code>string?</code> <code>null</code> Named options identifier <code>ValidateOnStart</code> <code>bool</code> <code>false</code> Validate at application startup <code>ValidateMethod</code> <code>string?</code> <code>\"Validate\"</code> Custom validation method name <code>Validator</code> <code>Type?</code> <code>null</code> External validator type"},{"location":"options/#generated-code","title":"Generated Code","text":"<p>The <code>[Options]</code> attribute causes the generator to emit registration code in <code>TypeRegistry.RegisterOptions()</code>:</p> <pre><code>// Generated code (simplified)\npublic static void RegisterOptions(IServiceCollection services, IConfiguration configuration)\n{\n    // Without validation\n    services.Configure&lt;CacheSettings&gt;(configuration.GetSection(\"CacheSettings\"));\n\n    // With validation\n    services.AddOptions&lt;ApiSettings&gt;()\n        .BindConfiguration(\"ApiSettings\")\n        .ValidateDataAnnotations()\n        .ValidateOnStart();\n}\n</code></pre>"},{"location":"options/#consuming-options","title":"Consuming Options","text":"<p>Inject options using standard Microsoft.Extensions.Options patterns:</p> <pre><code>public class MyService\n{\n    private readonly CacheSettings _settings;\n\n    // Option 1: IOptions&lt;T&gt; - singleton, doesn't reload\n    public MyService(IOptions&lt;CacheSettings&gt; options)\n    {\n        _settings = options.Value;\n    }\n\n    // Option 2: IOptionsSnapshot&lt;T&gt; - scoped, reloads per request\n    public MyService(IOptionsSnapshot&lt;CacheSettings&gt; options)\n    {\n        _settings = options.Value;\n    }\n\n    // Option 3: IOptionsMonitor&lt;T&gt; - singleton, live reload\n    public MyService(IOptionsMonitor&lt;CacheSettings&gt; options)\n    {\n        _settings = options.CurrentValue;\n        options.OnChange(newValue =&gt; { /* handle reload */ });\n    }\n}\n</code></pre>"},{"location":"options/#immutable-options","title":"Immutable Options","text":"<p>The <code>[Options]</code> attribute supports immutable options patterns, including <code>init</code>-only properties and records with init properties.</p>"},{"location":"options/#init-only-properties","title":"Init-Only Properties","text":"<pre><code>[Options(\"Cache\")]\npublic class CacheOptions\n{\n    public required string Host { get; init; }\n    public int Port { get; init; } = 6379;\n    public int TimeoutMs { get; init; } = 5000;\n}\n</code></pre>"},{"location":"options/#records-with-init-properties","title":"Records with Init Properties","text":"<pre><code>[Options(\"Redis\")]\npublic record RedisOptions\n{\n    public string Host { get; init; } = \"localhost\";\n    public int Port { get; init; } = 6379;\n}\n</code></pre>"},{"location":"options/#configuration-reload-with-immutable-types","title":"Configuration Reload with Immutable Types","text":"<p>Immutable types work correctly with <code>IOptionsMonitor&lt;T&gt;</code> for configuration reload. When the configuration file changes:</p> <ol> <li>A new instance is created with the updated values</li> <li><code>IOptionsMonitor&lt;T&gt;.CurrentValue</code> returns the new instance</li> <li><code>OnChange()</code> callbacks receive the new instance</li> </ol> <pre><code>public class CacheService\n{\n    private readonly IOptionsMonitor&lt;CacheOptions&gt; _options;\n\n    public CacheService(IOptionsMonitor&lt;CacheOptions&gt; options)\n    {\n        _options = options;\n\n        // React to configuration changes\n        options.OnChange(newOptions =&gt;\n        {\n            // newOptions is a new immutable instance\n            Console.WriteLine($\"Cache timeout changed to {newOptions.TimeoutMs}ms\");\n        });\n    }\n\n    public CacheOptions CurrentConfig =&gt; _options.CurrentValue;\n}\n</code></pre>"},{"location":"options/#positional-records","title":"Positional Records","text":"<p>Positional records (records with primary constructor parameters) are supported when declared as <code>partial</code>:</p> <pre><code>// \u2705 WORKS - partial positional record\n[Options(\"Redis\")]\npublic partial record RedisOptions(string Host, int Port);\n\n// \u2705 WORKS - init-only properties (no partial needed)\n[Options(\"Redis\")]\npublic record RedisOptions\n{\n    public string Host { get; init; } = \"\";\n    public int Port { get; init; } = 6379;\n}\n</code></pre> <p>When you use <code>partial</code>, Needlr generates a parameterless constructor that chains to the primary constructor:</p> <pre><code>// Generated code:\npublic partial record RedisOptions\n{\n    public RedisOptions() : this(string.Empty, default) { }\n}\n</code></pre> <p>This enables Microsoft's configuration binder to instantiate the record.</p> <p>\u26a0\ufe0f Non-partial positional records will emit warning NDLRGEN021 because they cannot work with configuration binding at runtime.</p>"},{"location":"options/#aot-compatibility","title":"AOT Compatibility","text":"<p>\u26a0\ufe0f Important: The <code>[Options]</code> attribute is not compatible with Native AOT.</p> <p>The generated code uses <code>Configure&lt;T&gt;()</code> and <code>BindConfiguration()</code> which rely on reflection for property binding. These APIs have <code>[RequiresDynamicCode]</code> attributes, making them incompatible with AOT compilation.</p> <p>If your project has <code>PublishAot=true</code> or <code>IsAotCompatible=true</code>, the generator will emit error NDLRGEN020.</p> <p>Workaround for AOT projects: Bind configuration manually:</p> <pre><code>public class CacheSettings\n{\n    public int TimeoutSeconds { get; set; }\n\n    public static CacheSettings FromConfiguration(IConfiguration config)\n    {\n        var section = config.GetSection(\"CacheSettings\");\n        return new CacheSettings\n        {\n            TimeoutSeconds = section.GetValue&lt;int&gt;(\"TimeoutSeconds\")\n        };\n    }\n}\n\n// In startup:\nvar settings = CacheSettings.FromConfiguration(configuration);\nservices.AddSingleton(Microsoft.Extensions.Options.Options.Create(settings));\n</code></pre>"},{"location":"options/#analyzers","title":"Analyzers","text":"<p>The following analyzers help catch common mistakes:</p> Analyzer Severity Description NDLRGEN014 Error Validator type has no validation method NDLRGEN015 Error Validator type mismatch NDLRGEN016 Error Validation method not found NDLRGEN017 Error Validation method has wrong signature NDLRGEN018 Warning Validator won't run (ValidateOnStart is false) NDLRGEN019 Warning Validation method won't run (ValidateOnStart is false) NDLRGEN020 Error [Options] is not compatible with Native AOT NDLRGEN021 Warning Positional record must be partial for [Options]"},{"location":"options/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Always validate in production: Use <code>ValidateOnStart = true</code> to fail fast on misconfiguration</p> </li> <li> <p>Use strongly-typed sections: Prefer explicit section names over relying on conventions when your config structure is complex</p> </li> <li> <p>Separate validation logic: Use external validators for complex validation rules to keep options classes clean</p> </li> <li> <p>Document required settings: Use <code>[Required]</code> and XML comments to make configuration requirements clear</p> </li> <li> <p>Provide sensible defaults: Initialize properties with default values for optional settings</p> </li> </ol>"},{"location":"options/#see-also","title":"See Also","text":"<ul> <li>Getting Started</li> <li>Analyzers Reference</li> </ul>"},{"location":"plugin-development/","title":"Plugin Development Guide","text":"<p>Plugins are a powerful way to extend Needlr's functionality and configure your application in a modular, reusable way.</p>"},{"location":"plugin-development/#plugin-types","title":"Plugin Types","text":"<p>Needlr provides several main plugin interfaces, each serving a specific purpose in the application lifecycle. They are intended to be split out into different packages as necessary with some in the core set of packages and others split out into others so you can control what you incorporate.</p>"},{"location":"plugin-development/#1-iservicecollectionplugin","title":"1. IServiceCollectionPlugin","text":"<p>Configures services during the initial registration phase.</p> <pre><code>using Microsoft.Extensions.DependencyInjection;\nusing NexusLabs.Needlr;\n\npublic class DatabasePlugin : IServiceCollectionPlugin\n{\n    public void Configure(ServiceCollectionPluginOptions options)\n    {\n        // Access the service collection\n        options.Services.AddDbContext&lt;MyDbContext&gt;(opts =&gt;\n            opts.UseSqlServer(options.Configuration.GetConnectionString(\"Default\")));\n\n        // Log registration activities\n        options.Logger.LogInformation(\"Database context registered\");\n\n        // Access configuration\n        var connectionString = options.Configuration.GetConnectionString(\"Default\");\n\n        // Register additional services\n        options.Services.AddScoped&lt;IRepository, Repository&gt;();\n    }\n}\n</code></pre>"},{"location":"plugin-development/#2-ipostbuildservicecollectionplugin","title":"2. IPostBuildServiceCollectionPlugin","text":"<p>Executes after the main service collection has been built, useful for validation or late configuration.</p> <pre><code>public class ValidationPlugin : IPostBuildServiceCollectionPlugin\n{\n    public void Configure(PostBuildServiceCollectionPluginOptions options)\n    {\n        // Validate that required services are registered\n        var requiredService = options.ServiceProvider.GetService&lt;IRequiredService&gt;();\n        if (requiredService == null)\n        {\n            options.Logger.LogError(\"IRequiredService is not registered!\");\n            throw new InvalidOperationException(\"Required service missing\");\n        }\n\n        // Perform post-build configuration\n        var configService = options.ServiceProvider.GetRequiredService&lt;IConfigurationService&gt;();\n        configService.Validate();\n\n        options.Logger.LogInformation(\"Post-build validation completed\");\n    }\n}\n</code></pre>"},{"location":"plugin-development/#3-iwebapplicationbuilderplugin","title":"3. IWebApplicationBuilderPlugin","text":"<p>Configures the WebApplicationBuilder before the application is built.</p> <pre><code>public class SecurityPlugin : IWebApplicationBuilderPlugin\n{\n    public void Configure(WebApplicationBuilderPluginOptions options)\n    {\n        // Configure services\n        options.Builder.Services.AddAuthentication()\n            .AddJwtBearer(opts =&gt; \n            {\n                opts.Authority = options.Builder.Configuration[\"Auth:Authority\"];\n            });\n\n        options.Builder.Services.AddAuthorization(opts =&gt;\n        {\n            opts.AddPolicy(\"AdminOnly\", policy =&gt; \n                policy.RequireRole(\"Admin\"));\n        });\n\n        // Configure Kestrel\n        options.Builder.WebHost.ConfigureKestrel(serverOptions =&gt;\n        {\n            serverOptions.Limits.MaxRequestBodySize = 10 * 1024 * 1024; // 10MB\n        });\n\n        // Add configuration sources\n        options.Builder.Configuration.AddJsonFile(\"security.json\", optional: true);\n\n        options.Logger.LogInformation(\"Security configured\");\n    }\n}\n</code></pre>"},{"location":"plugin-development/#4-iwebapplicationplugin","title":"4. IWebApplicationPlugin","text":"<p>Configures the WebApplication after it's built, typically for middleware and endpoint configuration.</p> <pre><code>public class ApiPlugin : IWebApplicationPlugin\n{\n    public void Configure(WebApplicationPluginOptions options)\n    {\n        var app = options.WebApplication;\n\n        // Configure middleware pipeline\n        if (app.Environment.IsDevelopment())\n        {\n            app.UseSwagger();\n            app.UseSwaggerUI();\n        }\n\n        app.UseAuthentication();\n        app.UseAuthorization();\n\n        // Map endpoints\n        app.MapGet(\"/api/health\", () =&gt; Results.Ok(new { Status = \"Healthy\" }))\n            .WithName(\"HealthCheck\")\n            .WithOpenApi();\n\n        app.MapPost(\"/api/data\", async (DataRequest request, IDataService service) =&gt;\n        {\n            var result = await service.ProcessAsync(request);\n            return Results.Ok(result);\n        })\n        .RequireAuthorization(\"AdminOnly\");\n\n        options.Logger.LogInformation(\"API endpoints configured\");\n    }\n}\n</code></pre>"},{"location":"plugin-development/#plugin-discovery-and-registration","title":"Plugin Discovery and Registration","text":""},{"location":"plugin-development/#automatic-discovery","title":"Automatic Discovery","text":"<p>Plugins are automatically discovered through assembly scanning. You must configure a discovery strategy:</p> <pre><code>// With source generation\nvar webApp = new Syringe()\n    .UsingSourceGen()\n    .ForWebApplication()\n    .BuildWebApplication();\n\n// With reflection\nvar webApp = new Syringe()\n    .UsingReflection()\n    .ForWebApplication()\n    .BuildWebApplication();\n</code></pre> <p>For built-in plugins, you do not need to annotate them with the special attributes that prevent auto-registration and injection prevention since this is done by the framework itself.</p>"},{"location":"plugin-development/#controlling-plugin-discovery","title":"Controlling Plugin Discovery","text":""},{"location":"plugin-development/#assembly-filtering","title":"Assembly Filtering","text":"<p>Control which assemblies are scanned for plugins:</p> <pre><code>var webApp = new Syringe()\n    .UsingSourceGen()  // or .UsingReflection()\n    .UsingAssemblyProvider(builder =&gt; builder\n        .MatchingAssemblies(x =&gt; \n            x.Contains(\"MyCompany.Plugins\"))\n        .Build())\n    .ForWebApplication()\n    .BuildWebApplication();\n</code></pre>"},{"location":"plugin-development/#plugin-execution-order","title":"Plugin Execution Order","text":"<p>Plugins are executed in a deterministic order based on two factors:</p> <ol> <li>Plugin Order Attribute - Explicit ordering via <code>[PluginOrder]</code></li> <li>Type Name - Alphabetical sorting when orders are equal</li> </ol>"},{"location":"plugin-development/#using-the-pluginorder-attribute","title":"Using the PluginOrder Attribute","text":"<p>Use the <code>[PluginOrder]</code> attribute to control when your plugin executes relative to others:</p> <pre><code>using NexusLabs.Needlr;\n\n// Executes first - negative values run before default (0)\n[PluginOrder(-100)]\npublic class DatabaseMigrationPlugin : IServiceCollectionPlugin\n{\n    public void Configure(ServiceCollectionPluginOptions options)\n    {\n        // Run migrations before other plugins register services\n        options.Services.AddDbContext&lt;MyDbContext&gt;();\n    }\n}\n\n// Executes at default order (0) - no attribute needed\npublic class BusinessLogicPlugin : IServiceCollectionPlugin\n{\n    public void Configure(ServiceCollectionPluginOptions options)\n    {\n        // Normal service registration\n        options.Services.AddScoped&lt;IOrderService, OrderService&gt;();\n    }\n}\n\n// Executes last - positive values run after default (0)\n[PluginOrder(100)]\npublic class ValidationPlugin : IServiceCollectionPlugin\n{\n    public void Configure(ServiceCollectionPluginOptions options)\n    {\n        // Validate all registrations are complete\n    }\n}\n</code></pre>"},{"location":"plugin-development/#order-values","title":"Order Values","text":"Order Range Typical Use Case -100 to -50 Infrastructure setup (database, logging, configuration) -50 to -1 Core services that others depend on 0 (default) Normal business logic plugins 1 to 50 Plugins that depend on other registrations 50 to 100 Validation, cleanup, and finalization"},{"location":"plugin-development/#same-order-determinism","title":"Same-Order Determinism","text":"<p>When multiple plugins have the same order value, they are sorted alphabetically by their fully qualified type name. This ensures deterministic execution across builds:</p> <pre><code>// Both have Order = 0, so they execute alphabetically\npublic class AuditPlugin : IServiceCollectionPlugin { }      // Executes first\npublic class ZipCodePlugin : IServiceCollectionPlugin { }    // Executes second\n</code></pre>"},{"location":"plugin-development/#works-with-all-plugin-types","title":"Works with All Plugin Types","text":"<p>The <code>[PluginOrder]</code> attribute works with all Needlr plugin interfaces:</p> <pre><code>// IServiceCollectionPlugin\n[PluginOrder(-50)]\npublic class EarlyServicePlugin : IServiceCollectionPlugin { }\n\n// IWebApplicationBuilderPlugin\n[PluginOrder(10)]\npublic class MiddlewareSetupPlugin : IWebApplicationBuilderPlugin { }\n\n// IWebApplicationPlugin\n[PluginOrder(100)]\npublic class FinalEndpointPlugin : IWebApplicationPlugin { }\n\n// IHostApplicationBuilderPlugin\n[PluginOrder(-100)]\npublic class HostSetupPlugin : IHostApplicationBuilderPlugin { }\n</code></pre>"},{"location":"plugin-development/#parity-between-reflection-and-source-generation","title":"Parity Between Reflection and Source Generation","text":"<p>Plugin ordering works identically whether you use reflection or source generation:</p> <pre><code>// Both produce the same plugin execution order\nvar reflectionApp = new Syringe()\n    .UsingReflection()\n    .ForWebApplication()\n    .BuildWebApplication();\n\nvar sourceGenApp = new Syringe()\n    .UsingSourceGen()\n    .ForWebApplication()\n    .BuildWebApplication();\n</code></pre>"},{"location":"plugin-development/#assembly-filtering_1","title":"Assembly Filtering","text":"<p>You can also control which assemblies are scanned for plugins:</p> <pre><code>var webApp = new Syringe()\n    .UsingSourceGen()  // or .UsingReflection()\n    .UsingAssemblyProvider(builder =&gt; builder\n        .MatchingAssemblies(x =&gt; x.Contains(\"MyCompany.Plugins\"))\n        .UseLibTestEntryOrdering() // Libraries \u2192 Executables \u2192 Tests\n        .Build())\n    .ForWebApplication()\n    .BuildWebApplication();\n</code></pre>"},{"location":"plugin-development/#execution-timeline","title":"Execution Timeline","text":"<p>Within each lifecycle phase, plugins are sorted by <code>[PluginOrder]</code> then by type name:</p> <ol> <li>IServiceCollectionPlugin - During service registration</li> <li>IPostBuildServiceCollectionPlugin - After service provider is built</li> <li>IWebApplicationBuilderPlugin - Before WebApplication.Build()</li> <li>IWebApplicationPlugin - After WebApplication.Build()</li> </ol>"},{"location":"plugin-development/#advanced-plugin-patterns","title":"Advanced Plugin Patterns","text":""},{"location":"plugin-development/#configuration-driven-plugins","title":"Configuration-Driven Plugins","text":"<pre><code>public class FeatureTogglePlugin : IServiceCollectionPlugin\n{\n    public void Configure(ServiceCollectionPluginOptions options)\n    {\n        var features = options.Configuration.GetSection(\"Features\");\n\n        if (features.GetValue&lt;bool&gt;(\"EnableCache\"))\n        {\n            options.Services.AddMemoryCache();\n            options.Services.AddSingleton&lt;ICacheService, MemoryCacheService&gt;();\n            options.Logger.LogInformation(\"Cache feature enabled\");\n        }\n\n        if (features.GetValue&lt;bool&gt;(\"EnableMetrics\"))\n        {\n            options.Services.AddSingleton&lt;IMetricsService, MetricsService&gt;();\n            options.Logger.LogInformation(\"Metrics feature enabled\");\n        }\n    }\n}\n</code></pre>"},{"location":"plugin-development/#composite-plugins","title":"Composite Plugins","text":"<p>Plugins may implement multiple plugin interfaces. This is especially common for ASP.NET plugins because we may want to configure both the builder and the web application that is created.</p> <pre><code>public class MicroservicePlugin : IServiceCollectionPlugin, \n    IWebApplicationBuilderPlugin, \n    IWebApplicationPlugin\n{\n    public void Configure(ServiceCollectionPluginOptions options)\n    {\n        // Register core services\n        options.Services.AddHealthChecks();\n        options.Services.AddHttpClient();\n    }\n\n    public void Configure(WebApplicationBuilderPluginOptions options)\n    {\n        // Configure distributed tracing\n        options.Builder.Services.AddOpenTelemetry()\n            .WithTracing(builder =&gt; builder\n                .AddAspNetCoreInstrumentation()\n                .AddHttpClientInstrumentation());\n    }\n\n    public void Configure(WebApplicationPluginOptions options)\n    {\n        // Configure middleware and endpoints\n        options.WebApplication.UseHealthChecks(\"/health\");\n        options.WebApplication.MapMetrics();\n    }\n}\n</code></pre>"},{"location":"plugin-development/#plugin-with-dependencies","title":"Plugin with Dependencies","text":"<p>The built-in plugins do not support dependency injection through their constructors, so if you need dependencies then you will need to access them from the dependency injection framework based on the lifecycle.</p> <pre><code>public class DependentPlugin : IPostBuildServiceCollectionPlugin\n{\n    public void Configure(PostBuildServiceCollectionPluginOptions options)\n    {\n        // Get services that were registered by other plugins\n        var dbContext = options.ServiceProvider.GetRequiredService&lt;MyDbContext&gt;();\n        var cache = options.ServiceProvider.GetService&lt;IMemoryCache&gt;();\n\n        if (cache != null)\n        {\n            // Initialize cache with data from database\n            var initialData = dbContext.Settings.ToList();\n            foreach (var setting in initialData)\n            {\n                cache.Set(setting.Key, setting.Value);\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"providers/","title":"Providers (Typed Service Locators)","text":"<p>Providers offer a strongly-typed alternative to the service locator pattern (<code>IServiceProvider.GetService&lt;T&gt;()</code>). Instead of relying on runtime type resolution, providers give you compile-time guarantees and IntelliSense for the services you need.</p>"},{"location":"providers/#why-use-providers","title":"Why Use Providers?","text":"<p>The service locator pattern is considered an anti-pattern because it:</p> <ul> <li>Hides dependencies (not visible in constructor signature)</li> <li>Fails at runtime instead of compile time</li> <li>Makes code harder to test</li> <li>Provides no IntelliSense for available services</li> </ul> <p>Providers solve these problems by generating strongly-typed interfaces with compile-time validation.</p>"},{"location":"providers/#basic-usage","title":"Basic Usage","text":""},{"location":"providers/#interface-mode","title":"Interface Mode","text":"<p>Define an interface decorated with <code>[Provider]</code>:</p> <pre><code>using NexusLabs.Needlr.Generators;\n\n[Provider]\npublic interface IOrderServicesProvider\n{\n    IOrderRepository Repository { get; }\n    IOrderValidator Validator { get; }\n    IOrderNotifier Notifier { get; }\n}\n</code></pre> <p>The source generator creates:</p> <ul> <li><code>OrderServicesProvider</code> - Implementation class in <code>{AssemblyName}.Generated</code> namespace</li> <li>Singleton registration - Provider is registered and resolved as a singleton</li> </ul>"},{"location":"providers/#shorthand-mode","title":"Shorthand Mode","text":"<p>For quick provider definitions, use the shorthand syntax on a partial class:</p> <pre><code>[Provider(typeof(IOrderRepository), typeof(IOrderValidator))]\npublic partial class OrderProvider { }\n</code></pre> <p>The generator creates:</p> <ul> <li><code>IOrderProvider</code> - Generated interface with properties for each type</li> <li>Partial class implementation - Completes your class with constructor and properties</li> </ul>"},{"location":"providers/#resolving-providers","title":"Resolving Providers","text":"<pre><code>// Get the provider (singleton)\nvar orderServices = serviceProvider.GetRequiredService&lt;IOrderServicesProvider&gt;();\n\n// Use strongly-typed properties\nvar order = orderServices.Repository.GetById(orderId);\nif (orderServices.Validator.Validate(order))\n{\n    orderServices.Notifier.NotifyCustomer(order);\n}\n</code></pre>"},{"location":"providers/#optional-services","title":"Optional Services","text":"<p>Use nullable types for optional dependencies:</p> <pre><code>[Provider]\npublic interface IServicesProvider\n{\n    IRequiredService Required { get; }\n    IOptionalService? Optional { get; }  // May be null if not registered\n}\n</code></pre> <p>Or with shorthand:</p> <pre><code>[Provider(\n    Required = new[] { typeof(IRequiredService) },\n    Optional = new[] { typeof(IOptionalService) })]\npublic partial class ServicesProvider { }\n</code></pre> <p>Optional services are resolved with <code>GetService&lt;T&gt;()</code> and may be null. The generated constructor uses optional parameters with default null values.</p>"},{"location":"providers/#collection-services","title":"Collection Services","text":"<p>Resolve all implementations of a service:</p> <pre><code>[Provider]\npublic interface IHandlersProvider\n{\n    IEnumerable&lt;IEventHandler&gt; EventHandlers { get; }\n}\n</code></pre> <p>Or with shorthand:</p> <pre><code>[Provider(Collections = new[] { typeof(IEventHandler) })]\npublic partial class HandlersProvider { }\n</code></pre> <p>The property name is automatically pluralized (<code>IEventHandler</code> \u2192 <code>EventHandlers</code>).</p>"},{"location":"providers/#factory-services","title":"Factory Services","text":"<p>For services that need runtime parameters, use the <code>Factories</code> parameter:</p> <pre><code>[GenerateFactory]\npublic class ReportGenerator\n{\n    public ReportGenerator(ILogger&lt;ReportGenerator&gt; logger, string reportTitle) { }\n}\n\n[Provider(Factories = new[] { typeof(ReportGenerator) })]\npublic partial class ReportingProvider { }\n</code></pre> <p>This generates a property for <code>IReportGeneratorFactory</code>:</p> <pre><code>// Generated interface includes factory\npublic interface IReportingProvider\n{\n    IReportGeneratorFactory ReportGeneratorFactory { get; }\n}\n\n// Usage\nvar reporting = serviceProvider.GetRequiredService&lt;IReportingProvider&gt;();\nvar report = reporting.ReportGeneratorFactory.Create(\"Monthly Sales Report\");\n</code></pre>"},{"location":"providers/#nested-providers","title":"Nested Providers","text":"<p>Providers can reference other providers for modular service organization:</p> <pre><code>[Provider]\npublic interface IOrderServicesProvider\n{\n    IOrderRepository Repository { get; }\n    IOrderValidator Validator { get; }\n}\n\n[Provider]\npublic interface IShippingServicesProvider\n{\n    IShippingCalculator Calculator { get; }\n    ICarrierService Carrier { get; }\n}\n\n[Provider]\npublic interface IEcommerceProvider\n{\n    IOrderServicesProvider Orders { get; }\n    IShippingServicesProvider Shipping { get; }\n}\n</code></pre> <p>Nested providers maintain singleton semantics - the same instance is shared.</p>"},{"location":"providers/#mixed-property-kinds","title":"Mixed Property Kinds","text":"<p>Combine all property kinds in a single provider:</p> <pre><code>[Provider]\npublic interface IApplicationServicesProvider\n{\n    // Required - must be registered\n    IUserService UserService { get; }\n\n    // Optional - may be null\n    IAnalyticsService? Analytics { get; }\n\n    // Collection - all implementations\n    IEnumerable&lt;IHealthCheck&gt; HealthChecks { get; }\n}\n</code></pre> <p>Or with shorthand:</p> <pre><code>[Provider(\n    Required = new[] { typeof(IUserService) },\n    Optional = new[] { typeof(IAnalyticsService) },\n    Collections = new[] { typeof(IHealthCheck) },\n    Factories = new[] { typeof(BackgroundJob) })]\npublic partial class ApplicationProvider { }\n</code></pre>"},{"location":"providers/#singleton-behavior","title":"Singleton Behavior","text":"<p>Providers are always registered as Singletons. This means:</p> <ul> <li>All services are resolved at construction time (fail-fast)</li> <li>The same provider instance is reused throughout the application</li> <li>Service properties return the same instances on every access</li> </ul> <p>For new instances on demand, use factory properties instead of direct service references.</p>"},{"location":"providers/#analyzers","title":"Analyzers","text":"<p>Needlr includes analyzers to validate provider usage at compile time:</p> Diagnostic Severity Description NDLRGEN031 Error <code>[Provider]</code> on class requires <code>partial</code> modifier NDLRGEN032 Error <code>[Provider]</code> interface has invalid member (methods, settable properties) NDLRGEN033 Warning Provider property uses concrete type instead of interface NDLRGEN034 Error Circular provider dependency detected"},{"location":"providers/#namespace","title":"Namespace","text":"<p>Generated provider implementations are placed in:</p> <ul> <li>Interface mode: <code>{AssemblyName}.Generated</code> namespace</li> <li>Shorthand mode: Same namespace as your partial class</li> </ul> <pre><code>using MyApp.Generated;  // Contains OrderServicesProvider, etc.\n</code></pre>"},{"location":"providers/#when-to-use-providers","title":"When to Use Providers","text":"<p>Use Providers when:</p> <ul> <li>You need to access multiple related services together</li> <li>You want compile-time validation of service dependencies</li> <li>You're replacing <code>IServiceProvider.GetService&lt;T&gt;()</code> calls</li> <li>You want better IntelliSense and discoverability</li> <li>You're organizing services into logical groups</li> </ul> <p>Consider Alternatives when:</p> <ul> <li>You only need one service (use constructor injection directly)</li> <li>You need to create scoped instances (use <code>IServiceScopeFactory</code>)</li> <li>You need runtime service resolution based on conditions (use <code>IServiceProvider</code>)</li> </ul>"},{"location":"providers/#complete-example","title":"Complete Example","text":"<pre><code>using NexusLabs.Needlr.Generators;\nusing MyApp.Generated;\n\n// Define your services\npublic interface IUserRepository { User GetById(Guid id); }\npublic interface IEmailService { Task SendAsync(string to, string subject, string body); }\npublic interface IAuditLogger { void Log(string action); }\n\n// Define a provider for user-related services\n[Provider]\npublic interface IUserServicesProvider\n{\n    IUserRepository Repository { get; }\n    IEmailService Email { get; }\n    IAuditLogger? Audit { get; }  // Optional\n}\n\n// Use in your application\npublic class UserController\n{\n    private readonly IUserServicesProvider _services;\n\n    public UserController(IUserServicesProvider services)\n    {\n        _services = services;\n    }\n\n    public async Task&lt;IActionResult&gt; NotifyUser(Guid userId, string message)\n    {\n        var user = _services.Repository.GetById(userId);\n\n        await _services.Email.SendAsync(user.Email, \"Notification\", message);\n\n        // Audit is optional - check for null\n        _services.Audit?.Log($\"Notified user {userId}\");\n\n        return Ok();\n    }\n}\n</code></pre>"},{"location":"register-as/","title":"RegisterAs&lt;T&gt; - Explicit Interface Registration","text":"<p>The <code>[RegisterAs&lt;T&gt;]</code> attribute gives you explicit control over which interfaces a class is registered as in dependency injection. By default, Needlr registers a class as all non-system interfaces it implements. Use <code>[RegisterAs&lt;T&gt;]</code> when you want to limit which interfaces are publicly resolvable.</p>"},{"location":"register-as/#basic-usage","title":"Basic Usage","text":"<pre><code>public interface IReader { string Read(); }\npublic interface IWriter { void Write(string data); }\npublic interface ILogger { void Log(string message); }\n\n// Only registered as IReader - not as IWriter or ILogger\n[RegisterAs&lt;IReader&gt;]\npublic class FileService : IReader, IWriter, ILogger\n{\n    public string Read() =&gt; \"file content\";\n    public void Write(string data) { /* ... */ }\n    public void Log(string message) { /* ... */ }\n}\n</code></pre> <p>With this configuration:</p> <ul> <li>\u2705 <code>provider.GetService&lt;IReader&gt;()</code> returns <code>FileService</code></li> <li>\u2705 <code>provider.GetService&lt;FileService&gt;()</code> returns <code>FileService</code> (concrete type always registered)</li> <li>\u274c <code>provider.GetService&lt;IWriter&gt;()</code> returns <code>null</code></li> <li>\u274c <code>provider.GetService&lt;ILogger&gt;()</code> returns <code>null</code></li> </ul>"},{"location":"register-as/#multiple-registeras-attributes","title":"Multiple RegisterAs Attributes","text":"<p>You can apply multiple <code>[RegisterAs&lt;T&gt;]</code> attributes to register as multiple specific interfaces:</p> <pre><code>[RegisterAs&lt;IReader&gt;]\n[RegisterAs&lt;IWriter&gt;]\npublic class FileService : IReader, IWriter, ILogger\n{\n    // Registered as IReader and IWriter, but NOT as ILogger\n}\n</code></pre>"},{"location":"register-as/#use-cases","title":"Use Cases","text":""},{"location":"register-as/#1-controlling-public-api-surface","title":"1. Controlling Public API Surface","text":"<p>When a class implements internal utility interfaces that shouldn't be exposed:</p> <pre><code>public interface IOrderService { void PlaceOrder(); }\ninternal interface IOrderValidator { bool Validate(); }\ninternal interface IAuditLogger { void Log(); }\n\n[RegisterAs&lt;IOrderService&gt;]\npublic class OrderService : IOrderService, IOrderValidator, IAuditLogger\n{\n    // Only IOrderService is resolvable - internal interfaces are hidden\n}\n</code></pre>"},{"location":"register-as/#2-avoiding-ambiguous-registrations","title":"2. Avoiding Ambiguous Registrations","text":"<p>When multiple classes implement the same interface but you want specific resolution:</p> <pre><code>public interface INotificationSender { void Send(); }\npublic interface IEmailSender { void SendEmail(); }\npublic interface ISmsSender { void SendSms(); }\n\n[RegisterAs&lt;IEmailSender&gt;]\npublic class EmailService : INotificationSender, IEmailSender\n{\n    // Only registered as IEmailSender, not INotificationSender\n}\n\n[RegisterAs&lt;ISmsSender&gt;]\npublic class SmsService : INotificationSender, ISmsSender\n{\n    // Only registered as ISmsSender, not INotificationSender\n}\n</code></pre>"},{"location":"register-as/#3-interface-hierarchies","title":"3. Interface Hierarchies","text":"<p>You can register as a base interface even if the class implements a derived interface:</p> <pre><code>public interface IRepository { }\npublic interface IUserRepository : IRepository { User Get(int id); }\n\n[RegisterAs&lt;IRepository&gt;]\npublic class UserRepository : IUserRepository\n{\n    public User Get(int id) =&gt; /* ... */;\n\n    // Registered as IRepository, not IUserRepository\n}\n</code></pre>"},{"location":"register-as/#behavior","title":"Behavior","text":"Scenario Result No <code>[RegisterAs&lt;T&gt;]</code> All non-system interfaces are registered One <code>[RegisterAs&lt;T&gt;]</code> Only that interface is registered Multiple <code>[RegisterAs&lt;T&gt;]</code> Only specified interfaces are registered Concrete type Always registered as itself"},{"location":"register-as/#analyzer-support","title":"Analyzer Support","text":"<p>Needlr includes compile-time validation:</p> Rule Severity Description NDLRCOR015 Error <code>T</code> must be an interface implemented by the class"},{"location":"register-as/#works-with-both-paths","title":"Works With Both Paths","text":"<p><code>[RegisterAs&lt;T&gt;]</code> works identically in both:</p> <ul> <li>Source Generation - Full AOT/trimming compatibility</li> <li>Reflection - Traditional runtime discovery</li> </ul>"},{"location":"register-as/#lifetime-behavior","title":"Lifetime Behavior","text":"<p><code>[RegisterAs&lt;T&gt;]</code> does not affect lifetime. Use it alongside lifetime attributes:</p> <pre><code>[Transient]\n[RegisterAs&lt;IReader&gt;]\npublic class TransientReader : IReader, IWriter\n{\n    // Transient, registered only as IReader\n}\n</code></pre>"},{"location":"register-as/#see-also","title":"See Also","text":"<ul> <li>Getting Started</li> <li>DoNotAutoRegister - Exclude from all registration</li> <li>NDLRCOR015 - Analyzer documentation</li> </ul> <p>Read More on Dev Leader</p> <ul> <li>Plugin Architecture with Needlr in .NET: Building Modular Applications</li> </ul>"},{"location":"service-catalog/","title":"Service Catalog","text":"<p>The Service Catalog provides compile-time metadata about all services discovered and registered by Needlr. It allows you to query your DI registrations at runtime without reflection.</p>"},{"location":"service-catalog/#overview","title":"Overview","text":"<p>When you use <code>[GenerateTypeRegistry]</code>, Needlr generates a <code>ServiceCatalog</code> class that implements <code>IServiceCatalog</code>. This catalog is automatically registered as a singleton in your DI container and can be resolved like any other service.</p> <pre><code>var catalog = serviceProvider.GetRequiredService&lt;IServiceCatalog&gt;();\n</code></pre>"},{"location":"service-catalog/#whats-in-the-catalog","title":"What's in the Catalog","text":"<p>The <code>IServiceCatalog</code> interface exposes collections for each type of registration Needlr discovers:</p> <ul> <li>Services - All standard service registrations with their lifetime, interfaces, and constructor parameters</li> <li>Decorators - All decorators with their target service type and order</li> <li>HostedServices - All discovered <code>BackgroundService</code>/<code>IHostedService</code> implementations</li> <li>InterceptedServices - Services with <code>[Intercept]</code> applied</li> <li>Options - Configuration bindings via <code>[Options]</code></li> <li>Plugins - Discovered Needlr plugins</li> </ul> <p>Each entry includes the type name, assembly, and source file path (when available).</p>"},{"location":"service-catalog/#usage-examples","title":"Usage Examples","text":""},{"location":"service-catalog/#resolving-the-catalog","title":"Resolving the Catalog","text":"<pre><code>var provider = new Syringe()\n    .UsingSourceGen()\n    .BuildServiceProvider();\n\nvar catalog = provider.GetRequiredService&lt;IServiceCatalog&gt;();\n</code></pre>"},{"location":"service-catalog/#finding-services-by-interface","title":"Finding Services by Interface","text":"<pre><code>// Find all services implementing a specific interface\nvar handlers = catalog.Services\n    .Where(s =&gt; s.Interfaces.Any(i =&gt; i.Contains(\"ICommandHandler\")))\n    .ToList();\n\nforeach (var handler in handlers)\n{\n    Console.WriteLine($\"{handler.ShortTypeName} ({handler.Lifetime})\");\n}\n</code></pre>"},{"location":"service-catalog/#listing-decorators-in-order","title":"Listing Decorators in Order","text":"<pre><code>// Find all decorators for IHostedService in decoration order\nvar hostedServiceDecorators = catalog.Decorators\n    .Where(d =&gt; d.ServiceTypeName.Contains(\"IHostedService\"))\n    .OrderBy(d =&gt; d.Order)\n    .ToList();\n\nforeach (var decorator in hostedServiceDecorators)\n{\n    Console.WriteLine($\"Order {decorator.Order}: {decorator.ShortDecoratorTypeName}\");\n}\n</code></pre>"},{"location":"service-catalog/#inspecting-hosted-services","title":"Inspecting Hosted Services","text":"<pre><code>foreach (var hostedService in catalog.HostedServices)\n{\n    Console.WriteLine($\"Hosted Service: {hostedService.ShortTypeName}\");\n\n    foreach (var param in hostedService.ConstructorParameters)\n    {\n        Console.WriteLine($\"  - {param.Name}: {param.TypeName}\");\n    }\n}\n</code></pre>"},{"location":"service-catalog/#querying-options-configuration","title":"Querying Options Configuration","text":"<pre><code>// Find options with validation enabled\nvar validatedOptions = catalog.Options\n    .Where(o =&gt; o.ValidateOnStart || o.HasValidator || o.HasDataAnnotations)\n    .ToList();\n\nforeach (var opt in validatedOptions)\n{\n    Console.WriteLine($\"{opt.ShortTypeName} -&gt; Section: {opt.SectionName}\");\n}\n</code></pre>"},{"location":"service-catalog/#use-cases","title":"Use Cases","text":"<ul> <li>Debugging: Inspect what Needlr discovered and registered at runtime</li> <li>Documentation: Generate API documentation from registration metadata</li> <li>Health Checks: Verify expected services are registered</li> <li>Admin Endpoints: Expose service registration info in admin/diagnostic APIs</li> <li>Testing: Assert specific registrations exist in integration tests</li> </ul>"},{"location":"service-catalog/#notes","title":"Notes","text":"<ul> <li>The catalog is generated at compile time - it reflects what the source generator discovered</li> <li>Types excluded with <code>[DoNotAutoRegister]</code> or <code>[DoNotInject]</code> will not appear in the catalog</li> <li>The catalog is registered as a singleton and is the same instance across resolutions</li> <li>Interface names in the catalog include the <code>global::</code> prefix for fully qualified names</li> </ul>"},{"location":"service-catalog/#api-reference","title":"API Reference","text":"<p>See the source code for full type definitions:</p> <ul> <li>IServiceCatalog Interface</li> <li>Catalog Entry Types</li> </ul>"},{"location":"solution-wide-source-generation/","title":"Solution-Wide Source Generation","text":"<p>When you have multiple projects in a solution and want Needlr source generation to work consistently across all of them, the recommended approach is to use the <code>NexusLabs.Needlr.Build</code> MSBuild package.</p>"},{"location":"solution-wide-source-generation/#the-problem-without-it","title":"The Problem Without It","text":"<p>Without a centralized setup, each project needs to individually reference <code>NexusLabs.Needlr.Generators</code> as an analyzer and manage the <code>NeedlrAutoGenerate</code> property. In large solutions this leads to:</p> <ul> <li>Duplication across every <code>.csproj</code></li> <li>Easy mistakes (missing generator reference, wrong property name)</li> <li>Confusion when integration packages also reference the generator (see below)</li> </ul>"},{"location":"solution-wide-source-generation/#recommended-setup","title":"Recommended Setup","text":"<p>Add one package reference to your solution-level <code>Directory.Build.props</code>:</p> <pre><code>&lt;Project&gt;\n  &lt;ItemGroup&gt;\n    &lt;PackageReference Include=\"NexusLabs.Needlr.Build\" Version=\"x.x.x\" PrivateAssets=\"all\" /&gt;\n  &lt;/ItemGroup&gt;\n\n  &lt;PropertyGroup&gt;\n    &lt;!-- Enable generation for every project; individual projects can override to false --&gt;\n    &lt;NeedlrAutoGenerate&gt;true&lt;/NeedlrAutoGenerate&gt;\n  &lt;/PropertyGroup&gt;\n&lt;/Project&gt;\n</code></pre> <p>That's it. The package handles:</p> <ul> <li>Making <code>NexusLabs.Needlr.Generators</code> and <code>NexusLabs.Needlr.Generators.Attributes</code> available to every project</li> <li>Activating the generator only for projects where <code>NeedlrAutoGenerate=true</code></li> <li>Deduplicating the generator DLL if it appears more than once in the analyzer list (defensive, see below)</li> </ul>"},{"location":"solution-wide-source-generation/#opting-out-in-test-projects","title":"Opting Out in Test Projects","text":"<p>Test helper libraries and shared test infrastructure typically don't need their own <code>TypeRegistry</code>. Override the property in the project file:</p> <pre><code>&lt;!-- MyFeature.Tests.csproj --&gt;\n&lt;PropertyGroup&gt;\n  &lt;NeedlrAutoGenerate&gt;false&lt;/NeedlrAutoGenerate&gt;\n&lt;/PropertyGroup&gt;\n</code></pre> <p>The generator DLL is still in the NuGet graph (so attribute types compile), but it won't run and produce output for that project.</p>"},{"location":"solution-wide-source-generation/#keeping-source-generation-enabled-in-test-projects","title":"Keeping Source Generation Enabled in Test Projects","text":"<p>Some test projects need their own plugin types discovered \u2014 for example, a test project that registers test fakes or overrides via a plugin class. Leave <code>NeedlrAutoGenerate</code> at its default (<code>true</code>) for those projects.</p> <p>Important \u2014 generator references are not transitively propagated as Analyzer items. A project that enables source generation must explicitly add the generator references, even if a referenced project already uses them:</p> <pre><code>&lt;ProjectReference Include=\"NexusLabs.Needlr.Generators.Attributes\" ... /&gt;\n&lt;ProjectReference Include=\"NexusLabs.Needlr.Generators\"\n                  OutputItemType=\"Analyzer\"\n                  ReferenceOutputAssembly=\"false\" /&gt;\n</code></pre> <p>Without these, the generator silently doesn't run and no <code>TypeRegistry</code> is produced for the project.</p> <p>Use <code>IncludeNamespacePrefixes</code> to scope type discovery to the test assembly only:</p> <pre><code>[assembly: GenerateTypeRegistry(IncludeNamespacePrefixes = [\"MyFeature.Tests\"])]\n</code></pre>"},{"location":"solution-wide-source-generation/#why-the-generator-can-appear-twice-and-how-we-handle-it","title":"Why the Generator Can Appear Twice (and How We Handle It)","text":"<p>If your project references both <code>NexusLabs.Needlr.Build</code> and an integration package like <code>NexusLabs.Needlr.AgentFramework</code> or <code>NexusLabs.Needlr.SemanticKernel</code>, Roslyn could theoretically see two copies of <code>NexusLabs.Needlr.Generators.dll</code> \u2014 one from each package path. Running the generator twice produces duplicate type registration code that fails to compile.</p> <p><code>NexusLabs.Needlr.Build</code> ships a <code>DeduplicateNeedlrGeneratorAnalyzers</code> MSBuild target that runs before compilation and ensures only one copy of the generator DLL is passed to Roslyn, regardless of how many are present in the analyzer item group. The integration packages (<code>AgentFramework</code>, <code>SemanticKernel</code>, <code>SignalR</code>) ship the same target as defense-in-depth.</p>"},{"location":"solution-wide-source-generation/#multi-assembly-typeregistry-composition","title":"Multi-Assembly TypeRegistry Composition","text":"<p>When multiple projects in your solution each have <code>[assembly: GenerateTypeRegistry]</code>, Needlr generates a <code>TypeRegistry</code> in each of them. At runtime, each assembly's <code>[ModuleInitializer]</code> calls <code>NeedlrSourceGenBootstrap.Register()</code>, which accumulates all registered providers.</p> <p>When you call <code>new Syringe().UsingSourceGen()</code>, it calls <code>TryGetProviders()</code>, which combines and deduplicates all registered providers from all loaded assemblies. This means:</p> <ul> <li>An entry-point project referencing a Bootstrap project (which references feature projects) gets all types from all of them</li> <li>Test projects that reference any of those get full service resolution without needing their own TypeRegistry</li> </ul>"},{"location":"solution-wide-source-generation/#example-multiprojectapp","title":"Example: MultiProjectApp","text":"<p>The <code>src/Examples/MultiProjectApp/</code> example in this repository demonstrates this pattern end-to-end:</p> <ul> <li>Feature projects (<code>Notifications</code>, <code>Reporting</code>) each have their own TypeRegistry</li> <li><code>Bootstrap</code> references both feature projects, acting as the single \"pull everything in\" anchor</li> <li>Entry points (<code>ConsoleApp</code>, <code>WorkerApp</code>) reference only Bootstrap</li> <li><code>ConsoleApp.Tests</code> and <code>Features.Reporting.Tests</code> set <code>NeedlrAutoGenerate=false</code> \u2014 they consume TypeRegistries from referenced projects but don't produce their own</li> <li><code>Integration.Tests</code> keeps source gen enabled and registers test-only plugin types (<code>TestInfrastructurePlugin</code>) that are discovered automatically alongside the real feature plugins</li> </ul> <p>See the example README for the full structure.</p>"},{"location":"video-tutorials/","title":"Needlr Video Tutorials","text":"<p>A collection of video tutorials and demonstrations to help developers learn and use Needlr effectively.</p>"},{"location":"video-tutorials/#getting-started","title":"Getting Started","text":""},{"location":"video-tutorials/#how-i-made-c-plugins-super-simple-in-my-dotnet-apps","title":"How I Made C# Plugins Super Simple in My DotNet Apps!","text":"<p>Description: Needlr is my opinionated framework that I use for scanning assemblies for types to register for dependency injection. Like Autofac and Scrutor, you can automatically register types that you can resolve from the dependency container later once the IServiceProvider has been built!</p> <p>Video Link: https://www.youtube.com/watch?v=IH5HEkcMsMg</p> <p>Topics Covered:</p> <ul> <li>Problems with extension method patterns in ASP.NET Core</li> <li>Plugin-based architecture approach</li> <li>Automatic type discovery and registration</li> <li>Web application plugin implementation</li> <li>Comparison with traditional DI setup patterns</li> <li>Fluent builder syntax with Syringe class</li> <li>Weather forecast API example transformation</li> <li>How Needlr keeps entry points thin</li> <li>Real-world usage in BrandGhost (https://www.brandghost.ai) application</li> </ul>"},{"location":"analyzers/","title":"Needlr Analyzers","text":"<p>Needlr includes optional Roslyn analyzers to help developers avoid common mistakes and ensure best practices.</p>"},{"location":"analyzers/#core-analyzers-nexuslabsneedlranalyzers","title":"Core Analyzers (NexusLabs.Needlr.Analyzers)","text":"<p>These analyzers are included with the <code>NexusLabs.Needlr</code> package.</p> Rule ID Severity Description NDLRCOR001 Error Reflection API used in AOT project NDLRCOR002 Warning Plugin has constructor dependencies NDLRCOR003 Error [DeferToContainer] attribute in generated code is ignored NDLRCOR004 Warning Injectable type in global namespace may not be discovered NDLRCOR005 Warning Lifetime mismatch: longer-lived service depends on shorter-lived service NDLRCOR006 Error Circular dependency detected NDLRCOR007 Error Intercept type must implement IMethodInterceptor NDLRCOR008 Warning [Intercept] applied to class without interfaces NDLRCOR009 Info Lazy references undiscovered type NDLRCOR010 Info IEnumerable has no discovered implementations NDLRCOR011 Info [FromKeyedServices] keyed service usage tracking NDLRCOR012 Error Disposable captive dependency NDLRCOR015 Error [RegisterAs] type T not implemented by class"},{"location":"analyzers/#maf-analyzers-nexuslabsneedlragentframeworkanalyzers","title":"MAF Analyzers (NexusLabs.Needlr.AgentFramework.Analyzers)","text":"<p>These analyzers are included with the <code>NexusLabs.Needlr.AgentFramework.Analyzers</code> package.</p> Rule ID Severity Description NDLRMAF001 Error [AgentHandoffsTo] target type is not a declared agent NDLRMAF002 Error Group chat has fewer than two members NDLRMAF003 Warning [AgentHandoffsTo] source class is not a declared agent NDLRMAF004 Warning Cyclic handoff chain detected NDLRMAF005 Warning FunctionGroups references an unregistered group name NDLRMAF006 Error Duplicate Order value in sequential pipeline NDLRMAF007 Warning Gap in sequential pipeline Order values NDLRMAF008 Info Agent participates in no topology declaration NDLRMAF009 Warning [WorkflowRunTerminationCondition] declared on a non-agent class NDLRMAF010 Error Termination condition type does not implement IWorkflowTerminationCondition NDLRMAF011 Info Prefer [AgentTerminationCondition] over [WorkflowRunTerminationCondition] for group chat members"},{"location":"analyzers/#signalr-analyzers-nexuslabsneedlrsignalranalyzers","title":"SignalR Analyzers (NexusLabs.Needlr.SignalR.Analyzers)","text":"<p>These analyzers are included with the <code>NexusLabs.Needlr.SignalR</code> package.</p> Rule ID Severity Description NDLRSIG001 Warning HubPath must be a constant expression NDLRSIG002 Warning HubType must be a typeof expression"},{"location":"analyzers/#generator-diagnostics-nexuslabsneedlrgenerators","title":"Generator Diagnostics (NexusLabs.Needlr.Generators)","text":"<p>These diagnostics are emitted by the source generator to detect configuration issues at compile time.</p> Rule ID Severity Description NDLRGEN001 Error Internal type in referenced assembly cannot be registered NDLRGEN002 Error Referenced assembly has internal plugin types but no type registry NDLRGEN003 Warning [GenerateFactory] all parameters are injectable NDLRGEN004 Warning [GenerateFactory] no parameters are injectable NDLRGEN005 Error [GenerateFactory] type T not implemented by class NDLRGEN006 Error [OpenDecoratorFor] type must be an open generic interface NDLRGEN007 Error [OpenDecoratorFor] decorator must be an open generic class NDLRGEN008 Error [OpenDecoratorFor] decorator must implement the interface NDLRGEN014 Error [Options] Validator type has no validation method NDLRGEN015 Error [Options] Validator type mismatch NDLRGEN016 Error [Options] Validation method not found NDLRGEN017 Error [Options] Validation method has wrong signature NDLRGEN018 Warning [Options] Validator won't run (ValidateOnStart is false) NDLRGEN019 Warning [Options] Validation method won't run (ValidateOnStart is false) NDLRGEN020 Error [Options] is not compatible with Native AOT NDLRGEN021 Warning [Options] Positional record must be partial NDLRGEN022 Error Disposable captive dependency (uses inferred lifetimes) NDLRGEN031 Error [Provider] on class requires partial modifier NDLRGEN032 Error [Provider] interface has invalid member NDLRGEN033 Warning [Provider] property uses concrete type NDLRGEN034 Error [Provider] circular dependency detected"},{"location":"analyzers/#diagnostic-id-naming-convention","title":"Diagnostic ID Naming Convention","text":"<p>Needlr uses a component-based naming convention for diagnostic IDs:</p> Component Prefix Example Core Analyzers <code>NDLRCOR</code> <code>NDLRCOR001</code> MAF Analyzers <code>NDLRMAF</code> <code>NDLRMAF001</code> SignalR Analyzers <code>NDLRSIG</code> <code>NDLRSIG001</code> Source Generators <code>NDLRGEN</code> <code>NDLRGEN001</code>"},{"location":"analyzers/#suppressing-warnings","title":"Suppressing Warnings","text":"<p>To suppress a specific analyzer warning, use pragma directives:</p> <pre><code>#pragma warning disable NDLRCOR001\n// Code that triggers the warning\n#pragma warning restore NDLRCOR001\n</code></pre> <p>Or suppress in your project file for the entire project:</p> <pre><code>&lt;PropertyGroup&gt;\n  &lt;NoWarn&gt;$(NoWarn);NDLRCOR002&lt;/NoWarn&gt;\n&lt;/PropertyGroup&gt;\n</code></pre> <p>Or configure severity in <code>.editorconfig</code> (recommended):</p> <pre><code># .editorconfig\n[*.cs]\n# Disable a diagnostic\ndotnet_diagnostic.NDLRCOR009.severity = none\n\n# Promote to warning\ndotnet_diagnostic.NDLRCOR010.severity = warning\n\n# Promote to error\ndotnet_diagnostic.NDLRCOR005.severity = error\n</code></pre>"},{"location":"analyzers/#resolution-validation-analyzers","title":"Resolution Validation Analyzers","text":"<p>NDLRCOR009, NDLRCOR010, and NDLRCOR011 are resolution validation analyzers that help catch potential issues with service resolution patterns.</p> <p>These analyzers:</p> <ul> <li>Only activate when <code>[assembly: GenerateTypeRegistry]</code> is present</li> <li>Default to <code>Info</code> severity (non-blocking)</li> <li>Can be promoted to <code>Warning</code> or <code>Error</code> via <code>.editorconfig</code></li> </ul> Analyzer Purpose NDLRCOR009 Validates <code>Lazy&lt;T&gt;</code> references discoverable types NDLRCOR010 Validates <code>IEnumerable&lt;T&gt;</code> has implementations NDLRCOR011 Tracks <code>[FromKeyedServices]</code> keyed service usage <p>To see which analyzers are active in your project, enable diagnostics output:</p> <pre><code>&lt;PropertyGroup&gt;\n  &lt;NeedlrDiagnostics&gt;true&lt;/NeedlrDiagnostics&gt;\n&lt;/PropertyGroup&gt;\n</code></pre> <p>This generates <code>AnalyzerStatus.md</code> in your output directory showing all analyzers and their current severity.</p>"},{"location":"analyzers/#configuration","title":"Configuration","text":"<p>Analyzers are automatically enabled when you reference the Needlr packages. No additional configuration is required.</p> <p>For AOT projects, ensure your project has the appropriate settings for the analyzers to detect AOT mode:</p> <pre><code>&lt;PropertyGroup&gt;\n  &lt;PublishAot&gt;true&lt;/PublishAot&gt;\n  &lt;!-- or --&gt;\n  &lt;IsAotCompatible&gt;true&lt;/IsAotCompatible&gt;\n&lt;/PropertyGroup&gt;\n</code></pre>"},{"location":"analyzers/NDLRCOR001/","title":"NDLRCOR001: Reflection API used in AOT project","text":""},{"location":"analyzers/NDLRCOR001/#cause","title":"Cause","text":"<p>You are using a reflection-based Needlr API in a project that has AOT (Ahead-of-Time) compilation or trimming enabled.</p>"},{"location":"analyzers/NDLRCOR001/#rule-description","title":"Rule Description","text":"<p>Native AOT and trimmed applications cannot use reflection reliably. The Needlr library provides source-generation-based alternatives for all reflection-based components. Using reflection APIs in an AOT-enabled project will cause runtime failures.</p> <p>This analyzer triggers when you use any of the following in a project with <code>PublishAot=true</code> or <code>IsAotCompatible=true</code>:</p>"},{"location":"analyzers/NDLRCOR001/#reflection-types","title":"Reflection Types","text":"<ul> <li><code>ReflectionPluginFactory</code></li> <li><code>ReflectionTypeRegistrar</code></li> <li><code>ReflectionTypeFilterer</code></li> <li><code>ReflectionAssemblyLoader</code></li> <li><code>ReflectionAssemblyProvider</code></li> <li><code>ReflectionServiceProviderBuilder</code></li> </ul>"},{"location":"analyzers/NDLRCOR001/#reflection-extension-methods","title":"Reflection Extension Methods","text":"<ul> <li><code>UsingReflectionTypeRegistrar()</code></li> <li><code>UsingReflectionTypeFilterer()</code></li> <li><code>UsingReflectionPluginFactory()</code></li> <li><code>UsingReflectionAssemblyLoader()</code></li> <li><code>UsingReflectionAssemblyProvider()</code></li> </ul>"},{"location":"analyzers/NDLRCOR001/#how-to-fix","title":"How to Fix","text":"<p>Replace reflection-based APIs with their source-generation equivalents:</p>"},{"location":"analyzers/NDLRCOR001/#before-reflection","title":"Before (Reflection)","text":"<pre><code>var app = new Syringe()\n    .UsingReflection()\n    .ForWebApplication()\n    .BuildWebApplication();\n</code></pre>"},{"location":"analyzers/NDLRCOR001/#after-source-generation","title":"After (Source Generation)","text":"<pre><code>var app = new Syringe()\n    .UsingSourceGen()\n    .ForWebApplication()\n    .BuildWebApplication();\n</code></pre> <p>Ensure you have the source generator packages installed:</p> <pre><code>&lt;PackageReference Include=\"NexusLabs.Needlr.Generators\" OutputItemType=\"Analyzer\" ReferenceOutputAssembly=\"false\" /&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.Generators.Attributes\" /&gt;\n&lt;PackageReference Include=\"NexusLabs.Needlr.Injection.SourceGen\" /&gt;\n</code></pre>"},{"location":"analyzers/NDLRCOR001/#when-to-suppress","title":"When to Suppress","text":"<p>Only suppress this warning if you are certain the reflection code path will not be executed at runtime, such as in conditional compilation scenarios where the reflection code is only used in non-AOT builds.</p> <pre><code>#pragma warning disable NDLRCOR001\n// Reflection code that won't run in AOT\n#pragma warning restore NDLRCOR001\n</code></pre>"},{"location":"analyzers/NDLRCOR001/#see-also","title":"See Also","text":"<ul> <li>Getting Started Guide</li> <li>Source Generation vs Reflection</li> </ul>"},{"location":"analyzers/NDLRCOR002/","title":"NDLRCOR002: Plugin has constructor dependencies","text":""},{"location":"analyzers/NDLRCOR002/#cause","title":"Cause","text":"<p>A class implementing <code>IServiceCollectionPlugin</code> or <code>IPostBuildServiceCollectionPlugin</code> has a constructor with parameters but no public parameterless constructor.</p>"},{"location":"analyzers/NDLRCOR002/#rule-description","title":"Rule Description","text":"<p>Needlr plugin classes are instantiated by the framework before the dependency injection container is fully built. This means constructor injection is not available for plugin classes in the same way it is for regular services.</p> <p>If a plugin has constructor parameters and no parameterless constructor, the framework may not be able to instantiate it, leading to runtime errors.</p>"},{"location":"analyzers/NDLRCOR002/#how-to-fix","title":"How to Fix","text":""},{"location":"analyzers/NDLRCOR002/#option-1-add-a-parameterless-constructor","title":"Option 1: Add a parameterless constructor","text":"<pre><code>public class MyPlugin : IServiceCollectionPlugin\n{\n    public MyPlugin() { }\n\n    public MyPlugin(ILogger logger) \n    { \n        // Optional: for use when instantiated via DI\n    }\n\n    public void Configure(ServiceCollectionPluginOptions options)\n    {\n        // Plugin configuration\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR002/#option-2-use-ipostbuildservicecollectionplugin-with-service-resolution","title":"Option 2: Use IPostBuildServiceCollectionPlugin with service resolution","text":"<p>If you need access to services, use <code>IPostBuildServiceCollectionPlugin</code> which runs after the container is built:</p> <pre><code>public class MyPlugin : IPostBuildServiceCollectionPlugin\n{\n    public void Configure(PostBuildServiceCollectionPluginOptions options)\n    {\n        var logger = options.ServiceProvider.GetRequiredService&lt;ILogger&lt;MyPlugin&gt;&gt;();\n        // Use the logger\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR002/#option-3-access-services-through-the-options-parameter","title":"Option 3: Access services through the options parameter","text":"<pre><code>public class MyPlugin : IServiceCollectionPlugin\n{\n    public void Configure(ServiceCollectionPluginOptions options)\n    {\n        // Register your service that needs dependencies\n        options.Services.AddSingleton&lt;MyService&gt;();\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR002/#when-to-suppress","title":"When to Suppress","text":"<p>Suppress this warning if:</p> <ul> <li>The plugin is intentionally designed to be instantiated via DI after container construction</li> <li>The plugin is abstract and constructor parameters are for derived classes</li> <li>You are using a custom plugin factory that handles constructor injection</li> </ul> <pre><code>#pragma warning disable NDLRCOR002\npublic class MyCustomPlugin : IServiceCollectionPlugin\n{\n    public MyCustomPlugin(IPluginFactory factory) { }\n    // ...\n}\n#pragma warning restore NDLRCOR002\n</code></pre>"},{"location":"analyzers/NDLRCOR002/#see-also","title":"See Also","text":"<ul> <li>Plugin Development Guide</li> <li>Core Concepts</li> </ul>"},{"location":"analyzers/NDLRCOR003/","title":"NDLRCOR003: [DeferToContainer] attribute in generated code is ignored","text":""},{"location":"analyzers/NDLRCOR003/#cause","title":"Cause","text":"<p>A <code>[DeferToContainer]</code> attribute was found in generated code (a <code>.g.cs</code>, <code>.generated.cs</code>, or <code>.designer.cs</code> file, or in an <code>obj/*/generated/</code> folder).</p>"},{"location":"analyzers/NDLRCOR003/#rule-description","title":"Rule Description","text":"<p>Source generators in Roslyn run in parallel and in isolation. Each generator only sees:</p> <ol> <li>Original user-written source code</li> <li>Referenced assemblies (metadata)</li> </ol> <p>Generators cannot see output from other generators in the same compilation. This means if one generator (like <code>CacheProviderGenerator</code>) adds <code>[DeferToContainer]</code> to a generated partial class, Needlr's <code>TypeRegistryGenerator</code> will never see it.</p> <pre><code>Compilation Pipeline:\n\n     Original Source Files\n           \u2502\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502           \u2502\n     \u25bc           \u25bc\n[CacheProvider  [TypeRegistry\n Generator]      Generator]\n     \u2502           \u2502\n     \u25bc           \u25bc\n  Output A     Output B    \u25c4\u2500\u2500 These can't see each other!\n     \u2502           \u2502\n     \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\n           \u25bc\n    Final Compilation\n           \u2502\n           \u25bc\n      [Analyzers]  \u25c4\u2500\u2500 CAN see everything (this is how we detect the issue)\n</code></pre> <p>When <code>TypeRegistryGenerator</code> runs, it only sees your original partial class (without the attribute) and generates incorrect factory code with a parameterless constructor call.</p>"},{"location":"analyzers/NDLRCOR003/#how-to-fix","title":"How to Fix","text":"<p>Move the <code>[DeferToContainer]</code> attribute to your original source file - the partial class declaration you wrote, not the one generated.</p>"},{"location":"analyzers/NDLRCOR003/#before-broken","title":"Before (broken)","text":"<pre><code>// Your code (MyService.cs)\n[CacheProvider(\"EngageFeed\")]  // This triggers CacheProviderGenerator\npublic partial class EngageFeedCacheProvider { }\n\n// Generated by CacheProviderGenerator (EngageFeedCacheProvider.g.cs)\n[DeferToContainer(typeof(ICacheProvider))]  // \u274c TypeRegistryGenerator won't see this!\npublic sealed partial class EngageFeedCacheProvider(ICacheProvider _cacheProvider)\n{\n    // ...\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR003/#after-correct","title":"After (correct)","text":"<pre><code>// Your code (MyService.cs)\n[DeferToContainer(typeof(ICacheProvider))]  // \u2705 TypeRegistryGenerator sees this!\n[CacheProvider(\"EngageFeed\")]\npublic partial class EngageFeedCacheProvider { }\n\n// Generated by CacheProviderGenerator (EngageFeedCacheProvider.g.cs)\npublic sealed partial class EngageFeedCacheProvider(ICacheProvider _cacheProvider)\n{\n    // ...\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR003/#impact-if-ignored","title":"Impact if Ignored","text":"<p>If you ignore this error, Needlr will generate factory code like:</p> <pre><code>sp =&gt; new EngageFeedCacheProvider()  // Missing the constructor parameter!\n</code></pre> <p>This will cause a compile error: <pre><code>CS7036: There is no argument given that corresponds to the required parameter \n'_cacheProvider' of 'EngageFeedCacheProvider.EngageFeedCacheProvider(ICacheProvider)'\n</code></pre></p>"},{"location":"analyzers/NDLRCOR003/#for-generator-authors","title":"For Generator Authors","text":"<p>If you're writing a source generator that adds constructors to partial classes, do not add <code>[DeferToContainer]</code> to your generated output. Instead, document that users must add the attribute to their original partial class.</p> <p>Example documentation for your generator's users:</p> <pre><code>## Usage with Needlr\n\nIf using Needlr for dependency injection, add the `[DeferToContainer]` attribute \nto your original class declaration:\n\n```csharp\n[DeferToContainer(typeof(ICacheProvider))]\n[CacheProvider(\"EngageFeed\")]\npublic partial class EngageFeedCacheProvider { }\n</code></pre> <p>This tells Needlr's source generator what constructor parameters to expect. <pre><code>## When to Suppress\n\nThis diagnostic should generally **not be suppressed**. The attribute in generated code will not work as intended.\n\nIf you must suppress it (for example, during migration), be aware that you'll need to manually register the service:\n\n```csharp\n#pragma warning disable NDLRCOR003\n// In generated file - this won't work but we're registering manually\n#pragma warning restore NDLRCOR003\n\n// In your Program.cs or startup:\nbuilder.Services.AddSingleton&lt;EngageFeedCacheProvider&gt;(sp =&gt; \n    new EngageFeedCacheProvider(sp.GetRequiredService&lt;ICacheProvider&gt;()));\n</code></pre></p>"},{"location":"analyzers/NDLRCOR003/#see-also","title":"See Also","text":"<ul> <li>Advanced Usage - Working with Other Source Generators</li> <li>DeferToContainer Attribute</li> </ul>"},{"location":"analyzers/NDLRCOR004/","title":"NDLRCOR004: Injectable type in global namespace may not be discovered","text":""},{"location":"analyzers/NDLRCOR004/#cause","title":"Cause","text":"<p>A type that appears to be designed for dependency injection is defined in the global namespace (no <code>namespace</code> declaration), but the assembly's <code>[GenerateTypeRegistry]</code> attribute has <code>IncludeNamespacePrefixes</code> set to values that don't include an empty string (<code>\"\"</code>).</p>"},{"location":"analyzers/NDLRCOR004/#rule-description","title":"Rule Description","text":"<p>When using Needlr's source generation with namespace filtering, types in the global namespace are excluded by default. This is because:</p> <ol> <li> <p>Namespace filtering is exact prefix matching: If you set <code>IncludeNamespacePrefixes = new[] { \"MyCompany\" }</code>, only types in namespaces starting with <code>MyCompany.</code> are included.</p> </li> <li> <p>Global namespace has no prefix: Types without a <code>namespace</code> declaration have no namespace to match against.</p> </li> <li> <p>Silent exclusion: Unlike a compile error, these types are silently skipped during type discovery.</p> </li> </ol> <p>This analyzer detects types that:</p> <ul> <li>Are in the global namespace</li> <li>Appear to be injectable (have DI attributes, implement interfaces, or have constructor dependencies)</li> <li>Would be excluded by the current <code>IncludeNamespacePrefixes</code> configuration</li> </ul> <pre><code>// \u26a0\ufe0f This triggers the warning\n[assembly: GenerateTypeRegistry(IncludeNamespacePrefixes = new[] { \"MyCompany\" })]\n\npublic class AmplitudeConfiguration  // No namespace! Won't be discovered!\n{\n    public string ApiKey { get; set; }\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR004/#how-to-fix","title":"How to Fix","text":""},{"location":"analyzers/NDLRCOR004/#option-1-add-a-namespace-recommended","title":"Option 1: Add a Namespace (Recommended)","text":"<p>Move the type into an appropriate namespace:</p> <pre><code>namespace MyCompany.Telemetry\n{\n    public class AmplitudeConfiguration\n    {\n        public string ApiKey { get; set; }\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR004/#option-2-include-global-namespace-in-prefixes","title":"Option 2: Include Global Namespace in Prefixes","text":"<p>Add an empty string <code>\"\"</code> to your <code>IncludeNamespacePrefixes</code> to explicitly include global namespace types:</p> <pre><code>[assembly: GenerateTypeRegistry(IncludeNamespacePrefixes = new[] { \"MyCompany\", \"\" })]\n</code></pre> <p>This tells Needlr: \"Include types in <code>MyCompany.*</code> namespaces AND types in the global namespace.\"</p>"},{"location":"analyzers/NDLRCOR004/#option-3-mark-as-not-injectable","title":"Option 3: Mark as Not Injectable","text":"<p>If the type shouldn't be registered with DI, add <code>[DoNotInject]</code> or <code>[DoNotAutoRegister]</code>:</p> <pre><code>[DoNotInject]\npublic class AmplitudeConfiguration { }\n</code></pre>"},{"location":"analyzers/NDLRCOR004/#impact-if-ignored","title":"Impact if Ignored","text":"<p>If you ignore this warning:</p> <ol> <li> <p>Runtime exception: Services depending on the undiscovered type will throw <code>InvalidOperationException</code>:    <pre><code>System.InvalidOperationException: No service for type 'AmplitudeConfiguration' has been registered.\n</code></pre></p> </li> <li> <p>Silent failures: The application may start but fail when the missing type is first requested.</p> </li> <li> <p>Debugging difficulty: The root cause isn't obvious since there's no compile error.</p> </li> </ol>"},{"location":"analyzers/NDLRCOR004/#why-this-happens","title":"Why This Happens","text":"<p>This commonly occurs when:</p> <ol> <li> <p>MSBuild conventions auto-set prefixes: Some build configurations automatically set <code>IncludeNamespacePrefixes</code> based on the project name.</p> </li> <li> <p>Copy-paste errors: Types copied from examples or templates may lack namespace declarations.</p> </li> <li> <p>Migration from reflection: Reflection-based discovery scanned all types regardless of namespace. Source generation requires explicit configuration.</p> </li> </ol>"},{"location":"analyzers/NDLRCOR004/#detection-criteria","title":"Detection Criteria","text":"<p>This analyzer reports a warning when ALL of these conditions are true:</p> <ol> <li>The type is in the global namespace</li> <li>The assembly has <code>[GenerateTypeRegistry]</code> with <code>IncludeNamespacePrefixes</code> set</li> <li><code>IncludeNamespacePrefixes</code> doesn't include <code>\"\"</code> (empty string)</li> <li>The type is NOT marked with <code>[DoNotInject]</code> or <code>[DoNotAutoRegister]</code></li> <li> <p>The type appears injectable:</p> </li> <li> <p>Has a lifetime attribute (<code>[Singleton]</code>, <code>[Scoped]</code>, <code>[Transient]</code>)</p> </li> <li>Implements one or more interfaces</li> <li>Has a constructor with interface/abstract class parameters</li> </ol>"},{"location":"analyzers/NDLRCOR004/#when-to-suppress","title":"When to Suppress","text":"<p>Suppress this warning if:</p> <ul> <li>The type is intentionally not registered with DI</li> <li>You're manually registering the type elsewhere</li> <li>The type is only used as a data transfer object (DTO)</li> </ul> <pre><code>#pragma warning disable NDLRCOR004\npublic class MyGlobalType { }  // Not intended for DI\n#pragma warning restore NDLRCOR004\n</code></pre> <p>Or in your project file: <pre><code>&lt;NoWarn&gt;$(NoWarn);NDLRCOR004&lt;/NoWarn&gt;\n</code></pre></p>"},{"location":"analyzers/NDLRCOR004/#see-also","title":"See Also","text":"<ul> <li>Advanced Usage</li> <li>NDLRCOR001: Plugin constructor dependency not registered</li> <li>Core Concepts</li> </ul>"},{"location":"analyzers/NDLRCOR005/","title":"NDLRCOR005: Lifetime mismatch - longer-lived service depends on shorter-lived service","text":""},{"location":"analyzers/NDLRCOR005/#cause","title":"Cause","text":"<p>A service with a longer lifetime (e.g., Singleton) has a constructor dependency on a service with a shorter lifetime (e.g., Scoped or Transient). This creates a \"captive dependency\" where the shorter-lived service is captured and held beyond its intended lifetime.</p>"},{"location":"analyzers/NDLRCOR005/#rule-description","title":"Rule Description","text":"<p>In dependency injection, services have three standard lifetimes:</p> Lifetime Rank Description Transient 0 New instance per request Scoped 1 One instance per scope (e.g., per HTTP request) Singleton 2 Single instance for application lifetime <p>A lifetime mismatch occurs when a longer-lived service depends on a shorter-lived one:</p> <pre><code>// \u26a0\ufe0f NDLRCOR005: Singleton depends on Scoped\n[Singleton]\npublic class CacheService(IUserContext userContext)  // IUserContext is Scoped\n{\n    private readonly IUserContext _userContext = userContext;\n\n    public string GetCacheKey() =&gt; $\"user_{_userContext.UserId}\";\n}\n\n[Scoped]\npublic class UserContext : IUserContext\n{\n    public int UserId { get; set; }\n}\n</code></pre> <p>Why this is dangerous:</p> <ol> <li> <p>Stale data: The Singleton captures the first <code>IUserContext</code> instance and uses it for ALL requests, even though <code>UserContext</code> was meant to change per-request.</p> </li> <li> <p>Memory leaks: Scoped services are designed to be disposed at scope end. A Singleton holding a reference prevents garbage collection.</p> </li> <li> <p>Concurrency bugs: Scoped services often aren't thread-safe because they're designed for single-request use. A Singleton may use them from multiple threads simultaneously.</p> </li> <li> <p>Silent failures: No runtime exception occurs\u2014the application works but produces incorrect results.</p> </li> </ol>"},{"location":"analyzers/NDLRCOR005/#common-mismatch-patterns","title":"Common Mismatch Patterns","text":""},{"location":"analyzers/NDLRCOR005/#singleton-scoped-most-dangerous","title":"Singleton \u2192 Scoped (Most Dangerous)","text":"<pre><code>[Singleton]\npublic class EmailService(IDbContext dbContext) { }  // DbContext is Scoped!\n</code></pre>"},{"location":"analyzers/NDLRCOR005/#singleton-transient","title":"Singleton \u2192 Transient","text":"<pre><code>[Singleton]\npublic class LoggingService(ITimeProvider time) { }  // May capture stale time\n</code></pre>"},{"location":"analyzers/NDLRCOR005/#scoped-transient","title":"Scoped \u2192 Transient","text":"<pre><code>[Scoped]\npublic class RequestHandler(IValidator validator) { }  // Less dangerous but still problematic\n</code></pre>"},{"location":"analyzers/NDLRCOR005/#how-to-fix","title":"How to Fix","text":""},{"location":"analyzers/NDLRCOR005/#option-1-match-lifetimes-recommended","title":"Option 1: Match Lifetimes (Recommended)","text":"<p>Make the consumer's lifetime equal or shorter than its dependencies:</p> <pre><code>// \u2705 Scoped depends on Scoped - OK!\n[Scoped]\npublic class CacheService(IUserContext userContext) { }\n</code></pre>"},{"location":"analyzers/NDLRCOR005/#option-2-use-factory-pattern","title":"Option 2: Use Factory Pattern","text":"<p>Inject a factory that creates fresh instances:</p> <pre><code>[Singleton]\npublic class CacheService(IServiceScopeFactory scopeFactory)\n{\n    public string GetCacheKey()\n    {\n        using var scope = scopeFactory.CreateScope();\n        var userContext = scope.ServiceProvider.GetRequiredService&lt;IUserContext&gt;();\n        return $\"user_{userContext.UserId}\";\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR005/#option-3-use-func-or-lazy","title":"Option 3: Use Func or Lazy <p>Configure a factory delegate:</p> <pre><code>[Singleton]\npublic class CacheService(Func&lt;IUserContext&gt; userContextFactory)\n{\n    public string GetCacheKey()\n    {\n        var userContext = userContextFactory();  // Fresh instance each call\n        return $\"user_{userContext.UserId}\";\n    }\n}\n</code></pre>","text":""},{"location":"analyzers/NDLRCOR005/#option-4-redesign-the-dependency","title":"Option 4: Redesign the Dependency <p>Sometimes the design needs rethinking. If a Singleton truly needs request-specific data, consider:</p> <ul> <li>Passing the data as a method parameter</li> <li>Using <code>IHttpContextAccessor</code> (for ASP.NET Core)</li> <li>Using ambient context patterns (with caution)</li> </ul>","text":""},{"location":"analyzers/NDLRCOR005/#runtime-detection","title":"Runtime Detection","text":"<p>This analyzer detects mismatches at compile-time for types with Needlr lifetime attributes. For additional runtime validation:</p> <pre><code>// Verify at startup\nservices.Verify(VerificationOptions.Strict);\n\n// Or get detailed diagnostics\nvar result = services.VerifyWithDiagnostics();\nif (!result.IsValid)\n{\n    Console.WriteLine(result.ToDetailedReport());\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR005/#detection-limitations","title":"Detection Limitations","text":"<p>This analyzer can only detect mismatches when:</p> <ol> <li>Both the consumer and dependency have explicit lifetime attributes (<code>[Singleton]</code>, <code>[Scoped]</code>, <code>[Transient]</code>, or <code>[RegisterAs]</code>)</li> <li>The dependency type is a concrete class (not an interface)</li> </ol> <p>For interface dependencies, use the runtime <code>Verify()</code> method which has access to the full service collection.</p>"},{"location":"analyzers/NDLRCOR005/#when-to-suppress","title":"When to Suppress","text":"<p>Suppress this warning only if you:</p> <ol> <li>Understand the implications and have mitigated them</li> <li>The dependency is thread-safe and stateless</li> <li>The dependency is intentionally shared across scopes</li> </ol> <pre><code>[Singleton]\n#pragma warning disable NDLRCOR005\npublic class MetricsService(ICounter counter) { }  // ICounter is thread-safe\n#pragma warning restore NDLRCOR005\n</code></pre>"},{"location":"analyzers/NDLRCOR005/#see-also","title":"See Also","text":"<ul> <li>Advanced Usage - Container Verification</li> <li>NDLRCOR006: Circular dependency detected</li> <li>Microsoft Docs: Service Lifetimes</li> </ul>"},{"location":"analyzers/NDLRCOR006/","title":"NDLRCOR006: Circular dependency detected","text":""},{"location":"analyzers/NDLRCOR006/#cause","title":"Cause","text":"<p>A service directly or indirectly depends on itself, creating a circular reference chain. This will cause a runtime exception when the dependency injection container attempts to resolve the service.</p>"},{"location":"analyzers/NDLRCOR006/#rule-description","title":"Rule Description","text":"<p>A circular dependency occurs when the dependency graph contains a cycle:</p> <pre><code>A \u2192 B \u2192 C \u2192 A  (cycle!)\n</code></pre> <p>This is impossible to resolve because:</p> <ul> <li>To create <code>A</code>, we need <code>B</code></li> <li>To create <code>B</code>, we need <code>C</code></li> <li>To create <code>C</code>, we need <code>A</code> \u2190 but we haven't finished creating <code>A</code> yet!</li> </ul> <pre><code>// \u26a0\ufe0f NDLRCOR006: Circular dependency: OrderService \u2192 InventoryService \u2192 OrderService\n[Scoped]\npublic class OrderService(IInventoryService inventory)\n{\n    public void PlaceOrder() =&gt; inventory.Reserve();\n}\n\n[Scoped]\npublic class InventoryService(IOrderService orders)  // Depends back on OrderService!\n{\n    public void Reserve() =&gt; orders.ValidateStock();\n}\n</code></pre> <p>What happens at runtime:</p> <pre><code>System.InvalidOperationException: A circular dependency was detected for the service of type 'IOrderService'.\nIOrderService -&gt; OrderService -&gt; IInventoryService -&gt; InventoryService -&gt; IOrderService\n</code></pre> <p>Or worse, a <code>StackOverflowException</code> if the container doesn't detect the cycle.</p>"},{"location":"analyzers/NDLRCOR006/#common-circular-dependency-patterns","title":"Common Circular Dependency Patterns","text":""},{"location":"analyzers/NDLRCOR006/#direct-cycle-a-b-a","title":"Direct Cycle (A \u2192 B \u2192 A)","text":"<pre><code>[Scoped] public class UserService(IRoleService roles) { }\n[Scoped] public class RoleService(IUserService users) { }\n</code></pre>"},{"location":"analyzers/NDLRCOR006/#indirect-cycle-a-b-c-a","title":"Indirect Cycle (A \u2192 B \u2192 C \u2192 A)","text":"<pre><code>[Scoped] public class OrderService(IPaymentService payments) { }\n[Scoped] public class PaymentService(INotificationService notifications) { }\n[Scoped] public class NotificationService(IOrderService orders) { }  // Cycle!\n</code></pre>"},{"location":"analyzers/NDLRCOR006/#self-reference-a-a","title":"Self-Reference (A \u2192 A)","text":"<pre><code>[Scoped] \npublic class TreeNode(ITreeNode parent) { }  // References itself\n</code></pre>"},{"location":"analyzers/NDLRCOR006/#how-to-fix","title":"How to Fix","text":""},{"location":"analyzers/NDLRCOR006/#option-1-refactor-to-remove-the-cycle-recommended","title":"Option 1: Refactor to Remove the Cycle (Recommended)","text":"<p>Often circular dependencies indicate a design problem. Consider:</p> <p>Extract shared logic: <pre><code>// Before: OrderService \u2194 InventoryService\n\n// After: Both depend on shared service\n[Scoped] public class StockValidator { }  // Shared logic here\n[Scoped] public class OrderService(IStockValidator validator) { }\n[Scoped] public class InventoryService(IStockValidator validator) { }\n</code></pre></p> <p>Use events/mediator: <pre><code>// Before: Direct dependency\n[Scoped] public class OrderService(IInventoryService inventory) { }\n\n// After: Decoupled via events\n[Scoped] public class OrderService(IEventBus events)\n{\n    public void PlaceOrder() =&gt; events.Publish(new OrderPlacedEvent());\n}\n\n[Scoped] public class InventoryHandler : IEventHandler&lt;OrderPlacedEvent&gt; { }\n</code></pre></p>"},{"location":"analyzers/NDLRCOR006/#option-2-use-lazy-deferred-resolution","title":"Option 2: Use Lazy (Deferred Resolution) <p>Break the cycle by deferring one dependency:</p> <pre><code>[Scoped]\npublic class OrderService(IInventoryService inventory) { }\n\n[Scoped]\npublic class InventoryService(Lazy&lt;IOrderService&gt; orders)  // Lazy breaks the cycle\n{\n    public void Reserve() =&gt; orders.Value.ValidateStock();\n}\n</code></pre> <p>Note: This only delays the problem\u2014the cycle still exists and may cause issues.</p>","text":""},{"location":"analyzers/NDLRCOR006/#option-3-use-factoryfunc","title":"Option 3: Use Factory/Func <p>Similar to Lazy, create instances on-demand: <pre><code>[Scoped]\npublic class InventoryService(Func&lt;IOrderService&gt; orderFactory)\n{\n    public void Reserve()\n    {\n        var orders = orderFactory();\n        orders.ValidateStock();\n    }\n}\n</code></pre>","text":""},{"location":"analyzers/NDLRCOR006/#option-4-property-injection-not-recommended","title":"Option 4: Property Injection (Not Recommended) <p>Some DI containers support property injection to break cycles:</p> <pre><code>[Scoped]\npublic class InventoryService\n{\n    [Inject] public IOrderService Orders { get; set; }  // Set after construction\n}\n</code></pre> <p>Warning: Property injection hides dependencies and makes testing harder. Use sparingly.</p>","text":""},{"location":"analyzers/NDLRCOR006/#prevention-best-practices","title":"Prevention Best Practices","text":"<ol> <li> <p>Single Responsibility: Each service should do one thing. Large services often develop circular dependencies.</p> </li> <li> <p>Dependency Direction: Dependencies should flow one way (e.g., Controllers \u2192 Services \u2192 Repositories).</p> </li> <li> <p>Interface Segregation: Split large interfaces into smaller, focused ones.</p> </li> <li> <p>Layer Architecture: Use clear layers where higher layers depend on lower layers, never the reverse.</p> </li> </ol> <pre><code>Controllers (top)\n    \u2193\nServices\n    \u2193\nRepositories (bottom)\n</code></pre>"},{"location":"analyzers/NDLRCOR006/#runtime-detection","title":"Runtime Detection","text":"<p>For comprehensive cycle detection including dynamic registrations:</p> <pre><code>// Detect all cycles at startup\nservices.Verify(VerificationOptions.Strict);\n\n// Or get detailed chain information\nvar result = services.VerifyWithDiagnostics();\nforeach (var issue in result.Issues.Where(i =&gt; i.Type == VerificationIssueType.CircularDependency))\n{\n    Console.WriteLine(issue.DetailedMessage);\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR006/#detection-limitations","title":"Detection Limitations","text":"<p>This analyzer detects cycles at compile-time by:</p> <ol> <li>Building a dependency graph from constructor parameters</li> <li>Traversing the graph using DFS to find back-edges</li> </ol> <p>Limitations:</p> <ul> <li>Only analyzes types with Needlr registration attributes</li> <li>Cannot detect cycles involving factory-registered services</li> <li>Cannot detect cycles created by runtime configuration</li> </ul> <p>Use the runtime <code>Verify()</code> method for complete coverage.</p>"},{"location":"analyzers/NDLRCOR006/#when-to-suppress","title":"When to Suppress","text":"<p>Generally, do not suppress this diagnostic. Circular dependencies will cause runtime failures.</p> <p>However, if you're using <code>Lazy&lt;T&gt;</code> or <code>Func&lt;T&gt;</code> to intentionally break the cycle:</p> <pre><code>#pragma warning disable NDLRCOR006\n[Scoped] public class ServiceA(Lazy&lt;IServiceB&gt; b) { }  // Lazy breaks cycle\n[Scoped] public class ServiceB(IServiceA a) { }\n#pragma warning restore NDLRCOR006\n</code></pre>"},{"location":"analyzers/NDLRCOR006/#see-also","title":"See Also","text":"<ul> <li>Advanced Usage - Container Verification</li> <li>NDLRCOR005: Lifetime mismatch</li> <li>Martin Fowler: Inversion of Control Containers</li> </ul>"},{"location":"analyzers/NDLRCOR007/","title":"NDLRCOR007: Intercept type must implement IMethodInterceptor","text":""},{"location":"analyzers/NDLRCOR007/#cause","title":"Cause","text":"<p>A type used in an <code>[Intercept]</code> or <code>[Intercept&lt;T&gt;]</code> attribute does not implement the <code>IMethodInterceptor</code> interface.</p>"},{"location":"analyzers/NDLRCOR007/#rule-description","title":"Rule Description","text":"<p>When using the <code>[Intercept]</code> attribute to apply an interceptor to a service, the specified type must implement <code>IMethodInterceptor</code>. This interface defines the <code>InterceptAsync</code> method that is called when intercepted methods are invoked.</p> <pre><code>// \u274c NDLRCOR007: MyLogger does not implement IMethodInterceptor\n[Intercept&lt;MyLogger&gt;]\npublic class OrderService : IOrderService\n{\n    public Order GetOrder(int id) =&gt; /* ... */;\n}\n\npublic class MyLogger  // Missing IMethodInterceptor implementation\n{\n    public void Log(string message) =&gt; Console.WriteLine(message);\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR007/#how-to-fix","title":"How to Fix","text":"<p>Implement <code>IMethodInterceptor</code> on the interceptor class:</p> <pre><code>// \u2705 Fixed: LoggingInterceptor implements IMethodInterceptor\n[Intercept&lt;LoggingInterceptor&gt;]\npublic class OrderService : IOrderService\n{\n    public Order GetOrder(int id) =&gt; /* ... */;\n}\n\npublic class LoggingInterceptor : IMethodInterceptor\n{\n    public async ValueTask&lt;object?&gt; InterceptAsync(IMethodInvocation invocation)\n    {\n        Console.WriteLine($\"Calling {invocation.Method.Name}\");\n        return await invocation.ProceedAsync();\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR007/#imethodinterceptor-interface","title":"IMethodInterceptor Interface","text":"<pre><code>public interface IMethodInterceptor\n{\n    ValueTask&lt;object?&gt; InterceptAsync(IMethodInvocation invocation);\n}\n</code></pre> <p>The interface requires a single method:</p> <ul> <li><code>InterceptAsync</code>: Called when an intercepted method is invoked. Call <code>invocation.ProceedAsync()</code> to continue to the next interceptor or the actual method.</li> </ul>"},{"location":"analyzers/NDLRCOR007/#when-to-suppress","title":"When to Suppress","text":"<p>Do not suppress this diagnostic. Using a type that doesn't implement <code>IMethodInterceptor</code> will cause a compilation error in the generated code.</p>"},{"location":"analyzers/NDLRCOR007/#see-also","title":"See Also","text":"<ul> <li>Interceptors - Full interceptor documentation</li> <li>IMethodInterceptor - Interface details</li> </ul>"},{"location":"analyzers/NDLRCOR008/","title":"NDLRCOR008: [Intercept] applied to class without interfaces","text":""},{"location":"analyzers/NDLRCOR008/#cause","title":"Cause","text":"<p>An <code>[Intercept]</code> or <code>[Intercept&lt;T&gt;]</code> attribute is applied to a class that does not implement any user-defined interfaces.</p>"},{"location":"analyzers/NDLRCOR008/#rule-description","title":"Rule Description","text":"<p>Interceptors work by generating a proxy class that implements the service's interfaces. When a consumer resolves <code>IOrderService</code>, they receive the proxy instead of the original implementation. The proxy intercepts method calls and forwards them through the interceptor chain.</p> <p>If the class doesn't implement any interfaces, there's nothing for the proxy to implement, and the interceptor cannot be applied.</p> <pre><code>// \u26a0\ufe0f NDLRCOR008: OrderService doesn't implement any interfaces\n[Intercept&lt;LoggingInterceptor&gt;]\npublic class OrderService  // No interface!\n{\n    public Order GetOrder(int id) =&gt; /* ... */;\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR008/#how-to-fix","title":"How to Fix","text":""},{"location":"analyzers/NDLRCOR008/#option-1-add-an-interface-recommended","title":"Option 1: Add an Interface (Recommended)","text":"<p>Define an interface for your service:</p> <pre><code>// \u2705 Fixed: OrderService now implements IOrderService\npublic interface IOrderService\n{\n    Order GetOrder(int id);\n}\n\n[Intercept&lt;LoggingInterceptor&gt;]\npublic class OrderService : IOrderService\n{\n    public Order GetOrder(int id) =&gt; /* ... */;\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR008/#option-2-use-a-decorator-instead","title":"Option 2: Use a Decorator Instead","text":"<p>If you can't add an interface, consider using a decorator pattern with manual registration:</p> <pre><code>public class OrderService\n{\n    public virtual Order GetOrder(int id) =&gt; /* ... */;\n}\n\npublic class LoggingOrderService : OrderService\n{\n    private readonly OrderService _inner;\n\n    public LoggingOrderService(OrderService inner) =&gt; _inner = inner;\n\n    public override Order GetOrder(int id)\n    {\n        Console.WriteLine(\"Getting order...\");\n        return _inner.GetOrder(id);\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR008/#option-3-remove-the-attribute","title":"Option 3: Remove the Attribute","text":"<p>If interception isn't needed, remove the <code>[Intercept]</code> attribute:</p> <pre><code>// No interception\npublic class OrderService\n{\n    public Order GetOrder(int id) =&gt; /* ... */;\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR008/#why-interfaces-are-required","title":"Why Interfaces Are Required","text":"<p>The source generator creates a proxy class like this:</p> <pre><code>// Generated proxy\ninternal sealed class OrderService_InterceptorProxy : IOrderService\n{\n    private readonly OrderService _target;\n    private readonly IServiceProvider _serviceProvider;\n\n    public Order GetOrder(int id)\n    {\n        // Interceptor chain logic...\n    }\n}\n</code></pre> <p>The proxy must implement an interface so that consumers can depend on the interface while receiving the proxy. Without an interface, this pattern isn't possible.</p>"},{"location":"analyzers/NDLRCOR008/#when-to-suppress","title":"When to Suppress","text":"<p>Suppress this warning if you're intentionally applying <code>[Intercept]</code> for future use when an interface will be added:</p> <pre><code>#pragma warning disable NDLRCOR008\n[Intercept&lt;LoggingInterceptor&gt;]  // Interface coming in next PR\npublic class OrderService\n{\n    // ...\n}\n#pragma warning restore NDLRCOR008\n</code></pre>"},{"location":"analyzers/NDLRCOR008/#see-also","title":"See Also","text":"<ul> <li>Interceptors - Full interceptor documentation</li> <li>Open Generic Decorators - Alternative for interface-less services</li> </ul>"},{"location":"analyzers/NDLRCOR009/","title":"NDLRCOR009: Lazy references undiscovered type","text":""},{"location":"analyzers/NDLRCOR009/#cause","title":"Cause","text":"<p>A constructor parameter of type <code>Lazy&lt;T&gt;</code> references a type <code>T</code> that was not discovered by source generation.</p>"},{"location":"analyzers/NDLRCOR009/#rule-description","title":"Rule Description","text":"<p>When using source generation with <code>[assembly: GenerateTypeRegistry]</code>, Needlr scans your codebase to discover injectable types. This analyzer detects when a <code>Lazy&lt;T&gt;</code> dependency references a type that wasn't found during that scan.</p> <pre><code>// \u26a0\ufe0f NDLRCOR009: IUnknownService not discovered\npublic class OrderService(Lazy&lt;IUnknownService&gt; unknown)\n{\n    // ...\n}\n</code></pre> <p>This is an informational diagnostic (not a warning or error) because:</p> <ul> <li>The type may be registered via reflection at runtime</li> <li>The type may come from a third-party library</li> <li>The type may be registered manually in an <code>IServiceCollectionPlugin</code></li> </ul>"},{"location":"analyzers/NDLRCOR009/#how-to-fix","title":"How to Fix","text":""},{"location":"analyzers/NDLRCOR009/#option-1-ensure-the-type-is-discoverable","title":"Option 1: Ensure the Type is Discoverable","text":"<p>Make sure the implementation is in a namespace matching your <code>IncludeNamespacePrefixes</code>:</p> <pre><code>[assembly: GenerateTypeRegistry(IncludeNamespacePrefixes = new[] { \"MyApp\" })]\n\nnamespace MyApp.Services\n{\n    public interface IUnknownService { }\n\n    // \u2705 This will be discovered\n    public class UnknownService : IUnknownService { }\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR009/#option-2-register-manually-via-plugin","title":"Option 2: Register Manually via Plugin","text":"<p>If the type is intentionally registered elsewhere:</p> <pre><code>public class MyPlugin : IServiceCollectionPlugin\n{\n    public void Configure(IServiceCollection services)\n    {\n        // Registered manually - Lazy&lt;IExternalService&gt; will work\n        services.AddSingleton&lt;IExternalService, ExternalService&gt;();\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR009/#option-3-suppress-the-diagnostic","title":"Option 3: Suppress the Diagnostic","text":"<p>If you know the type will be available at runtime:</p> <pre><code>#pragma warning disable NDLRCOR009\npublic class OrderService(Lazy&lt;IExternalService&gt; external)\n#pragma warning restore NDLRCOR009\n{\n    // ...\n}\n</code></pre> <p>Or suppress project-wide in <code>.editorconfig</code>:</p> <pre><code># .editorconfig\n[*.cs]\ndotnet_diagnostic.NDLRCOR009.severity = none\n</code></pre>"},{"location":"analyzers/NDLRCOR009/#when-this-analyzer-activates","title":"When This Analyzer Activates","text":"<p>This analyzer only runs when <code>[assembly: GenerateTypeRegistry]</code> is present. In reflection-only projects, there's no type registry to validate against.</p>"},{"location":"analyzers/NDLRCOR009/#severity-levels","title":"Severity Levels","text":"Level Meaning <code>info</code> (default) Informational hint in IDE <code>warning</code> Promote to build warning <code>error</code> Fail the build <code>none</code> Disable completely <p>Configure in <code>.editorconfig</code>:</p> <pre><code># Promote to warning for stricter validation\ndotnet_diagnostic.NDLRCOR009.severity = warning\n</code></pre>"},{"location":"analyzers/NDLRCOR009/#see-also","title":"See Also","text":"<ul> <li>Core Concepts - How <code>Lazy&lt;T&gt;</code> works in Needlr</li> <li>AnalyzerStatus.md - View all active analyzers in diagnostics output</li> </ul>"},{"location":"analyzers/NDLRCOR010/","title":"NDLRCOR010: IEnumerable has no discovered implementations","text":""},{"location":"analyzers/NDLRCOR010/#cause","title":"Cause","text":"<p>A constructor parameter of type <code>IEnumerable&lt;T&gt;</code> references an interface <code>T</code> that has no implementations discovered by source generation.</p>"},{"location":"analyzers/NDLRCOR010/#rule-description","title":"Rule Description","text":"<p>When using source generation with <code>[assembly: GenerateTypeRegistry]</code>, Needlr scans your codebase to discover injectable types. This analyzer detects when an <code>IEnumerable&lt;T&gt;</code> dependency references an interface with no discovered implementations.</p> <pre><code>// \u26a0\ufe0f NDLRCOR010: No implementations of IPlugin discovered\npublic class PluginHost(IEnumerable&lt;IPlugin&gt; plugins)\n{\n    // plugins will be empty unless registered via reflection\n}\n</code></pre> <p>This is an informational diagnostic (not a warning or error) because:</p> <ul> <li>Implementations may be registered via reflection at runtime</li> <li>Implementations may come from a third-party library</li> <li>Implementations may be registered manually in an <code>IServiceCollectionPlugin</code></li> <li>An empty collection is valid in some scenarios</li> </ul>"},{"location":"analyzers/NDLRCOR010/#how-to-fix","title":"How to Fix","text":""},{"location":"analyzers/NDLRCOR010/#option-1-add-implementations","title":"Option 1: Add Implementations","text":"<p>Create classes that implement the interface:</p> <pre><code>public interface IPlugin { }\n\n// \u2705 These will be discovered and registered\npublic class LoggingPlugin : IPlugin { }\npublic class CachingPlugin : IPlugin { }\npublic class MetricsPlugin : IPlugin { }\n</code></pre>"},{"location":"analyzers/NDLRCOR010/#option-2-ensure-namespace-matches","title":"Option 2: Ensure Namespace Matches","text":"<p>Make sure implementations are in a namespace matching your <code>IncludeNamespacePrefixes</code>:</p> <pre><code>[assembly: GenerateTypeRegistry(IncludeNamespacePrefixes = new[] { \"MyApp\" })]\n\nnamespace MyApp.Plugins  // \u2705 Matches prefix\n{\n    public class MyPlugin : IPlugin { }\n}\n\nnamespace ThirdParty.Plugins  // \u274c Won't be discovered\n{\n    public class ExternalPlugin : IPlugin { }\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR010/#option-3-register-manually-via-plugin","title":"Option 3: Register Manually via Plugin","text":"<p>For external implementations:</p> <pre><code>public class ExternalPluginRegistration : IServiceCollectionPlugin\n{\n    public void Configure(IServiceCollection services)\n    {\n        services.AddSingleton&lt;IPlugin, ThirdPartyPlugin&gt;();\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR010/#option-4-suppress-the-diagnostic","title":"Option 4: Suppress the Diagnostic","text":"<p>If empty collections are expected:</p> <pre><code>#pragma warning disable NDLRCOR010\npublic class PluginHost(IEnumerable&lt;IOptionalPlugin&gt; plugins)\n#pragma warning restore NDLRCOR010\n{\n    // Empty collection is valid here\n}\n</code></pre> <p>Or suppress project-wide in <code>.editorconfig</code>:</p> <pre><code># .editorconfig\n[*.cs]\ndotnet_diagnostic.NDLRCOR010.severity = none\n</code></pre>"},{"location":"analyzers/NDLRCOR010/#when-this-analyzer-activates","title":"When This Analyzer Activates","text":"<p>This analyzer only runs when: 1. <code>[assembly: GenerateTypeRegistry]</code> is present 2. The <code>IEnumerable&lt;T&gt;</code> parameter uses an interface type (not a concrete class) 3. The interface is not a framework type (System., Microsoft.)</p>"},{"location":"analyzers/NDLRCOR010/#severity-levels","title":"Severity Levels","text":"Level Meaning <code>info</code> (default) Informational hint in IDE <code>warning</code> Promote to build warning <code>error</code> Fail the build <code>none</code> Disable completely <p>Configure in <code>.editorconfig</code>:</p> <pre><code># Promote to warning for stricter validation\ndotnet_diagnostic.NDLRCOR010.severity = warning\n</code></pre>"},{"location":"analyzers/NDLRCOR010/#see-also","title":"See Also","text":"<ul> <li>Core Concepts - How <code>IEnumerable&lt;T&gt;</code> works in Needlr</li> <li>AnalyzerStatus.md - View all active analyzers in diagnostics output</li> </ul>"},{"location":"analyzers/NDLRCOR011/","title":"NDLRCOR011: Keyed Service Unknown Key","text":""},{"location":"analyzers/NDLRCOR011/#cause","title":"Cause","text":"<p>A constructor parameter uses <code>[FromKeyedServices(\"key\")]</code> to resolve a keyed service, but no <code>[Keyed(\"key\")]</code> registration was found in the compilation.</p>"},{"location":"analyzers/NDLRCOR011/#rule-description","title":"Rule Description","text":"<p>When using source generation with <code>[assembly: GenerateTypeRegistry]</code>, Needlr validates that <code>[FromKeyedServices(\"key\")]</code> parameters reference keys that are statically discoverable.</p> <pre><code>// \u2139\ufe0f NDLRCOR011: No registration found for key \"unknown\"\npublic class PaymentHandler(\n    [FromKeyedServices(\"unknown\")] IPaymentProcessor processor)\n{\n}\n</code></pre> <p>This is an informational diagnostic (not a warning or error) because:</p> <ul> <li>Keys may be registered at runtime via <code>IServiceCollectionPlugin</code></li> <li>The analyzer only validates statically-discoverable <code>[Keyed]</code> registrations</li> </ul>"},{"location":"analyzers/NDLRCOR011/#how-to-fix","title":"How to Fix","text":""},{"location":"analyzers/NDLRCOR011/#option-1-add-keyed-attribute","title":"Option 1: Add [Keyed] Attribute","text":"<p>Register the service with a matching key:</p> <pre><code>[Keyed(\"primary\")]\npublic class StripeProcessor : IPaymentProcessor { }\n\n// \u2705 Now validated - \"primary\" key is discovered\npublic class PaymentHandler(\n    [FromKeyedServices(\"primary\")] IPaymentProcessor processor)\n{\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR011/#option-2-register-via-plugin-suppress-diagnostic","title":"Option 2: Register via Plugin (Suppress Diagnostic)","text":"<p>If registering via plugin, suppress the diagnostic:</p> <pre><code>// Plugin registers keyed services at runtime\npublic class PaymentPlugin : IServiceCollectionPlugin\n{\n    public void Configure(ServiceCollectionPluginOptions options)\n    {\n        options.Services.AddKeyedSingleton&lt;IPaymentProcessor, StripeProcessor&gt;(\"primary\");\n    }\n}\n\n// Suppress because key is registered via plugin\n#pragma warning disable NDLRCOR011\npublic class PaymentHandler(\n    [FromKeyedServices(\"primary\")] IPaymentProcessor processor)\n#pragma warning restore NDLRCOR011\n{\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR011/#option-3-project-wide-suppression","title":"Option 3: Project-Wide Suppression","text":"<pre><code># .editorconfig\n[*.cs]\ndotnet_diagnostic.NDLRCOR011.severity = none\n</code></pre>"},{"location":"analyzers/NDLRCOR011/#validation-logic","title":"Validation Logic","text":"<p>The analyzer: 1. Collects all <code>[Keyed(\"key\")]</code> attributes from classes in the compilation 2. Collects all <code>[FromKeyedServices(\"key\")]</code> parameters 3. Reports diagnostic when a key is not found in discovered registrations</p> <p>Keys registered via plugins cannot be validated at compile time.</p>"},{"location":"analyzers/NDLRCOR011/#when-this-analyzer-activates","title":"When This Analyzer Activates","text":"<p>This analyzer only runs when: 1. <code>[assembly: GenerateTypeRegistry]</code> is present 2. A constructor parameter has <code>[FromKeyedServices(\"key\")]</code> attribute 3. The parameter type is not a framework type (System., Microsoft.)</p>"},{"location":"analyzers/NDLRCOR011/#severity-levels","title":"Severity Levels","text":"Level Meaning <code>info</code> (default) Informational hint in IDE <code>warning</code> Promote to build warning <code>error</code> Fail the build <code>none</code> Disable completely"},{"location":"analyzers/NDLRCOR011/#see-also","title":"See Also","text":"<ul> <li>Keyed Services - Static keyed service registration</li> <li>AnalyzerStatus.md - View all active analyzers</li> </ul>"},{"location":"analyzers/NDLRCOR012/","title":"NDLRCOR012: Disposable captive dependency","text":""},{"location":"analyzers/NDLRCOR012/#cause","title":"Cause","text":"<p>A service with a longer lifetime holds a reference to an <code>IDisposable</code> or <code>IAsyncDisposable</code> dependency with a shorter lifetime. When the shorter-lived scope ends, the dependency will be disposed while the longer-lived service still holds a reference, causing <code>ObjectDisposedException</code> at runtime.</p>"},{"location":"analyzers/NDLRCOR012/#rule-description","title":"Rule Description","text":"<p>This is a more severe form of captive dependency (see NDLRCOR005) that specifically targets disposable services. While a general captive dependency causes stale data, a disposable captive dependency causes runtime crashes.</p> <pre><code>// \u274c NDLRCOR012: Singleton holds Scoped IDisposable\n[Singleton]\npublic class CacheService\n{\n    private readonly MyDbContext _dbContext;\n\n    public CacheService(MyDbContext dbContext)\n    {\n        _dbContext = dbContext;\n    }\n\n    public async Task RefreshCache()\n    {\n        // \ud83d\udca5 ObjectDisposedException - dbContext was disposed when scope ended!\n        var data = await _dbContext.Items.ToListAsync();\n    }\n}\n\n[Scoped]\npublic class MyDbContext : DbContext, IDisposable\n{\n    // ...\n}\n</code></pre> <p>Why this is dangerous:</p> <ol> <li>Runtime exceptions: Accessing a disposed object throws <code>ObjectDisposedException</code></li> <li>Unpredictable timing: The exception may occur long after the service was created</li> <li>Hard to debug: The stack trace points to the usage site, not the registration problem</li> </ol>"},{"location":"analyzers/NDLRCOR012/#mismatch-patterns-that-trigger-this-error","title":"Mismatch Patterns That Trigger This Error","text":"Consumer Dependency Result Singleton Scoped IDisposable \u274c Error Singleton Transient IDisposable \u274c Error Scoped Transient IDisposable \u274c Error"},{"location":"analyzers/NDLRCOR012/#how-to-fix","title":"How to Fix","text":""},{"location":"analyzers/NDLRCOR012/#option-1-match-lifetimes","title":"Option 1: Match Lifetimes","text":"<p>Make the consumer's lifetime equal or shorter than its dependencies:</p> <pre><code>// \u2705 Scoped depends on Scoped - OK!\n[Scoped]\npublic class CacheService(MyDbContext dbContext) { }\n</code></pre>"},{"location":"analyzers/NDLRCOR012/#option-2-use-iservicescopefactory","title":"Option 2: Use IServiceScopeFactory","text":"<p>Create a new scope when you need the disposable service:</p> <pre><code>[Singleton]\npublic class CacheService\n{\n    private readonly IServiceScopeFactory _scopeFactory;\n\n    public CacheService(IServiceScopeFactory scopeFactory)\n    {\n        _scopeFactory = scopeFactory;\n    }\n\n    public async Task RefreshCache()\n    {\n        using var scope = _scopeFactory.CreateScope();\n        var dbContext = scope.ServiceProvider.GetRequiredService&lt;MyDbContext&gt;();\n        var data = await dbContext.Items.ToListAsync();\n        // dbContext is disposed when scope ends - that's fine, we're done with it\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR012/#option-3-use-func-factory","title":"Option 3: Use Func Factory <p>Inject a factory that creates fresh instances:</p> <pre><code>[Singleton]\npublic class CacheService(Func&lt;MyDbContext&gt; dbContextFactory)\n{\n    public async Task RefreshCache()\n    {\n        using var dbContext = dbContextFactory();\n        var data = await dbContext.Items.ToListAsync();\n    }\n}\n</code></pre>","text":""},{"location":"analyzers/NDLRCOR012/#detection-limitations","title":"Detection Limitations","text":"<p>This analyzer only fires when:</p> <ol> <li>Both types have explicit lifetime attributes (<code>[Singleton]</code>, <code>[Scoped]</code>, <code>[Transient]</code>)</li> <li>The dependency is a concrete class (not an interface)</li> <li>The dependency directly implements <code>IDisposable</code> or <code>IAsyncDisposable</code></li> </ol> <p>This conservative approach ensures zero false positives but may miss some cases (false negatives are acceptable).</p>"},{"location":"analyzers/NDLRCOR012/#not-detected-by-design","title":"Not Detected (by design) <pre><code>// Interface dependency - can't determine concrete type\n[Singleton]\npublic class Service(IDbContext dbContext) { }  // No error (might not be disposable)\n\n// No explicit lifetime attributes\npublic class Service(ScopedDisposable dep) { }  // No error (lifetime unknown)\n</code></pre>","text":""},{"location":"analyzers/NDLRCOR012/#when-to-suppress","title":"When to Suppress","text":"<p>You should rarely suppress this error. Consider suppressing only if:</p> <ol> <li>You've implemented proper disposal handling manually</li> <li>The disposable's <code>Dispose()</code> is a no-op or the object remains usable after disposal</li> </ol> <pre><code>[Singleton]\n#pragma warning disable NDLRCOR012\npublic class Service(PooledConnection connection) { }  // Connection returns to pool\n#pragma warning restore NDLRCOR012\n</code></pre>"},{"location":"analyzers/NDLRCOR012/#see-also","title":"See Also","text":"<ul> <li>NDLRCOR005: Lifetime mismatch - General captive dependency warning</li> <li>NDLRCOR006: Circular dependency detected</li> </ul>"},{"location":"analyzers/NDLRCOR015/","title":"NDLRCOR015: [RegisterAs\\] type argument not implemented","text":""},{"location":"analyzers/NDLRCOR015/#summary","title":"Summary","text":"<p>The type specified in <code>[RegisterAs&lt;T&gt;]</code> must be an interface that the decorated class actually implements.</p>"},{"location":"analyzers/NDLRCOR015/#description","title":"Description","text":"<p>When using <code>[RegisterAs&lt;T&gt;]</code> to control which interface a class is registered as in dependency injection, the type argument <code>T</code> must be an interface that the class implements. If the class doesn't implement the specified interface, the registration would be invalid and the service could not be resolved.</p>"},{"location":"analyzers/NDLRCOR015/#severity","title":"Severity","text":"<p>Error - This is a compile-time error because the service registration would fail at runtime.</p>"},{"location":"analyzers/NDLRCOR015/#example","title":"Example","text":""},{"location":"analyzers/NDLRCOR015/#invalid-code","title":"Invalid Code","text":"<pre><code>public interface IReader { string Read(); }\npublic interface IWriter { void Write(string data); }\n\n// \u274c Error: MyService does not implement IWriter\n[RegisterAs&lt;IWriter&gt;]\npublic class MyService : IReader\n{\n    public string Read() =&gt; \"data\";\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR015/#valid-code","title":"Valid Code","text":"<pre><code>public interface IReader { string Read(); }\npublic interface IWriter { void Write(string data); }\npublic interface ILogger { void Log(string message); }\n\n// \u2705 OK: MyService implements IReader\n[RegisterAs&lt;IReader&gt;]\npublic class MyService : IReader, IWriter, ILogger\n{\n    public string Read() =&gt; \"data\";\n    public void Write(string data) { }\n    public void Log(string message) { }\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR015/#how-to-fix","title":"How to Fix","text":"<ol> <li>Add the interface to the class - Make the class implement the interface specified in <code>[RegisterAs&lt;T&gt;]</code></li> <li>Change the type argument - Use a different interface that the class already implements</li> <li>Remove the attribute - If you want all interfaces registered, remove <code>[RegisterAs&lt;T&gt;]</code> entirely</li> </ol>"},{"location":"analyzers/NDLRCOR015/#when-to-suppress","title":"When to Suppress","text":"<p>Do not suppress this diagnostic. If the class doesn't implement the interface, the registration is invalid and will fail.</p>"},{"location":"analyzers/NDLRCOR015/#see-also","title":"See Also","text":"<ul> <li>RegisterAs Documentation</li> </ul>"},{"location":"analyzers/NDLRCOR016/","title":"NDLRCOR016: [DoNotAutoRegister] on a plugin class is redundant","text":""},{"location":"analyzers/NDLRCOR016/#summary","title":"Summary","text":"<p>A class that implements a Needlr plugin interface has <code>[DoNotAutoRegister]</code> applied directly. This attribute is already present on the plugin interface itself and does not need to be repeated on implementing classes.</p>"},{"location":"analyzers/NDLRCOR016/#description","title":"Description","text":"<p><code>[DoNotAutoRegister]</code> tells the Needlr source generator to skip automatic DI service registration for the decorated type. Plugin interfaces like <code>IServiceCollectionPlugin</code>, <code>IWebApplicationPlugin</code>, and others already carry this attribute so that Needlr does not register the interface type itself as a DI service.</p> <p>Applying <code>[DoNotAutoRegister]</code> directly to a class that implements one of these interfaces is redundant. More importantly, in older versions of Needlr this pattern accidentally prevented the plugin class from being discovered at all (see fix for <code>IsPluginType</code>). Removing the attribute from the implementing class is the correct fix.</p>"},{"location":"analyzers/NDLRCOR016/#severity","title":"Severity","text":"<p>Warning - The code compiles, but the attribute is redundant and may indicate a misunderstanding of how the attribute is intended to work.</p>"},{"location":"analyzers/NDLRCOR016/#example","title":"Example","text":""},{"location":"analyzers/NDLRCOR016/#invalid-code","title":"Invalid Code","text":"<pre><code>// \u26a0\ufe0f Warning: [DoNotAutoRegister] on the implementing class is redundant.\n// The attribute is already on IServiceCollectionPlugin.\n[DoNotAutoRegister]\npublic class MyPlugin : IServiceCollectionPlugin\n{\n    public void Configure(ServiceCollectionPluginOptions options)\n    {\n        options.Services.AddSingleton&lt;IMyService, MyService&gt;();\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR016/#valid-code","title":"Valid Code","text":"<pre><code>// \u2705 OK: [DoNotAutoRegister] is not needed here.\n// IServiceCollectionPlugin already carries it.\npublic class MyPlugin : IServiceCollectionPlugin\n{\n    public void Configure(ServiceCollectionPluginOptions options)\n    {\n        options.Services.AddSingleton&lt;IMyService, MyService&gt;();\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR016/#valid-usage-on-a-non-plugin-class","title":"Valid usage on a non-plugin class","text":"<pre><code>// \u2705 OK: applying [DoNotAutoRegister] to a class that does not implement\n// a plugin interface is the intended usage \u2014 it prevents DI auto-registration.\n[DoNotAutoRegister]\npublic class InternalHelper\n{\n    // ...\n}\n</code></pre>"},{"location":"analyzers/NDLRCOR016/#how-to-fix","title":"How to Fix","text":"<p>Remove <code>[DoNotAutoRegister]</code> from the plugin class. The plugin interface already carries the attribute; it does not need to be repeated.</p>"},{"location":"analyzers/NDLRCOR016/#when-to-suppress","title":"When to Suppress","text":"<p>Suppress only if you are intentionally targeting an older version of Needlr that has the <code>IsPluginType</code> bug and need <code>[DoNotAutoRegister]</code> on the class as a workaround. In all current versions, removing the attribute is the correct fix.</p>"},{"location":"analyzers/NDLRCOR016/#see-also","title":"See Also","text":"<ul> <li>Plugin Development</li> <li>NDLRCOR001</li> </ul>"},{"location":"analyzers/NDLRGEN001/","title":"NDLRGEN001: Internal type in referenced assembly cannot be registered","text":""},{"location":"analyzers/NDLRGEN001/#cause","title":"Cause","text":"<p>You are scanning a namespace that contains internal types in a referenced assembly, but those types cannot be registered because they are not accessible from the generated code.</p>"},{"location":"analyzers/NDLRGEN001/#rule-description","title":"Rule Description","text":"<p>When using source generation with <code>[GenerateTypeRegistry]</code>, the generator scans specified namespace prefixes to discover types for automatic registration. If an internal type in a referenced assembly matches the namespace filter and would otherwise be registerable (e.g., implements an interface or is a plugin), the generator cannot access it.</p> <p>This error indicates a configuration problem that would cause silent runtime failures if not addressed.</p>"},{"location":"analyzers/NDLRGEN001/#how-to-fix","title":"How to Fix","text":"<p>You have two options:</p>"},{"location":"analyzers/NDLRGEN001/#option-1-add-generatetyperegistry-to-the-referenced-assembly","title":"Option 1: Add [GenerateTypeRegistry] to the Referenced Assembly","text":"<p>Add the <code>[GenerateTypeRegistry]</code> attribute to the assembly containing the internal types. This allows that assembly to generate its own type registry that can access its internal types.</p> <pre><code>// In the referenced assembly (e.g., MyPlugin project)\nusing NexusLabs.Needlr.Generators;\n\n[assembly: GenerateTypeRegistry(IncludeNamespacePrefixes = new[] { \"MyPlugin\" })]\n\nnamespace MyPlugin\n{\n    internal class MyInternalService : IMyService { }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN001/#option-2-make-the-type-public","title":"Option 2: Make the Type Public","text":"<p>If the type can be made public, change its accessibility:</p> <pre><code>namespace MyPlugin\n{\n    public class MyService : IMyService { }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN001/#when-to-suppress","title":"When to Suppress","text":"<p>Only suppress this error if you intentionally don't want the internal type to be registered:</p> <pre><code>#pragma warning disable NDLRGEN001\n// Intentionally not registering this internal type\n#pragma warning restore NDLRGEN001\n</code></pre>"},{"location":"analyzers/NDLRGEN001/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN001/#code-with-error","title":"Code with Error","text":"<pre><code>// HostApp project\nusing NexusLabs.Needlr.Generators;\n\n// Scanning \"MyPlugin\" namespace but MyPlugin assembly has internal types\n[assembly: GenerateTypeRegistry(IncludeNamespacePrefixes = new[] { \"MyPlugin\" })]\n</code></pre> <pre><code>// MyPlugin project (referenced by HostApp) - NO [GenerateTypeRegistry]\nnamespace MyPlugin\n{\n    public interface IMyService { }\n    internal class MyInternalService : IMyService { }  // Error: Cannot be registered\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN001/#fixed-code","title":"Fixed Code","text":"<pre><code>// MyPlugin project - WITH [GenerateTypeRegistry]\nusing NexusLabs.Needlr.Generators;\n\n[assembly: GenerateTypeRegistry(IncludeNamespacePrefixes = new[] { \"MyPlugin\" })]\n\nnamespace MyPlugin\n{\n    public interface IMyService { }\n    internal class MyInternalService : IMyService { }  // Now properly registered\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN001/#see-also","title":"See Also","text":"<ul> <li>NDLRGEN002 - Missing type registry for internal plugin types</li> <li>Advanced Usage - Multi-Project Solutions</li> <li>Getting Started Guide</li> </ul>"},{"location":"analyzers/NDLRGEN002/","title":"NDLRGEN002: Referenced assembly has internal plugin types but no type registry","text":""},{"location":"analyzers/NDLRGEN002/#cause","title":"Cause","text":"<p>A referenced assembly contains internal types that implement Needlr plugin interfaces (e.g., <code>IServiceCollectionPlugin</code>), but the assembly does not have a <code>[GenerateTypeRegistry]</code> attribute.</p>"},{"location":"analyzers/NDLRGEN002/#rule-description","title":"Rule Description","text":"<p>When using source generation, internal plugin types in referenced assemblies cannot be discovered by the host application's generator. This means internal plugins will silently fail to load at runtime.</p> <p>This error proactively detects this misconfiguration at compile time, preventing runtime failures.</p>"},{"location":"analyzers/NDLRGEN002/#plugin-interfaces-checked","title":"Plugin Interfaces Checked","text":"<p>The generator checks for internal types implementing any of these interfaces:</p> <ul> <li><code>NexusLabs.Needlr.IServiceCollectionPlugin</code></li> <li><code>NexusLabs.Needlr.IPostBuildServiceCollectionPlugin</code></li> <li><code>NexusLabs.Needlr.IWebApplicationPlugin</code></li> <li><code>NexusLabs.Needlr.IWebApplicationBuilderPlugin</code></li> <li><code>NexusLabs.Needlr.SignalR.IHubRegistrationPlugin</code></li> <li><code>NexusLabs.Needlr.SemanticKernel.IKernelBuilderPlugin</code></li> </ul>"},{"location":"analyzers/NDLRGEN002/#how-to-fix","title":"How to Fix","text":"<p>You have two options:</p>"},{"location":"analyzers/NDLRGEN002/#option-1-add-generatetyperegistry-to-the-plugin-assembly","title":"Option 1: Add [GenerateTypeRegistry] to the Plugin Assembly","text":"<p>Add the <code>[GenerateTypeRegistry]</code> attribute to the assembly containing the internal plugin:</p> <pre><code>// In the plugin assembly (e.g., MyPlugin project)\nusing NexusLabs.Needlr.Generators;\n\n[assembly: GenerateTypeRegistry(IncludeNamespacePrefixes = new[] { \"MyPlugin\" })]\n\nnamespace MyPlugin\n{\n    internal class MyPlugin : IServiceCollectionPlugin\n    {\n        public void Configure(ServiceCollectionPluginOptions options) { }\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN002/#option-2-make-the-plugin-type-public","title":"Option 2: Make the Plugin Type Public","text":"<p>If the plugin can be made public, change its accessibility:</p> <pre><code>namespace MyPlugin\n{\n    public class MyPlugin : IServiceCollectionPlugin\n    {\n        public void Configure(ServiceCollectionPluginOptions options) { }\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN002/#when-to-suppress","title":"When to Suppress","text":"<p>Only suppress this error if you intentionally don't want the plugin to be discovered:</p> <pre><code>#pragma warning disable NDLRGEN002\n// Intentionally keeping this plugin internal and unregistered\n#pragma warning restore NDLRGEN002\n</code></pre>"},{"location":"analyzers/NDLRGEN002/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN002/#code-with-error","title":"Code with Error","text":"<pre><code>// HostApp project\nusing NexusLabs.Needlr.Generators;\n\n[assembly: GenerateTypeRegistry]\n</code></pre> <pre><code>// MyPlugin project (referenced by HostApp) - NO [GenerateTypeRegistry]\nnamespace MyPlugin\n{\n    internal class AuthenticationPlugin : IWebApplicationBuilderPlugin\n    {\n        public void Configure(WebApplicationBuilderPluginOptions options)\n        {\n            options.Builder.Services.AddAuthentication();\n        }\n    }\n}\n</code></pre> <p>Result: <code>NDLRGEN002</code> error - AuthenticationPlugin will not be discovered at runtime.</p>"},{"location":"analyzers/NDLRGEN002/#fixed-code","title":"Fixed Code","text":"<pre><code>// MyPlugin project - WITH [GenerateTypeRegistry]\nusing NexusLabs.Needlr.Generators;\n\n[assembly: GenerateTypeRegistry(IncludeNamespacePrefixes = new[] { \"MyPlugin\" })]\n\nnamespace MyPlugin\n{\n    internal class AuthenticationPlugin : IWebApplicationBuilderPlugin\n    {\n        public void Configure(WebApplicationBuilderPluginOptions options)\n        {\n            options.Builder.Services.AddAuthentication();\n        }\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN002/#multi-project-solutions","title":"Multi-Project Solutions","text":"<p>For solutions with many plugin projects, consider using MSBuild conventions to automatically add <code>[GenerateTypeRegistry]</code> to matching projects. See Advanced Usage - Multi-Project Solutions for details.</p>"},{"location":"analyzers/NDLRGEN002/#see-also","title":"See Also","text":"<ul> <li>NDLRGEN001 - Internal type in referenced assembly cannot be registered</li> <li>Advanced Usage - Multi-Project Solutions</li> <li>Getting Started Guide</li> </ul>"},{"location":"analyzers/NDLRGEN003/","title":"NDLRGEN003: All factory parameters are injectable","text":""},{"location":"analyzers/NDLRGEN003/#diagnostic-info","title":"Diagnostic Info","text":"Property Value ID NDLRGEN003 Category NexusLabs.Needlr.Generators Severity Warning Enabled Yes"},{"location":"analyzers/NDLRGEN003/#description","title":"Description","text":"<p>This warning is raised when a class marked with <code>[GenerateFactory]</code> has a constructor where all parameters are injectable types (interfaces or classes). In this case, the factory provides no additional value since the type could be auto-registered normally.</p>"},{"location":"analyzers/NDLRGEN003/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN003/#code-that-triggers-the-warning","title":"Code that triggers the warning","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n// \u26a0\ufe0f NDLRGEN003: All parameters are injectable, factory provides no value\n[GenerateFactory]\npublic class MyService\n{\n    public MyService(ILogger&lt;MyService&gt; logger, IConfiguration config)\n    {\n        // Both parameters are injectable - no need for a factory\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN003/#how-to-fix","title":"How to fix","text":"<p>Either remove the <code>[GenerateFactory]</code> attribute (the type will be auto-registered normally), or add a runtime parameter that justifies the factory:</p> <p>Option 1: Remove the attribute <pre><code>// Let Needlr auto-register this normally\npublic class MyService\n{\n    public MyService(ILogger&lt;MyService&gt; logger, IConfiguration config)\n    {\n    }\n}\n</code></pre></p> <p>Option 2: Add a runtime parameter <pre><code>[GenerateFactory]\npublic class MyService\n{\n    public MyService(ILogger&lt;MyService&gt; logger, IConfiguration config, string tenantId)\n    {\n        // Now the factory makes sense - tenantId must be provided at runtime\n    }\n}\n</code></pre></p>"},{"location":"analyzers/NDLRGEN003/#why-this-matters","title":"Why This Matters","text":"<p>Factory generation adds code to your assembly. If all parameters can be auto-injected, the factory is unnecessary overhead. The type can simply be registered directly with the container.</p>"},{"location":"analyzers/NDLRGEN003/#see-also","title":"See Also","text":"<ul> <li>Factory Delegates</li> <li>NDLRGEN004 - No injectable parameters</li> <li>NDLRGEN005 - Invalid generic type parameter</li> </ul>"},{"location":"analyzers/NDLRGEN004/","title":"NDLRGEN004: No factory parameters are injectable","text":""},{"location":"analyzers/NDLRGEN004/#diagnostic-info","title":"Diagnostic Info","text":"Property Value ID NDLRGEN004 Category NexusLabs.Needlr.Generators Severity Warning Enabled Yes"},{"location":"analyzers/NDLRGEN004/#description","title":"Description","text":"<p>This warning is raised when a class marked with <code>[GenerateFactory]</code> has a constructor where no parameters are injectable types. The factory will still work, but it provides low value since there are no dependencies to inject - you could simply use <code>new</code> directly.</p>"},{"location":"analyzers/NDLRGEN004/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN004/#code-that-triggers-the-warning","title":"Code that triggers the warning","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n// \u26a0\ufe0f NDLRGEN004: No parameters are injectable, factory provides low value\n[GenerateFactory]\npublic class ConnectionString\n{\n    public ConnectionString(string server, int port, string database)\n    {\n        // All parameters are runtime - nothing to inject\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN004/#how-to-fix","title":"How to fix","text":"<p>Either remove the <code>[GenerateFactory]</code> attribute and use <code>new</code> directly, or add an injectable dependency:</p> <p>Option 1: Remove the attribute and use <code>new</code> <pre><code>// Just use new directly - no factory needed\npublic class ConnectionString\n{\n    public ConnectionString(string server, int port, string database) { }\n}\n\n// Usage\nvar conn = new ConnectionString(\"localhost\", 5432, \"mydb\");\n</code></pre></p> <p>Option 2: Add an injectable dependency <pre><code>[GenerateFactory]\npublic class ConnectionString\n{\n    public ConnectionString(IConfiguration config, string server, int port, string database)\n    {\n        // Now the factory provides value - it injects IConfiguration\n    }\n}\n</code></pre></p>"},{"location":"analyzers/NDLRGEN004/#why-this-matters","title":"Why This Matters","text":"<p>The primary purpose of factory generation is to partition constructor parameters into those that can be auto-injected and those that must be provided at runtime. If there's nothing to inject, the factory is just an extra layer of indirection.</p>"},{"location":"analyzers/NDLRGEN004/#when-to-suppress","title":"When to Suppress","text":"<p>You might intentionally want a factory for a type with no injectable dependencies if:</p> <ul> <li>You want consistent factory patterns across your codebase</li> <li>You anticipate adding injectable dependencies later</li> <li>You prefer resolving factories from DI for consistency</li> </ul> <pre><code>#pragma warning disable NDLRGEN004\n[GenerateFactory]\npublic class ConnectionString { /* ... */ }\n#pragma warning restore NDLRGEN004\n</code></pre>"},{"location":"analyzers/NDLRGEN004/#see-also","title":"See Also","text":"<ul> <li>Factory Delegates</li> <li>NDLRGEN003 - All parameters injectable</li> <li>NDLRGEN005 - Invalid generic type parameter</li> </ul>"},{"location":"analyzers/NDLRGEN005/","title":"NDLRGEN005: Factory generic type not implemented by class","text":""},{"location":"analyzers/NDLRGEN005/#diagnostic-info","title":"Diagnostic Info","text":"Property Value ID NDLRGEN005 Category NexusLabs.Needlr.Generators Severity Error Enabled Yes"},{"location":"analyzers/NDLRGEN005/#description","title":"Description","text":"<p>This error is raised when a class uses <code>[GenerateFactory&lt;T&gt;]</code> with a type parameter <code>T</code> that the class does not implement. The generic type must be an interface or base class that the decorated class implements or inherits from.</p>"},{"location":"analyzers/NDLRGEN005/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN005/#code-that-triggers-the-error","title":"Code that triggers the error","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\npublic interface IRequestHandler { }\npublic interface IMessageHandler { }\n\n// \u274c NDLRGEN005: MyHandler does not implement IMessageHandler\n[GenerateFactory&lt;IMessageHandler&gt;]\npublic class MyHandler : IRequestHandler\n{\n    public MyHandler(ILogger logger, Guid correlationId) { }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN005/#how-to-fix","title":"How to fix","text":"<p>Use an interface that the class actually implements:</p> <pre><code>// \u2705 Correct - MyHandler implements IRequestHandler\n[GenerateFactory&lt;IRequestHandler&gt;]\npublic class MyHandler : IRequestHandler\n{\n    public MyHandler(ILogger logger, Guid correlationId) { }\n}\n</code></pre> <p>Or implement the interface you want to use:</p> <pre><code>// \u2705 Correct - MyHandler now implements IMessageHandler\n[GenerateFactory&lt;IMessageHandler&gt;]\npublic class MyHandler : IRequestHandler, IMessageHandler\n{\n    public MyHandler(ILogger logger, Guid correlationId) { }\n}\n</code></pre> <p>Or use the non-generic attribute to return the concrete type:</p> <pre><code>// \u2705 Correct - returns concrete MyHandler type\n[GenerateFactory]\npublic class MyHandler : IRequestHandler\n{\n    public MyHandler(ILogger logger, Guid correlationId) { }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN005/#why-this-matters","title":"Why This Matters","text":"<p>The <code>[GenerateFactory&lt;T&gt;]</code> attribute changes the return type of the factory's <code>Create()</code> method from the concrete class to <code>T</code>. If the class doesn't implement <code>T</code>, the generated code would have an invalid cast and fail to compile.</p>"},{"location":"analyzers/NDLRGEN005/#generated-code-comparison","title":"Generated Code Comparison","text":"<p>Non-generic <code>[GenerateFactory]</code>: <pre><code>public interface IMyHandlerFactory\n{\n    MyHandler Create(Guid correlationId);  // Returns concrete type\n}\n</code></pre></p> <p>Generic <code>[GenerateFactory&lt;IRequestHandler&gt;]</code>: <pre><code>public interface IMyHandlerFactory\n{\n    IRequestHandler Create(Guid correlationId);  // Returns interface\n}\n</code></pre></p>"},{"location":"analyzers/NDLRGEN005/#see-also","title":"See Also","text":"<ul> <li>Factory Delegates</li> <li>NDLRGEN003 - All parameters injectable</li> <li>NDLRGEN004 - No injectable parameters</li> </ul>"},{"location":"analyzers/NDLRGEN006/","title":"NDLRGEN006: [OpenDecoratorFor] type argument must be an open generic interface","text":""},{"location":"analyzers/NDLRGEN006/#cause","title":"Cause","text":"<p>The type argument passed to <code>[OpenDecoratorFor]</code> is not an open generic interface (unbound generic type).</p>"},{"location":"analyzers/NDLRGEN006/#rule-description","title":"Rule Description","text":"<p>The <code>[OpenDecoratorFor]</code> attribute is designed to create decorators for all closed implementations of an open generic interface. The type argument must be:</p> <ol> <li>An interface (not a class or struct)</li> <li>An open/unbound generic using the <code>typeof(IInterface&lt;&gt;)</code> syntax</li> </ol> <p>Common mistakes include:</p> <ul> <li>Passing a closed generic type like <code>typeof(IHandler&lt;string&gt;)</code></li> <li>Passing a non-generic interface like <code>typeof(IService)</code></li> <li>Passing a class instead of an interface</li> </ul>"},{"location":"analyzers/NDLRGEN006/#how-to-fix","title":"How to Fix","text":"<p>Use the open generic <code>typeof()</code> syntax with empty angle brackets:</p> <pre><code>// \u274c Wrong - closed generic\n[OpenDecoratorFor(typeof(IHandler&lt;string&gt;))]\n\n// \u274c Wrong - non-generic\n[OpenDecoratorFor(typeof(IService))]\n\n// \u2705 Correct - open generic interface\n[OpenDecoratorFor(typeof(IHandler&lt;&gt;))]\n</code></pre>"},{"location":"analyzers/NDLRGEN006/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN006/#code-with-error","title":"Code with Error","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\npublic interface IHandler&lt;T&gt; { void Handle(T message); }\n\n// NDLRGEN006: Type argument 'IHandler&lt;string&gt;' is not an open generic interface\n[OpenDecoratorFor(typeof(IHandler&lt;string&gt;))]\npublic class LoggingDecorator&lt;T&gt; : IHandler&lt;T&gt;\n{\n    private readonly IHandler&lt;T&gt; _inner;\n    public LoggingDecorator(IHandler&lt;T&gt; inner) =&gt; _inner = inner;\n    public void Handle(T message) =&gt; _inner.Handle(message);\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN006/#fixed-code","title":"Fixed Code","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\npublic interface IHandler&lt;T&gt; { void Handle(T message); }\n\n// \u2705 Using open generic syntax\n[OpenDecoratorFor(typeof(IHandler&lt;&gt;))]\npublic class LoggingDecorator&lt;T&gt; : IHandler&lt;T&gt;\n{\n    private readonly IHandler&lt;T&gt; _inner;\n    public LoggingDecorator(IHandler&lt;T&gt; inner) =&gt; _inner = inner;\n    public void Handle(T message) =&gt; _inner.Handle(message);\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN006/#alternative-approaches","title":"Alternative Approaches","text":"<p>If you want to decorate a specific closed type instead of all implementations:</p> <pre><code>// Use [DecoratorFor&lt;T&gt;] for closed types\n[DecoratorFor&lt;IHandler&lt;string&gt;&gt;]\npublic class StringHandlerDecorator : IHandler&lt;string&gt;\n{\n    private readonly IHandler&lt;string&gt; _inner;\n    public StringHandlerDecorator(IHandler&lt;string&gt; inner) =&gt; _inner = inner;\n    public void Handle(string message) =&gt; _inner.Handle(message);\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN006/#see-also","title":"See Also","text":"<ul> <li>NDLRGEN007 - Decorator class must be an open generic</li> <li>NDLRGEN008 - Decorator must implement the interface</li> <li>Open Generic Decorators Guide</li> </ul>"},{"location":"analyzers/NDLRGEN007/","title":"NDLRGEN007: [OpenDecoratorFor] decorator must be an open generic class","text":""},{"location":"analyzers/NDLRGEN007/#cause","title":"Cause","text":"<p>A class marked with <code>[OpenDecoratorFor(typeof(IInterface&lt;&gt;))]</code> is either: 1. Not a generic class, or 2. Has a different number of type parameters than the interface</p>"},{"location":"analyzers/NDLRGEN007/#rule-description","title":"Rule Description","text":"<p>When using <code>[OpenDecoratorFor]</code>, the decorator class must be an open generic with the same number of type parameters as the interface it decorates. This is because Needlr needs to close both the interface and decorator with the same type arguments at compile time.</p> <p>For example:</p> <ul> <li><code>IHandler&lt;T&gt;</code> (1 type parameter) \u2192 decorator must have 1 type parameter</li> <li><code>IRequestHandler&lt;TRequest, TResponse&gt;</code> (2 type parameters) \u2192 decorator must have 2 type parameters</li> </ul>"},{"location":"analyzers/NDLRGEN007/#how-to-fix","title":"How to Fix","text":"<p>Ensure your decorator class: 1. Is a generic class 2. Has the same number of type parameters as the target interface</p> <pre><code>// \u274c Wrong - decorator is not generic\n[OpenDecoratorFor(typeof(IHandler&lt;&gt;))]\npublic class LoggingDecorator : IHandler&lt;string&gt; { }\n\n// \u274c Wrong - arity mismatch (1 vs 2)\n[OpenDecoratorFor(typeof(IRequestHandler&lt;,&gt;))]\npublic class LoggingDecorator&lt;T&gt; : IRequestHandler&lt;T, T&gt; { }\n\n// \u2705 Correct - same arity\n[OpenDecoratorFor(typeof(IHandler&lt;&gt;))]\npublic class LoggingDecorator&lt;T&gt; : IHandler&lt;T&gt; { }\n\n// \u2705 Correct - both have 2 type parameters\n[OpenDecoratorFor(typeof(IRequestHandler&lt;,&gt;))]\npublic class LoggingDecorator&lt;TRequest, TResponse&gt; : IRequestHandler&lt;TRequest, TResponse&gt; { }\n</code></pre>"},{"location":"analyzers/NDLRGEN007/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN007/#code-with-error","title":"Code with Error","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\npublic interface IHandler&lt;T&gt; { void Handle(T message); }\n\n// NDLRGEN007: Class 'LoggingDecorator' must be an open generic class with 1 type parameter(s)\n[OpenDecoratorFor(typeof(IHandler&lt;&gt;))]\npublic class LoggingDecorator : IHandler&lt;string&gt;\n{\n    private readonly IHandler&lt;string&gt; _inner;\n    public LoggingDecorator(IHandler&lt;string&gt; inner) =&gt; _inner = inner;\n    public void Handle(string message) =&gt; _inner.Handle(message);\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN007/#fixed-code","title":"Fixed Code","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\npublic interface IHandler&lt;T&gt; { void Handle(T message); }\n\n// \u2705 Decorator is now generic\n[OpenDecoratorFor(typeof(IHandler&lt;&gt;))]\npublic class LoggingDecorator&lt;T&gt; : IHandler&lt;T&gt;\n{\n    private readonly IHandler&lt;T&gt; _inner;\n    public LoggingDecorator(IHandler&lt;T&gt; inner) =&gt; _inner = inner;\n    public void Handle(T message) =&gt; _inner.Handle(message);\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN007/#alternative-approaches","title":"Alternative Approaches","text":"<p>If you want to create a non-generic decorator for a specific closed type:</p> <pre><code>// Use [DecoratorFor&lt;T&gt;] for closed types\n[DecoratorFor&lt;IHandler&lt;string&gt;&gt;]\npublic class StringHandlerDecorator : IHandler&lt;string&gt;\n{\n    private readonly IHandler&lt;string&gt; _inner;\n    public StringHandlerDecorator(IHandler&lt;string&gt; inner) =&gt; _inner = inner;\n    public void Handle(string message) =&gt; _inner.Handle(message);\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN007/#see-also","title":"See Also","text":"<ul> <li>NDLRGEN006 - Type argument must be an open generic interface</li> <li>NDLRGEN008 - Decorator must implement the interface</li> <li>Open Generic Decorators Guide</li> </ul>"},{"location":"analyzers/NDLRGEN008/","title":"NDLRGEN008: [OpenDecoratorFor] decorator must implement the interface","text":""},{"location":"analyzers/NDLRGEN008/#cause","title":"Cause","text":"<p>A class marked with <code>[OpenDecoratorFor(typeof(IInterface&lt;&gt;))]</code> does not implement the open generic interface specified in the attribute.</p>"},{"location":"analyzers/NDLRGEN008/#rule-description","title":"Rule Description","text":"<p>For the decorator pattern to work, the decorator class must implement the same interface as the services it wraps. This allows the decorator to be substituted for the original service in the DI container.</p> <p>When using <code>[OpenDecoratorFor(typeof(IHandler&lt;&gt;))]</code>, your decorator class must implement <code>IHandler&lt;T&gt;</code>.</p>"},{"location":"analyzers/NDLRGEN008/#how-to-fix","title":"How to Fix","text":"<p>Add the interface implementation to your decorator class:</p> <pre><code>// \u274c Wrong - doesn't implement IHandler&lt;T&gt;\n[OpenDecoratorFor(typeof(IHandler&lt;&gt;))]\npublic class LoggingDecorator&lt;T&gt;\n{\n    // Missing : IHandler&lt;T&gt;\n}\n\n// \u2705 Correct - implements IHandler&lt;T&gt;\n[OpenDecoratorFor(typeof(IHandler&lt;&gt;))]\npublic class LoggingDecorator&lt;T&gt; : IHandler&lt;T&gt;\n{\n    private readonly IHandler&lt;T&gt; _inner;\n    public LoggingDecorator(IHandler&lt;T&gt; inner) =&gt; _inner = inner;\n    public void Handle(T message) =&gt; _inner.Handle(message);\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN008/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN008/#code-with-error","title":"Code with Error","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\npublic interface IHandler&lt;T&gt; { void Handle(T message); }\n\n// NDLRGEN008: Class 'LoggingDecorator' has [OpenDecoratorFor(IHandler&lt;&gt;)] \n//             but does not implement 'IHandler&lt;&gt;'\n[OpenDecoratorFor(typeof(IHandler&lt;&gt;))]\npublic class LoggingDecorator&lt;T&gt;\n{\n    private readonly IHandler&lt;T&gt; _inner;\n\n    public LoggingDecorator(IHandler&lt;T&gt; inner) =&gt; _inner = inner;\n\n    public void Handle(T message)\n    {\n        Console.WriteLine(\"Logging...\");\n        _inner.Handle(message);\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN008/#fixed-code","title":"Fixed Code","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\npublic interface IHandler&lt;T&gt; { void Handle(T message); }\n\n// \u2705 Now implements IHandler&lt;T&gt;\n[OpenDecoratorFor(typeof(IHandler&lt;&gt;))]\npublic class LoggingDecorator&lt;T&gt; : IHandler&lt;T&gt;  // Added interface\n{\n    private readonly IHandler&lt;T&gt; _inner;\n\n    public LoggingDecorator(IHandler&lt;T&gt; inner) =&gt; _inner = inner;\n\n    public void Handle(T message)\n    {\n        Console.WriteLine(\"Logging...\");\n        _inner.Handle(message);\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN008/#why-this-matters","title":"Why This Matters","text":"<p>The decorator pattern relies on polymorphism - the decorator must be usable wherever the original interface is expected:</p> <pre><code>IHandler&lt;Order&gt; handler = new OrderHandler();\nIHandler&lt;Order&gt; decorated = new LoggingDecorator&lt;Order&gt;(handler);\n\n// The container resolves IHandler&lt;Order&gt; \u2192 LoggingDecorator&lt;Order&gt;\n// LoggingDecorator&lt;Order&gt; wraps the original OrderHandler\n</code></pre> <p>If the decorator doesn't implement the interface, this substitution is impossible.</p>"},{"location":"analyzers/NDLRGEN008/#see-also","title":"See Also","text":"<ul> <li>NDLRGEN006 - Type argument must be an open generic interface</li> <li>NDLRGEN007 - Decorator class must be an open generic</li> <li>Open Generic Decorators Guide</li> </ul>"},{"location":"analyzers/NDLRGEN014/","title":"NDLRGEN014: Validator type has no validation method","text":""},{"location":"analyzers/NDLRGEN014/#cause","title":"Cause","text":"<p>A type specified in <code>[Options(Validator = typeof(...))]</code> does not have a valid validation method.</p>"},{"location":"analyzers/NDLRGEN014/#rule-description","title":"Rule Description","text":"<p>When you specify a <code>Validator</code> type on the <code>[Options]</code> attribute, that type must have a way to validate the options. The validator must either:</p> <ol> <li>Implement <code>IOptionsValidator&lt;T&gt;</code> (from <code>NexusLabs.Needlr.Generators</code>)</li> <li>Have a <code>Validate(TOptions)</code> method that returns <code>IEnumerable&lt;ValidationError&gt;</code> or <code>IEnumerable&lt;string&gt;</code></li> </ol>"},{"location":"analyzers/NDLRGEN014/#how-to-fix","title":"How to Fix","text":"<p>Add a validation method to your validator type:</p> <pre><code>// \u274c Wrong - no validation method\npublic class MyOptionsValidator\n{\n    // Missing Validate method\n}\n\n// \u2705 Option 1: Implement IOptionsValidator&lt;T&gt;\npublic class MyOptionsValidator : IOptionsValidator&lt;MyOptions&gt;\n{\n    public IEnumerable&lt;ValidationError&gt; Validate(MyOptions options)\n    {\n        if (string.IsNullOrEmpty(options.ApiKey))\n            yield return \"ApiKey is required\";\n    }\n}\n\n// \u2705 Option 2: Add a Validate method with correct signature\npublic class MyOptionsValidator\n{\n    public IEnumerable&lt;string&gt; Validate(MyOptions options)\n    {\n        if (string.IsNullOrEmpty(options.ApiKey))\n            yield return \"ApiKey is required\";\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN014/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN014/#code-with-error","title":"Code with Error","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n[Options(Validator = typeof(StripeOptionsValidator), ValidateOnStart = true)]\npublic class StripeOptions\n{\n    public string ApiKey { get; set; } = \"\";\n}\n\n// NDLRGEN014: Validator type 'StripeOptionsValidator' must have a Validate method\npublic class StripeOptionsValidator\n{\n    // No validation method!\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN014/#fixed-code","title":"Fixed Code","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n[Options(Validator = typeof(StripeOptionsValidator), ValidateOnStart = true)]\npublic class StripeOptions\n{\n    public string ApiKey { get; set; } = \"\";\n}\n\npublic class StripeOptionsValidator : IOptionsValidator&lt;StripeOptions&gt;\n{\n    public IEnumerable&lt;ValidationError&gt; Validate(StripeOptions options)\n    {\n        if (!options.ApiKey.StartsWith(\"sk_\"))\n            yield return \"ApiKey must start with 'sk_'\";\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN014/#valid-validation-method-signatures","title":"Valid Validation Method Signatures","text":"<p>The following signatures are recognized:</p> <pre><code>// Instance method on external validator\nIEnumerable&lt;ValidationError&gt; Validate(TOptions options)\nIEnumerable&lt;string&gt; Validate(TOptions options)\n\n// Static method on external validator\nstatic IEnumerable&lt;ValidationError&gt; Validate(TOptions options)\nstatic IEnumerable&lt;string&gt; Validate(TOptions options)\n</code></pre>"},{"location":"analyzers/NDLRGEN014/#see-also","title":"See Also","text":"<ul> <li>NDLRGEN015 - Validator type mismatch</li> <li>NDLRGEN016 - Validation method not found</li> <li>NDLRGEN017 - Validation method has wrong signature</li> <li>Options Documentation</li> </ul>"},{"location":"analyzers/NDLRGEN015/","title":"NDLRGEN015: Validator type mismatch","text":""},{"location":"analyzers/NDLRGEN015/#cause","title":"Cause","text":"<p>A validator's generic type parameter doesn't match the options type it's applied to.</p>"},{"location":"analyzers/NDLRGEN015/#rule-description","title":"Rule Description","text":"<p>When using <code>[Options(Validator = typeof(SomeValidator))]</code>, the validator must be designed to validate the same type as the options class. If you have <code>IOptionsValidator&lt;DatabaseOptions&gt;</code> but apply it to <code>CacheOptions</code>, this error is raised.</p>"},{"location":"analyzers/NDLRGEN015/#how-to-fix","title":"How to Fix","text":"<p>Ensure the validator is for the correct options type:</p> <pre><code>// \u274c Wrong - validator is for DatabaseOptions, not CacheOptions\n[Options(Validator = typeof(DatabaseOptionsValidator), ValidateOnStart = true)]\npublic class CacheOptions  // Mismatch!\n{\n    public int TimeoutSeconds { get; set; }\n}\n\npublic class DatabaseOptionsValidator : IOptionsValidator&lt;DatabaseOptions&gt;\n{\n    public IEnumerable&lt;ValidationError&gt; Validate(DatabaseOptions options) { ... }\n}\n\n// \u2705 Correct - validator matches options type\n[Options(Validator = typeof(CacheOptionsValidator), ValidateOnStart = true)]\npublic class CacheOptions\n{\n    public int TimeoutSeconds { get; set; }\n}\n\npublic class CacheOptionsValidator : IOptionsValidator&lt;CacheOptions&gt;\n{\n    public IEnumerable&lt;ValidationError&gt; Validate(CacheOptions options) { ... }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN015/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN015/#code-with-error","title":"Code with Error","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n// NDLRGEN015: Validator 'PaymentValidator' validates 'PaymentOptions' \n//             but is applied to options type 'ShippingOptions'\n[Options(Validator = typeof(PaymentValidator), ValidateOnStart = true)]\npublic class ShippingOptions\n{\n    public string Carrier { get; set; } = \"\";\n}\n\npublic class PaymentValidator : IOptionsValidator&lt;PaymentOptions&gt;\n{\n    public IEnumerable&lt;ValidationError&gt; Validate(PaymentOptions options)\n    {\n        // This validates PaymentOptions, not ShippingOptions!\n        yield break;\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN015/#fixed-code","title":"Fixed Code","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n[Options(Validator = typeof(ShippingValidator), ValidateOnStart = true)]\npublic class ShippingOptions\n{\n    public string Carrier { get; set; } = \"\";\n}\n\n// \u2705 Validator now matches the options type\npublic class ShippingValidator : IOptionsValidator&lt;ShippingOptions&gt;\n{\n    public IEnumerable&lt;ValidationError&gt; Validate(ShippingOptions options)\n    {\n        if (string.IsNullOrEmpty(options.Carrier))\n            yield return \"Carrier is required\";\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN015/#common-causes","title":"Common Causes","text":"<ol> <li>Copy-paste error - Copied validation setup from another options class</li> <li>Refactoring - Renamed options class but forgot to update validator</li> <li>Wrong validator - Selected wrong validator from IntelliSense</li> </ol>"},{"location":"analyzers/NDLRGEN015/#see-also","title":"See Also","text":"<ul> <li>NDLRGEN014 - Validator type has no validation method</li> <li>NDLRGEN016 - Validation method not found</li> <li>Options Documentation</li> </ul>"},{"location":"analyzers/NDLRGEN016/","title":"NDLRGEN016: Validation method not found","text":""},{"location":"analyzers/NDLRGEN016/#cause","title":"Cause","text":"<p>The <code>ValidateMethod</code> specified in <code>[Options]</code> does not exist on the target type.</p>"},{"location":"analyzers/NDLRGEN016/#rule-description","title":"Rule Description","text":"<p>When you use <code>[Options(ValidateMethod = \"MethodName\")]</code>, the generator looks for a method with that name on: 1. The options class itself (if no <code>Validator</code> is specified) 2. The validator class (if <code>Validator</code> is specified)</p> <p>If the method doesn't exist, this error is raised.</p>"},{"location":"analyzers/NDLRGEN016/#how-to-fix","title":"How to Fix","text":"<p>Add the method with the correct name:</p> <pre><code>// \u274c Wrong - method name doesn't match\n[Options(ValidateMethod = \"ValidateSettings\", ValidateOnStart = true)]\npublic class AppSettings\n{\n    public string Name { get; set; } = \"\";\n\n    // Method is named \"Validate\", not \"ValidateSettings\"\n    public IEnumerable&lt;ValidationError&gt; Validate() { ... }\n}\n\n// \u2705 Correct - method name matches\n[Options(ValidateMethod = \"ValidateSettings\", ValidateOnStart = true)]\npublic class AppSettings\n{\n    public string Name { get; set; } = \"\";\n\n    public IEnumerable&lt;ValidationError&gt; ValidateSettings()\n    {\n        if (string.IsNullOrEmpty(Name))\n            yield return \"Name is required\";\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN016/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN016/#code-with-error","title":"Code with Error","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n// NDLRGEN016: Method 'CheckValidity' not found on type 'DatabaseOptions'\n[Options(ValidateMethod = \"CheckValidity\", ValidateOnStart = true)]\npublic class DatabaseOptions\n{\n    public string ConnectionString { get; set; } = \"\";\n\n    // No method named \"CheckValidity\" exists!\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN016/#fixed-code","title":"Fixed Code","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n[Options(ValidateMethod = \"CheckValidity\", ValidateOnStart = true)]\npublic class DatabaseOptions\n{\n    public string ConnectionString { get; set; } = \"\";\n\n    // \u2705 Added the method with matching name\n    public IEnumerable&lt;ValidationError&gt; CheckValidity()\n    {\n        if (string.IsNullOrEmpty(ConnectionString))\n            yield return \"ConnectionString is required\";\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN016/#using-convention-based-naming","title":"Using Convention-Based Naming","text":"<p>If you name your method <code>Validate</code>, you don't need to specify <code>ValidateMethod</code>:</p> <pre><code>// No need for ValidateMethod - \"Validate\" is discovered by convention\n[Options(ValidateOnStart = true)]\npublic class CacheOptions\n{\n    public int TimeoutSeconds { get; set; }\n\n    // Convention: method named \"Validate\" is auto-discovered\n    public IEnumerable&lt;ValidationError&gt; Validate()\n    {\n        if (TimeoutSeconds &lt;= 0)\n            yield return \"TimeoutSeconds must be positive\";\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN016/#see-also","title":"See Also","text":"<ul> <li>NDLRGEN014 - Validator type has no validation method</li> <li>NDLRGEN017 - Validation method has wrong signature</li> <li>Options Documentation</li> </ul>"},{"location":"analyzers/NDLRGEN017/","title":"NDLRGEN017: Validation method has wrong signature","text":""},{"location":"analyzers/NDLRGEN017/#cause","title":"Cause","text":"<p>A validation method exists but has an incorrect signature.</p>"},{"location":"analyzers/NDLRGEN017/#rule-description","title":"Rule Description","text":"<p>Validation methods must follow specific signatures to be recognized by the generator:</p> <p>For methods on the options class itself: <pre><code>IEnumerable&lt;ValidationError&gt; Validate()\nIEnumerable&lt;string&gt; Validate()\n</code></pre></p> <p>For methods on an external validator: <pre><code>IEnumerable&lt;ValidationError&gt; Validate(TOptions options)\nIEnumerable&lt;string&gt; Validate(TOptions options)\n</code></pre></p> <p>If your method doesn't match one of these patterns, this error is raised.</p>"},{"location":"analyzers/NDLRGEN017/#how-to-fix","title":"How to Fix","text":"<p>Correct the method signature:</p> <pre><code>// \u274c Wrong - returns void instead of IEnumerable\n[Options(ValidateOnStart = true)]\npublic class ApiOptions\n{\n    public string Key { get; set; } = \"\";\n\n    public void Validate()  // Wrong return type!\n    {\n        if (string.IsNullOrEmpty(Key))\n            throw new Exception(\"Key required\");\n    }\n}\n\n// \u2705 Correct - returns IEnumerable&lt;ValidationError&gt;\n[Options(ValidateOnStart = true)]\npublic class ApiOptions\n{\n    public string Key { get; set; } = \"\";\n\n    public IEnumerable&lt;ValidationError&gt; Validate()\n    {\n        if (string.IsNullOrEmpty(Key))\n            yield return \"Key is required\";\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN017/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN017/#code-with-error","title":"Code with Error","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n// NDLRGEN017: Method 'Validate' on type 'EmailOptions' has wrong signature\n[Options(ValidateOnStart = true)]\npublic class EmailOptions\n{\n    public string SmtpHost { get; set; } = \"\";\n\n    // Wrong: takes a parameter (should be parameterless for instance methods)\n    public IEnumerable&lt;string&gt; Validate(bool strict)\n    {\n        if (string.IsNullOrEmpty(SmtpHost))\n            yield return \"SmtpHost required\";\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN017/#fixed-code","title":"Fixed Code","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n[Options(ValidateOnStart = true)]\npublic class EmailOptions\n{\n    public string SmtpHost { get; set; } = \"\";\n\n    // \u2705 Correct: no parameters for instance method on options class\n    public IEnumerable&lt;string&gt; Validate()\n    {\n        if (string.IsNullOrEmpty(SmtpHost))\n            yield return \"SmtpHost required\";\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN017/#valid-signatures","title":"Valid Signatures","text":""},{"location":"analyzers/NDLRGEN017/#on-options-class-instance-method-no-parameters","title":"On Options Class (instance method, no parameters)","text":"<pre><code>public IEnumerable&lt;ValidationError&gt; Validate()\npublic IEnumerable&lt;string&gt; Validate()\n</code></pre>"},{"location":"analyzers/NDLRGEN017/#on-external-validator-takes-options-as-parameter","title":"On External Validator (takes options as parameter)","text":"<pre><code>// Instance method\npublic IEnumerable&lt;ValidationError&gt; Validate(TOptions options)\npublic IEnumerable&lt;string&gt; Validate(TOptions options)\n\n// Static method\npublic static IEnumerable&lt;ValidationError&gt; Validate(TOptions options)\npublic static IEnumerable&lt;string&gt; Validate(TOptions options)\n</code></pre>"},{"location":"analyzers/NDLRGEN017/#common-mistakes","title":"Common Mistakes","text":"Wrong Signature Problem Correct Signature <code>void Validate()</code> Wrong return type <code>IEnumerable&lt;ValidationError&gt; Validate()</code> <code>bool Validate()</code> Wrong return type <code>IEnumerable&lt;string&gt; Validate()</code> <code>List&lt;string&gt; Validate()</code> Must be IEnumerable <code>IEnumerable&lt;string&gt; Validate()</code> <code>IEnumerable&lt;ValidationError&gt; Validate(bool flag)</code> Extra parameter <code>IEnumerable&lt;ValidationError&gt; Validate()</code>"},{"location":"analyzers/NDLRGEN017/#see-also","title":"See Also","text":"<ul> <li>NDLRGEN014 - Validator type has no validation method</li> <li>NDLRGEN016 - Validation method not found</li> <li>Options Documentation</li> </ul>"},{"location":"analyzers/NDLRGEN018/","title":"NDLRGEN018: Validator won't run","text":""},{"location":"analyzers/NDLRGEN018/#cause","title":"Cause","text":"<p>A <code>Validator</code> is specified but <code>ValidateOnStart</code> is <code>false</code>, so the validator will never be invoked.</p>"},{"location":"analyzers/NDLRGEN018/#rule-description","title":"Rule Description","text":"<p>When you specify <code>[Options(Validator = typeof(...))]</code> but don't set <code>ValidateOnStart = true</code>, the validator is registered but never actually called. This is likely a configuration mistake.</p> <p>This is a warning because the code is technically valid, but probably not what you intended.</p>"},{"location":"analyzers/NDLRGEN018/#how-to-fix","title":"How to Fix","text":"<p>Either enable validation or remove the validator:</p> <pre><code>// \u26a0\ufe0f Warning - validator specified but won't run\n[Options(Validator = typeof(MyValidator))]  // ValidateOnStart defaults to false\npublic class MyOptions { }\n\n// \u2705 Option 1: Enable ValidateOnStart\n[Options(Validator = typeof(MyValidator), ValidateOnStart = true)]\npublic class MyOptions { }\n\n// \u2705 Option 2: Remove the unused Validator\n[Options]\npublic class MyOptions { }\n</code></pre>"},{"location":"analyzers/NDLRGEN018/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN018/#code-with-warning","title":"Code with Warning","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n// NDLRGEN018: Validator 'PaymentOptionsValidator' will not run \n//             because ValidateOnStart is false\n[Options(Validator = typeof(PaymentOptionsValidator))]\npublic class PaymentOptions\n{\n    public string MerchantId { get; set; } = \"\";\n}\n\npublic class PaymentOptionsValidator : IOptionsValidator&lt;PaymentOptions&gt;\n{\n    public IEnumerable&lt;ValidationError&gt; Validate(PaymentOptions options)\n    {\n        if (string.IsNullOrEmpty(options.MerchantId))\n            yield return \"MerchantId is required\";\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN018/#fixed-code","title":"Fixed Code","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n// \u2705 ValidateOnStart = true enables the validator\n[Options(Validator = typeof(PaymentOptionsValidator), ValidateOnStart = true)]\npublic class PaymentOptions\n{\n    public string MerchantId { get; set; } = \"\";\n}\n\npublic class PaymentOptionsValidator : IOptionsValidator&lt;PaymentOptions&gt;\n{\n    public IEnumerable&lt;ValidationError&gt; Validate(PaymentOptions options)\n    {\n        if (string.IsNullOrEmpty(options.MerchantId))\n            yield return \"MerchantId is required\";\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN018/#why-this-warning-exists","title":"Why This Warning Exists","text":"<p>Specifying a validator without enabling validation is almost always a mistake:</p> <ul> <li>You wrote validation logic that will never execute</li> <li>Your application won't fail fast on invalid configuration</li> <li>Future maintainers may assume validation is happening</li> </ul>"},{"location":"analyzers/NDLRGEN018/#suppressing-the-warning","title":"Suppressing the Warning","text":"<p>If you intentionally want to specify a validator without running it at startup (e.g., for manual validation later), suppress the warning:</p> <pre><code>#pragma warning disable NDLRGEN018\n[Options(Validator = typeof(MyValidator))]\npublic class MyOptions { }\n#pragma warning restore NDLRGEN018\n</code></pre> <p>Or in <code>.editorconfig</code>:</p> <pre><code>[*.cs]\ndotnet_diagnostic.NDLRGEN018.severity = none\n</code></pre>"},{"location":"analyzers/NDLRGEN018/#see-also","title":"See Also","text":"<ul> <li>NDLRGEN019 - Validation method won't run</li> <li>NDLRGEN014 - Validator type has no validation method</li> <li>Options Documentation</li> </ul>"},{"location":"analyzers/NDLRGEN019/","title":"NDLRGEN019: Validation method won't run","text":""},{"location":"analyzers/NDLRGEN019/#cause","title":"Cause","text":"<p>A <code>ValidateMethod</code> is specified but <code>ValidateOnStart</code> is <code>false</code>, so the validation method will never be invoked.</p>"},{"location":"analyzers/NDLRGEN019/#rule-description","title":"Rule Description","text":"<p>When you specify <code>[Options(ValidateMethod = \"...\")]</code> but don't set <code>ValidateOnStart = true</code>, the validation method exists but is never called. This is likely a configuration mistake.</p> <p>This is a warning because the code is technically valid, but probably not what you intended.</p>"},{"location":"analyzers/NDLRGEN019/#how-to-fix","title":"How to Fix","text":"<p>Either enable validation or remove the ValidateMethod:</p> <pre><code>// \u26a0\ufe0f Warning - method specified but won't run\n[Options(ValidateMethod = \"CheckConfig\")]  // ValidateOnStart defaults to false\npublic class MyOptions\n{\n    public IEnumerable&lt;ValidationError&gt; CheckConfig() { ... }\n}\n\n// \u2705 Option 1: Enable ValidateOnStart\n[Options(ValidateMethod = \"CheckConfig\", ValidateOnStart = true)]\npublic class MyOptions\n{\n    public IEnumerable&lt;ValidationError&gt; CheckConfig() { ... }\n}\n\n// \u2705 Option 2: Remove the unused ValidateMethod\n[Options]\npublic class MyOptions\n{\n    // Method can stay but won't be auto-invoked\n    public IEnumerable&lt;ValidationError&gt; CheckConfig() { ... }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN019/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN019/#code-with-warning","title":"Code with Warning","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n// NDLRGEN019: ValidateMethod 'CheckSettings' will not run \n//             because ValidateOnStart is false\n[Options(ValidateMethod = \"CheckSettings\")]\npublic class FeatureFlags\n{\n    public bool EnableBeta { get; set; }\n    public int MaxUsers { get; set; }\n\n    public IEnumerable&lt;ValidationError&gt; CheckSettings()\n    {\n        if (EnableBeta &amp;&amp; MaxUsers &gt; 100)\n            yield return \"Beta features limited to 100 users\";\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN019/#fixed-code","title":"Fixed Code","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n// \u2705 ValidateOnStart = true enables the validation method\n[Options(ValidateMethod = \"CheckSettings\", ValidateOnStart = true)]\npublic class FeatureFlags\n{\n    public bool EnableBeta { get; set; }\n    public int MaxUsers { get; set; }\n\n    public IEnumerable&lt;ValidationError&gt; CheckSettings()\n    {\n        if (EnableBeta &amp;&amp; MaxUsers &gt; 100)\n            yield return \"Beta features limited to 100 users\";\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN019/#using-convention-based-naming","title":"Using Convention-Based Naming","text":"<p>If you name your method <code>Validate</code> and set <code>ValidateOnStart = true</code>, you don't need to specify <code>ValidateMethod</code>:</p> <pre><code>// Convention: \"Validate\" method is auto-discovered when ValidateOnStart = true\n[Options(ValidateOnStart = true)]\npublic class CacheOptions\n{\n    public int TimeoutSeconds { get; set; }\n\n    public IEnumerable&lt;ValidationError&gt; Validate()\n    {\n        if (TimeoutSeconds &lt;= 0)\n            yield return \"TimeoutSeconds must be positive\";\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN019/#suppressing-the-warning","title":"Suppressing the Warning","text":"<p>If you intentionally want to specify a validation method without running it at startup:</p> <pre><code>#pragma warning disable NDLRGEN019\n[Options(ValidateMethod = \"CheckConfig\")]\npublic class MyOptions { }\n#pragma warning restore NDLRGEN019\n</code></pre>"},{"location":"analyzers/NDLRGEN019/#see-also","title":"See Also","text":"<ul> <li>NDLRGEN018 - Validator won't run</li> <li>NDLRGEN016 - Validation method not found</li> <li>Options Documentation</li> </ul>"},{"location":"analyzers/NDLRGEN020/","title":"NDLRGEN020: [Options] is not compatible with AOT","text":""},{"location":"analyzers/NDLRGEN020/#cause","title":"Cause","text":"<p>A class has the <code>[Options]</code> attribute but is in a project with <code>PublishAot=true</code> or <code>IsAotCompatible=true</code>.</p>"},{"location":"analyzers/NDLRGEN020/#rule-description","title":"Rule Description","text":"<p>The <code>[Options]</code> attribute generates code that calls Microsoft's configuration binding APIs:</p> <ul> <li><code>Configure&lt;T&gt;()</code></li> <li><code>BindConfiguration()</code></li> <li><code>ValidateDataAnnotations()</code></li> </ul> <p>These APIs use reflection to bind configuration values to properties at runtime. They are marked with <code>[RequiresDynamicCode]</code> and <code>[RequiresUnreferencedCode]</code>, making them incompatible with:</p> <ul> <li>Native AOT - No JIT compiler to generate code at runtime</li> <li>Trimming - Reflection targets may be trimmed away</li> </ul>"},{"location":"analyzers/NDLRGEN020/#how-to-fix","title":"How to Fix","text":"<p>You have two options:</p>"},{"location":"analyzers/NDLRGEN020/#option-1-remove-options-from-aot-projects","title":"Option 1: Remove [Options] from AOT Projects","text":"<p>If you're building a plugin or library that must be AOT-compatible, don't use <code>[Options]</code>:</p> <pre><code>// \u274c Won't work in AOT\n[Options]\npublic class CacheSettings\n{\n    public int TimeoutSeconds { get; set; }\n}\n\n// \u2705 Manual configuration binding\npublic class CacheSettings\n{\n    public int TimeoutSeconds { get; set; }\n\n    public static CacheSettings FromConfiguration(IConfiguration config)\n    {\n        return new CacheSettings\n        {\n            TimeoutSeconds = config.GetValue&lt;int&gt;(\"Cache:TimeoutSeconds\")\n        };\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN020/#option-2-disable-aot-for-the-project","title":"Option 2: Disable AOT for the Project","text":"<p>If you need <code>[Options]</code> functionality, disable AOT:</p> <pre><code>&lt;PropertyGroup&gt;\n  &lt;!-- Remove or set to false --&gt;\n  &lt;PublishAot&gt;false&lt;/PublishAot&gt;\n  &lt;IsAotCompatible&gt;false&lt;/IsAotCompatible&gt;\n&lt;/PropertyGroup&gt;\n</code></pre>"},{"location":"analyzers/NDLRGEN020/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN020/#code-with-error","title":"Code with Error","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n// In a project with &lt;PublishAot&gt;true&lt;/PublishAot&gt;\n\n// NDLRGEN020: Type 'DatabaseOptions' has [Options] attribute but is in an \n//             AOT-enabled project\n[Options]\npublic class DatabaseOptions\n{\n    public string ConnectionString { get; set; } = \"\";\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN020/#fixed-code-manual-binding","title":"Fixed Code (Manual Binding)","text":"<pre><code>// Remove [Options] and bind manually\npublic class DatabaseOptions\n{\n    public string ConnectionString { get; set; } = \"\";\n}\n\n// In your startup code:\npublic static class ServiceRegistration\n{\n    public static void RegisterOptions(IServiceCollection services, IConfiguration config)\n    {\n        var dbOptions = new DatabaseOptions\n        {\n            ConnectionString = config[\"Database:ConnectionString\"] ?? \"\"\n        };\n        services.AddSingleton(Microsoft.Extensions.Options.Options.Create(dbOptions));\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN020/#why-this-limitation-exists","title":"Why This Limitation Exists","text":"<p>Microsoft's Configuration Binding Generator (<code>&lt;EnableConfigurationBindingGenerator&gt;</code>) uses C# interceptors to replace reflection-based calls with compile-time generated code. However:</p> <ol> <li>Interceptors can only intercept calls in hand-written source code</li> <li>Needlr's <code>[Options]</code> generates the <code>Configure&lt;T&gt;()</code> calls in <code>TypeRegistry.g.cs</code></li> <li>One source generator cannot intercept another's output</li> </ol> <p>Therefore, the reflection-based calls cannot be replaced with AOT-safe alternatives.</p>"},{"location":"analyzers/NDLRGEN020/#future-considerations","title":"Future Considerations","text":"<p>A future version of Needlr may generate AOT-compatible binding code directly, similar to Microsoft's approach. Until then, manual configuration binding is required for AOT projects.</p>"},{"location":"analyzers/NDLRGEN020/#affected-project-properties","title":"Affected Project Properties","text":"<p>This error is triggered when either of these MSBuild properties is <code>true</code>:</p> Property Purpose <code>PublishAot</code> Enables Native AOT publishing <code>IsAotCompatible</code> Marks a library as AOT-compatible"},{"location":"analyzers/NDLRGEN020/#see-also","title":"See Also","text":"<ul> <li>Microsoft Docs: Native AOT Deployment</li> <li>Microsoft Docs: Configuration Binding Generator</li> <li>Options Documentation</li> </ul>"},{"location":"analyzers/NDLRGEN021/","title":"NDLRGEN021: Positional record must be partial for [Options]","text":""},{"location":"analyzers/NDLRGEN021/#cause","title":"Cause","text":"<p>A positional record (a record with primary constructor parameters) has the <code>[Options]</code> attribute but is not declared as <code>partial</code>.</p>"},{"location":"analyzers/NDLRGEN021/#rule-description","title":"Rule Description","text":"<p>Positional records like <code>record Foo(string Bar, int Baz)</code> do not have parameterless constructors. Microsoft's configuration binder uses <code>Activator.CreateInstance()</code> to instantiate options types, which requires a parameterless constructor.</p> <p>When a positional record is declared as <code>partial</code>, Needlr's source generator emits a parameterless constructor that chains to the primary constructor with default values. This enables configuration binding to work.</p> <p>Non-partial records cannot be extended by source generators, so configuration binding will fail at runtime with a <code>MissingMethodException</code>.</p>"},{"location":"analyzers/NDLRGEN021/#how-to-fix","title":"How to Fix","text":"<p>Add the <code>partial</code> modifier to the positional record:</p> <pre><code>// \u274c Before: Will fail at runtime\n[Options(\"Database\")]\npublic record DatabaseConfig(string Host, int Port);\n\n// \u2705 After: Generator creates parameterless constructor\n[Options(\"Database\")]\npublic partial record DatabaseConfig(string Host, int Port);\n</code></pre> <p>Alternatively, use a record with init-only properties instead of positional parameters:</p> <pre><code>// \u2705 Alternative: Init-only properties have parameterless constructor\n[Options(\"Database\")]\npublic record DatabaseConfig\n{\n    public string Host { get; init; } = \"\";\n    public int Port { get; init; } = 5432;\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN021/#generated-code","title":"Generated Code","text":"<p>For a partial positional record, Needlr generates:</p> <pre><code>// User code:\n[Options(\"Redis\")]\npublic partial record RedisConfig(string Host, int Port);\n\n// Generated code (OptionsConstructors.g.cs):\npublic partial record RedisConfig\n{\n    public RedisConfig() : this(string.Empty, default) { }\n}\n</code></pre> <p>The generated constructor uses:</p> <ul> <li><code>string.Empty</code> for string parameters</li> <li><code>default</code> for value types (0 for int, false for bool, etc.)</li> <li><code>default!</code> for other reference types</li> </ul>"},{"location":"analyzers/NDLRGEN021/#when-to-suppress","title":"When to Suppress","text":"<p>Suppress this warning only if you are manually providing a parameterless constructor or if you are not using the record with configuration binding:</p> <pre><code>#pragma warning disable NDLRGEN021\n[Options(\"Custom\")]\npublic record CustomConfig(string Value)\n{\n    public CustomConfig() : this(\"default-value\") { }\n}\n#pragma warning restore NDLRGEN021\n</code></pre>"},{"location":"analyzers/NDLRGEN021/#see-also","title":"See Also","text":"<ul> <li>Options Binding</li> <li>NDLRGEN020 - Options not compatible with AOT</li> </ul>"},{"location":"analyzers/NDLRGEN022/","title":"NDLRGEN022: Disposable captive dependency detected","text":"Property Value Diagnostic ID NDLRGEN022 Severity Error Category NexusLabs.Needlr.Generators Default Enabled"},{"location":"analyzers/NDLRGEN022/#summary","title":"Summary","text":"<p>A longer-lived service captures a shorter-lived service that implements <code>IDisposable</code> or <code>IAsyncDisposable</code>. This is a \"captive dependency\" anti-pattern that can cause <code>ObjectDisposedException</code> at runtime.</p>"},{"location":"analyzers/NDLRGEN022/#description","title":"Description","text":"<p>When a Singleton or Scoped service has a constructor dependency on a service with a shorter lifetime (Scoped or Transient respectively) that implements <code>IDisposable</code>, the disposable will be disposed when its scope ends while the consuming service continues to hold a reference.</p> <p>This diagnostic uses Needlr's inferred lifetimes from convention-based discovery, not just explicit attributes. This means it works for the majority of Needlr users who rely on automatic lifetime inference.</p>"},{"location":"analyzers/NDLRGEN022/#lifetime-violations-detected","title":"Lifetime Violations Detected","text":"Consumer Lifetime Dependency Lifetime Violation? Singleton Scoped \u2705 Yes Singleton Transient \u2705 Yes Scoped Transient \u2705 Yes Singleton Singleton \u274c No Scoped Scoped \u274c No Scoped Singleton \u274c No Transient Any \u274c No"},{"location":"analyzers/NDLRGEN022/#related-diagnostic","title":"Related Diagnostic","text":"<p>NDLRCOR012 is a standalone Roslyn analyzer that performs the same check but only when both types have explicit lifetime attributes (<code>[Singleton]</code>, <code>[Scoped]</code>, <code>[Transient]</code>). NDLRGEN022 is more comprehensive because it uses Needlr's inferred lifetimes.</p>"},{"location":"analyzers/NDLRGEN022/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN022/#violation","title":"\u274c Violation","text":"<pre><code>[Scoped]\npublic class DbContext : IDisposable\n{\n    public void Dispose() { }\n}\n\n[Singleton]\npublic class CacheService\n{\n    private readonly DbContext _context;\n\n    // NDLRGEN022: CacheService (Singleton) depends on DbContext (Scoped)\n    // which implements IDisposable\n    public CacheService(DbContext context) =&gt; _context = context;\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN022/#fix-use-factory-pattern","title":"\u2705 Fix: Use Factory Pattern","text":"<pre><code>[Singleton]\npublic class CacheService\n{\n    private readonly Func&lt;DbContext&gt; _contextFactory;\n\n    public CacheService(Func&lt;DbContext&gt; contextFactory) =&gt; _contextFactory = contextFactory;\n\n    public void DoWork()\n    {\n        using var context = _contextFactory();\n        // Use context within its proper scope\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN022/#fix-use-iservicescopefactory","title":"\u2705 Fix: Use IServiceScopeFactory","text":"<pre><code>[Singleton]\npublic class CacheService\n{\n    private readonly IServiceScopeFactory _scopeFactory;\n\n    public CacheService(IServiceScopeFactory scopeFactory) =&gt; _scopeFactory = scopeFactory;\n\n    public void DoWork()\n    {\n        using var scope = _scopeFactory.CreateScope();\n        var context = scope.ServiceProvider.GetRequiredService&lt;DbContext&gt;();\n        // Use context within its proper scope\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN022/#safe-patterns-not-flagged","title":"Safe Patterns (Not Flagged)","text":"<p>The diagnostic recognizes these factory patterns and does not flag them:</p> <ul> <li><code>Func&lt;T&gt;</code> - Creates new instances on demand</li> <li><code>Lazy&lt;T&gt;</code> - Deferred creation</li> <li><code>IServiceScopeFactory</code> - Creates new scopes</li> <li><code>IServiceProvider</code> - Dynamic service resolution</li> </ul>"},{"location":"analyzers/NDLRGEN022/#how-lifetimes-are-determined","title":"How Lifetimes Are Determined","text":"<p>NDLRGEN022 uses Needlr's convention-based lifetime inference:</p> <ol> <li>Explicit attributes (<code>[Singleton]</code>, <code>[Scoped]</code>, <code>[Transient]</code>) take precedence</li> <li>Hosted services (<code>BackgroundService</code>, <code>IHostedService</code>) are always Singleton</li> <li>Injectable types with parameterless or all-injectable constructors default to Singleton</li> </ol> <p>For detailed information about lifetime inference, see the Needlr documentation.</p>"},{"location":"analyzers/NDLRGEN022/#suppression","title":"Suppression","text":"<p>To suppress this diagnostic:</p> <pre><code>#pragma warning disable NDLRGEN022\n[Singleton]\npublic class KnownCaptiveDependency\n{\n    public KnownCaptiveDependency(ScopedDisposable dep) { }\n}\n#pragma warning restore NDLRGEN022\n</code></pre>"},{"location":"analyzers/NDLRGEN022/#see-also","title":"See Also","text":"<ul> <li>NDLRCOR012 - Standalone analyzer for explicit attributes only</li> <li>Captive Dependency anti-pattern</li> </ul>"},{"location":"analyzers/NDLRGEN031/","title":"NDLRGEN031: Provider class requires partial modifier","text":""},{"location":"analyzers/NDLRGEN031/#diagnostic-info","title":"Diagnostic Info","text":"Property Value ID NDLRGEN031 Category NexusLabs.Needlr.Generators Severity Error Enabled Yes"},{"location":"analyzers/NDLRGEN031/#description","title":"Description","text":"<p>This error is raised when a class has the <code>[Provider]</code> attribute but is not declared with the <code>partial</code> modifier. The generator needs to add an interface implementation and constructor to the class, which requires it to be partial.</p>"},{"location":"analyzers/NDLRGEN031/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN031/#code-that-triggers-the-error","title":"Code that triggers the error","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n// \u274c NDLRGEN031: Class needs partial modifier\n[Provider(typeof(IOrderRepository))]\npublic class OrderProvider { }\n</code></pre>"},{"location":"analyzers/NDLRGEN031/#how-to-fix","title":"How to fix","text":"<p>Add the <code>partial</code> modifier to the class:</p> <pre><code>using NexusLabs.Needlr.Generators;\n\n// \u2705 Correct: Class is partial\n[Provider(typeof(IOrderRepository))]\npublic partial class OrderProvider { }\n</code></pre>"},{"location":"analyzers/NDLRGEN031/#why-this-matters","title":"Why This Matters","text":"<p>When using <code>[Provider]</code> on a class (shorthand mode), the source generator creates:</p> <ol> <li>A generated interface (<code>IOrderProvider</code>)</li> <li>A partial class implementation with constructor and properties</li> </ol> <p>Without the <code>partial</code> modifier, the compiler cannot merge the generated code with your class definition.</p>"},{"location":"analyzers/NDLRGEN031/#alternative-interface-mode","title":"Alternative: Interface Mode","text":"<p>If you don't want a partial class, use interface mode instead:</p> <pre><code>[Provider]\npublic interface IOrderProvider\n{\n    IOrderRepository Repository { get; }\n}\n</code></pre> <p>The generator will create the implementation class for you in the <code>{AssemblyName}.Generated</code> namespace.</p>"},{"location":"analyzers/NDLRGEN031/#see-also","title":"See Also","text":"<ul> <li>Providers</li> <li>NDLRGEN032 - Invalid interface member</li> </ul>"},{"location":"analyzers/NDLRGEN032/","title":"NDLRGEN032: Provider interface has invalid member","text":""},{"location":"analyzers/NDLRGEN032/#diagnostic-info","title":"Diagnostic Info","text":"Property Value ID NDLRGEN032 Category NexusLabs.Needlr.Generators Severity Error Enabled Yes"},{"location":"analyzers/NDLRGEN032/#description","title":"Description","text":"<p>This error is raised when a <code>[Provider]</code> interface contains members other than get-only properties. Provider interfaces should only have read-only properties representing the services to be resolved.</p>"},{"location":"analyzers/NDLRGEN032/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN032/#code-that-triggers-the-error","title":"Code that triggers the error","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n[Provider]\npublic interface IMyProvider\n{\n    IService Service { get; }\n\n    // \u274c NDLRGEN032: Settable property not allowed\n    ILogger Logger { get; set; }\n\n    // \u274c NDLRGEN032: Methods not allowed\n    void DoSomething();\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN032/#how-to-fix","title":"How to fix","text":"<p>Remove the invalid members or convert them to get-only properties:</p> <pre><code>using NexusLabs.Needlr.Generators;\n\n// \u2705 Correct: Only get-only properties\n[Provider]\npublic interface IMyProvider\n{\n    IService Service { get; }\n    ILogger Logger { get; }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN032/#why-this-matters","title":"Why This Matters","text":"<p>Provider interfaces are designed to be simple service containers. The generator:</p> <ol> <li>Creates a constructor that accepts all property types</li> <li>Assigns each service to its corresponding property</li> </ol> <p>Methods and settable properties don't fit this model and would require manual implementation.</p>"},{"location":"analyzers/NDLRGEN032/#supported-member-types","title":"Supported Member Types","text":"Member Type Supported Get-only property (<code>{ get; }</code>) \u2705 Yes Settable property (<code>{ get; set; }</code>) \u274c No Init-only property (<code>{ get; init; }</code>) \u274c No Methods \u274c No Events \u274c No Indexers \u274c No"},{"location":"analyzers/NDLRGEN032/#alternative-use-shorthand-mode","title":"Alternative: Use Shorthand Mode","text":"<p>If you need more flexibility, consider using the shorthand class mode where you control the class definition:</p> <pre><code>[Provider(typeof(IService), typeof(ILogger))]\npublic partial class MyProvider\n{\n    // You can add your own methods here\n    public void DoSomething()\n    {\n        Service.Process();\n        Logger.LogInformation(\"Done\");\n    }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN032/#see-also","title":"See Also","text":"<ul> <li>Providers</li> <li>NDLRGEN031 - Missing partial modifier</li> <li>NDLRGEN033 - Concrete type warning</li> </ul>"},{"location":"analyzers/NDLRGEN033/","title":"NDLRGEN033: Provider property uses concrete type","text":""},{"location":"analyzers/NDLRGEN033/#diagnostic-info","title":"Diagnostic Info","text":"Property Value ID NDLRGEN033 Category NexusLabs.Needlr.Generators Severity Warning Enabled Yes"},{"location":"analyzers/NDLRGEN033/#description","title":"Description","text":"<p>This warning is raised when a provider property uses a concrete class type instead of an interface. While this works, using interfaces is generally preferred for better testability and flexibility.</p>"},{"location":"analyzers/NDLRGEN033/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN033/#code-that-triggers-the-warning","title":"Code that triggers the warning","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\npublic class OrderRepository { }  // Concrete class\n\n[Provider]\npublic interface IMyProvider\n{\n    // \u26a0\ufe0f NDLRGEN033: Consider using an interface\n    OrderRepository Repository { get; }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN033/#how-to-fix","title":"How to fix","text":"<p>Define an interface for the service:</p> <pre><code>using NexusLabs.Needlr.Generators;\n\npublic interface IOrderRepository { }\npublic class OrderRepository : IOrderRepository { }\n\n// \u2705 Correct: Uses interface type\n[Provider]\npublic interface IMyProvider\n{\n    IOrderRepository Repository { get; }\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN033/#why-this-matters","title":"Why This Matters","text":"<p>Using interfaces instead of concrete types:</p> <ul> <li>Testability: Easy to mock in unit tests</li> <li>Flexibility: Can swap implementations without changing the provider</li> <li>Dependency Inversion: Follows SOLID principles</li> <li>Loose Coupling: Reduces dependencies between components</li> </ul>"},{"location":"analyzers/NDLRGEN033/#when-concrete-types-are-acceptable","title":"When Concrete Types Are Acceptable","text":"<p>This is a warning, not an error. Concrete types are acceptable in some scenarios:</p> <ul> <li>Value objects that have no behavior to mock</li> <li>Sealed utility classes that are lightweight and deterministic</li> <li>Third-party classes that don't implement interfaces</li> </ul> <p>To suppress the warning:</p> <pre><code>#pragma warning disable NDLRGEN033\n[Provider]\npublic interface IMyProvider\n{\n    ConcreteClass MyProperty { get; }\n}\n#pragma warning restore NDLRGEN033\n</code></pre>"},{"location":"analyzers/NDLRGEN033/#exceptions","title":"Exceptions","text":"<p>The warning is not raised for:</p> <ul> <li>Interface types (obviously)</li> <li>Factory types (ending with \"Factory\")</li> <li>Collection types (<code>IEnumerable&lt;T&gt;</code>, etc.)</li> <li>Other providers (nested provider references)</li> </ul>"},{"location":"analyzers/NDLRGEN033/#see-also","title":"See Also","text":"<ul> <li>Providers</li> <li>NDLRGEN031 - Missing partial modifier</li> <li>NDLRGEN032 - Invalid interface member</li> </ul>"},{"location":"analyzers/NDLRGEN034/","title":"NDLRGEN034: Circular provider dependency detected","text":""},{"location":"analyzers/NDLRGEN034/#diagnostic-info","title":"Diagnostic Info","text":"Property Value ID NDLRGEN034 Category NexusLabs.Needlr.Generators Severity Error Enabled Yes"},{"location":"analyzers/NDLRGEN034/#description","title":"Description","text":"<p>This error is raised when providers reference each other in a way that creates a circular dependency. This would cause a stack overflow at runtime when attempting to construct the providers.</p>"},{"location":"analyzers/NDLRGEN034/#example","title":"Example","text":""},{"location":"analyzers/NDLRGEN034/#code-that-triggers-the-error","title":"Code that triggers the error","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n// \u274c NDLRGEN034: Circular dependency detected\n[Provider]\npublic interface IProviderA\n{\n    IProviderB ProviderB { get; }  // References B\n}\n\n[Provider]\npublic interface IProviderB\n{\n    IProviderA ProviderA { get; }  // References A \u2192 Cycle!\n}\n</code></pre>"},{"location":"analyzers/NDLRGEN034/#how-to-fix","title":"How to fix","text":"<p>Break the circular dependency by restructuring your providers:</p> <p>Option 1: Remove one of the references <pre><code>[Provider]\npublic interface IProviderA\n{\n    IServiceFromB Service { get; }  // Reference the service directly, not the provider\n}\n\n[Provider]\npublic interface IProviderB\n{\n    IProviderA ProviderA { get; }\n}\n</code></pre></p> <p>Option 2: Create a third provider for shared services <pre><code>// Shared services used by both\n[Provider]\npublic interface ISharedProvider\n{\n    ISharedService SharedService { get; }\n}\n\n[Provider]\npublic interface IProviderA\n{\n    ISharedProvider Shared { get; }\n    IServiceA ServiceA { get; }\n}\n\n[Provider]\npublic interface IProviderB\n{\n    ISharedProvider Shared { get; }\n    IServiceB ServiceB { get; }\n}\n</code></pre></p> <p>Option 3: Use factory for deferred resolution <pre><code>[Provider]\npublic interface IProviderA\n{\n    Func&lt;IProviderB&gt; ProviderBFactory { get; }  // Lazy resolution breaks the cycle\n}\n</code></pre></p>"},{"location":"analyzers/NDLRGEN034/#why-this-matters","title":"Why This Matters","text":"<p>Circular dependencies in constructor injection cause infinite recursion:</p> <ol> <li>Constructing <code>ProviderA</code> requires <code>ProviderB</code></li> <li>Constructing <code>ProviderB</code> requires <code>ProviderA</code></li> <li>Constructing <code>ProviderA</code> requires <code>ProviderB</code></li> <li>... stack overflow</li> </ol> <p>The analyzer detects these cycles at compile time before they become runtime failures.</p>"},{"location":"analyzers/NDLRGEN034/#detection-scope","title":"Detection Scope","text":"<p>The analyzer detects:</p> <ul> <li>Direct cycles: A \u2192 B \u2192 A</li> <li>Indirect cycles: A \u2192 B \u2192 C \u2192 A</li> </ul>"},{"location":"analyzers/NDLRGEN034/#see-also","title":"See Also","text":"<ul> <li>Providers</li> <li>NDLRGEN031 - Missing partial modifier</li> <li>Factories - Alternative for breaking cycles</li> </ul>"},{"location":"analyzers/NDLRMAF001/","title":"NDLRMAF001: [AgentHandoffsTo] target type is not a declared agent","text":""},{"location":"analyzers/NDLRMAF001/#cause","title":"Cause","text":"<p>A type referenced in <code>[AgentHandoffsTo(typeof(X))]</code> is not decorated with <code>[NeedlrAiAgent]</code>.</p>"},{"location":"analyzers/NDLRMAF001/#rule-description","title":"Rule Description","text":"<p>Every type listed as a handoff target must be a registered Needlr agent. If the target type does not carry <code>[NeedlrAiAgent]</code>, the source generator cannot include it in the generated agent registry, and <code>IWorkflowFactory</code> will not be able to resolve it at runtime \u2014 causing the workflow to fail.</p>"},{"location":"analyzers/NDLRMAF001/#how-to-fix","title":"How to Fix","text":"<p>Add <code>[NeedlrAiAgent]</code> to the target type, or remove it from <code>[AgentHandoffsTo]</code> if the handoff was declared by mistake.</p>"},{"location":"analyzers/NDLRMAF001/#before","title":"Before","text":"<pre><code>[NeedlrAiAgent(Instructions = \"Route the request.\")]\n[AgentHandoffsTo(typeof(SummaryAgent), When = \"Summarization needed\")]\npublic class TriageAgent { }\n\npublic class SummaryAgent { }   // \u2190 missing [NeedlrAiAgent]\n</code></pre>"},{"location":"analyzers/NDLRMAF001/#after","title":"After","text":"<pre><code>[NeedlrAiAgent(Instructions = \"Route the request.\")]\n[AgentHandoffsTo(typeof(SummaryAgent), When = \"Summarization needed\")]\npublic class TriageAgent { }\n\n[NeedlrAiAgent(Instructions = \"You summarize content.\")]\npublic class SummaryAgent { }   // \u2190 registered\n</code></pre>"},{"location":"analyzers/NDLRMAF001/#when-to-suppress","title":"When to Suppress","text":"<p>Only suppress if you are intentionally referencing a type that is managed outside of Needlr's agent registry (for example, a programmatically created agent that does not participate in source generation).</p> <pre><code>#pragma warning disable NDLRMAF001\n[AgentHandoffsTo(typeof(ExternalAgent))]\npublic class TriageAgent { }\n#pragma warning restore NDLRMAF001\n</code></pre>"},{"location":"analyzers/NDLRMAF001/#see-also","title":"See Also","text":"<ul> <li>AI Integrations \u2014 Multi-Agent Orchestration</li> <li>NDLRMAF003 \u2014 source class is not a declared agent</li> </ul>"},{"location":"analyzers/NDLRMAF002/","title":"NDLRMAF002: Group chat has fewer than two members","text":""},{"location":"analyzers/NDLRMAF002/#cause","title":"Cause","text":"<p>A group chat named <code>\"X\"</code> has only one class decorated with <code>[AgentGroupChatMember(\"X\")]</code> in the compilation.</p>"},{"location":"analyzers/NDLRMAF002/#rule-description","title":"Rule Description","text":"<p>A group chat requires at least two participants to function \u2014 a single-member group chat cannot produce a multi-agent exchange. This diagnostic fires at compilation end after all <code>[AgentGroupChatMember]</code> declarations are collected.</p> <p>Note: This is a compilation-end diagnostic. It appears after the build completes, not as you type.</p>"},{"location":"analyzers/NDLRMAF002/#how-to-fix","title":"How to Fix","text":"<p>Either add a second agent to the group chat, or remove the <code>[AgentGroupChatMember]</code> attribute if the group chat was declared in error.</p>"},{"location":"analyzers/NDLRMAF002/#before","title":"Before","text":"<pre><code>[NeedlrAiAgent(Instructions = \"Review code.\")]\n[AgentGroupChatMember(\"code-review\")]\npublic class ReviewerAgent { }\n// No second agent in the \"code-review\" group\n</code></pre>"},{"location":"analyzers/NDLRMAF002/#after","title":"After","text":"<pre><code>[NeedlrAiAgent(Instructions = \"Review code.\")]\n[AgentGroupChatMember(\"code-review\")]\npublic class ReviewerAgent { }\n\n[NeedlrAiAgent(Instructions = \"Approve or reject changes.\")]\n[AgentGroupChatMember(\"code-review\")]\npublic class ApproverAgent { }\n</code></pre>"},{"location":"analyzers/NDLRMAF002/#when-to-suppress","title":"When to Suppress","text":"<p>Only suppress if you are building a group chat incrementally across multiple assemblies where the second member is defined elsewhere and will be merged at link time.</p> <pre><code>#pragma warning disable NDLRMAF002\n[AgentGroupChatMember(\"code-review\")]\npublic class ReviewerAgent { }\n#pragma warning restore NDLRMAF002\n</code></pre>"},{"location":"analyzers/NDLRMAF002/#see-also","title":"See Also","text":"<ul> <li>AI Integrations \u2014 Multi-Agent Orchestration</li> <li>NDLRMAF008 \u2014 agent participates in no topology</li> </ul>"},{"location":"analyzers/NDLRMAF003/","title":"NDLRMAF003: [AgentHandoffsTo] source class is not a declared agent","text":""},{"location":"analyzers/NDLRMAF003/#cause","title":"Cause","text":"<p>A class bearing <code>[AgentHandoffsTo]</code> is not itself decorated with <code>[NeedlrAiAgent]</code>.</p>"},{"location":"analyzers/NDLRMAF003/#rule-description","title":"Rule Description","text":"<p>A handoff relationship is only meaningful when the source of the handoff is itself a Needlr agent. If the class owning <code>[AgentHandoffsTo]</code> is not registered with <code>[NeedlrAiAgent]</code>, it will not appear in the generated agent registry, and the handoff declaration has no effect at runtime.</p>"},{"location":"analyzers/NDLRMAF003/#how-to-fix","title":"How to Fix","text":"<p>Add <code>[NeedlrAiAgent]</code> to the class that declares <code>[AgentHandoffsTo]</code>.</p>"},{"location":"analyzers/NDLRMAF003/#before","title":"Before","text":"<pre><code>[AgentHandoffsTo(typeof(SummaryAgent), When = \"Summarization needed\")]\npublic class TriageAgent { }   // \u2190 missing [NeedlrAiAgent]\n\n[NeedlrAiAgent(Instructions = \"You summarize content.\")]\npublic class SummaryAgent { }\n</code></pre>"},{"location":"analyzers/NDLRMAF003/#after","title":"After","text":"<pre><code>[NeedlrAiAgent(Instructions = \"Route the request.\")]\n[AgentHandoffsTo(typeof(SummaryAgent), When = \"Summarization needed\")]\npublic class TriageAgent { }   // \u2190 registered\n\n[NeedlrAiAgent(Instructions = \"You summarize content.\")]\npublic class SummaryAgent { }\n</code></pre>"},{"location":"analyzers/NDLRMAF003/#when-to-suppress","title":"When to Suppress","text":"<p>Only suppress if the class is a temporary scaffold during development.</p> <pre><code>#pragma warning disable NDLRMAF003\n[AgentHandoffsTo(typeof(SummaryAgent))]\npublic class TriageAgent { }\n#pragma warning restore NDLRMAF003\n</code></pre>"},{"location":"analyzers/NDLRMAF003/#see-also","title":"See Also","text":"<ul> <li>AI Integrations \u2014 Multi-Agent Orchestration</li> <li>NDLRMAF001 \u2014 target type is not a declared agent</li> </ul>"},{"location":"analyzers/NDLRMAF004/","title":"NDLRMAF004: Cyclic handoff chain detected","text":""},{"location":"analyzers/NDLRMAF004/#cause","title":"Cause","text":"<p>The <code>[AgentHandoffsTo]</code> declarations in the compilation form a cycle (e.g. A \u2192 B \u2192 A, or A \u2192 B \u2192 C \u2192 A).</p>"},{"location":"analyzers/NDLRMAF004/#rule-description","title":"Rule Description","text":"<p>A cyclic handoff chain means no workflow using these agents can reach a terminal state via normal handoff logic \u2014 execution will loop indefinitely between the agents in the cycle. This diagnostic fires at compilation end after the full handoff graph is constructed.</p> <p>Note: This is a compilation-end diagnostic. It appears after the build completes, not as you type.</p>"},{"location":"analyzers/NDLRMAF004/#how-to-fix","title":"How to Fix","text":"<p>Break the cycle by removing one of the <code>[AgentHandoffsTo]</code> declarations or by introducing a separate non-participating agent as the terminal step.</p>"},{"location":"analyzers/NDLRMAF004/#before","title":"Before","text":"<pre><code>[NeedlrAiAgent]\n[AgentHandoffsTo(typeof(AgentB))]\npublic class AgentA { }\n\n[NeedlrAiAgent]\n[AgentHandoffsTo(typeof(AgentA))]  // \u2190 creates cycle A \u2192 B \u2192 A\npublic class AgentB { }\n</code></pre>"},{"location":"analyzers/NDLRMAF004/#after","title":"After","text":"<pre><code>[NeedlrAiAgent]\n[AgentHandoffsTo(typeof(AgentB))]\npublic class AgentA { }\n\n[NeedlrAiAgent]\n[AgentHandoffsTo(typeof(AgentC))]  // \u2190 breaks cycle, routes to terminal agent\npublic class AgentB { }\n\n[NeedlrAiAgent(Instructions = \"Produce the final answer.\")]\npublic class AgentC { }\n</code></pre>"},{"location":"analyzers/NDLRMAF004/#when-to-suppress","title":"When to Suppress","text":"<p>Cyclic handoffs are almost always a design error. Suppress only if you are intentionally modelling a re-entrant workflow and handling termination via <code>[AgentTerminationCondition]</code>.</p> <pre><code>#pragma warning disable NDLRMAF004\n[AgentHandoffsTo(typeof(AgentB))]\npublic class AgentA { }\n#pragma warning restore NDLRMAF004\n</code></pre>"},{"location":"analyzers/NDLRMAF004/#see-also","title":"See Also","text":"<ul> <li>AI Integrations \u2014 Multi-Agent Orchestration</li> <li>NDLRMAF001 \u2014 target type is not a declared agent</li> </ul>"},{"location":"analyzers/NDLRMAF005/","title":"NDLRMAF005: FunctionGroups references an unregistered group name","text":""},{"location":"analyzers/NDLRMAF005/#cause","title":"Cause","text":"<p>An agent declares <code>FunctionGroups = new[] { \"xyz\" }</code> but no class in the compilation is decorated with <code>[AgentFunctionGroup(\"xyz\")]</code>.</p>"},{"location":"analyzers/NDLRMAF005/#rule-description","title":"Rule Description","text":"<p>Group names in <code>FunctionGroups</code> are matched at runtime against the registered <code>[AgentFunctionGroup]</code> classes. If the referenced name has no matching class, the agent will receive zero tools silently \u2014 there is no runtime error. This diagnostic catches that silent failure at compile time.</p>"},{"location":"analyzers/NDLRMAF005/#how-to-fix","title":"How to Fix","text":"<p>Either register a class for the referenced group name, correct the spelling in <code>FunctionGroups</code>, or remove the group reference.</p>"},{"location":"analyzers/NDLRMAF005/#before","title":"Before","text":"<pre><code>[NeedlrAiAgent(FunctionGroups = new[] { \"geography\" })]\npublic class GeographyAgent { }\n\n// No class has [AgentFunctionGroup(\"geography\")]\n</code></pre>"},{"location":"analyzers/NDLRMAF005/#after","title":"After","text":"<pre><code>[NeedlrAiAgent(FunctionGroups = new[] { \"geography\" })]\npublic class GeographyAgent { }\n\n[AgentFunctionGroup(\"geography\")]\npublic class GeographyFunctions\n{\n    [AgentFunction]\n    public string GetCountriesLived() =&gt; \"Canada, UK\";\n}\n</code></pre>"},{"location":"analyzers/NDLRMAF005/#when-to-suppress","title":"When to Suppress","text":"<p>Only suppress if the function group class is defined in a separate assembly that Needlr's analyzer cannot see in this compilation unit.</p> <pre><code>#pragma warning disable NDLRMAF005\n[NeedlrAiAgent(FunctionGroups = new[] { \"external-group\" })]\npublic class MyAgent { }\n#pragma warning restore NDLRMAF005\n</code></pre>"},{"location":"analyzers/NDLRMAF005/#see-also","title":"See Also","text":"<ul> <li>AI Integrations \u2014 Multi-Agent Orchestration</li> <li>NDLRMAF008 \u2014 agent participates in no topology</li> </ul>"},{"location":"analyzers/NDLRMAF006/","title":"NDLRMAF006: Duplicate Order value in sequential pipeline","text":""},{"location":"analyzers/NDLRMAF006/#cause","title":"Cause","text":"<p>Two or more agents in the same sequential pipeline share the same <code>Order</code> value in their <code>[AgentSequenceMember]</code> attribute.</p>"},{"location":"analyzers/NDLRMAF006/#rule-description","title":"Rule Description","text":"<p>The <code>Order</code> value determines execution sequence within the pipeline. Duplicate order values create an ambiguous sequence \u2014 the generator cannot determine which agent runs first, and the resulting behavior is undefined. This diagnostic fires at compilation end.</p> <p>Note: This is a compilation-end diagnostic. It appears after the build completes, not as you type.</p>"},{"location":"analyzers/NDLRMAF006/#how-to-fix","title":"How to Fix","text":"<p>Assign a unique <code>Order</code> value to each agent in the pipeline. Convention is to use consecutive integers starting from 1.</p>"},{"location":"analyzers/NDLRMAF006/#before","title":"Before","text":"<pre><code>[NeedlrAiAgent]\n[AgentSequenceMember(\"content-pipeline\", Order = 1)]\npublic class ExtractorAgent { }\n\n[NeedlrAiAgent]\n[AgentSequenceMember(\"content-pipeline\", Order = 1)]  // \u2190 duplicate\npublic class EnricherAgent { }\n</code></pre>"},{"location":"analyzers/NDLRMAF006/#after","title":"After","text":"<pre><code>[NeedlrAiAgent]\n[AgentSequenceMember(\"content-pipeline\", Order = 1)]\npublic class ExtractorAgent { }\n\n[NeedlrAiAgent]\n[AgentSequenceMember(\"content-pipeline\", Order = 2)]  // \u2190 unique\npublic class EnricherAgent { }\n</code></pre>"},{"location":"analyzers/NDLRMAF006/#when-to-suppress","title":"When to Suppress","text":"<p>This should not be suppressed. Duplicate order values produce unpredictable pipeline execution.</p>"},{"location":"analyzers/NDLRMAF006/#see-also","title":"See Also","text":"<ul> <li>AI Integrations \u2014 Multi-Agent Orchestration</li> <li>NDLRMAF007 \u2014 gap in sequential pipeline order values</li> </ul>"},{"location":"analyzers/NDLRMAF007/","title":"NDLRMAF007: Gap in sequential pipeline Order values","text":""},{"location":"analyzers/NDLRMAF007/#cause","title":"Cause","text":"<p>The <code>Order</code> values declared for a sequential pipeline are non-consecutive (e.g. 1, 2, 4 \u2014 missing 3).</p>"},{"location":"analyzers/NDLRMAF007/#rule-description","title":"Rule Description","text":"<p>Gaps in order values suggest a step was removed without updating the remaining values, or an agent was accidentally skipped. While the pipeline will still execute in the declared order at runtime, the gap is a likely authoring error. This diagnostic is informational \u2014 the pipeline will function correctly with gaps.</p>"},{"location":"analyzers/NDLRMAF007/#how-to-fix","title":"How to Fix","text":"<p>Renumber the agents in the pipeline to fill the gap, or confirm the gap is intentional.</p>"},{"location":"analyzers/NDLRMAF007/#before","title":"Before","text":"<pre><code>[NeedlrAiAgent]\n[AgentSequenceMember(\"content-pipeline\", Order = 1)]\npublic class ExtractorAgent { }\n\n[NeedlrAiAgent]\n[AgentSequenceMember(\"content-pipeline\", Order = 2)]\npublic class EnricherAgent { }\n\n[NeedlrAiAgent]\n[AgentSequenceMember(\"content-pipeline\", Order = 4)]  // \u2190 gap: 3 is missing\npublic class PublisherAgent { }\n</code></pre>"},{"location":"analyzers/NDLRMAF007/#after","title":"After","text":"<pre><code>[NeedlrAiAgent]\n[AgentSequenceMember(\"content-pipeline\", Order = 1)]\npublic class ExtractorAgent { }\n\n[NeedlrAiAgent]\n[AgentSequenceMember(\"content-pipeline\", Order = 2)]\npublic class EnricherAgent { }\n\n[NeedlrAiAgent]\n[AgentSequenceMember(\"content-pipeline\", Order = 3)]  // \u2190 consecutive\npublic class PublisherAgent { }\n</code></pre>"},{"location":"analyzers/NDLRMAF007/#when-to-suppress","title":"When to Suppress","text":"<p>Suppress if you are deliberately reserving order values for future agents and want to avoid renumbering.</p> <pre><code>#pragma warning disable NDLRMAF007\n[AgentSequenceMember(\"content-pipeline\", Order = 10)]\npublic class PublisherAgent { }\n#pragma warning restore NDLRMAF007\n</code></pre>"},{"location":"analyzers/NDLRMAF007/#see-also","title":"See Also","text":"<ul> <li>AI Integrations \u2014 Multi-Agent Orchestration</li> <li>NDLRMAF006 \u2014 duplicate order value</li> </ul>"},{"location":"analyzers/NDLRMAF008/","title":"NDLRMAF008: Agent participates in no topology declaration","text":""},{"location":"analyzers/NDLRMAF008/#cause","title":"Cause","text":"<p>A class decorated with <code>[NeedlrAiAgent]</code> does not appear in any handoff chain, group chat, or sequential pipeline.</p>"},{"location":"analyzers/NDLRMAF008/#rule-description","title":"Rule Description","text":"<p>An agent that is not wired into any topology cannot be reached through any generated workflow factory method. It will be included in the agent registry but will never participate in a workflow unless it is invoked programmatically. This is typically an authoring error \u2014 either the topology attribute was forgotten, or the agent declaration is a work-in-progress.</p> <p>This diagnostic is informational and will not block compilation or execution.</p>"},{"location":"analyzers/NDLRMAF008/#how-to-fix","title":"How to Fix","text":"<p>Add the agent to an appropriate topology, or remove the <code>[NeedlrAiAgent]</code> attribute if the agent is no longer needed.</p>"},{"location":"analyzers/NDLRMAF008/#before","title":"Before","text":"<pre><code>[NeedlrAiAgent(Instructions = \"You summarize content.\")]\npublic class SummaryAgent { }   // \u2190 no topology attribute\n</code></pre>"},{"location":"analyzers/NDLRMAF008/#after","title":"After","text":"<pre><code>[NeedlrAiAgent(Instructions = \"You summarize content.\")]\n[AgentSequenceMember(\"content-pipeline\", Order = 2)]\npublic class SummaryAgent { }   // \u2190 wired into sequential pipeline\n</code></pre>"},{"location":"analyzers/NDLRMAF008/#when-to-suppress","title":"When to Suppress","text":"<p>Suppress when declaring a standalone agent that will be invoked programmatically via <code>IAgentFactory</code>, not through a generated workflow.</p> <pre><code>#pragma warning disable NDLRMAF008\n[NeedlrAiAgent(Instructions = \"Standalone utility agent.\")]\npublic class UtilityAgent { }\n#pragma warning restore NDLRMAF008\n</code></pre>"},{"location":"analyzers/NDLRMAF008/#see-also","title":"See Also","text":"<ul> <li>AI Integrations \u2014 Multi-Agent Orchestration</li> <li>NDLRMAF002 \u2014 group chat has fewer than two members</li> </ul>"},{"location":"analyzers/NDLRMAF009/","title":"NDLRMAF009: [WorkflowRunTerminationCondition] declared on a non-agent class","text":""},{"location":"analyzers/NDLRMAF009/#cause","title":"Cause","text":"<p>A class bearing <code>[WorkflowRunTerminationCondition]</code> is not decorated with any topology attribute (<code>[AgentHandoffsTo]</code>, <code>[AgentGroupChatMember]</code>, or <code>[AgentSequenceMember]</code>).</p>"},{"location":"analyzers/NDLRMAF009/#rule-description","title":"Rule Description","text":"<p><code>[WorkflowRunTerminationCondition]</code> is a Layer 2 termination declaration \u2014 it instructs the source generator to emit a <code>Run*Async()</code> method that includes the declared condition. The generator infers which workflow to attach the condition to from the agent's topology membership. If the class is not part of any topology, the attribute is orphaned and the condition will never be wired into a generated runner.</p>"},{"location":"analyzers/NDLRMAF009/#how-to-fix","title":"How to Fix","text":"<p>Add the appropriate topology attribute, or move the <code>[WorkflowRunTerminationCondition]</code> to a class that participates in a workflow.</p>"},{"location":"analyzers/NDLRMAF009/#before","title":"Before","text":"<pre><code>[NeedlrAiAgent]\n[WorkflowRunTerminationCondition(typeof(KeywordTerminationCondition), \"DONE\")]\npublic class SummaryAgent { }   // \u2190 no topology attribute\n</code></pre>"},{"location":"analyzers/NDLRMAF009/#after","title":"After","text":"<pre><code>[NeedlrAiAgent]\n[AgentSequenceMember(\"content-pipeline\", Order = 1)]\n[WorkflowRunTerminationCondition(typeof(KeywordTerminationCondition), \"DONE\")]\npublic class SummaryAgent { }\n</code></pre>"},{"location":"analyzers/NDLRMAF009/#when-to-suppress","title":"When to Suppress","text":"<p>Only suppress if you are attaching a condition to an agent that you plan to invoke programmatically and the topology will be configured at runtime.</p> <pre><code>#pragma warning disable NDLRMAF009\n[WorkflowRunTerminationCondition(typeof(KeywordTerminationCondition), \"DONE\")]\npublic class SummaryAgent { }\n#pragma warning restore NDLRMAF009\n</code></pre>"},{"location":"analyzers/NDLRMAF009/#see-also","title":"See Also","text":"<ul> <li>AI Integrations \u2014 Multi-Agent Orchestration</li> <li>NDLRMAF010 \u2014 condition type does not implement IWorkflowTerminationCondition</li> <li>NDLRMAF011 \u2014 prefer [AgentTerminationCondition] for group chat members</li> </ul>"},{"location":"analyzers/NDLRMAF010/","title":"NDLRMAF010: Termination condition type does not implement IWorkflowTerminationCondition","text":""},{"location":"analyzers/NDLRMAF010/#cause","title":"Cause","text":"<p>The type referenced in <code>[AgentTerminationCondition(typeof(X))]</code> or <code>[WorkflowRunTerminationCondition(typeof(X))]</code> does not implement <code>IWorkflowTerminationCondition</code>.</p>"},{"location":"analyzers/NDLRMAF010/#rule-description","title":"Rule Description","text":"<p>Termination condition types are instantiated at runtime via <code>Activator.CreateInstance</code> and cast to <code>IWorkflowTerminationCondition</code>. If the type does not implement this interface, the cast will fail with an <code>InvalidCastException</code> at the point the workflow is first executed. This diagnostic catches the problem at compile time.</p>"},{"location":"analyzers/NDLRMAF010/#how-to-fix","title":"How to Fix","text":"<p>Implement <code>IWorkflowTerminationCondition</code> on the referenced type, or replace the reference with a built-in condition type such as <code>KeywordTerminationCondition</code> or <code>RegexTerminationCondition</code>.</p>"},{"location":"analyzers/NDLRMAF010/#before","title":"Before","text":"<pre><code>public class MyStopCondition   // \u2190 does not implement IWorkflowTerminationCondition\n{\n    public bool Check(string text) =&gt; text.Contains(\"STOP\");\n}\n\n[NeedlrAiAgent]\n[AgentTerminationCondition(typeof(MyStopCondition))]\npublic class ReviewerAgent { }\n</code></pre>"},{"location":"analyzers/NDLRMAF010/#after","title":"After","text":"<pre><code>public class MyStopCondition : IWorkflowTerminationCondition\n{\n    public bool ShouldTerminate(TerminationContext context)\n        =&gt; context.ResponseText.Contains(\"STOP\");\n}\n\n[NeedlrAiAgent]\n[AgentTerminationCondition(typeof(MyStopCondition))]\npublic class ReviewerAgent { }\n</code></pre>"},{"location":"analyzers/NDLRMAF010/#when-to-suppress","title":"When to Suppress","text":"<p>This should not be suppressed. A condition type that does not implement the interface will always fail at runtime.</p>"},{"location":"analyzers/NDLRMAF010/#see-also","title":"See Also","text":"<ul> <li>AI Integrations \u2014 Multi-Agent Orchestration</li> <li>NDLRMAF009 \u2014 condition declared on a non-agent class</li> </ul>"},{"location":"analyzers/NDLRMAF011/","title":"NDLRMAF011: Prefer [AgentTerminationCondition] for group chat members","text":""},{"location":"analyzers/NDLRMAF011/#cause","title":"Cause","text":"<p>A class decorated with <code>[AgentGroupChatMember]</code> also declares <code>[WorkflowRunTerminationCondition]</code>.</p>"},{"location":"analyzers/NDLRMAF011/#rule-description","title":"Rule Description","text":"<p><code>[WorkflowRunTerminationCondition]</code> is a Layer 2 (post-response) termination mechanism \u2014 it fires inside Needlr's event loop after a complete agent response has been emitted. For group chats, a Layer 1 mechanism is available: <code>[AgentTerminationCondition]</code> wires conditions into the group chat manager, which fires before the next agent is called. Layer 1 termination is strictly preferable for group chats because:</p> <ul> <li>It stops the workflow before another round-trip to the model occurs</li> <li>It provides cleaner separation between \"this response completes the workflow\" and \"this response starts the next turn\"</li> </ul> <p><code>[WorkflowRunTerminationCondition]</code> on a group chat member is not incorrect \u2014 the condition will fire \u2014 but it incurs an extra model turn compared to <code>[AgentTerminationCondition]</code>.</p> <p>This diagnostic is informational.</p>"},{"location":"analyzers/NDLRMAF011/#how-to-fix","title":"How to Fix","text":"<p>Replace <code>[WorkflowRunTerminationCondition]</code> with <code>[AgentTerminationCondition]</code> on the group chat member.</p>"},{"location":"analyzers/NDLRMAF011/#before","title":"Before","text":"<pre><code>[NeedlrAiAgent]\n[AgentGroupChatMember(\"code-review\")]\n[WorkflowRunTerminationCondition(typeof(KeywordTerminationCondition), \"APPROVED\")]\npublic class ApproverAgent { }\n</code></pre>"},{"location":"analyzers/NDLRMAF011/#after","title":"After","text":"<pre><code>[NeedlrAiAgent]\n[AgentGroupChatMember(\"code-review\")]\n[AgentTerminationCondition(typeof(KeywordTerminationCondition), \"APPROVED\")]\npublic class ApproverAgent { }\n</code></pre>"},{"location":"analyzers/NDLRMAF011/#when-to-suppress","title":"When to Suppress","text":"<p>Suppress if you intentionally want the condition to fire in Layer 2 (e.g. you are also using the raw workflow object in code that bypasses the generated <code>Run*Async()</code> method and need consistent termination semantics).</p> <pre><code>#pragma warning disable NDLRMAF011\n[AgentGroupChatMember(\"code-review\")]\n[WorkflowRunTerminationCondition(typeof(KeywordTerminationCondition), \"APPROVED\")]\npublic class ApproverAgent { }\n#pragma warning restore NDLRMAF011\n</code></pre>"},{"location":"analyzers/NDLRMAF011/#see-also","title":"See Also","text":"<ul> <li>AI Integrations \u2014 Multi-Agent Orchestration</li> <li>NDLRMAF009 \u2014 condition declared on a non-agent class</li> <li>NDLRMAF010 \u2014 condition type does not implement IWorkflowTerminationCondition</li> </ul>"},{"location":"analyzers/NDLRSIG001/","title":"NDLRSIG001: HubPath must be a constant","text":""},{"location":"analyzers/NDLRSIG001/#cause","title":"Cause","text":"<p>The <code>hubPath</code> parameter of <code>HubPathAttribute</code> is not a compile-time constant expression.</p>"},{"location":"analyzers/NDLRSIG001/#rule-description","title":"Rule Description","text":"<p>SignalR hub paths must be known at compile time for proper route registration and AOT compatibility. Using non-constant values (like static fields or method calls) prevents the source generator from properly analyzing and generating the hub registration code.</p>"},{"location":"analyzers/NDLRSIG001/#example","title":"Example","text":""},{"location":"analyzers/NDLRSIG001/#incorrect","title":"Incorrect","text":"<pre><code>public static class HubPaths\n{\n    public static string ChatHub = \"/chat\"; // Not const!\n}\n\n[HubPath(HubPaths.ChatHub, typeof(ChatHub))] // NDLRSIG001\npublic class ChatHubRegistration : ISignalRHub { }\n</code></pre>"},{"location":"analyzers/NDLRSIG001/#correct","title":"Correct","text":"<pre><code>public static class HubPaths\n{\n    public const string ChatHub = \"/chat\"; // const is OK\n}\n\n[HubPath(HubPaths.ChatHub, typeof(ChatHub))]\npublic class ChatHubRegistration : ISignalRHub { }\n\n// Or use a string literal directly\n[HubPath(\"/chat\", typeof(ChatHub))]\npublic class ChatHubRegistration : ISignalRHub { }\n</code></pre>"},{"location":"analyzers/NDLRSIG001/#how-to-fix","title":"How to Fix","text":"<ol> <li>Change the hub path to a <code>const</code> string field</li> <li>Use a string literal directly in the attribute</li> <li>Use <code>nameof()</code> if deriving the path from a type name</li> </ol>"},{"location":"analyzers/NDLRSIG001/#when-to-suppress","title":"When to Suppress","text":"<p>This warning should not be suppressed. Non-constant hub paths will cause compilation errors in the C# compiler itself (CS0182).</p>"},{"location":"analyzers/NDLRSIG001/#see-also","title":"See Also","text":"<ul> <li>Advanced Usage</li> </ul>"},{"location":"analyzers/NDLRSIG002/","title":"NDLRSIG002: HubType must be a typeof expression","text":""},{"location":"analyzers/NDLRSIG002/#cause","title":"Cause","text":"<p>The <code>hubType</code> parameter of <code>HubPathAttribute</code> is not a <code>typeof()</code> expression.</p>"},{"location":"analyzers/NDLRSIG002/#rule-description","title":"Rule Description","text":"<p>SignalR hub type references must use the <code>typeof()</code> operator for proper type resolution at compile time. This ensures AOT compatibility and allows the source generator to properly analyze the hub type.</p>"},{"location":"analyzers/NDLRSIG002/#example","title":"Example","text":""},{"location":"analyzers/NDLRSIG002/#incorrect","title":"Incorrect","text":"<pre><code>[HubPath(\"/chat\", someTypeVariable)] // NDLRSIG002\npublic class ChatHubRegistration : ISignalRHub { }\n</code></pre>"},{"location":"analyzers/NDLRSIG002/#correct","title":"Correct","text":"<pre><code>[HubPath(\"/chat\", typeof(ChatHub))]\npublic class ChatHubRegistration : ISignalRHub { }\n</code></pre>"},{"location":"analyzers/NDLRSIG002/#how-to-fix","title":"How to Fix","text":"<p>Always use <code>typeof(YourHubClass)</code> for the hub type parameter:</p> <pre><code>[HubPath(\"/notifications\", typeof(NotificationHub))]\npublic class NotificationHubRegistration : ISignalRHub { }\n</code></pre>"},{"location":"analyzers/NDLRSIG002/#when-to-suppress","title":"When to Suppress","text":"<p>This warning should not be suppressed. Non-typeof expressions will cause compilation errors in the C# compiler itself (CS0182).</p>"},{"location":"analyzers/NDLRSIG002/#see-also","title":"See Also","text":"<ul> <li>Advanced Usage</li> <li>NDLRSIG001: HubPath must be a constant</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>Select a version:</p> <ul> <li>Stable (Latest Release) - Recommended for most users</li> <li>Development - Latest from main branch (may be unstable)</li> </ul> <p>Auto-Generated Documentation</p> <p>API documentation is automatically generated from XML doc comments during CI/CD.</p> <ul> <li>On push to main: Updates <code>/api/dev/</code></li> <li>On release: Creates <code>/api/v{version}/</code> and updates <code>/api/stable/</code></li> </ul>"},{"location":"api/dev/","title":"API Reference (Development)","text":"<p>This documentation is auto-generated from the latest <code>main</code> branch.</p> <p>Unstable</p> <p>This documentation reflects unreleased changes and may not match any published NuGet package.</p> <p>For stable release documentation, see stable.</p>"},{"location":"api/dev/#packages","title":"Packages","text":"<ul> <li>NexusLabs.Needlr</li> <li>NexusLabs.Needlr.AgentFramework</li> <li>NexusLabs.Needlr.AgentFramework.Analyzers</li> <li>NexusLabs.Needlr.AgentFramework.Generators</li> <li>NexusLabs.Needlr.AgentFramework.Workflows</li> <li>NexusLabs.Needlr.Analyzers</li> <li>NexusLabs.Needlr.AspNet</li> <li>NexusLabs.Needlr.Carter</li> <li>NexusLabs.Needlr.Extensions.Logging</li> <li>NexusLabs.Needlr.FluentValidation</li> <li>NexusLabs.Needlr.FluentValidation.Generators</li> <li>NexusLabs.Needlr.Generators</li> <li>NexusLabs.Needlr.Generators.Attributes</li> <li>NexusLabs.Needlr.Hosting</li> <li>NexusLabs.Needlr.Injection</li> <li>NexusLabs.Needlr.Injection.Bundle</li> <li>NexusLabs.Needlr.Injection.Reflection</li> <li>NexusLabs.Needlr.Injection.Scrutor</li> <li>NexusLabs.Needlr.Injection.SourceGen</li> <li>NexusLabs.Needlr.SemanticKernel</li> <li>NexusLabs.Needlr.SemanticKernel.Generators</li> <li>NexusLabs.Needlr.SignalR</li> <li>NexusLabs.Needlr.SignalR.Analyzers</li> <li>NexusLabs.Needlr.SignalR.Generators</li> </ul>"},{"location":"api/dev/NexusLabs.Needlr/","title":"Index","text":""},{"location":"api/dev/NexusLabs.Needlr/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/#nexuslabsneedlr-assembly","title":"NexusLabs.Needlr Assembly","text":"Namespaces NexusLabs.Needlr NexusLabs.Needlr.Catalog"},{"location":"api/dev/NexusLabs.Needlr/ConstructorParameterEntry/","title":"ConstructorParameterEntry","text":""},{"location":"api/dev/NexusLabs.Needlr/ConstructorParameterEntry/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/ConstructorParameterEntry/#nexuslabsneedlrcatalog","title":"NexusLabs.Needlr.Catalog","text":""},{"location":"api/dev/NexusLabs.Needlr/ConstructorParameterEntry/#constructorparameterentry-class","title":"ConstructorParameterEntry Class","text":"<p>Represents a constructor parameter.</p> <pre><code>public sealed record ConstructorParameterEntry : System.IEquatable&lt;NexusLabs.Needlr.Catalog.ConstructorParameterEntry&gt;\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 ConstructorParameterEntry</p> <p>Implements System.IEquatable&lt;ConstructorParameterEntry&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr/ConstructorParameterEntry/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr/ConstructorParameterEntry/#constructorparameterentrystring-string-bool-string-constructor","title":"ConstructorParameterEntry(string, string, bool, string) Constructor","text":"<p>Represents a constructor parameter.</p> <pre><code>public ConstructorParameterEntry(string Name, string TypeName, bool IsKeyed=false, string? ServiceKey=null);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ConstructorParameterEntry/#parameters","title":"Parameters","text":"<p><code>Name</code> System.String</p> <p>The parameter name.</p> <p></p> <p><code>TypeName</code> System.String</p> <p>The fully qualified type name of the parameter.</p> <p></p> <p><code>IsKeyed</code> System.Boolean</p> <p>True if this is a keyed service parameter.</p> <p></p> <p><code>ServiceKey</code> System.String</p> <p>The service key if this is a keyed parameter.</p>"},{"location":"api/dev/NexusLabs.Needlr/ConstructorParameterEntry/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr/ConstructorParameterEntry/#constructorparameterentryiskeyed-property","title":"ConstructorParameterEntry.IsKeyed Property","text":"<p>True if this is a keyed service parameter.</p> <pre><code>public bool IsKeyed { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ConstructorParameterEntry/#property-value","title":"Property Value","text":"<p>System.Boolean</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/ConstructorParameterEntry/#constructorparameterentryname-property","title":"ConstructorParameterEntry.Name Property","text":"<p>The parameter name.</p> <pre><code>public string Name { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ConstructorParameterEntry/#property-value_1","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/ConstructorParameterEntry/#constructorparameterentryservicekey-property","title":"ConstructorParameterEntry.ServiceKey Property","text":"<p>The service key if this is a keyed parameter.</p> <pre><code>public string? ServiceKey { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ConstructorParameterEntry/#property-value_2","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/ConstructorParameterEntry/#constructorparameterentrytypename-property","title":"ConstructorParameterEntry.TypeName Property","text":"<p>The fully qualified type name of the parameter.</p> <pre><code>public string TypeName { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ConstructorParameterEntry/#property-value_3","title":"Property Value","text":"<p>System.String</p>"},{"location":"api/dev/NexusLabs.Needlr/ContainerVerificationException/","title":"ContainerVerificationException","text":""},{"location":"api/dev/NexusLabs.Needlr/ContainerVerificationException/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/ContainerVerificationException/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/ContainerVerificationException/#containerverificationexception-class","title":"ContainerVerificationException Class","text":"<p>Exception thrown when Needlr container verification detects one or more registered issues that are configured to fail-fast at startup.</p> <pre><code>public sealed class ContainerVerificationException : System.Exception\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 System.Exception \ud83e\udc52 ContainerVerificationException</p>"},{"location":"api/dev/NexusLabs.Needlr/ContainerVerificationException/#example","title":"Example","text":"<pre><code>try\n{\n    var provider = services.BuildServiceProvider();\n    provider.VerifyContainer();\n}\ncatch (ContainerVerificationException ex)\n{\n    foreach (var issue in ex.Issues)\n    {\n        Console.Error.WriteLine($\"[{issue.Type}] {issue.Message}\");\n    }\n    throw;\n}\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ContainerVerificationException/#remarks","title":"Remarks","text":"<p>Container verification is triggered by calling <code>VerifyContainer()</code> (or the equivalent extension) after building the service provider. Each VerificationIssue in Issues describes one problem \u2014 for example, a missing required dependency or a misconfigured lifetime.</p> <p>Only issues whose configured severity is set to throw will produce this exception. Issues configured to warn are reported through the logging pipeline instead.</p>"},{"location":"api/dev/NexusLabs.Needlr/ContainerVerificationException/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr/ContainerVerificationException/#containerverificationexceptionireadonlylistverificationissue-constructor","title":"ContainerVerificationException(IReadOnlyList&lt;VerificationIssue&gt;) Constructor","text":"<p>Creates a new container verification exception.</p> <pre><code>public ContainerVerificationException(System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.VerificationIssue&gt; issues);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ContainerVerificationException/#parameters","title":"Parameters","text":"<p><code>issues</code> System.Collections.Generic.IReadOnlyList&lt;VerificationIssue&gt;</p> <p>The verification issues that caused the exception.</p>"},{"location":"api/dev/NexusLabs.Needlr/ContainerVerificationException/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr/ContainerVerificationException/#containerverificationexceptionissues-property","title":"ContainerVerificationException.Issues Property","text":"<p>Gets the verification issues that caused this exception.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.VerificationIssue&gt; Issues { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ContainerVerificationException/#property-value","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;VerificationIssue&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr/DecoratorCatalogEntry/","title":"DecoratorCatalogEntry","text":""},{"location":"api/dev/NexusLabs.Needlr/DecoratorCatalogEntry/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/DecoratorCatalogEntry/#nexuslabsneedlrcatalog","title":"NexusLabs.Needlr.Catalog","text":""},{"location":"api/dev/NexusLabs.Needlr/DecoratorCatalogEntry/#decoratorcatalogentry-class","title":"DecoratorCatalogEntry Class","text":"<p>Represents a decorator registration discovered at compile time.</p> <pre><code>public sealed record DecoratorCatalogEntry : System.IEquatable&lt;NexusLabs.Needlr.Catalog.DecoratorCatalogEntry&gt;\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 DecoratorCatalogEntry</p> <p>Implements System.IEquatable&lt;DecoratorCatalogEntry&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr/DecoratorCatalogEntry/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr/DecoratorCatalogEntry/#decoratorcatalogentrystring-string-string-int-string-string-constructor","title":"DecoratorCatalogEntry(string, string, string, int, string, string) Constructor","text":"<p>Represents a decorator registration discovered at compile time.</p> <pre><code>public DecoratorCatalogEntry(string DecoratorTypeName, string ShortDecoratorTypeName, string ServiceTypeName, int Order, string AssemblyName, string? SourceFilePath=null);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/DecoratorCatalogEntry/#parameters","title":"Parameters","text":"<p><code>DecoratorTypeName</code> System.String</p> <p>The fully qualified name of the decorator type.</p> <p></p> <p><code>ShortDecoratorTypeName</code> System.String</p> <p>The short name of the decorator type (without namespace).</p> <p></p> <p><code>ServiceTypeName</code> System.String</p> <p>The fully qualified name of the service type being decorated.</p> <p></p> <p><code>Order</code> System.Int32</p> <p>The order in which this decorator is applied (lower = closer to original service).</p> <p></p> <p><code>AssemblyName</code> System.String</p> <p>The assembly name where this decorator is defined.</p> <p></p> <p><code>SourceFilePath</code> System.String</p> <p>Source file path where the decorator is defined, if available.</p>"},{"location":"api/dev/NexusLabs.Needlr/DecoratorCatalogEntry/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr/DecoratorCatalogEntry/#decoratorcatalogentryassemblyname-property","title":"DecoratorCatalogEntry.AssemblyName Property","text":"<p>The assembly name where this decorator is defined.</p> <pre><code>public string AssemblyName { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/DecoratorCatalogEntry/#property-value","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/DecoratorCatalogEntry/#decoratorcatalogentrydecoratortypename-property","title":"DecoratorCatalogEntry.DecoratorTypeName Property","text":"<p>The fully qualified name of the decorator type.</p> <pre><code>public string DecoratorTypeName { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/DecoratorCatalogEntry/#property-value_1","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/DecoratorCatalogEntry/#decoratorcatalogentryorder-property","title":"DecoratorCatalogEntry.Order Property","text":"<p>The order in which this decorator is applied (lower = closer to original service).</p> <pre><code>public int Order { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/DecoratorCatalogEntry/#property-value_2","title":"Property Value","text":"<p>System.Int32</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/DecoratorCatalogEntry/#decoratorcatalogentryservicetypename-property","title":"DecoratorCatalogEntry.ServiceTypeName Property","text":"<p>The fully qualified name of the service type being decorated.</p> <pre><code>public string ServiceTypeName { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/DecoratorCatalogEntry/#property-value_3","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/DecoratorCatalogEntry/#decoratorcatalogentryshortdecoratortypename-property","title":"DecoratorCatalogEntry.ShortDecoratorTypeName Property","text":"<p>The short name of the decorator type (without namespace).</p> <pre><code>public string ShortDecoratorTypeName { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/DecoratorCatalogEntry/#property-value_4","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/DecoratorCatalogEntry/#decoratorcatalogentrysourcefilepath-property","title":"DecoratorCatalogEntry.SourceFilePath Property","text":"<p>Source file path where the decorator is defined, if available.</p> <pre><code>public string? SourceFilePath { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/DecoratorCatalogEntry/#property-value_5","title":"Property Value","text":"<p>System.String</p>"},{"location":"api/dev/NexusLabs.Needlr/DecoratorForAttribute_TService_/","title":"DecoratorForAttribute TService","text":""},{"location":"api/dev/NexusLabs.Needlr/DecoratorForAttribute_TService_/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/DecoratorForAttribute_TService_/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/DecoratorForAttribute_TService_/#decoratorforattributetservice-class","title":"DecoratorForAttribute&lt;TService&gt; Class","text":"<p>Marks a class as a decorator for the specified service type. When discovered by Needlr (via source generation or reflection), the decorator will be  automatically wired using AddDecorator&lt;TService,TDecorator&gt;(this IServiceCollection).</p> <pre><code>public sealed class DecoratorForAttribute&lt;TService&gt; : System.Attribute\n    where TService : class\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/DecoratorForAttribute_TService_/#type-parameters","title":"Type parameters","text":"<p><code>TService</code></p> <p>The service type (interface or class) that this class decorates.</p> <p>Inheritance System.Object \ud83e\udc52 System.Attribute \ud83e\udc52 DecoratorForAttribute\\&lt;TService&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr/DecoratorForAttribute_TService_/#example","title":"Example","text":"<pre><code>public interface IMyService\n{\n    string GetValue();\n}\n\npublic class MyService : IMyService\n{\n    public string GetValue() =&gt; \"Original\";\n}\n\n[DecoratorFor&lt;IMyService&gt;(Order = 1)]\npublic class LoggingDecorator : IMyService\n{\n    private readonly IMyService _inner;\n\n    public LoggingDecorator(IMyService inner) =&gt; _inner = inner;\n\n    public string GetValue()\n    {\n        Console.WriteLine(\"Before\");\n        var result = _inner.GetValue();\n        Console.WriteLine(\"After\");\n        return result;\n    }\n}\n\n[DecoratorFor&lt;IMyService&gt;(Order = 2)]\npublic class CachingDecorator : IMyService\n{\n    private readonly IMyService _inner;\n    private string? _cached;\n\n    public CachingDecorator(IMyService inner) =&gt; _inner = inner;\n\n    public string GetValue() =&gt; _cached ??= _inner.GetValue();\n}\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/DecoratorForAttribute_TService_/#remarks","title":"Remarks","text":"<p>The decorated class must implement TService and accept an instance of TService in its constructor.</p> <p>When multiple decorators exist for the same service, use the Order  property to control the decoration order. Lower values are applied first (closer to the original service), higher values wrap outer layers.</p> <p>Using this attribute implicitly excludes the type from normal interface  registration (equivalent to applying DoNotAutoRegisterAttribute for the decorated interface).</p>"},{"location":"api/dev/NexusLabs.Needlr/DecoratorForAttribute_TService_/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr/DecoratorForAttribute_TService_/#decoratorforattributetserviceorder-property","title":"DecoratorForAttribute&lt;TService&gt;.Order Property","text":"<p>Gets or sets the order in which this decorator is applied relative to other decorators for the same service. Lower values are applied first (closer to the original implementation). Default is 0.</p> <pre><code>public int Order { get; set; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/DecoratorForAttribute_TService_/#property-value","title":"Property Value","text":"<p>System.Int32</p>"},{"location":"api/dev/NexusLabs.Needlr/DecoratorForAttribute_TService_/#remarks_1","title":"Remarks","text":"<p>Example with Order values: - Original service: MyService - Order = 1: LoggingDecorator wraps MyService - Order = 2: CachingDecorator wraps LoggingDecorator</p> <p>Resolving IMyService returns: CachingDecorator \u2192 LoggingDecorator \u2192 MyService</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/DecoratorForAttribute_TService_/#decoratorforattributetserviceservicetype-property","title":"DecoratorForAttribute&lt;TService&gt;.ServiceType Property","text":"<p>Gets the service type that this decorator wraps.</p> <pre><code>public System.Type ServiceType { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/DecoratorForAttribute_TService_/#property-value_1","title":"Property Value","text":"<p>System.Type</p>"},{"location":"api/dev/NexusLabs.Needlr/DeferToContainerAttribute/","title":"DeferToContainerAttribute","text":""},{"location":"api/dev/NexusLabs.Needlr/DeferToContainerAttribute/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/DeferToContainerAttribute/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/DeferToContainerAttribute/#defertocontainerattribute-class","title":"DeferToContainerAttribute Class","text":"<p>Specifies constructor parameter types for a partial class whose constructor will be generated by another source generator.</p> <pre><code>public sealed class DeferToContainerAttribute : System.Attribute\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 System.Attribute \ud83e\udc52 DeferToContainerAttribute</p>"},{"location":"api/dev/NexusLabs.Needlr/DeferToContainerAttribute/#example","title":"Example","text":"<pre><code>// Your partial class - another generator will add a primary constructor\n[DeferToContainer(typeof(IRepository), typeof(ILogger&lt;MyService&gt;))]\n[GeneratedService]  // This triggers another source generator\npublic partial class MyService { }\n\n// The other generator produces:\n// public partial class MyService(IRepository repository, ILogger&lt;MyService&gt; logger) { }\n\n// Needlr generates factory based on your [DeferToContainer] declaration:\n// sp =&gt; new MyService(\n//     sp.GetRequiredService&lt;IRepository&gt;(),\n//     sp.GetRequiredService&lt;ILogger&lt;MyService&gt;&gt;())\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/DeferToContainerAttribute/#remarks","title":"Remarks","text":"<p>Use this attribute when your partial class receives a constructor from another source generator (e.g., a code generator that adds a primary constructor based on an attribute). Since Needlr's source generator cannot see constructors added by other generators, you must explicitly declare the expected constructor parameter types.</p> <p>Needlr will generate a factory that calls the constructor with the specified parameter types, resolving each dependency from the service provider.</p> <p>If the declared parameter types don't match the actual generated constructor, the build will fail with a compile error.</p>"},{"location":"api/dev/NexusLabs.Needlr/DeferToContainerAttribute/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr/DeferToContainerAttribute/#defertocontainerattributetype-constructor","title":"DeferToContainerAttribute(Type[]) Constructor","text":"<p>Initializes a new instance of DeferToContainerAttribute with the specified constructor parameter types.</p> <pre><code>public DeferToContainerAttribute(params System.Type[] constructorParameterTypes);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/DeferToContainerAttribute/#parameters","title":"Parameters","text":"<p><code>constructorParameterTypes</code> System.Type[]</p> <p>The types of the constructor parameters in order. Each type will be resolved from the service provider when creating an instance.</p>"},{"location":"api/dev/NexusLabs.Needlr/DeferToContainerAttribute/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr/DeferToContainerAttribute/#defertocontainerattributeconstructorparametertypes-property","title":"DeferToContainerAttribute.ConstructorParameterTypes Property","text":"<p>Gets the constructor parameter types in order.</p> <pre><code>public System.Type[] ConstructorParameterTypes { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/DeferToContainerAttribute/#property-value","title":"Property Value","text":"<p>System.Type[]</p>"},{"location":"api/dev/NexusLabs.Needlr/DeferToContainerAttribute/#remarks_1","title":"Remarks","text":"<p>These types are used by the source generator to create a factory delegate that resolves each parameter from the service provider and passes them to the constructor.</p>"},{"location":"api/dev/NexusLabs.Needlr/DoNotAutoRegisterAttribute/","title":"DoNotAutoRegisterAttribute","text":""},{"location":"api/dev/NexusLabs.Needlr/DoNotAutoRegisterAttribute/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/DoNotAutoRegisterAttribute/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/DoNotAutoRegisterAttribute/#donotautoregisterattribute-class","title":"DoNotAutoRegisterAttribute Class","text":"<p>Prevents a class or interface from being automatically registered by Needlr's dependency injection discovery pipeline.</p> <pre><code>public sealed class DoNotAutoRegisterAttribute : System.Attribute\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 System.Attribute \ud83e\udc52 DoNotAutoRegisterAttribute</p>"},{"location":"api/dev/NexusLabs.Needlr/DoNotAutoRegisterAttribute/#example","title":"Example","text":"<pre><code>// This class is discovered during scanning but never added to the container\n[DoNotAutoRegister]\npublic class InternalHelper : IHelper\n{\n    // Registered manually or not at all\n}\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/DoNotAutoRegisterAttribute/#remarks","title":"Remarks","text":"<p>Use this attribute when a type should be discovered (scanned) but not registered in the Microsoft.Extensions.DependencyInjection.IServiceCollection. Common scenarios include: - Types with a custom or conditional registration strategy. - Abstract base classes that should not be resolved directly. - Types registered manually elsewhere in the composition root.</p>"},{"location":"api/dev/NexusLabs.Needlr/DoNotInjectAttribute/","title":"DoNotInjectAttribute","text":""},{"location":"api/dev/NexusLabs.Needlr/DoNotInjectAttribute/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/DoNotInjectAttribute/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/DoNotInjectAttribute/#donotinjectattribute-class","title":"DoNotInjectAttribute Class","text":"<p>Prevents a class or interface from being injected as a dependency by Needlr. Types decorated with this attribute are discovered but excluded from service collection registration.</p> <pre><code>public sealed class DoNotInjectAttribute : System.Attribute\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 System.Attribute \ud83e\udc52 DoNotInjectAttribute</p>"},{"location":"api/dev/NexusLabs.Needlr/DoNotInjectAttribute/#example","title":"Example","text":"<pre><code>// This interface is used as a constraint but should never be resolved from the container\n[DoNotInject]\npublic interface IInternalMarker\n{\n}\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/DoNotInjectAttribute/#remarks","title":"Remarks","text":"<p>Use <code>[DoNotInject]</code> when a type should never appear as a resolvable service \u2014 for example, infrastructure base classes, marker interfaces, or types that are only used as generic constraints.</p> <p>Unlike DoNotAutoRegisterAttribute, which signals \"register me some other way\", <code>[DoNotInject]</code> signals \"this type is not a DI service at all\".</p>"},{"location":"api/dev/NexusLabs.Needlr/DumpExtensions/","title":"DumpExtensions","text":""},{"location":"api/dev/NexusLabs.Needlr/DumpExtensions/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/DumpExtensions/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/DumpExtensions/#dumpextensions-class","title":"DumpExtensions Class","text":"<p>Extension methods for dumping service registration information for debugging.</p> <pre><code>public static class DumpExtensions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 DumpExtensions</p>"},{"location":"api/dev/NexusLabs.Needlr/DumpExtensions/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr/DumpExtensions/#dumpextensionsdumpthis-iservicecollection-dumpoptions-method","title":"DumpExtensions.Dump(this IServiceCollection, DumpOptions) Method","text":"<p>Returns a formatted string representation of all service registrations in the service collection for debugging purposes.</p> <pre><code>public static string Dump(this Microsoft.Extensions.DependencyInjection.IServiceCollection services, NexusLabs.Needlr.DumpOptions? options=null);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/DumpExtensions/#parameters","title":"Parameters","text":"<p><code>services</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service collection to dump.</p> <p></p> <p><code>options</code> DumpOptions</p> <p>Optional dump options for filtering and formatting.</p>"},{"location":"api/dev/NexusLabs.Needlr/DumpExtensions/#returns","title":"Returns","text":"<p>System.String A formatted string with registration details.</p>"},{"location":"api/dev/NexusLabs.Needlr/DumpExtensions/#exceptions","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when services is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/DumpExtensions/#dumpextensionsdumpthis-iserviceprovider-dumpoptions-method","title":"DumpExtensions.Dump(this IServiceProvider, DumpOptions) Method","text":"<p>Returns a formatted string representation of all service registrations in the service provider for debugging purposes.</p> <pre><code>public static string Dump(this System.IServiceProvider serviceProvider, NexusLabs.Needlr.DumpOptions? options=null);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/DumpExtensions/#parameters_1","title":"Parameters","text":"<p><code>serviceProvider</code> System.IServiceProvider</p> <p>The service provider to dump.</p> <p></p> <p><code>options</code> DumpOptions</p> <p>Optional dump options for filtering and formatting.</p>"},{"location":"api/dev/NexusLabs.Needlr/DumpExtensions/#returns_1","title":"Returns","text":"<p>System.String A formatted string with registration details.</p>"},{"location":"api/dev/NexusLabs.Needlr/DumpExtensions/#exceptions_1","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when serviceProvider is null.</p> <p>System.InvalidOperationException Thrown when the service collection is not accessible.</p>"},{"location":"api/dev/NexusLabs.Needlr/DumpOptions/","title":"DumpOptions","text":""},{"location":"api/dev/NexusLabs.Needlr/DumpOptions/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/DumpOptions/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/DumpOptions/#dumpoptions-class","title":"DumpOptions Class","text":"<p>Options for customizing the output of Dump(this IServiceCollection, DumpOptions).</p> <pre><code>public sealed record DumpOptions : System.IEquatable&lt;NexusLabs.Needlr.DumpOptions&gt;\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 DumpOptions</p> <p>Implements System.IEquatable&lt;DumpOptions&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr/DumpOptions/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr/DumpOptions/#dumpoptionsdefault-property","title":"DumpOptions.Default Property","text":"<p>Gets the default dump options with no filtering.</p> <pre><code>public static NexusLabs.Needlr.DumpOptions Default { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/DumpOptions/#property-value","title":"Property Value","text":"<p>DumpOptions</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/DumpOptions/#dumpoptionsgroupbylifetime-property","title":"DumpOptions.GroupByLifetime Property","text":"<p>Gets or sets whether to group registrations by lifetime in the output. Default is false.</p> <pre><code>public bool GroupByLifetime { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/DumpOptions/#property-value_1","title":"Property Value","text":"<p>System.Boolean</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/DumpOptions/#dumpoptionslifetimefilter-property","title":"DumpOptions.LifetimeFilter Property","text":"<p>Gets or sets an optional filter to only include services with a specific lifetime. When null, all lifetimes are included.</p> <pre><code>public System.Nullable&lt;Microsoft.Extensions.DependencyInjection.ServiceLifetime&gt; LifetimeFilter { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/DumpOptions/#property-value_2","title":"Property Value","text":"<p>System.Nullable&lt;Microsoft.Extensions.DependencyInjection.ServiceLifetime&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/DumpOptions/#dumpoptionsservicetypefilter-property","title":"DumpOptions.ServiceTypeFilter Property","text":"<p>Gets or sets an optional predicate to filter services by their service type. When null, all service types are included.</p> <pre><code>public System.Func&lt;System.Type,bool&gt;? ServiceTypeFilter { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/DumpOptions/#property-value_3","title":"Property Value","text":"<p>System.Func&lt;System.Type,System.Boolean&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr/HostedServiceCatalogEntry/","title":"HostedServiceCatalogEntry","text":""},{"location":"api/dev/NexusLabs.Needlr/HostedServiceCatalogEntry/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/HostedServiceCatalogEntry/#nexuslabsneedlrcatalog","title":"NexusLabs.Needlr.Catalog","text":""},{"location":"api/dev/NexusLabs.Needlr/HostedServiceCatalogEntry/#hostedservicecatalogentry-class","title":"HostedServiceCatalogEntry Class","text":"<p>Represents a hosted service registration discovered at compile time.</p> <pre><code>public sealed record HostedServiceCatalogEntry : System.IEquatable&lt;NexusLabs.Needlr.Catalog.HostedServiceCatalogEntry&gt;\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 HostedServiceCatalogEntry</p> <p>Implements System.IEquatable&lt;HostedServiceCatalogEntry&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr/HostedServiceCatalogEntry/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr/HostedServiceCatalogEntry/#hostedservicecatalogentrystring-string-string-ireadonlylistconstructorparameterentry-string-constructor","title":"HostedServiceCatalogEntry(string, string, string, IReadOnlyList&lt;ConstructorParameterEntry&gt;, string) Constructor","text":"<p>Represents a hosted service registration discovered at compile time.</p> <pre><code>public HostedServiceCatalogEntry(string TypeName, string ShortTypeName, string AssemblyName, System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.ConstructorParameterEntry&gt; ConstructorParameters, string? SourceFilePath=null);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/HostedServiceCatalogEntry/#parameters","title":"Parameters","text":"<p><code>TypeName</code> System.String</p> <p>The fully qualified name of the hosted service type.</p> <p></p> <p><code>ShortTypeName</code> System.String</p> <p>The short name of the hosted service type (without namespace).</p> <p></p> <p><code>AssemblyName</code> System.String</p> <p>The assembly name where this type is defined.</p> <p></p> <p><code>ConstructorParameters</code> System.Collections.Generic.IReadOnlyList&lt;ConstructorParameterEntry&gt;</p> <p>Constructor parameter type names.</p> <p></p> <p><code>SourceFilePath</code> System.String</p> <p>Source file path where the type is defined, if available.</p>"},{"location":"api/dev/NexusLabs.Needlr/HostedServiceCatalogEntry/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr/HostedServiceCatalogEntry/#hostedservicecatalogentryassemblyname-property","title":"HostedServiceCatalogEntry.AssemblyName Property","text":"<p>The assembly name where this type is defined.</p> <pre><code>public string AssemblyName { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/HostedServiceCatalogEntry/#property-value","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/HostedServiceCatalogEntry/#hostedservicecatalogentryconstructorparameters-property","title":"HostedServiceCatalogEntry.ConstructorParameters Property","text":"<p>Constructor parameter type names.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.ConstructorParameterEntry&gt; ConstructorParameters { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/HostedServiceCatalogEntry/#property-value_1","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;ConstructorParameterEntry&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/HostedServiceCatalogEntry/#hostedservicecatalogentryshorttypename-property","title":"HostedServiceCatalogEntry.ShortTypeName Property","text":"<p>The short name of the hosted service type (without namespace).</p> <pre><code>public string ShortTypeName { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/HostedServiceCatalogEntry/#property-value_2","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/HostedServiceCatalogEntry/#hostedservicecatalogentrysourcefilepath-property","title":"HostedServiceCatalogEntry.SourceFilePath Property","text":"<p>Source file path where the type is defined, if available.</p> <pre><code>public string? SourceFilePath { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/HostedServiceCatalogEntry/#property-value_3","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/HostedServiceCatalogEntry/#hostedservicecatalogentrytypename-property","title":"HostedServiceCatalogEntry.TypeName Property","text":"<p>The fully qualified name of the hosted service type.</p> <pre><code>public string TypeName { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/HostedServiceCatalogEntry/#property-value_4","title":"Property Value","text":"<p>System.String</p>"},{"location":"api/dev/NexusLabs.Needlr/IMethodInterceptor/","title":"IMethodInterceptor","text":""},{"location":"api/dev/NexusLabs.Needlr/IMethodInterceptor/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/IMethodInterceptor/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/IMethodInterceptor/#imethodinterceptor-interface","title":"IMethodInterceptor Interface","text":"<p>Intercepts method invocations on a service. Implement this interface to create reusable cross-cutting concerns like logging, caching, or timing.</p> <pre><code>public interface IMethodInterceptor\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/IMethodInterceptor/#example","title":"Example","text":"<pre><code>public class LoggingInterceptor : IMethodInterceptor\n{\n    private readonly ILogger _logger;\n\n    public LoggingInterceptor(ILogger logger) =&gt; _logger = logger;\n\n    public async ValueTask&lt;object?&gt; InterceptAsync(IMethodInvocation invocation)\n    {\n        _logger.LogInformation(\"Calling {Method}\", invocation.Method.Name);\n        var sw = Stopwatch.StartNew();\n        try\n        {\n            var result = await invocation.ProceedAsync();\n            _logger.LogInformation(\"{Method} completed in {Elapsed}ms\", \n                invocation.Method.Name, sw.ElapsedMilliseconds);\n            return result;\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"{Method} failed\", invocation.Method.Name);\n            throw;\n        }\n    }\n}\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/IMethodInterceptor/#remarks","title":"Remarks","text":"<p>Unlike decorators (which require implementing every method of an interface), interceptors handle any method invocation with a single implementation. Apply interceptors to services using InterceptAttribute&lt;TInterceptor&gt;.</p> <p>Interceptors are resolved from the DI container and can have their own dependencies. They are automatically excluded from Needlr's auto-registration because they are internal infrastructure resolved by generated proxy classes, not by user code.</p>"},{"location":"api/dev/NexusLabs.Needlr/IMethodInterceptor/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr/IMethodInterceptor/#imethodinterceptorinterceptasyncimethodinvocation-method","title":"IMethodInterceptor.InterceptAsync(IMethodInvocation) Method","text":"<p>Called when an intercepted method is invoked. Call  ProceedAsync() to continue to the next interceptor in the chain or to the actual method implementation.</p> <pre><code>System.Threading.Tasks.ValueTask&lt;object?&gt; InterceptAsync(NexusLabs.Needlr.IMethodInvocation invocation);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/IMethodInterceptor/#parameters","title":"Parameters","text":"<p><code>invocation</code> IMethodInvocation</p> <p>Context about the method being invoked, including the target instance, method metadata, and arguments.</p>"},{"location":"api/dev/NexusLabs.Needlr/IMethodInterceptor/#returns","title":"Returns","text":"<p>System.Threading.Tasks.ValueTask&lt;System.Object&gt; The result of the method invocation (or the modified result if the interceptor transforms it). For void methods, return <code>null</code>.</p>"},{"location":"api/dev/NexusLabs.Needlr/IMethodInvocation/","title":"IMethodInvocation","text":""},{"location":"api/dev/NexusLabs.Needlr/IMethodInvocation/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/IMethodInvocation/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/IMethodInvocation/#imethodinvocation-interface","title":"IMethodInvocation Interface","text":"<p>Represents a method invocation that is being intercepted. Provides access to the target instance, method metadata, and arguments.</p> <pre><code>public interface IMethodInvocation\n</code></pre> <p>Derived \u21b3 MethodInvocation</p>"},{"location":"api/dev/NexusLabs.Needlr/IMethodInvocation/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr/IMethodInvocation/#imethodinvocationarguments-property","title":"IMethodInvocation.Arguments Property","text":"<p>Gets the arguments passed to the method. The array can be modified to change argument values before calling ProceedAsync().</p> <pre><code>object?[] Arguments { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/IMethodInvocation/#property-value","title":"Property Value","text":"<p>System.Object[]</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/IMethodInvocation/#imethodinvocationgenericarguments-property","title":"IMethodInvocation.GenericArguments Property","text":"<p>Gets the generic type arguments if the method is a generic method. Returns an empty array for non-generic methods.</p> <pre><code>System.Type[] GenericArguments { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/IMethodInvocation/#property-value_1","title":"Property Value","text":"<p>System.Type[]</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/IMethodInvocation/#imethodinvocationmethod-property","title":"IMethodInvocation.Method Property","text":"<p>Gets metadata about the method being invoked.</p> <pre><code>System.Reflection.MethodInfo Method { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/IMethodInvocation/#property-value_2","title":"Property Value","text":"<p>System.Reflection.MethodInfo</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/IMethodInvocation/#imethodinvocationtarget-property","title":"IMethodInvocation.Target Property","text":"<p>Gets the target service instance on which the method is being invoked.</p> <pre><code>object Target { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/IMethodInvocation/#property-value_3","title":"Property Value","text":"<p>System.Object</p>"},{"location":"api/dev/NexusLabs.Needlr/IMethodInvocation/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr/IMethodInvocation/#imethodinvocationproceedasync-method","title":"IMethodInvocation.ProceedAsync() Method","text":"<p>Proceeds to the next interceptor in the chain, or to the actual method implementation if this is the last interceptor.</p> <pre><code>System.Threading.Tasks.ValueTask&lt;object?&gt; ProceedAsync();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/IMethodInvocation/#returns","title":"Returns","text":"<p>System.Threading.Tasks.ValueTask&lt;System.Object&gt; The result of the method (or the result from the next interceptor). Returns <code>null</code> for void methods.</p>"},{"location":"api/dev/NexusLabs.Needlr/IPluginFactory/","title":"IPluginFactory","text":""},{"location":"api/dev/NexusLabs.Needlr/IPluginFactory/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/IPluginFactory/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/IPluginFactory/#ipluginfactory-interface","title":"IPluginFactory Interface","text":"<p>Defines a factory for discovering and creating plugin instances from assemblies.</p> <pre><code>public interface IPluginFactory\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/IPluginFactory/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr/IPluginFactory/#ipluginfactorycreatepluginsfromassembliestplugintattributeienumerableassembly-method","title":"IPluginFactory.CreatePluginsFromAssemblies&lt;TPlugin,TAttribute&gt;(IEnumerable&lt;Assembly&gt;) Method","text":"<p>Creates instances of plugins of type TPlugin from the provided assemblies  that are also decorated with the specified attribute.</p> <pre><code>System.Collections.Generic.IEnumerable&lt;TPlugin&gt; CreatePluginsFromAssemblies&lt;TPlugin,TAttribute&gt;(System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt; assemblies)\n    where TPlugin : class\n    where TAttribute : System.Attribute;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/IPluginFactory/#type-parameters","title":"Type parameters","text":"<p><code>TPlugin</code></p> <p>The plugin interface or base type to search for.</p> <p></p> <p><code>TAttribute</code></p> <p>The attribute type to search for in the type hierarchy.</p>"},{"location":"api/dev/NexusLabs.Needlr/IPluginFactory/#parameters","title":"Parameters","text":"<p><code>assemblies</code> System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt;</p> <p>A collection of assemblies to scan for plugin types.</p>"},{"location":"api/dev/NexusLabs.Needlr/IPluginFactory/#returns","title":"Returns","text":"<p>System.Collections.Generic.IEnumerable&lt;TPlugin&gt; An enumerable of instantiated plugins implementing TPlugin and  decorated with TAttribute.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/IPluginFactory/#ipluginfactorycreatepluginsfromassembliestpluginienumerableassembly-method","title":"IPluginFactory.CreatePluginsFromAssemblies&lt;TPlugin&gt;(IEnumerable&lt;Assembly&gt;) Method","text":"<p>Creates instances of plugins of type TPlugin from the provided assemblies.</p> <pre><code>System.Collections.Generic.IEnumerable&lt;TPlugin&gt; CreatePluginsFromAssemblies&lt;TPlugin&gt;(System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt; assemblies)\n    where TPlugin : class;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/IPluginFactory/#type-parameters_1","title":"Type parameters","text":"<p><code>TPlugin</code></p> <p>The plugin interface or base type to search for.</p>"},{"location":"api/dev/NexusLabs.Needlr/IPluginFactory/#parameters_1","title":"Parameters","text":"<p><code>assemblies</code> System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt;</p> <p>A collection of assemblies to scan for plugin types.</p>"},{"location":"api/dev/NexusLabs.Needlr/IPluginFactory/#returns_1","title":"Returns","text":"<p>System.Collections.Generic.IEnumerable&lt;TPlugin&gt; An enumerable of instantiated plugins implementing TPlugin.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/IPluginFactory/#ipluginfactorycreatepluginswithattributefromassembliestattributeienumerableassembly-method","title":"IPluginFactory.CreatePluginsWithAttributeFromAssemblies&lt;TAttribute&gt;(IEnumerable&lt;Assembly&gt;) Method","text":"<p>Creates instances of plugins from the provided assemblies that are decorated with the specified attribute.</p> <pre><code>System.Collections.Generic.IEnumerable&lt;object&gt; CreatePluginsWithAttributeFromAssemblies&lt;TAttribute&gt;(System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt; assemblies)\n    where TAttribute : System.Attribute;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/IPluginFactory/#type-parameters_2","title":"Type parameters","text":"<p><code>TAttribute</code></p> <p>The attribute type to search for in the type hierarchy.</p>"},{"location":"api/dev/NexusLabs.Needlr/IPluginFactory/#parameters_2","title":"Parameters","text":"<p><code>assemblies</code> System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt;</p> <p>A collection of assemblies to scan for plugin types.</p>"},{"location":"api/dev/NexusLabs.Needlr/IPluginFactory/#returns_2","title":"Returns","text":"<p>System.Collections.Generic.IEnumerable&lt;System.Object&gt; An enumerable of instantiated plugins decorated with TAttribute.</p>"},{"location":"api/dev/NexusLabs.Needlr/IPostBuildServiceCollectionPlugin/","title":"IPostBuildServiceCollectionPlugin","text":""},{"location":"api/dev/NexusLabs.Needlr/IPostBuildServiceCollectionPlugin/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/IPostBuildServiceCollectionPlugin/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/IPostBuildServiceCollectionPlugin/#ipostbuildservicecollectionplugin-interface","title":"IPostBuildServiceCollectionPlugin Interface","text":"<p>Defines a plugin that executes after the service provider has been built. Implement this interface to perform configuration that requires access to the fully built service provider.</p> <pre><code>public interface IPostBuildServiceCollectionPlugin\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/IPostBuildServiceCollectionPlugin/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr/IPostBuildServiceCollectionPlugin/#ipostbuildservicecollectionpluginconfigurepostbuildservicecollectionpluginoptions-method","title":"IPostBuildServiceCollectionPlugin.Configure(PostBuildServiceCollectionPluginOptions) Method","text":"<p>Allows execution of additional configuration after the main service collection has been built.</p> <pre><code>void Configure(NexusLabs.Needlr.PostBuildServiceCollectionPluginOptions options);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/IPostBuildServiceCollectionPlugin/#parameters","title":"Parameters","text":"<p><code>options</code> PostBuildServiceCollectionPluginOptions</p>"},{"location":"api/dev/NexusLabs.Needlr/IServiceCatalog/","title":"IServiceCatalog","text":""},{"location":"api/dev/NexusLabs.Needlr/IServiceCatalog/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/IServiceCatalog/#nexuslabsneedlrcatalog","title":"NexusLabs.Needlr.Catalog","text":""},{"location":"api/dev/NexusLabs.Needlr/IServiceCatalog/#iservicecatalog-interface","title":"IServiceCatalog Interface","text":"<p>Provides compile-time service registration metadata. Generated by Needlr source generator when [GenerateTypeRegistry] is used.</p> <pre><code>public interface IServiceCatalog\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/IServiceCatalog/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr/IServiceCatalog/#iservicecatalogassemblyname-property","title":"IServiceCatalog.AssemblyName Property","text":"<p>Gets the assembly name this catalog was generated for.</p> <pre><code>string AssemblyName { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/IServiceCatalog/#property-value","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/IServiceCatalog/#iservicecatalogdecorators-property","title":"IServiceCatalog.Decorators Property","text":"<p>Gets all discovered decorator registrations.</p> <pre><code>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.DecoratorCatalogEntry&gt; Decorators { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/IServiceCatalog/#property-value_1","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;DecoratorCatalogEntry&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/IServiceCatalog/#iservicecataloggeneratedat-property","title":"IServiceCatalog.GeneratedAt Property","text":"<p>Gets the UTC timestamp when this catalog was generated.</p> <pre><code>string GeneratedAt { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/IServiceCatalog/#property-value_2","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/IServiceCatalog/#iservicecataloghostedservices-property","title":"IServiceCatalog.HostedServices Property","text":"<p>Gets all discovered hosted service registrations.</p> <pre><code>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.HostedServiceCatalogEntry&gt; HostedServices { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/IServiceCatalog/#property-value_3","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;HostedServiceCatalogEntry&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/IServiceCatalog/#iservicecataloginterceptedservices-property","title":"IServiceCatalog.InterceptedServices Property","text":"<p>Gets all discovered intercepted service registrations.</p> <pre><code>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.InterceptedServiceCatalogEntry&gt; InterceptedServices { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/IServiceCatalog/#property-value_4","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;InterceptedServiceCatalogEntry&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/IServiceCatalog/#iservicecatalogoptions-property","title":"IServiceCatalog.Options Property","text":"<p>Gets all discovered options/configuration bindings.</p> <pre><code>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.OptionsCatalogEntry&gt; Options { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/IServiceCatalog/#property-value_5","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;OptionsCatalogEntry&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/IServiceCatalog/#iservicecatalogplugins-property","title":"IServiceCatalog.Plugins Property","text":"<p>Gets all discovered plugin registrations.</p> <pre><code>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.PluginCatalogEntry&gt; Plugins { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/IServiceCatalog/#property-value_6","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;PluginCatalogEntry&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/IServiceCatalog/#iservicecatalogservices-property","title":"IServiceCatalog.Services Property","text":"<p>Gets all discovered service registrations.</p> <pre><code>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.ServiceCatalogEntry&gt; Services { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/IServiceCatalog/#property-value_7","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;ServiceCatalogEntry&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr/IServiceCollectionPlugin/","title":"IServiceCollectionPlugin","text":""},{"location":"api/dev/NexusLabs.Needlr/IServiceCollectionPlugin/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/IServiceCollectionPlugin/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/IServiceCollectionPlugin/#iservicecollectionplugin-interface","title":"IServiceCollectionPlugin Interface","text":"<p>Defines a plugin that participates in Needlr's Microsoft.Extensions.DependencyInjection.IServiceCollection configuration pipeline. Implement this interface to encapsulate a cohesive block of service registrations that can be discovered and applied automatically during startup.</p> <pre><code>public interface IServiceCollectionPlugin\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/IServiceCollectionPlugin/#example","title":"Example","text":"<pre><code>public class InfrastructurePlugin : IServiceCollectionPlugin\n{\n    public void Configure(ServiceCollectionPluginOptions options)\n    {\n        options.Services.AddSingleton&lt;IConnectionFactory, SqlConnectionFactory&gt;();\n        options.Services.AddScoped&lt;IUnitOfWork, SqlUnitOfWork&gt;();\n    }\n}\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/IServiceCollectionPlugin/#remarks","title":"Remarks","text":"<p>Plugins are discovered and invoked by the Needlr startup pipeline as part of its fluent setup chain. The DoNotAutoRegisterAttribute and DoNotInjectAttribute on this interface prevent Needlr from mistakenly registering it as a concrete service.</p> <p>Create a class that implements IServiceCollectionPlugin and place your registration logic in Configure(ServiceCollectionPluginOptions). Needlr will call Configure(ServiceCollectionPluginOptions) once during the startup assembly scan.</p> <p>Do not apply DoNotAutoRegisterAttribute directly to an implementing class. This interface already carries the attribute to prevent DI registration of the interface itself; adding it to the class too is redundant and was historically a silent bug that suppressed plugin discovery. Analyzer NDLRCOR016 will warn you if you do this.</p>"},{"location":"api/dev/NexusLabs.Needlr/IServiceCollectionPlugin/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr/IServiceCollectionPlugin/#iservicecollectionpluginconfigureservicecollectionpluginoptions-method","title":"IServiceCollectionPlugin.Configure(ServiceCollectionPluginOptions) Method","text":"<p>Configures the Microsoft.Extensions.DependencyInjection.IServiceCollection instance.</p> <pre><code>void Configure(NexusLabs.Needlr.ServiceCollectionPluginOptions options);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/IServiceCollectionPlugin/#parameters","title":"Parameters","text":"<p><code>options</code> ServiceCollectionPluginOptions</p>"},{"location":"api/dev/NexusLabs.Needlr/InterceptAttribute/","title":"InterceptAttribute","text":""},{"location":"api/dev/NexusLabs.Needlr/InterceptAttribute/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/InterceptAttribute/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/InterceptAttribute/#interceptattribute-class","title":"InterceptAttribute Class","text":"<p>Applies an interceptor to a class or method. When discovered by Needlr's source generator, a proxy class is generated that routes method calls through the specified interceptor(s).</p> <pre><code>public sealed class InterceptAttribute : System.Attribute\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 System.Attribute \ud83e\udc52 InterceptAttribute</p>"},{"location":"api/dev/NexusLabs.Needlr/InterceptAttribute/#example","title":"Example","text":"<pre><code>// Class-level interception (all methods)\n[Intercept(typeof(LoggingInterceptor))]\n[Scoped]\npublic class OrderService : IOrderService\n{\n    public Task&lt;Order&gt; GetOrderAsync(int id) =&gt; ...;\n    public Task CreateOrderAsync(Order order) =&gt; ...;\n}\n\n// Method-level interception\n[Scoped]\npublic class ProductService : IProductService\n{\n    [Intercept(typeof(CachingInterceptor))]\n    public Task&lt;Product&gt; GetProductAsync(int id) =&gt; ...;\n\n    // This method is NOT intercepted\n    public Task UpdateProductAsync(Product product) =&gt; ...;\n}\n\n// Multiple interceptors with ordering\n[Intercept(typeof(LoggingInterceptor), Order = 1)]\n[Intercept(typeof(TimingInterceptor), Order = 2)]\n[Scoped]\npublic class ReportService : IReportService { }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/InterceptAttribute/#remarks","title":"Remarks","text":"<p>This attribute can be applied at the class level (intercepts all methods) or at the method level (intercepts only that method).</p> <p>The interceptor type must implement IMethodInterceptor and will be resolved from the DI container, allowing it to have dependencies.</p> <p>When multiple interceptors are applied, use the Order property to control execution order. Lower values execute first (outermost in the chain).</p> <p>Note: Interceptors are only supported with source generation.             They are not available when using reflection-based registration.</p>"},{"location":"api/dev/NexusLabs.Needlr/InterceptAttribute/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr/InterceptAttribute/#interceptattributetype-constructor","title":"InterceptAttribute(Type) Constructor","text":"<p>Initializes a new instance of the InterceptAttribute class.</p> <pre><code>public InterceptAttribute(System.Type interceptorType);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/InterceptAttribute/#parameters","title":"Parameters","text":"<p><code>interceptorType</code> System.Type</p> <p>The type of the interceptor. Must implement IMethodInterceptor.</p>"},{"location":"api/dev/NexusLabs.Needlr/InterceptAttribute/#exceptions","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when interceptorType is null.</p>"},{"location":"api/dev/NexusLabs.Needlr/InterceptAttribute/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr/InterceptAttribute/#interceptattributeinterceptortype-property","title":"InterceptAttribute.InterceptorType Property","text":"<p>Gets the type of the interceptor to apply.</p> <pre><code>public System.Type InterceptorType { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/InterceptAttribute/#property-value","title":"Property Value","text":"<p>System.Type</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/InterceptAttribute/#interceptattributeorder-property","title":"InterceptAttribute.Order Property","text":"<p>Gets or sets the order in which this interceptor executes relative to other interceptors on the same target. Lower values execute first (outermost in the interceptor chain). Default is 0.</p> <pre><code>public int Order { get; set; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/InterceptAttribute/#property-value_1","title":"Property Value","text":"<p>System.Int32</p>"},{"location":"api/dev/NexusLabs.Needlr/InterceptAttribute/#remarks_1","title":"Remarks","text":"<p>Example with Order values: - Order = 1: LoggingInterceptor (executes first, wraps everything) - Order = 2: CachingInterceptor (executes second) - Order = 3: ValidationInterceptor (executes last, closest to actual method)</p>"},{"location":"api/dev/NexusLabs.Needlr/InterceptAttribute_TInterceptor_/","title":"InterceptAttribute TInterceptor","text":""},{"location":"api/dev/NexusLabs.Needlr/InterceptAttribute_TInterceptor_/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/InterceptAttribute_TInterceptor_/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/InterceptAttribute_TInterceptor_/#interceptattributetinterceptor-class","title":"InterceptAttribute&lt;TInterceptor&gt; Class","text":"<p>Applies an interceptor to a class or method. Generic version that provides compile-time type safety for the interceptor type.</p> <pre><code>public sealed class InterceptAttribute&lt;TInterceptor&gt; : System.Attribute\n    where TInterceptor : class, NexusLabs.Needlr.IMethodInterceptor\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/InterceptAttribute_TInterceptor_/#type-parameters","title":"Type parameters","text":"<p><code>TInterceptor</code></p> <p>The type of the interceptor. Must implement IMethodInterceptor.</p> <p>Inheritance System.Object \ud83e\udc52 System.Attribute \ud83e\udc52 InterceptAttribute\\&lt;TInterceptor&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr/InterceptAttribute_TInterceptor_/#example","title":"Example","text":"<pre><code>[Intercept&lt;LoggingInterceptor&gt;(Order = 1)]\n[Intercept&lt;CachingInterceptor&gt;(Order = 2)]\n[Scoped]\npublic class OrderService : IOrderService\n{\n    public Task&lt;Order&gt; GetOrderAsync(int id) =&gt; ...;\n}\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/InterceptAttribute_TInterceptor_/#remarks","title":"Remarks","text":"<p>This is the preferred form when the interceptor type is known at compile time. For dynamic scenarios, use the non-generic InterceptAttribute.</p> <p>See InterceptAttribute for full documentation and examples.</p>"},{"location":"api/dev/NexusLabs.Needlr/InterceptAttribute_TInterceptor_/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr/InterceptAttribute_TInterceptor_/#interceptattributetinterceptorinterceptortype-property","title":"InterceptAttribute&lt;TInterceptor&gt;.InterceptorType Property","text":"<p>Gets the type of the interceptor to apply.</p> <pre><code>public System.Type InterceptorType { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/InterceptAttribute_TInterceptor_/#property-value","title":"Property Value","text":"<p>System.Type</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/InterceptAttribute_TInterceptor_/#interceptattributetinterceptororder-property","title":"InterceptAttribute&lt;TInterceptor&gt;.Order Property","text":"<p>Gets or sets the order in which this interceptor executes relative to other interceptors on the same target. Lower values execute first (outermost in the interceptor chain). Default is 0.</p> <pre><code>public int Order { get; set; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/InterceptAttribute_TInterceptor_/#property-value_1","title":"Property Value","text":"<p>System.Int32</p>"},{"location":"api/dev/NexusLabs.Needlr/InterceptedServiceCatalogEntry/","title":"InterceptedServiceCatalogEntry","text":""},{"location":"api/dev/NexusLabs.Needlr/InterceptedServiceCatalogEntry/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/InterceptedServiceCatalogEntry/#nexuslabsneedlrcatalog","title":"NexusLabs.Needlr.Catalog","text":""},{"location":"api/dev/NexusLabs.Needlr/InterceptedServiceCatalogEntry/#interceptedservicecatalogentry-class","title":"InterceptedServiceCatalogEntry Class","text":"<p>Represents an intercepted service discovered at compile time.</p> <pre><code>public sealed record InterceptedServiceCatalogEntry : System.IEquatable&lt;NexusLabs.Needlr.Catalog.InterceptedServiceCatalogEntry&gt;\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 InterceptedServiceCatalogEntry</p> <p>Implements System.IEquatable&lt;InterceptedServiceCatalogEntry&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr/InterceptedServiceCatalogEntry/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr/InterceptedServiceCatalogEntry/#interceptedservicecatalogentrystring-string-string-servicecataloglifetime-ireadonlyliststring-ireadonlyliststring-string-constructor","title":"InterceptedServiceCatalogEntry(string, string, string, ServiceCatalogLifetime, IReadOnlyList&lt;string&gt;, IReadOnlyList&lt;string&gt;, string) Constructor","text":"<p>Represents an intercepted service discovered at compile time.</p> <pre><code>public InterceptedServiceCatalogEntry(string TypeName, string ShortTypeName, string AssemblyName, NexusLabs.Needlr.Catalog.ServiceCatalogLifetime Lifetime, System.Collections.Generic.IReadOnlyList&lt;string&gt; Interfaces, System.Collections.Generic.IReadOnlyList&lt;string&gt; InterceptorTypeNames, string? SourceFilePath=null);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/InterceptedServiceCatalogEntry/#parameters","title":"Parameters","text":"<p><code>TypeName</code> System.String</p> <p>The fully qualified name of the intercepted service type.</p> <p></p> <p><code>ShortTypeName</code> System.String</p> <p>The short name of the intercepted service type (without namespace).</p> <p></p> <p><code>AssemblyName</code> System.String</p> <p>The assembly name where this type is defined.</p> <p></p> <p><code>Lifetime</code> ServiceCatalogLifetime</p> <p>The service lifetime (Singleton, Scoped, Transient).</p> <p></p> <p><code>Interfaces</code> System.Collections.Generic.IReadOnlyList&lt;System.String&gt;</p> <p>The interfaces this type is registered as.</p> <p></p> <p><code>InterceptorTypeNames</code> System.Collections.Generic.IReadOnlyList&lt;System.String&gt;</p> <p>The interceptor type names applied to this service, in order.</p> <p></p> <p><code>SourceFilePath</code> System.String</p> <p>Source file path where the type is defined, if available.</p>"},{"location":"api/dev/NexusLabs.Needlr/InterceptedServiceCatalogEntry/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr/InterceptedServiceCatalogEntry/#interceptedservicecatalogentryassemblyname-property","title":"InterceptedServiceCatalogEntry.AssemblyName Property","text":"<p>The assembly name where this type is defined.</p> <pre><code>public string AssemblyName { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/InterceptedServiceCatalogEntry/#property-value","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/InterceptedServiceCatalogEntry/#interceptedservicecatalogentryinterceptortypenames-property","title":"InterceptedServiceCatalogEntry.InterceptorTypeNames Property","text":"<p>The interceptor type names applied to this service, in order.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;string&gt; InterceptorTypeNames { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/InterceptedServiceCatalogEntry/#property-value_1","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;System.String&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/InterceptedServiceCatalogEntry/#interceptedservicecatalogentryinterfaces-property","title":"InterceptedServiceCatalogEntry.Interfaces Property","text":"<p>The interfaces this type is registered as.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;string&gt; Interfaces { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/InterceptedServiceCatalogEntry/#property-value_2","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;System.String&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/InterceptedServiceCatalogEntry/#interceptedservicecatalogentrylifetime-property","title":"InterceptedServiceCatalogEntry.Lifetime Property","text":"<p>The service lifetime (Singleton, Scoped, Transient).</p> <pre><code>public NexusLabs.Needlr.Catalog.ServiceCatalogLifetime Lifetime { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/InterceptedServiceCatalogEntry/#property-value_3","title":"Property Value","text":"<p>ServiceCatalogLifetime</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/InterceptedServiceCatalogEntry/#interceptedservicecatalogentryshorttypename-property","title":"InterceptedServiceCatalogEntry.ShortTypeName Property","text":"<p>The short name of the intercepted service type (without namespace).</p> <pre><code>public string ShortTypeName { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/InterceptedServiceCatalogEntry/#property-value_4","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/InterceptedServiceCatalogEntry/#interceptedservicecatalogentrysourcefilepath-property","title":"InterceptedServiceCatalogEntry.SourceFilePath Property","text":"<p>Source file path where the type is defined, if available.</p> <pre><code>public string? SourceFilePath { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/InterceptedServiceCatalogEntry/#property-value_5","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/InterceptedServiceCatalogEntry/#interceptedservicecatalogentrytypename-property","title":"InterceptedServiceCatalogEntry.TypeName Property","text":"<p>The fully qualified name of the intercepted service type.</p> <pre><code>public string TypeName { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/InterceptedServiceCatalogEntry/#property-value_6","title":"Property Value","text":"<p>System.String</p>"},{"location":"api/dev/NexusLabs.Needlr/InterfaceEntry/","title":"InterfaceEntry","text":""},{"location":"api/dev/NexusLabs.Needlr/InterfaceEntry/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/InterfaceEntry/#nexuslabsneedlrcatalog","title":"NexusLabs.Needlr.Catalog","text":""},{"location":"api/dev/NexusLabs.Needlr/InterfaceEntry/#interfaceentry-class","title":"InterfaceEntry Class","text":"<p>Represents an interface with its source location information.</p> <pre><code>public sealed record InterfaceEntry : System.IEquatable&lt;NexusLabs.Needlr.Catalog.InterfaceEntry&gt;\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 InterfaceEntry</p> <p>Implements System.IEquatable&lt;InterfaceEntry&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr/InterfaceEntry/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr/InterfaceEntry/#interfaceentrystring-string-int-constructor","title":"InterfaceEntry(string, string, int) Constructor","text":"<p>Represents an interface with its source location information.</p> <pre><code>public InterfaceEntry(string FullName, string? SourceFilePath=null, int SourceLine=0);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/InterfaceEntry/#parameters","title":"Parameters","text":"<p><code>FullName</code> System.String</p> <p>The fully qualified name of the interface.</p> <p></p> <p><code>SourceFilePath</code> System.String</p> <p>Source file path where the interface is defined, if available.</p> <p></p> <p><code>SourceLine</code> System.Int32</p> <p>1-based line number where the interface is defined, or 0 if unknown.</p>"},{"location":"api/dev/NexusLabs.Needlr/InterfaceEntry/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr/InterfaceEntry/#interfaceentryfullname-property","title":"InterfaceEntry.FullName Property","text":"<p>The fully qualified name of the interface.</p> <pre><code>public string FullName { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/InterfaceEntry/#property-value","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/InterfaceEntry/#interfaceentrysourcefilepath-property","title":"InterfaceEntry.SourceFilePath Property","text":"<p>Source file path where the interface is defined, if available.</p> <pre><code>public string? SourceFilePath { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/InterfaceEntry/#property-value_1","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/InterfaceEntry/#interfaceentrysourceline-property","title":"InterfaceEntry.SourceLine Property","text":"<p>1-based line number where the interface is defined, or 0 if unknown.</p> <pre><code>public int SourceLine { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/InterfaceEntry/#property-value_2","title":"Property Value","text":"<p>System.Int32</p>"},{"location":"api/dev/NexusLabs.Needlr/KeyedAttribute/","title":"KeyedAttribute","text":""},{"location":"api/dev/NexusLabs.Needlr/KeyedAttribute/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/KeyedAttribute/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/KeyedAttribute/#keyedattribute-class","title":"KeyedAttribute Class","text":"<p>Marks a class for keyed service registration. The type will be registered with the specified service key in addition to its normal registration.</p> <pre><code>public sealed class KeyedAttribute : System.Attribute\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 System.Attribute \ud83e\udc52 KeyedAttribute</p>"},{"location":"api/dev/NexusLabs.Needlr/KeyedAttribute/#remarks","title":"Remarks","text":"<p>Use this attribute when you want to register multiple implementations of the same interface with different keys, allowing consumers to resolve specific implementations using <code>[FromKeyedServices(\"key\")]</code>.</p> <p>Example:</p> <pre><code>[Keyed(\"stripe\")]\npublic class StripeProcessor : IPaymentProcessor { }\n\n[Keyed(\"paypal\")]\npublic class PayPalProcessor : IPaymentProcessor { }\n\n// Consumer resolves specific implementation:\npublic class OrderService(\n    [FromKeyedServices(\"stripe\")] IPaymentProcessor processor) { }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/KeyedAttribute/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr/KeyedAttribute/#keyedattributestring-constructor","title":"KeyedAttribute(string) Constructor","text":"<p>Initializes a new instance of the KeyedAttribute class.</p> <pre><code>public KeyedAttribute(string key);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/KeyedAttribute/#parameters","title":"Parameters","text":"<p><code>key</code> System.String</p> <p>The service key for this registration.</p>"},{"location":"api/dev/NexusLabs.Needlr/KeyedAttribute/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr/KeyedAttribute/#keyedattributekey-property","title":"KeyedAttribute.Key Property","text":"<p>Gets the service key for this registration.</p> <pre><code>public string Key { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/KeyedAttribute/#property-value","title":"Property Value","text":"<p>System.String</p>"},{"location":"api/dev/NexusLabs.Needlr/LifetimeMismatch/","title":"LifetimeMismatch","text":""},{"location":"api/dev/NexusLabs.Needlr/LifetimeMismatch/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/LifetimeMismatch/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/LifetimeMismatch/#lifetimemismatch-class","title":"LifetimeMismatch Class","text":"<p>Represents a lifetime mismatch where a longer-lived service depends on a shorter-lived service. This is also known as a \"captive dependency\" and can lead to unexpected behavior.</p> <pre><code>public sealed record LifetimeMismatch : System.IEquatable&lt;NexusLabs.Needlr.LifetimeMismatch&gt;\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 LifetimeMismatch</p> <p>Implements System.IEquatable&lt;LifetimeMismatch&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr/LifetimeMismatch/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr/LifetimeMismatch/#lifetimemismatchtype-type-servicelifetime-type-servicelifetime-constructor","title":"LifetimeMismatch(Type, Type, ServiceLifetime, Type, ServiceLifetime) Constructor","text":"<p>Represents a lifetime mismatch where a longer-lived service depends on a shorter-lived service. This is also known as a \"captive dependency\" and can lead to unexpected behavior.</p> <pre><code>public LifetimeMismatch(System.Type ConsumerServiceType, System.Type? ConsumerImplementationType, Microsoft.Extensions.DependencyInjection.ServiceLifetime ConsumerLifetime, System.Type DependencyServiceType, Microsoft.Extensions.DependencyInjection.ServiceLifetime DependencyLifetime);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/LifetimeMismatch/#parameters","title":"Parameters","text":"<p><code>ConsumerServiceType</code> System.Type</p> <p>The service type that has the dependency.</p> <p></p> <p><code>ConsumerImplementationType</code> System.Type</p> <p>The implementation type that has the dependency.</p> <p></p> <p><code>ConsumerLifetime</code> Microsoft.Extensions.DependencyInjection.ServiceLifetime</p> <p>The lifetime of the consumer service.</p> <p></p> <p><code>DependencyServiceType</code> System.Type</p> <p>The service type being depended upon.</p> <p></p> <p><code>DependencyLifetime</code> Microsoft.Extensions.DependencyInjection.ServiceLifetime</p> <p>The lifetime of the dependency.</p>"},{"location":"api/dev/NexusLabs.Needlr/LifetimeMismatch/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr/LifetimeMismatch/#lifetimemismatchconsumerimplementationtype-property","title":"LifetimeMismatch.ConsumerImplementationType Property","text":"<p>The implementation type that has the dependency.</p> <pre><code>public System.Type? ConsumerImplementationType { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/LifetimeMismatch/#property-value","title":"Property Value","text":"<p>System.Type</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/LifetimeMismatch/#lifetimemismatchconsumerlifetime-property","title":"LifetimeMismatch.ConsumerLifetime Property","text":"<p>The lifetime of the consumer service.</p> <pre><code>public Microsoft.Extensions.DependencyInjection.ServiceLifetime ConsumerLifetime { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/LifetimeMismatch/#property-value_1","title":"Property Value","text":"<p>Microsoft.Extensions.DependencyInjection.ServiceLifetime</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/LifetimeMismatch/#lifetimemismatchconsumerservicetype-property","title":"LifetimeMismatch.ConsumerServiceType Property","text":"<p>The service type that has the dependency.</p> <pre><code>public System.Type ConsumerServiceType { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/LifetimeMismatch/#property-value_2","title":"Property Value","text":"<p>System.Type</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/LifetimeMismatch/#lifetimemismatchdependencylifetime-property","title":"LifetimeMismatch.DependencyLifetime Property","text":"<p>The lifetime of the dependency.</p> <pre><code>public Microsoft.Extensions.DependencyInjection.ServiceLifetime DependencyLifetime { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/LifetimeMismatch/#property-value_3","title":"Property Value","text":"<p>Microsoft.Extensions.DependencyInjection.ServiceLifetime</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/LifetimeMismatch/#lifetimemismatchdependencyservicetype-property","title":"LifetimeMismatch.DependencyServiceType Property","text":"<p>The service type being depended upon.</p> <pre><code>public System.Type DependencyServiceType { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/LifetimeMismatch/#property-value_4","title":"Property Value","text":"<p>System.Type</p>"},{"location":"api/dev/NexusLabs.Needlr/LifetimeMismatch/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr/LifetimeMismatch/#lifetimemismatchtodetailedstring-method","title":"LifetimeMismatch.ToDetailedString() Method","text":"<p>Returns a detailed, formatted string representation of this mismatch suitable for debugging and diagnostics.</p> <pre><code>public string ToDetailedString();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/LifetimeMismatch/#returns","title":"Returns","text":"<p>System.String</p>"},{"location":"api/dev/NexusLabs.Needlr/LifetimeMismatchExtensions/","title":"LifetimeMismatchExtensions","text":""},{"location":"api/dev/NexusLabs.Needlr/LifetimeMismatchExtensions/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/LifetimeMismatchExtensions/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/LifetimeMismatchExtensions/#lifetimemismatchextensions-class","title":"LifetimeMismatchExtensions Class","text":"<p>Extension methods for detecting lifetime mismatches (captive dependencies) in service registrations.</p> <pre><code>public static class LifetimeMismatchExtensions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 LifetimeMismatchExtensions</p>"},{"location":"api/dev/NexusLabs.Needlr/LifetimeMismatchExtensions/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr/LifetimeMismatchExtensions/#lifetimemismatchextensionsdetectlifetimemismatchesthis-iservicecollection-method","title":"LifetimeMismatchExtensions.DetectLifetimeMismatches(this IServiceCollection) Method","text":"<p>Detects lifetime mismatches (captive dependencies) in the service collection. A lifetime mismatch occurs when a longer-lived service depends on a shorter-lived service.</p> <pre><code>public static System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.LifetimeMismatch&gt; DetectLifetimeMismatches(this Microsoft.Extensions.DependencyInjection.IServiceCollection services);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/LifetimeMismatchExtensions/#parameters","title":"Parameters","text":"<p><code>services</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service collection to analyze.</p>"},{"location":"api/dev/NexusLabs.Needlr/LifetimeMismatchExtensions/#returns","title":"Returns","text":"<p>System.Collections.Generic.IReadOnlyList&lt;LifetimeMismatch&gt; A list of detected lifetime mismatches.</p>"},{"location":"api/dev/NexusLabs.Needlr/LifetimeMismatchExtensions/#exceptions","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when services is null.</p>"},{"location":"api/dev/NexusLabs.Needlr/LifetimeMismatchExtensions/#remarks","title":"Remarks","text":"<p>Lifetime hierarchy (from longest to shortest): - Singleton (lives for entire application lifetime) - Scoped (lives for the scope/request lifetime) - Transient (new instance every time)</p> <p>A mismatch occurs when a service with a longer lifetime depends on a service with a shorter lifetime. For example, a Singleton depending on a Scoped service will \"capture\" the scoped instance, causing it to live longer than intended.</p> <p>Factory registrations cannot be analyzed and are skipped.</p>"},{"location":"api/dev/NexusLabs.Needlr/MethodInvocation/","title":"MethodInvocation","text":""},{"location":"api/dev/NexusLabs.Needlr/MethodInvocation/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/MethodInvocation/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/MethodInvocation/#methodinvocation-class","title":"MethodInvocation Class","text":"<p>Default implementation of IMethodInvocation used by generated interceptor proxy classes.</p> <pre><code>public sealed class MethodInvocation : NexusLabs.Needlr.IMethodInvocation\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 MethodInvocation</p> <p>Implements IMethodInvocation</p>"},{"location":"api/dev/NexusLabs.Needlr/MethodInvocation/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr/MethodInvocation/#methodinvocationobject-methodinfo-object-funcvaluetaskobject-constructor","title":"MethodInvocation(object, MethodInfo, object[], Func&lt;ValueTask&lt;object&gt;&gt;) Constructor","text":"<p>Initializes a new instance of the MethodInvocation class for non-generic methods.</p> <pre><code>public MethodInvocation(object target, System.Reflection.MethodInfo method, object?[] arguments, System.Func&lt;System.Threading.Tasks.ValueTask&lt;object?&gt;&gt; proceed);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/MethodInvocation/#parameters","title":"Parameters","text":"<p><code>target</code> System.Object</p> <p>The target service instance.</p> <p></p> <p><code>method</code> System.Reflection.MethodInfo</p> <p>The method being invoked.</p> <p></p> <p><code>arguments</code> System.Object[]</p> <p>The arguments passed to the method.</p> <p></p> <p><code>proceed</code> System.Func&lt;System.Threading.Tasks.ValueTask&lt;System.Object&gt;&gt;</p> <p>A function that invokes the next interceptor or the actual method.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/MethodInvocation/#methodinvocationobject-methodinfo-object-type-funcvaluetaskobject-constructor","title":"MethodInvocation(object, MethodInfo, object[], Type[], Func&lt;ValueTask&lt;object&gt;&gt;) Constructor","text":"<p>Initializes a new instance of the MethodInvocation class.</p> <pre><code>public MethodInvocation(object target, System.Reflection.MethodInfo method, object?[] arguments, System.Type[] genericArguments, System.Func&lt;System.Threading.Tasks.ValueTask&lt;object?&gt;&gt; proceed);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/MethodInvocation/#parameters_1","title":"Parameters","text":"<p><code>target</code> System.Object</p> <p>The target service instance.</p> <p></p> <p><code>method</code> System.Reflection.MethodInfo</p> <p>The method being invoked.</p> <p></p> <p><code>arguments</code> System.Object[]</p> <p>The arguments passed to the method.</p> <p></p> <p><code>genericArguments</code> System.Type[]</p> <p>The generic type arguments (empty for non-generic methods).</p> <p></p> <p><code>proceed</code> System.Func&lt;System.Threading.Tasks.ValueTask&lt;System.Object&gt;&gt;</p> <p>A function that invokes the next interceptor or the actual method.</p>"},{"location":"api/dev/NexusLabs.Needlr/MethodInvocation/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr/MethodInvocation/#methodinvocationarguments-property","title":"MethodInvocation.Arguments Property","text":"<p>Gets the arguments passed to the method. The array can be modified to change argument values before calling ProceedAsync().</p> <pre><code>public object?[] Arguments { get; }\n</code></pre> <p>Implements Arguments</p>"},{"location":"api/dev/NexusLabs.Needlr/MethodInvocation/#property-value","title":"Property Value","text":"<p>System.Object[]</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/MethodInvocation/#methodinvocationgenericarguments-property","title":"MethodInvocation.GenericArguments Property","text":"<p>Gets the generic type arguments if the method is a generic method. Returns an empty array for non-generic methods.</p> <pre><code>public System.Type[] GenericArguments { get; }\n</code></pre> <p>Implements GenericArguments</p>"},{"location":"api/dev/NexusLabs.Needlr/MethodInvocation/#property-value_1","title":"Property Value","text":"<p>System.Type[]</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/MethodInvocation/#methodinvocationmethod-property","title":"MethodInvocation.Method Property","text":"<p>Gets metadata about the method being invoked.</p> <pre><code>public System.Reflection.MethodInfo Method { get; }\n</code></pre> <p>Implements Method</p>"},{"location":"api/dev/NexusLabs.Needlr/MethodInvocation/#property-value_2","title":"Property Value","text":"<p>System.Reflection.MethodInfo</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/MethodInvocation/#methodinvocationtarget-property","title":"MethodInvocation.Target Property","text":"<p>Gets the target service instance on which the method is being invoked.</p> <pre><code>public object Target { get; }\n</code></pre> <p>Implements Target</p>"},{"location":"api/dev/NexusLabs.Needlr/MethodInvocation/#property-value_3","title":"Property Value","text":"<p>System.Object</p>"},{"location":"api/dev/NexusLabs.Needlr/MethodInvocation/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr/MethodInvocation/#methodinvocationproceedasync-method","title":"MethodInvocation.ProceedAsync() Method","text":"<p>Proceeds to the next interceptor in the chain, or to the actual method implementation if this is the last interceptor.</p> <pre><code>public System.Threading.Tasks.ValueTask&lt;object?&gt; ProceedAsync();\n</code></pre> <p>Implements ProceedAsync()</p>"},{"location":"api/dev/NexusLabs.Needlr/MethodInvocation/#returns","title":"Returns","text":"<p>System.Threading.Tasks.ValueTask&lt;System.Object&gt; The result of the method (or the result from the next interceptor). Returns <code>null</code> for void methods.</p>"},{"location":"api/dev/NexusLabs.Needlr/NexusLabs.Needlr.Catalog/","title":"NexusLabs.Needlr.Catalog","text":""},{"location":"api/dev/NexusLabs.Needlr/NexusLabs.Needlr.Catalog/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/NexusLabs.Needlr.Catalog/#nexuslabsneedlrcatalog-namespace","title":"NexusLabs.Needlr.Catalog Namespace","text":"Classes ConstructorParameterEntry Represents a constructor parameter. DecoratorCatalogEntry Represents a decorator registration discovered at compile time. HostedServiceCatalogEntry Represents a hosted service registration discovered at compile time. InterceptedServiceCatalogEntry Represents an intercepted service discovered at compile time. InterfaceEntry Represents an interface with its source location information. OptionsCatalogEntry Represents an options/configuration binding discovered at compile time. PluginCatalogEntry Represents a plugin discovered at compile time. ServiceCatalogEntry Represents a service registration discovered at compile time. Interfaces IServiceCatalog Provides compile-time service registration metadata. Generated by Needlr source generator when [GenerateTypeRegistry] is used. Enums ServiceCatalogLifetime Service lifetime as discovered at compile time."},{"location":"api/dev/NexusLabs.Needlr/NexusLabs.Needlr/","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/NexusLabs.Needlr/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/NexusLabs.Needlr/#nexuslabsneedlr-namespace","title":"NexusLabs.Needlr Namespace","text":"Classes ContainerVerificationException Exception thrown when Needlr container verification detects one or more registered issues that are configured to fail-fast at startup. DecoratorForAttribute&lt;TService&gt; Marks a class as a decorator for the specified service type. When discovered by Needlr (via source generation or reflection), the decorator will be  automatically wired using AddDecorator&lt;TService,TDecorator&gt;(this IServiceCollection). DeferToContainerAttribute Specifies constructor parameter types for a partial class whose constructor will be generated by another source generator. DoNotAutoRegisterAttribute Prevents a class or interface from being automatically registered by Needlr's dependency injection discovery pipeline. DoNotInjectAttribute Prevents a class or interface from being injected as a dependency by Needlr. Types decorated with this attribute are discovered but excluded from service collection registration. DumpExtensions Extension methods for dumping service registration information for debugging. DumpOptions Options for customizing the output of Dump(this IServiceCollection, DumpOptions). InterceptAttribute Applies an interceptor to a class or method. When discovered by Needlr's source generator, a proxy class is generated that routes method calls through the specified interceptor(s). InterceptAttribute&lt;TInterceptor&gt; Applies an interceptor to a class or method. Generic version that provides compile-time type safety for the interceptor type. KeyedAttribute Marks a class for keyed service registration. The type will be registered with the specified service key in addition to its normal registration. LifetimeMismatch Represents a lifetime mismatch where a longer-lived service depends on a shorter-lived service. This is also known as a \"captive dependency\" and can lead to unexpected behavior. LifetimeMismatchExtensions Extension methods for detecting lifetime mismatches (captive dependencies) in service registrations. MethodInvocation Default implementation of IMethodInvocation used by generated interceptor proxy classes. PluginOrderAttribute Specifies the execution order for a plugin. Lower values execute first. Plugins without this attribute default to Order = 0. PostBuildServiceCollectionPluginOptions Options provided to IPostBuildServiceCollectionPlugin implementations during configuration. Contains the built service provider, configuration, discovered assemblies, and plugin factory. RegisterAsAttribute&lt;TInterface&gt; Specifies that the decorated class should only be registered as the specified interface type, rather than all interfaces it implements. ScopedAttribute Specifies that the decorated class should be registered with \\&lt;b&gt;Scoped\\&lt;/b&gt; lifetime. Scoped services are created once per scope \u2014 for example, once per HTTP request in ASP.NET Core. ServiceCollectionExtensions Extension methods for Microsoft.Extensions.DependencyInjection.IServiceCollection that add decorator wiring, service inspection, and registration-check utilities to the standard Microsoft DI container. ServiceCollectionPluginOptions Options provided to IServiceCollectionPlugin implementations during configuration. Contains the service collection, configuration, discovered assemblies, and plugin factory. ServiceCollectionVerificationExtensions Extension methods for verifying service collection configuration. ServiceProviderExtensions Extension methods for System.IServiceProvider to provide type inspection functionality. SingletonAttribute Specifies that the decorated class should be registered with \\&lt;b&gt;Singleton\\&lt;/b&gt; lifetime. Singleton services are created once for the lifetime of the application and reused for every request. SourceGenRegistry Static registry for source-generated registrations. TransientAttribute Specifies that the decorated class should be registered with \\&lt;b&gt;Transient\\&lt;/b&gt; lifetime. Transient services are created fresh every time they are resolved from the container. TypeExtensions Extension methods for System.Type to provide additional type inspection capabilities. VerificationIssue Represents a verification issue detected during container analysis. VerificationOptions Options for controlling container verification behavior. VerificationOptionsBuilder Builder for creating VerificationOptions with a fluent API. VerificationResult Result of container verification containing all detected issues. Structs ServiceRegistrationInfo Interfaces IMethodInterceptor Intercepts method invocations on a service. Implement this interface to create reusable cross-cutting concerns like logging, caching, or timing. IMethodInvocation Represents a method invocation that is being intercepted. Provides access to the target instance, method metadata, and arguments. IPluginFactory Defines a factory for discovering and creating plugin instances from assemblies. IPostBuildServiceCollectionPlugin Defines a plugin that executes after the service provider has been built. Implement this interface to perform configuration that requires access to the fully built service provider. IServiceCollectionPlugin Defines a plugin that participates in Needlr's Microsoft.Extensions.DependencyInjection.IServiceCollection configuration pipeline. Implement this interface to encapsulate a cohesive block of service registrations that can be discovered and applied automatically during startup. Enums VerificationBehavior Specifies the behavior when a verification issue is detected. VerificationIssueType The type of verification issue detected."},{"location":"api/dev/NexusLabs.Needlr/OptionsCatalogEntry/","title":"OptionsCatalogEntry","text":""},{"location":"api/dev/NexusLabs.Needlr/OptionsCatalogEntry/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/OptionsCatalogEntry/#nexuslabsneedlrcatalog","title":"NexusLabs.Needlr.Catalog","text":""},{"location":"api/dev/NexusLabs.Needlr/OptionsCatalogEntry/#optionscatalogentry-class","title":"OptionsCatalogEntry Class","text":"<p>Represents an options/configuration binding discovered at compile time.</p> <pre><code>public sealed record OptionsCatalogEntry : System.IEquatable&lt;NexusLabs.Needlr.Catalog.OptionsCatalogEntry&gt;\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 OptionsCatalogEntry</p> <p>Implements System.IEquatable&lt;OptionsCatalogEntry&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr/OptionsCatalogEntry/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr/OptionsCatalogEntry/#optionscatalogentrystring-string-string-string-string-bool-bool-bool-string-constructor","title":"OptionsCatalogEntry(string, string, string, string, string, bool, bool, bool, string) Constructor","text":"<p>Represents an options/configuration binding discovered at compile time.</p> <pre><code>public OptionsCatalogEntry(string TypeName, string ShortTypeName, string SectionName, string AssemblyName, string? Name=null, bool ValidateOnStart=false, bool HasValidator=false, bool HasDataAnnotations=false, string? SourceFilePath=null);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/OptionsCatalogEntry/#parameters","title":"Parameters","text":"<p><code>TypeName</code> System.String</p> <p>The fully qualified name of the options type.</p> <p></p> <p><code>ShortTypeName</code> System.String</p> <p>The short name of the options type (without namespace).</p> <p></p> <p><code>SectionName</code> System.String</p> <p>The configuration section name this options type binds to.</p> <p></p> <p><code>AssemblyName</code> System.String</p> <p>The assembly name where this type is defined.</p> <p></p> <p><code>Name</code> System.String</p> <p>The named options name, or null for default options.</p> <p></p> <p><code>ValidateOnStart</code> System.Boolean</p> <p>True if validation is performed on application start.</p> <p></p> <p><code>HasValidator</code> System.Boolean</p> <p>True if this options type has a validation method.</p> <p></p> <p><code>HasDataAnnotations</code> System.Boolean</p> <p>True if this options type has DataAnnotation validation attributes.</p> <p></p> <p><code>SourceFilePath</code> System.String</p> <p>Source file path where the type is defined, if available.</p>"},{"location":"api/dev/NexusLabs.Needlr/OptionsCatalogEntry/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr/OptionsCatalogEntry/#optionscatalogentryassemblyname-property","title":"OptionsCatalogEntry.AssemblyName Property","text":"<p>The assembly name where this type is defined.</p> <pre><code>public string AssemblyName { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/OptionsCatalogEntry/#property-value","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/OptionsCatalogEntry/#optionscatalogentryhasdataannotations-property","title":"OptionsCatalogEntry.HasDataAnnotations Property","text":"<p>True if this options type has DataAnnotation validation attributes.</p> <pre><code>public bool HasDataAnnotations { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/OptionsCatalogEntry/#property-value_1","title":"Property Value","text":"<p>System.Boolean</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/OptionsCatalogEntry/#optionscatalogentryhasvalidator-property","title":"OptionsCatalogEntry.HasValidator Property","text":"<p>True if this options type has a validation method.</p> <pre><code>public bool HasValidator { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/OptionsCatalogEntry/#property-value_2","title":"Property Value","text":"<p>System.Boolean</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/OptionsCatalogEntry/#optionscatalogentryname-property","title":"OptionsCatalogEntry.Name Property","text":"<p>The named options name, or null for default options.</p> <pre><code>public string? Name { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/OptionsCatalogEntry/#property-value_3","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/OptionsCatalogEntry/#optionscatalogentrysectionname-property","title":"OptionsCatalogEntry.SectionName Property","text":"<p>The configuration section name this options type binds to.</p> <pre><code>public string SectionName { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/OptionsCatalogEntry/#property-value_4","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/OptionsCatalogEntry/#optionscatalogentryshorttypename-property","title":"OptionsCatalogEntry.ShortTypeName Property","text":"<p>The short name of the options type (without namespace).</p> <pre><code>public string ShortTypeName { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/OptionsCatalogEntry/#property-value_5","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/OptionsCatalogEntry/#optionscatalogentrysourcefilepath-property","title":"OptionsCatalogEntry.SourceFilePath Property","text":"<p>Source file path where the type is defined, if available.</p> <pre><code>public string? SourceFilePath { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/OptionsCatalogEntry/#property-value_6","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/OptionsCatalogEntry/#optionscatalogentrytypename-property","title":"OptionsCatalogEntry.TypeName Property","text":"<p>The fully qualified name of the options type.</p> <pre><code>public string TypeName { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/OptionsCatalogEntry/#property-value_7","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/OptionsCatalogEntry/#optionscatalogentryvalidateonstart-property","title":"OptionsCatalogEntry.ValidateOnStart Property","text":"<p>True if validation is performed on application start.</p> <pre><code>public bool ValidateOnStart { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/OptionsCatalogEntry/#property-value_8","title":"Property Value","text":"<p>System.Boolean</p>"},{"location":"api/dev/NexusLabs.Needlr/PluginCatalogEntry/","title":"PluginCatalogEntry","text":""},{"location":"api/dev/NexusLabs.Needlr/PluginCatalogEntry/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/PluginCatalogEntry/#nexuslabsneedlrcatalog","title":"NexusLabs.Needlr.Catalog","text":""},{"location":"api/dev/NexusLabs.Needlr/PluginCatalogEntry/#plugincatalogentry-class","title":"PluginCatalogEntry Class","text":"<p>Represents a plugin discovered at compile time.</p> <pre><code>public sealed record PluginCatalogEntry : System.IEquatable&lt;NexusLabs.Needlr.Catalog.PluginCatalogEntry&gt;\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 PluginCatalogEntry</p> <p>Implements System.IEquatable&lt;PluginCatalogEntry&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr/PluginCatalogEntry/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr/PluginCatalogEntry/#plugincatalogentrystring-string-ireadonlyliststring-string-int-string-constructor","title":"PluginCatalogEntry(string, string, IReadOnlyList&lt;string&gt;, string, int, string) Constructor","text":"<p>Represents a plugin discovered at compile time.</p> <pre><code>public PluginCatalogEntry(string TypeName, string ShortTypeName, System.Collections.Generic.IReadOnlyList&lt;string&gt; Interfaces, string AssemblyName, int Order=0, string? SourceFilePath=null);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/PluginCatalogEntry/#parameters","title":"Parameters","text":"<p><code>TypeName</code> System.String</p> <p>The fully qualified name of the plugin type.</p> <p></p> <p><code>ShortTypeName</code> System.String</p> <p>The short name of the plugin type (without namespace).</p> <p></p> <p><code>Interfaces</code> System.Collections.Generic.IReadOnlyList&lt;System.String&gt;</p> <p>The plugin interfaces this type implements.</p> <p></p> <p><code>AssemblyName</code> System.String</p> <p>The assembly name where this type is defined.</p> <p></p> <p><code>Order</code> System.Int32</p> <p>The execution order of this plugin.</p> <p></p> <p><code>SourceFilePath</code> System.String</p> <p>Source file path where the type is defined, if available.</p>"},{"location":"api/dev/NexusLabs.Needlr/PluginCatalogEntry/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr/PluginCatalogEntry/#plugincatalogentryassemblyname-property","title":"PluginCatalogEntry.AssemblyName Property","text":"<p>The assembly name where this type is defined.</p> <pre><code>public string AssemblyName { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/PluginCatalogEntry/#property-value","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/PluginCatalogEntry/#plugincatalogentryinterfaces-property","title":"PluginCatalogEntry.Interfaces Property","text":"<p>The plugin interfaces this type implements.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;string&gt; Interfaces { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/PluginCatalogEntry/#property-value_1","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;System.String&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/PluginCatalogEntry/#plugincatalogentryorder-property","title":"PluginCatalogEntry.Order Property","text":"<p>The execution order of this plugin.</p> <pre><code>public int Order { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/PluginCatalogEntry/#property-value_2","title":"Property Value","text":"<p>System.Int32</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/PluginCatalogEntry/#plugincatalogentryshorttypename-property","title":"PluginCatalogEntry.ShortTypeName Property","text":"<p>The short name of the plugin type (without namespace).</p> <pre><code>public string ShortTypeName { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/PluginCatalogEntry/#property-value_3","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/PluginCatalogEntry/#plugincatalogentrysourcefilepath-property","title":"PluginCatalogEntry.SourceFilePath Property","text":"<p>Source file path where the type is defined, if available.</p> <pre><code>public string? SourceFilePath { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/PluginCatalogEntry/#property-value_4","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/PluginCatalogEntry/#plugincatalogentrytypename-property","title":"PluginCatalogEntry.TypeName Property","text":"<p>The fully qualified name of the plugin type.</p> <pre><code>public string TypeName { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/PluginCatalogEntry/#property-value_5","title":"Property Value","text":"<p>System.String</p>"},{"location":"api/dev/NexusLabs.Needlr/PluginOrderAttribute/","title":"PluginOrderAttribute","text":""},{"location":"api/dev/NexusLabs.Needlr/PluginOrderAttribute/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/PluginOrderAttribute/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/PluginOrderAttribute/#pluginorderattribute-class","title":"PluginOrderAttribute Class","text":"<p>Specifies the execution order for a plugin. Lower values execute first. Plugins without this attribute default to Order = 0.</p> <pre><code>public sealed class PluginOrderAttribute : System.Attribute\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 System.Attribute \ud83e\udc52 PluginOrderAttribute</p>"},{"location":"api/dev/NexusLabs.Needlr/PluginOrderAttribute/#remarks","title":"Remarks","text":"<p>Use this attribute to control the order in which plugins are executed. This is useful when plugins have dependencies on each other or when certain plugins must run before or after others.</p> <p>Example usage:</p> <pre><code>// Infrastructure plugins run first (negative order)\n[PluginOrder(-100)]\npublic class DatabaseMigrationPlugin : IServiceCollectionPlugin { }\n\n// Default order (0) - no attribute needed\npublic class BusinessLogicPlugin : IServiceCollectionPlugin { }\n\n// Validation plugins run last (positive order)\n[PluginOrder(100)]\npublic class ValidationPlugin : IServiceCollectionPlugin { }\n</code></pre> <p>When multiple plugins have the same order, they are sorted alphabetically by their fully qualified type name to ensure deterministic execution order.</p>"},{"location":"api/dev/NexusLabs.Needlr/PluginOrderAttribute/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr/PluginOrderAttribute/#pluginorderattributeint-constructor","title":"PluginOrderAttribute(int) Constructor","text":"<p>Initializes a new instance of PluginOrderAttribute with the specified order.</p> <pre><code>public PluginOrderAttribute(int order);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/PluginOrderAttribute/#parameters","title":"Parameters","text":"<p><code>order</code> System.Int32</p> <p>The execution order. Lower values execute first.  Negative values run before default (0), positive values run after.</p>"},{"location":"api/dev/NexusLabs.Needlr/PluginOrderAttribute/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr/PluginOrderAttribute/#pluginorderattributeorder-property","title":"PluginOrderAttribute.Order Property","text":"<p>Gets the execution order. Lower values execute first.</p> <pre><code>public int Order { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/PluginOrderAttribute/#property-value","title":"Property Value","text":"<p>System.Int32</p>"},{"location":"api/dev/NexusLabs.Needlr/PostBuildServiceCollectionPluginOptions/","title":"PostBuildServiceCollectionPluginOptions","text":""},{"location":"api/dev/NexusLabs.Needlr/PostBuildServiceCollectionPluginOptions/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/PostBuildServiceCollectionPluginOptions/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/PostBuildServiceCollectionPluginOptions/#postbuildservicecollectionpluginoptions-class","title":"PostBuildServiceCollectionPluginOptions Class","text":"<p>Options provided to IPostBuildServiceCollectionPlugin implementations during configuration. Contains the built service provider, configuration, discovered assemblies, and plugin factory.</p> <pre><code>public sealed record PostBuildServiceCollectionPluginOptions : System.IEquatable&lt;NexusLabs.Needlr.PostBuildServiceCollectionPluginOptions&gt;\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 PostBuildServiceCollectionPluginOptions</p> <p>Implements System.IEquatable&lt;PostBuildServiceCollectionPluginOptions&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr/PostBuildServiceCollectionPluginOptions/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr/PostBuildServiceCollectionPluginOptions/#postbuildservicecollectionpluginoptionsiserviceprovider-iconfiguration-ireadonlylistassembly-ipluginfactory-constructor","title":"PostBuildServiceCollectionPluginOptions(IServiceProvider, IConfiguration, IReadOnlyList&lt;Assembly&gt;, IPluginFactory) Constructor","text":"<p>Options provided to IPostBuildServiceCollectionPlugin implementations during configuration. Contains the built service provider, configuration, discovered assemblies, and plugin factory.</p> <pre><code>public PostBuildServiceCollectionPluginOptions(System.IServiceProvider Provider, Microsoft.Extensions.Configuration.IConfiguration Config, System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt; Assemblies, NexusLabs.Needlr.IPluginFactory PluginFactory);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/PostBuildServiceCollectionPluginOptions/#parameters","title":"Parameters","text":"<p><code>Provider</code> System.IServiceProvider</p> <p>The built service provider for resolving dependencies.</p> <p></p> <p><code>Config</code> Microsoft.Extensions.Configuration.IConfiguration</p> <p>The application configuration.</p> <p></p> <p><code>Assemblies</code> System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt;</p> <p>The list of assemblies discovered by Needlr.</p> <p></p> <p><code>PluginFactory</code> IPluginFactory</p> <p>Factory for creating additional plugin instances.</p>"},{"location":"api/dev/NexusLabs.Needlr/PostBuildServiceCollectionPluginOptions/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr/PostBuildServiceCollectionPluginOptions/#postbuildservicecollectionpluginoptionsassemblies-property","title":"PostBuildServiceCollectionPluginOptions.Assemblies Property","text":"<p>The list of assemblies discovered by Needlr.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt; Assemblies { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/PostBuildServiceCollectionPluginOptions/#property-value","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/PostBuildServiceCollectionPluginOptions/#postbuildservicecollectionpluginoptionsconfig-property","title":"PostBuildServiceCollectionPluginOptions.Config Property","text":"<p>The application configuration.</p> <pre><code>public Microsoft.Extensions.Configuration.IConfiguration Config { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/PostBuildServiceCollectionPluginOptions/#property-value_1","title":"Property Value","text":"<p>Microsoft.Extensions.Configuration.IConfiguration</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/PostBuildServiceCollectionPluginOptions/#postbuildservicecollectionpluginoptionspluginfactory-property","title":"PostBuildServiceCollectionPluginOptions.PluginFactory Property","text":"<p>Factory for creating additional plugin instances.</p> <pre><code>public NexusLabs.Needlr.IPluginFactory PluginFactory { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/PostBuildServiceCollectionPluginOptions/#property-value_2","title":"Property Value","text":"<p>IPluginFactory</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/PostBuildServiceCollectionPluginOptions/#postbuildservicecollectionpluginoptionsprovider-property","title":"PostBuildServiceCollectionPluginOptions.Provider Property","text":"<p>The built service provider for resolving dependencies.</p> <pre><code>public System.IServiceProvider Provider { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/PostBuildServiceCollectionPluginOptions/#property-value_3","title":"Property Value","text":"<p>System.IServiceProvider</p>"},{"location":"api/dev/NexusLabs.Needlr/RegisterAsAttribute_TInterface_/","title":"RegisterAsAttribute TInterface","text":""},{"location":"api/dev/NexusLabs.Needlr/RegisterAsAttribute_TInterface_/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/RegisterAsAttribute_TInterface_/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/RegisterAsAttribute_TInterface_/#registerasattributetinterface-class","title":"RegisterAsAttribute&lt;TInterface&gt; Class","text":"<p>Specifies that the decorated class should only be registered as the specified interface type, rather than all interfaces it implements.</p> <pre><code>public sealed class RegisterAsAttribute&lt;TInterface&gt; : System.Attribute\n    where TInterface : class\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/RegisterAsAttribute_TInterface_/#type-parameters","title":"Type parameters","text":"<p><code>TInterface</code></p> <p>The interface type to register as. Must be an interface implemented by the decorated class.</p> <p>Inheritance System.Object \ud83e\udc52 System.Attribute \ud83e\udc52 RegisterAsAttribute\\&lt;TInterface&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr/RegisterAsAttribute_TInterface_/#example","title":"Example","text":"<pre><code>public interface IReader { string Read(); }\npublic interface IWriter { void Write(string data); }\npublic interface ILogger { void Log(string message); }\n\n// Only registered as IReader - not as IWriter or ILogger\n[RegisterAs&lt;IReader&gt;]\npublic class FileService : IReader, IWriter, ILogger\n{\n    public string Read() =&gt; \"data\";\n    public void Write(string data) { }\n    public void Log(string message) { }\n}\n\n// Register as multiple specific interfaces\n[RegisterAs&lt;IReader&gt;]\n[RegisterAs&lt;IWriter&gt;]\npublic class DualService : IReader, IWriter, ILogger\n{\n    // Registered as IReader and IWriter, but NOT as ILogger\n}\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/RegisterAsAttribute_TInterface_/#remarks","title":"Remarks","text":"<p>By default, Needlr registers a class as all non-system interfaces it implements. Use this attribute when you want explicit control over which interface(s) are publicly  resolvable from the container.</p> <p>When this attribute is present, the class will ONLY be registered as the specified interface(s) and as itself (the concrete type). Other implemented interfaces will not be registered.</p> <p>Multiple [RegisterAs] attributes can be applied to register the class as multiple specific interfaces while still excluding others."},{"location":"api/dev/NexusLabs.Needlr/RegisterAsAttribute_TInterface_/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr/RegisterAsAttribute_TInterface_/#registerasattributetinterfaceinterfacetype-property","title":"RegisterAsAttribute&lt;TInterface&gt;.InterfaceType Property","text":"<p>Gets the interface type that the class should be registered as.</p> <pre><code>public System.Type InterfaceType { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/RegisterAsAttribute_TInterface_/#property-value","title":"Property Value","text":"<p>System.Type</p>"},{"location":"api/dev/NexusLabs.Needlr/ScopedAttribute/","title":"ScopedAttribute","text":""},{"location":"api/dev/NexusLabs.Needlr/ScopedAttribute/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/ScopedAttribute/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/ScopedAttribute/#scopedattribute-class","title":"ScopedAttribute Class","text":"<p>Specifies that the decorated class should be registered with \\&lt;b&gt;Scoped\\&lt;/b&gt; lifetime. Scoped services are created once per scope \u2014 for example, once per HTTP request in ASP.NET Core.</p> <pre><code>public sealed class ScopedAttribute : System.Attribute\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 System.Attribute \ud83e\udc52 ScopedAttribute</p>"},{"location":"api/dev/NexusLabs.Needlr/ScopedAttribute/#example","title":"Example","text":"<pre><code>[Scoped]\npublic class OrderRepository : IOrderRepository\n{\n    // Created once per HTTP request / DI scope\n}\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ScopedAttribute/#remarks","title":"Remarks","text":"<p>Use <code>[Scoped]</code> when a service must share state across multiple calls within the same logical operation (e.g., a request), but must not be shared across operations.</p> <p>Without this attribute, Needlr registers classes as Singleton by default. Apply <code>[Scoped]</code> to override that default.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCatalogEntry/","title":"ServiceCatalogEntry","text":""},{"location":"api/dev/NexusLabs.Needlr/ServiceCatalogEntry/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/ServiceCatalogEntry/#nexuslabsneedlrcatalog","title":"NexusLabs.Needlr.Catalog","text":""},{"location":"api/dev/NexusLabs.Needlr/ServiceCatalogEntry/#servicecatalogentry-class","title":"ServiceCatalogEntry Class","text":"<p>Represents a service registration discovered at compile time.</p> <pre><code>public sealed record ServiceCatalogEntry : System.IEquatable&lt;NexusLabs.Needlr.Catalog.ServiceCatalogEntry&gt;\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 ServiceCatalogEntry</p> <p>Implements System.IEquatable&lt;ServiceCatalogEntry&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCatalogEntry/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr/ServiceCatalogEntry/#servicecatalogentrystring-string-string-servicecataloglifetime-ireadonlyliststring-ireadonlylistconstructorparameterentry-ireadonlyliststring-string-int-ireadonlylistinterfaceentry-constructor","title":"ServiceCatalogEntry(string, string, string, ServiceCatalogLifetime, IReadOnlyList&lt;string&gt;, IReadOnlyList&lt;ConstructorParameterEntry&gt;, IReadOnlyList&lt;string&gt;, string, int, IReadOnlyList&lt;InterfaceEntry&gt;) Constructor","text":"<p>Represents a service registration discovered at compile time.</p> <pre><code>public ServiceCatalogEntry(string TypeName, string ShortTypeName, string AssemblyName, NexusLabs.Needlr.Catalog.ServiceCatalogLifetime Lifetime, System.Collections.Generic.IReadOnlyList&lt;string&gt; Interfaces, System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.ConstructorParameterEntry&gt; ConstructorParameters, System.Collections.Generic.IReadOnlyList&lt;string&gt; ServiceKeys, string? SourceFilePath=null, int SourceLine=0, System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.InterfaceEntry&gt;? InterfaceEntries=null);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCatalogEntry/#parameters","title":"Parameters","text":"<p><code>TypeName</code> System.String</p> <p>The fully qualified name of the implementation type.</p> <p></p> <p><code>ShortTypeName</code> System.String</p> <p>The short name of the implementation type (without namespace).</p> <p></p> <p><code>AssemblyName</code> System.String</p> <p>The assembly name where this type is defined.</p> <p></p> <p><code>Lifetime</code> ServiceCatalogLifetime</p> <p>The service lifetime (Singleton, Scoped, Transient).</p> <p></p> <p><code>Interfaces</code> System.Collections.Generic.IReadOnlyList&lt;System.String&gt;</p> <p>The interfaces this type is registered as.</p> <p></p> <p><code>ConstructorParameters</code> System.Collections.Generic.IReadOnlyList&lt;ConstructorParameterEntry&gt;</p> <p>Constructor parameter type names.</p> <p></p> <p><code>ServiceKeys</code> System.Collections.Generic.IReadOnlyList&lt;System.String&gt;</p> <p>Service keys if registered as keyed service.</p> <p></p> <p><code>SourceFilePath</code> System.String</p> <p>Source file path where the type is defined, if available.</p> <p></p> <p><code>SourceLine</code> System.Int32</p> <p>1-based line number where the type is defined, or 0 if unknown.</p> <p></p> <p><code>InterfaceEntries</code> System.Collections.Generic.IReadOnlyList&lt;InterfaceEntry&gt;</p> <p>Detailed interface information including source locations.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCatalogEntry/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr/ServiceCatalogEntry/#servicecatalogentryassemblyname-property","title":"ServiceCatalogEntry.AssemblyName Property","text":"<p>The assembly name where this type is defined.</p> <pre><code>public string AssemblyName { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCatalogEntry/#property-value","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCatalogEntry/#servicecatalogentryconstructorparameters-property","title":"ServiceCatalogEntry.ConstructorParameters Property","text":"<p>Constructor parameter type names.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.ConstructorParameterEntry&gt; ConstructorParameters { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCatalogEntry/#property-value_1","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;ConstructorParameterEntry&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCatalogEntry/#servicecatalogentryinterfaceentries-property","title":"ServiceCatalogEntry.InterfaceEntries Property","text":"<p>Detailed interface information including source locations.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.InterfaceEntry&gt;? InterfaceEntries { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCatalogEntry/#property-value_2","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;InterfaceEntry&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCatalogEntry/#servicecatalogentryinterfaces-property","title":"ServiceCatalogEntry.Interfaces Property","text":"<p>The interfaces this type is registered as.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;string&gt; Interfaces { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCatalogEntry/#property-value_3","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;System.String&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCatalogEntry/#servicecatalogentrylifetime-property","title":"ServiceCatalogEntry.Lifetime Property","text":"<p>The service lifetime (Singleton, Scoped, Transient).</p> <pre><code>public NexusLabs.Needlr.Catalog.ServiceCatalogLifetime Lifetime { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCatalogEntry/#property-value_4","title":"Property Value","text":"<p>ServiceCatalogLifetime</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCatalogEntry/#servicecatalogentryservicekeys-property","title":"ServiceCatalogEntry.ServiceKeys Property","text":"<p>Service keys if registered as keyed service.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;string&gt; ServiceKeys { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCatalogEntry/#property-value_5","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;System.String&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCatalogEntry/#servicecatalogentryshorttypename-property","title":"ServiceCatalogEntry.ShortTypeName Property","text":"<p>The short name of the implementation type (without namespace).</p> <pre><code>public string ShortTypeName { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCatalogEntry/#property-value_6","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCatalogEntry/#servicecatalogentrysourcefilepath-property","title":"ServiceCatalogEntry.SourceFilePath Property","text":"<p>Source file path where the type is defined, if available.</p> <pre><code>public string? SourceFilePath { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCatalogEntry/#property-value_7","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCatalogEntry/#servicecatalogentrysourceline-property","title":"ServiceCatalogEntry.SourceLine Property","text":"<p>1-based line number where the type is defined, or 0 if unknown.</p> <pre><code>public int SourceLine { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCatalogEntry/#property-value_8","title":"Property Value","text":"<p>System.Int32</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCatalogEntry/#servicecatalogentrytypename-property","title":"ServiceCatalogEntry.TypeName Property","text":"<p>The fully qualified name of the implementation type.</p> <pre><code>public string TypeName { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCatalogEntry/#property-value_9","title":"Property Value","text":"<p>System.String</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCatalogLifetime/","title":"ServiceCatalogLifetime","text":""},{"location":"api/dev/NexusLabs.Needlr/ServiceCatalogLifetime/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/ServiceCatalogLifetime/#nexuslabsneedlrcatalog","title":"NexusLabs.Needlr.Catalog","text":""},{"location":"api/dev/NexusLabs.Needlr/ServiceCatalogLifetime/#servicecataloglifetime-enum","title":"ServiceCatalogLifetime Enum","text":"<p>Service lifetime as discovered at compile time.</p> <pre><code>public enum ServiceCatalogLifetime\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/","title":"ServiceCollectionExtensions","text":""},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/#servicecollectionextensions-class","title":"ServiceCollectionExtensions Class","text":"<p>Extension methods for Microsoft.Extensions.DependencyInjection.IServiceCollection that add decorator wiring, service inspection, and registration-check utilities to the standard Microsoft DI container.</p> <pre><code>public static class ServiceCollectionExtensions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 ServiceCollectionExtensions</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/#remarks","title":"Remarks","text":"<p>The primary extension in this class is <code>AddDecorator</code>, which wraps an already-registered service with a decorator while preserving the original service's lifetime. This complements the attribute-based DecoratorForAttribute&lt;TService&gt; used with Needlr's source generation and reflection scanning.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/#servicecollectionextensionsadddecoratorthis-iservicecollection-type-type-method","title":"ServiceCollectionExtensions.AddDecorator(this IServiceCollection, Type, Type) Method","text":"<p>Decorates an existing service registration with a decorator type, preserving the original service's lifetime. The decorator must implement the service interface and take the service interface as a constructor parameter. Works with both interfaces and class types.</p> <pre><code>public static Microsoft.Extensions.DependencyInjection.IServiceCollection AddDecorator(this Microsoft.Extensions.DependencyInjection.IServiceCollection services, System.Type serviceType, System.Type decoratorType);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/#parameters","title":"Parameters","text":"<p><code>services</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service collection to modify.</p> <p></p> <p><code>serviceType</code> System.Type</p> <p>The service type (interface or class) to decorate.</p> <p></p> <p><code>decoratorType</code> System.Type</p> <p>The decorator type that implements the service type.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/#returns","title":"Returns","text":"<p>Microsoft.Extensions.DependencyInjection.IServiceCollection The service collection for method chaining.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/#exceptions","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when services, serviceType, or decoratorType is null.</p> <p>System.InvalidOperationException Thrown when no service registration is found for the service type.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/#example","title":"Example","text":"<pre><code>// Register the original service\nservices.AddScoped&lt;IMyService, MyService&gt;();\n\n// Decorate it while preserving the scoped lifetime\nservices.AddDecorator(typeof(IMyService), typeof(MyServiceDecorator));\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/#servicecollectionextensionsadddecoratortservicetdecoratorthis-iservicecollection-method","title":"ServiceCollectionExtensions.AddDecorator&lt;TService,TDecorator&gt;(this IServiceCollection) Method","text":"<p>Decorates an existing service registration with a decorator type, preserving the original service's lifetime. The decorator must implement the service interface and take the service interface as a constructor parameter. Works with both interfaces and class types.</p> <pre><code>public static Microsoft.Extensions.DependencyInjection.IServiceCollection AddDecorator&lt;TService,TDecorator&gt;(this Microsoft.Extensions.DependencyInjection.IServiceCollection services)\n    where TDecorator : class, TService;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/#type-parameters","title":"Type parameters","text":"<p><code>TService</code></p> <p>The service type (interface or class) to decorate.</p> <p></p> <p><code>TDecorator</code></p> <p>The decorator type that implements TService.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/#parameters_1","title":"Parameters","text":"<p><code>services</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service collection to modify.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/#returns_1","title":"Returns","text":"<p>Microsoft.Extensions.DependencyInjection.IServiceCollection The service collection for method chaining.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/#exceptions_1","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when services is null.</p> <p>System.InvalidOperationException Thrown when no service registration is found for TService.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/#example_1","title":"Example","text":"<pre><code>// Register the original service\nservices.AddScoped&lt;IMyService, MyService&gt;();\n\n// Decorate it while preserving the scoped lifetime\nservices.AddDecorator&lt;IMyService, MyServiceDecorator&gt;();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/#servicecollectionextensionsgetserviceregistrationsthis-iservicecollection-method","title":"ServiceCollectionExtensions.GetServiceRegistrations(this IServiceCollection) Method","text":"<p>Gets detailed information about all registered services.</p> <pre><code>public static System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.ServiceRegistrationInfo&gt; GetServiceRegistrations(this Microsoft.Extensions.DependencyInjection.IServiceCollection serviceCollection);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/#parameters_2","title":"Parameters","text":"<p><code>serviceCollection</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service provider to inspect.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/#returns_2","title":"Returns","text":"<p>System.Collections.Generic.IReadOnlyList&lt;ServiceRegistrationInfo&gt; A read-only list of service registration information.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/#exceptions_2","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when serviceCollection is null.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/#example_2","title":"Example","text":"<pre><code>// Get all singleton services\nvar singletons = serviceCollection.GetServiceRegistrations(\n    descriptor =&gt; descriptor.Lifetime == ServiceLifetime.Singleton);\n\n// Get all services with a specific implementation type\nvar specificImpls = serviceCollection.GetServiceRegistrations(\n    descriptor =&gt; descriptor.ImplementationType == typeof(MyService));\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/#servicecollectionextensionsgetserviceregistrationsthis-iservicecollection-funcservicedescriptorbool-method","title":"ServiceCollectionExtensions.GetServiceRegistrations(this IServiceCollection, Func&lt;ServiceDescriptor,bool&gt;) Method","text":"<p>Gets detailed information about all registered services that match the specified predicate.</p> <pre><code>public static System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.ServiceRegistrationInfo&gt; GetServiceRegistrations(this Microsoft.Extensions.DependencyInjection.IServiceCollection serviceCollection, System.Func&lt;Microsoft.Extensions.DependencyInjection.ServiceDescriptor,bool&gt; predicate);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/#parameters_3","title":"Parameters","text":"<p><code>serviceCollection</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service provider to inspect.</p> <p></p> <p><code>predicate</code> System.Func&lt;Microsoft.Extensions.DependencyInjection.ServiceDescriptor,System.Boolean&gt;</p> <p>A function to filter the service descriptors.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/#returns_3","title":"Returns","text":"<p>System.Collections.Generic.IReadOnlyList&lt;ServiceRegistrationInfo&gt; A read-only list of service registration information.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/#exceptions_3","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when serviceCollection or predicate is null.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/#example_3","title":"Example","text":"<pre><code>// Get all singleton services\nvar singletons = serviceCollection.GetServiceRegistrations(\n    descriptor =&gt; descriptor.Lifetime == ServiceLifetime.Singleton);\n\n// Get all services with a specific implementation type\nvar specificImpls = serviceCollection.GetServiceRegistrations(\n    descriptor =&gt; descriptor.ImplementationType == typeof(MyService));\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/#servicecollectionextensionsisregisteredthis-iservicecollection-type-method","title":"ServiceCollectionExtensions.IsRegistered(this IServiceCollection, Type) Method","text":"<p>Determines whether a service of the specified type is registered in the service collection.</p> <pre><code>public static bool IsRegistered(this Microsoft.Extensions.DependencyInjection.IServiceCollection services, System.Type serviceType);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/#parameters_4","title":"Parameters","text":"<p><code>services</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service collection to check.</p> <p></p> <p><code>serviceType</code> System.Type</p> <p>The service type to check.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/#returns_4","title":"Returns","text":"<p>System.Boolean True if the service is registered; otherwise, false.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/#servicecollectionextensionsisregisteredtservicethis-iservicecollection-method","title":"ServiceCollectionExtensions.IsRegistered&lt;TService&gt;(this IServiceCollection) Method","text":"<p>Determines whether a service of the specified type is registered in the service collection.</p> <pre><code>public static bool IsRegistered&lt;TService&gt;(this Microsoft.Extensions.DependencyInjection.IServiceCollection services);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/#type-parameters_1","title":"Type parameters","text":"<p><code>TService</code></p> <p>The service type to check.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/#parameters_5","title":"Parameters","text":"<p><code>services</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service collection to check.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionExtensions/#returns_5","title":"Returns","text":"<p>System.Boolean True if the service is registered; otherwise, false.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionPluginOptions/","title":"ServiceCollectionPluginOptions","text":""},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionPluginOptions/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionPluginOptions/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionPluginOptions/#servicecollectionpluginoptions-class","title":"ServiceCollectionPluginOptions Class","text":"<p>Options provided to IServiceCollectionPlugin implementations during configuration. Contains the service collection, configuration, discovered assemblies, and plugin factory.</p> <pre><code>public sealed record ServiceCollectionPluginOptions : System.IEquatable&lt;NexusLabs.Needlr.ServiceCollectionPluginOptions&gt;\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 ServiceCollectionPluginOptions</p> <p>Implements System.IEquatable&lt;ServiceCollectionPluginOptions&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionPluginOptions/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionPluginOptions/#servicecollectionpluginoptionsiservicecollection-iconfiguration-ireadonlylistassembly-ipluginfactory-constructor","title":"ServiceCollectionPluginOptions(IServiceCollection, IConfiguration, IReadOnlyList&lt;Assembly&gt;, IPluginFactory) Constructor","text":"<p>Options provided to IServiceCollectionPlugin implementations during configuration. Contains the service collection, configuration, discovered assemblies, and plugin factory.</p> <pre><code>public ServiceCollectionPluginOptions(Microsoft.Extensions.DependencyInjection.IServiceCollection Services, Microsoft.Extensions.Configuration.IConfiguration Config, System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt; Assemblies, NexusLabs.Needlr.IPluginFactory PluginFactory);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionPluginOptions/#parameters","title":"Parameters","text":"<p><code>Services</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service collection for registering dependencies.</p> <p></p> <p><code>Config</code> Microsoft.Extensions.Configuration.IConfiguration</p> <p>The application configuration.</p> <p></p> <p><code>Assemblies</code> System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt;</p> <p>The list of assemblies discovered by Needlr.</p> <p></p> <p><code>PluginFactory</code> IPluginFactory</p> <p>Factory for creating additional plugin instances.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionPluginOptions/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionPluginOptions/#servicecollectionpluginoptionsassemblies-property","title":"ServiceCollectionPluginOptions.Assemblies Property","text":"<p>The list of assemblies discovered by Needlr.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt; Assemblies { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionPluginOptions/#property-value","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionPluginOptions/#servicecollectionpluginoptionsconfig-property","title":"ServiceCollectionPluginOptions.Config Property","text":"<p>The application configuration.</p> <pre><code>public Microsoft.Extensions.Configuration.IConfiguration Config { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionPluginOptions/#property-value_1","title":"Property Value","text":"<p>Microsoft.Extensions.Configuration.IConfiguration</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionPluginOptions/#servicecollectionpluginoptionspluginfactory-property","title":"ServiceCollectionPluginOptions.PluginFactory Property","text":"<p>Factory for creating additional plugin instances.</p> <pre><code>public NexusLabs.Needlr.IPluginFactory PluginFactory { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionPluginOptions/#property-value_2","title":"Property Value","text":"<p>IPluginFactory</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionPluginOptions/#servicecollectionpluginoptionsservices-property","title":"ServiceCollectionPluginOptions.Services Property","text":"<p>The service collection for registering dependencies.</p> <pre><code>public Microsoft.Extensions.DependencyInjection.IServiceCollection Services { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionPluginOptions/#property-value_3","title":"Property Value","text":"<p>Microsoft.Extensions.DependencyInjection.IServiceCollection</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionVerificationExtensions/","title":"ServiceCollectionVerificationExtensions","text":""},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionVerificationExtensions/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionVerificationExtensions/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionVerificationExtensions/#servicecollectionverificationextensions-class","title":"ServiceCollectionVerificationExtensions Class","text":"<p>Extension methods for verifying service collection configuration.</p> <pre><code>public static class ServiceCollectionVerificationExtensions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 ServiceCollectionVerificationExtensions</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionVerificationExtensions/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionVerificationExtensions/#servicecollectionverificationextensionsverifythis-iservicecollection-verificationoptions-method","title":"ServiceCollectionVerificationExtensions.Verify(this IServiceCollection, VerificationOptions) Method","text":"<p>Verifies the service collection configuration and throws if issues are configured to throw.</p> <pre><code>public static Microsoft.Extensions.DependencyInjection.IServiceCollection Verify(this Microsoft.Extensions.DependencyInjection.IServiceCollection services, NexusLabs.Needlr.VerificationOptions? options=null);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionVerificationExtensions/#parameters","title":"Parameters","text":"<p><code>services</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service collection to verify.</p> <p></p> <p><code>options</code> VerificationOptions</p> <p>The verification options. Defaults to Default.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionVerificationExtensions/#returns","title":"Returns","text":"<p>Microsoft.Extensions.DependencyInjection.IServiceCollection The same service collection for chaining.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionVerificationExtensions/#exceptions","title":"Exceptions","text":"<p>ContainerVerificationException Thrown if verification issues are detected and the configured behavior is Throw.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionVerificationExtensions/#servicecollectionverificationextensionsverifywithdiagnosticsthis-iservicecollection-verificationoptions-method","title":"ServiceCollectionVerificationExtensions.VerifyWithDiagnostics(this IServiceCollection, VerificationOptions) Method","text":"<p>Verifies the service collection and returns detailed diagnostic results.</p> <pre><code>public static NexusLabs.Needlr.VerificationResult VerifyWithDiagnostics(this Microsoft.Extensions.DependencyInjection.IServiceCollection services, NexusLabs.Needlr.VerificationOptions? options=null);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionVerificationExtensions/#parameters_1","title":"Parameters","text":"<p><code>services</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service collection to verify.</p> <p></p> <p><code>options</code> VerificationOptions</p> <p>The verification options. Defaults to Default.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceCollectionVerificationExtensions/#returns_1","title":"Returns","text":"<p>VerificationResult A VerificationResult containing all detected issues.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/","title":"ServiceProviderExtensions","text":""},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#serviceproviderextensions-class","title":"ServiceProviderExtensions Class","text":"<p>Extension methods for System.IServiceProvider to provide type inspection functionality.</p> <pre><code>public static class ServiceProviderExtensions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 ServiceProviderExtensions</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#serviceproviderextensionscopyregistrationstoservicecollectionthis-iserviceprovider-method","title":"ServiceProviderExtensions.CopyRegistrationsToServiceCollection(this IServiceProvider) Method","text":"<p>Copies all service registrations from the service provider to a new service collection.</p> <pre><code>public static Microsoft.Extensions.DependencyInjection.IServiceCollection CopyRegistrationsToServiceCollection(this System.IServiceProvider serviceProvider);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#parameters","title":"Parameters","text":"<p><code>serviceProvider</code> System.IServiceProvider</p> <p>The source service provider.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#returns","title":"Returns","text":"<p>Microsoft.Extensions.DependencyInjection.IServiceCollection A new service collection containing all registrations.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#serviceproviderextensionscopyregistrationstoservicecollectionthis-iserviceprovider-iservicecollection-method","title":"ServiceProviderExtensions.CopyRegistrationsToServiceCollection(this IServiceProvider, IServiceCollection) Method","text":"<p>Copies all service registrations from the service provider to the specified service collection.</p> <pre><code>public static void CopyRegistrationsToServiceCollection(this System.IServiceProvider serviceProvider, Microsoft.Extensions.DependencyInjection.IServiceCollection serviceCollection);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#parameters_1","title":"Parameters","text":"<p><code>serviceProvider</code> System.IServiceProvider</p> <p>The source service provider.</p> <p></p> <p><code>serviceCollection</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The target service collection.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#serviceproviderextensionsgetregisteredtypesthis-iserviceprovider-functypebool-method","title":"ServiceProviderExtensions.GetRegisteredTypes(this IServiceProvider, Func&lt;Type,bool&gt;) Method","text":"<p>Gets all registered service types that match the specified predicate without instantiating the services.</p> <pre><code>public static System.Collections.Generic.IEnumerable&lt;System.Type&gt; GetRegisteredTypes(this System.IServiceProvider serviceProvider, System.Func&lt;System.Type,bool&gt; predicate);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#parameters_2","title":"Parameters","text":"<p><code>serviceProvider</code> System.IServiceProvider</p> <p>The service provider to inspect.</p> <p></p> <p><code>predicate</code> System.Func&lt;System.Type,System.Boolean&gt;</p> <p>A function to filter the service types.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#returns_1","title":"Returns","text":"<p>System.Collections.Generic.IEnumerable&lt;System.Type&gt; A read-only list of types that match the predicate.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#exceptions","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when serviceProvider or predicate is null.</p> <p>System.InvalidOperationException Thrown when the service collection is not accessible.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#example","title":"Example","text":"<pre><code>// Get all interface types\nvar interfaceTypes = serviceProvider.GetRegisteredTypes(type =&gt; type.IsInterface);\n\n// Get all types in a specific namespace\nvar myNamespaceTypes = serviceProvider.GetRegisteredTypes(type =&gt; \n    type.Namespace?.StartsWith(\"MyApp.Services\") == true);\n\n// Get all types implementing a specific interface\nvar repositoryTypes = serviceProvider.GetRegisteredTypes(type =&gt; \n    typeof(IRepository).IsAssignableFrom(type));\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#serviceproviderextensionsgetregisteredtypesoftthis-iserviceprovider-method","title":"ServiceProviderExtensions.GetRegisteredTypesOf&lt;T&gt;(this IServiceProvider) Method","text":"<p>Gets all registered service types that implement or inherit from the specified type without instantiating the services.</p> <pre><code>public static System.Collections.Generic.IEnumerable&lt;System.Type&gt; GetRegisteredTypesOf&lt;T&gt;(this System.IServiceProvider serviceProvider);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#type-parameters","title":"Type parameters","text":"<p><code>T</code></p> <p>The base type or interface to filter by.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#parameters_3","title":"Parameters","text":"<p><code>serviceProvider</code> System.IServiceProvider</p> <p>The service provider to inspect.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#returns_2","title":"Returns","text":"<p>System.Collections.Generic.IEnumerable&lt;System.Type&gt; A read-only list of types that implement or inherit from T.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#exceptions_1","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when serviceProvider is null.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#example_1","title":"Example","text":"<pre><code>// Get all types implementing IRepository\nvar repositoryTypes = serviceProvider.GetRegisteredTypesOf&lt;IRepository&gt;();\n\n// Get all types inheriting from BaseService\nvar serviceTypes = serviceProvider.GetRegisteredTypesOf&lt;BaseService&gt;();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#serviceproviderextensionsgetservicecollectionthis-iserviceprovider-method","title":"ServiceProviderExtensions.GetServiceCollection(this IServiceProvider) Method","text":"<p>Gets the service collection from the service provider.</p> <pre><code>public static Microsoft.Extensions.DependencyInjection.IServiceCollection GetServiceCollection(this System.IServiceProvider serviceProvider);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#parameters_4","title":"Parameters","text":"<p><code>serviceProvider</code> System.IServiceProvider</p> <p>The service provider.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#returns_3","title":"Returns","text":"<p>Microsoft.Extensions.DependencyInjection.IServiceCollection The service collection.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#exceptions_2","title":"Exceptions","text":"<p>System.InvalidOperationException Thrown when the service collection is not available.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#serviceproviderextensionsgetserviceregistrationsthis-iserviceprovider-method","title":"ServiceProviderExtensions.GetServiceRegistrations(this IServiceProvider) Method","text":"<p>Gets detailed information about all registered services.</p> <pre><code>public static System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.ServiceRegistrationInfo&gt; GetServiceRegistrations(this System.IServiceProvider serviceProvider);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#parameters_5","title":"Parameters","text":"<p><code>serviceProvider</code> System.IServiceProvider</p> <p>The service provider to inspect.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#returns_4","title":"Returns","text":"<p>System.Collections.Generic.IReadOnlyList&lt;ServiceRegistrationInfo&gt; A read-only list of service registration information.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#exceptions_3","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when serviceProvider is null.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#example_2","title":"Example","text":"<pre><code>// Get all singleton services\nvar singletons = serviceProvider.GetServiceRegistrations(\n    descriptor =&gt; descriptor.Lifetime == ServiceLifetime.Singleton);\n\n// Get all services with a specific implementation type\nvar specificImpls = serviceProvider.GetServiceRegistrations(\n    descriptor =&gt; descriptor.ImplementationType == typeof(MyService));\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#serviceproviderextensionsgetserviceregistrationsthis-iserviceprovider-funcservicedescriptorbool-method","title":"ServiceProviderExtensions.GetServiceRegistrations(this IServiceProvider, Func&lt;ServiceDescriptor,bool&gt;) Method","text":"<p>Gets detailed information about all registered services that match the specified predicate.</p> <pre><code>public static System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.ServiceRegistrationInfo&gt; GetServiceRegistrations(this System.IServiceProvider serviceProvider, System.Func&lt;Microsoft.Extensions.DependencyInjection.ServiceDescriptor,bool&gt; predicate);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#parameters_6","title":"Parameters","text":"<p><code>serviceProvider</code> System.IServiceProvider</p> <p>The service provider to inspect.</p> <p></p> <p><code>predicate</code> System.Func&lt;Microsoft.Extensions.DependencyInjection.ServiceDescriptor,System.Boolean&gt;</p> <p>A function to filter the service descriptors.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#returns_5","title":"Returns","text":"<p>System.Collections.Generic.IReadOnlyList&lt;ServiceRegistrationInfo&gt; A read-only list of service registration information.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#exceptions_4","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when serviceProvider or predicate is null.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#example_3","title":"Example","text":"<pre><code>// Get all singleton services\nvar singletons = serviceProvider.GetServiceRegistrations(\n    descriptor =&gt; descriptor.Lifetime == ServiceLifetime.Singleton);\n\n// Get all services with a specific implementation type\nvar specificImpls = serviceProvider.GetServiceRegistrations(\n    descriptor =&gt; descriptor.ImplementationType == typeof(MyService));\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#serviceproviderextensionsisregisteredthis-iserviceprovider-type-method","title":"ServiceProviderExtensions.IsRegistered(this IServiceProvider, Type) Method","text":"<p>Determines whether a service of the specified type is registered in the service provider.</p> <pre><code>public static bool IsRegistered(this System.IServiceProvider serviceProvider, System.Type serviceType);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#parameters_7","title":"Parameters","text":"<p><code>serviceProvider</code> System.IServiceProvider</p> <p>The service provider to check.</p> <p></p> <p><code>serviceType</code> System.Type</p> <p>The service type to check.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#returns_6","title":"Returns","text":"<p>System.Boolean True if the service is registered; otherwise, false.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#serviceproviderextensionsisregisteredtservicethis-iserviceprovider-method","title":"ServiceProviderExtensions.IsRegistered&lt;TService&gt;(this IServiceProvider) Method","text":"<p>Determines whether a service of the specified type is registered in the service provider.</p> <pre><code>public static bool IsRegistered&lt;TService&gt;(this System.IServiceProvider serviceProvider);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#type-parameters_1","title":"Type parameters","text":"<p><code>TService</code></p> <p>The service type to check.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#parameters_8","title":"Parameters","text":"<p><code>serviceProvider</code> System.IServiceProvider</p> <p>The service provider to check.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceProviderExtensions/#returns_7","title":"Returns","text":"<p>System.Boolean True if the service is registered; otherwise, false.</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceRegistrationInfo/","title":"ServiceRegistrationInfo","text":""},{"location":"api/dev/NexusLabs.Needlr/ServiceRegistrationInfo/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/ServiceRegistrationInfo/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/ServiceRegistrationInfo/#serviceregistrationinfo-struct","title":"ServiceRegistrationInfo Struct","text":"<pre><code>public readonly record struct ServiceRegistrationInfo : System.IEquatable&lt;NexusLabs.Needlr.ServiceRegistrationInfo&gt;\n</code></pre> <p>Implements System.IEquatable&lt;ServiceRegistrationInfo&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceRegistrationInfo/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr/ServiceRegistrationInfo/#serviceregistrationinfohasfactory-property","title":"ServiceRegistrationInfo.HasFactory Property","text":"<p>Indicates whether the registration was configured with a factory delegate (Microsoft.Extensions.DependencyInjection.ServiceDescriptor.ImplementationFactory). When true, ImplementationType will be null.</p> <pre><code>public bool HasFactory { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceRegistrationInfo/#property-value","title":"Property Value","text":"<p>System.Boolean</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceRegistrationInfo/#serviceregistrationinfohasinstance-property","title":"ServiceRegistrationInfo.HasInstance Property","text":"<p>Indicates whether the registration was configured with a pre-constructed instance (Microsoft.Extensions.DependencyInjection.ServiceDescriptor.ImplementationInstance). When true, ImplementationType will typically be null (unless metadata reflects the instance's type indirectly).</p> <pre><code>public bool HasInstance { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceRegistrationInfo/#property-value_1","title":"Property Value","text":"<p>System.Boolean</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceRegistrationInfo/#serviceregistrationinfoimplementationtype-property","title":"ServiceRegistrationInfo.ImplementationType Property","text":"<p>Gets the concrete implementation System.Type, if the registration was made with an implementation type. Returns null when: - The registration uses an Microsoft.Extensions.DependencyInjection.ServiceDescriptor.ImplementationFactory. - The registration supplies a pre-built Microsoft.Extensions.DependencyInjection.ServiceDescriptor.ImplementationInstance. - The registration represents an open generic without a concrete close (rare in reflection scenarios).</p> <pre><code>public System.Type? ImplementationType { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceRegistrationInfo/#property-value_2","title":"Property Value","text":"<p>System.Type</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceRegistrationInfo/#serviceregistrationinfolifetime-property","title":"ServiceRegistrationInfo.Lifetime Property","text":"<p>Gets the lifetime (Microsoft.Extensions.DependencyInjection.ServiceLifetime.Singleton, Microsoft.Extensions.DependencyInjection.ServiceLifetime.Scoped, or Microsoft.Extensions.DependencyInjection.ServiceLifetime.Transient) associated with the registration.</p> <pre><code>public Microsoft.Extensions.DependencyInjection.ServiceLifetime Lifetime { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceRegistrationInfo/#property-value_3","title":"Property Value","text":"<p>Microsoft.Extensions.DependencyInjection.ServiceLifetime</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceRegistrationInfo/#serviceregistrationinfoservicetype-property","title":"ServiceRegistrationInfo.ServiceType Property","text":"<p>Gets the service (abstraction/contract) System.Type that was registered. This is the key used by the DI container for resolution requests.</p> <pre><code>public System.Type ServiceType { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceRegistrationInfo/#property-value_4","title":"Property Value","text":"<p>System.Type</p>"},{"location":"api/dev/NexusLabs.Needlr/ServiceRegistrationInfo/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr/ServiceRegistrationInfo/#serviceregistrationinfotodetailedstring-method","title":"ServiceRegistrationInfo.ToDetailedString() Method","text":"<p>Returns a detailed, formatted string representation of this registration suitable for debugging and diagnostics.</p> <pre><code>public string ToDetailedString();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/ServiceRegistrationInfo/#returns","title":"Returns","text":"<p>System.String A multi-line formatted string with registration details.</p>"},{"location":"api/dev/NexusLabs.Needlr/SingletonAttribute/","title":"SingletonAttribute","text":""},{"location":"api/dev/NexusLabs.Needlr/SingletonAttribute/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/SingletonAttribute/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/SingletonAttribute/#singletonattribute-class","title":"SingletonAttribute Class","text":"<p>Specifies that the decorated class should be registered with \\&lt;b&gt;Singleton\\&lt;/b&gt; lifetime. Singleton services are created once for the lifetime of the application and reused for every request.</p> <pre><code>public sealed class SingletonAttribute : System.Attribute\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 System.Attribute \ud83e\udc52 SingletonAttribute</p>"},{"location":"api/dev/NexusLabs.Needlr/SingletonAttribute/#example","title":"Example","text":"<pre><code>[Singleton]\npublic class ConfigurationCache : IConfigurationCache\n{\n    // Created once for the application lifetime\n}\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/SingletonAttribute/#remarks","title":"Remarks","text":"<p>Singleton is the default lifetime in Needlr. You only need to apply this attribute explicitly             when you want to document intent clearly, or when overriding a different default set in your             Needlr configuration.</p> <p>Be careful with Singleton services that depend on Scoped or Transient services \u2014 resolving a shorter-lived dependency from a Singleton creates a \"captive dependency\" and can cause bugs.</p>"},{"location":"api/dev/NexusLabs.Needlr/SourceGenRegistry/","title":"SourceGenRegistry","text":""},{"location":"api/dev/NexusLabs.Needlr/SourceGenRegistry/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/SourceGenRegistry/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/SourceGenRegistry/#sourcegenregistry-class","title":"SourceGenRegistry Class","text":"<p>Static registry for source-generated registrations.</p> <pre><code>public static class SourceGenRegistry\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 SourceGenRegistry</p>"},{"location":"api/dev/NexusLabs.Needlr/SourceGenRegistry/#remarks","title":"Remarks","text":"<p>This class provides a decoupling layer between the core Needlr runtime and the source-generated bootstrap code. The source generator emits a module initializer that registers callbacks here, and the <code>ConfiguredSyringe</code> calls these callbacks during <code>BuildServiceProvider</code>.</p> <p>This allows <code>NexusLabs.Needlr.Injection</code> to have no dependency on <code>NexusLabs.Needlr.Generators.Attributes</code>.</p>"},{"location":"api/dev/NexusLabs.Needlr/SourceGenRegistry/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr/SourceGenRegistry/#sourcegenregistryregisterextensionactionobjectobject-method","title":"SourceGenRegistry.RegisterExtension(Action&lt;object,object&gt;) Method","text":"<p>Registers an extension registrar from extension packages.</p> <pre><code>public static void RegisterExtension(System.Action&lt;object,object&gt; registrar);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/SourceGenRegistry/#parameters","title":"Parameters","text":"<p><code>registrar</code> System.Action&lt;System.Object,System.Object&gt;</p> <p>Action that registers extension services. Parameters are (IServiceCollection, IConfiguration), typed as object to avoid package dependencies.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/SourceGenRegistry/#sourcegenregistryregisteroptionsregistraractionobjectobject-method","title":"SourceGenRegistry.RegisterOptionsRegistrar(Action&lt;object,object&gt;) Method","text":"<p>Registers the options registrar from source-generated code.</p> <pre><code>public static void RegisterOptionsRegistrar(System.Action&lt;object,object&gt; registrar);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/SourceGenRegistry/#parameters_1","title":"Parameters","text":"<p><code>registrar</code> System.Action&lt;System.Object,System.Object&gt;</p> <p>Action that registers options. Parameters are (IServiceCollection, IConfiguration), typed as object to avoid package dependencies.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/SourceGenRegistry/#sourcegenregistrytrygetextensionregistraractionobjectobject-method","title":"SourceGenRegistry.TryGetExtensionRegistrar(Action&lt;object,object&gt;) Method","text":"<p>Gets the extension registrar if one is registered.</p> <pre><code>public static bool TryGetExtensionRegistrar(out System.Action&lt;object,object&gt;? registrar);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/SourceGenRegistry/#parameters_2","title":"Parameters","text":"<p><code>registrar</code> System.Action&lt;System.Object,System.Object&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr/SourceGenRegistry/#returns","title":"Returns","text":"<p>System.Boolean</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/SourceGenRegistry/#sourcegenregistrytrygetoptionsregistraractionobjectobject-method","title":"SourceGenRegistry.TryGetOptionsRegistrar(Action&lt;object,object&gt;) Method","text":"<p>Gets the options registrar if one is registered.</p> <pre><code>public static bool TryGetOptionsRegistrar(out System.Action&lt;object,object&gt;? registrar);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/SourceGenRegistry/#parameters_3","title":"Parameters","text":"<p><code>registrar</code> System.Action&lt;System.Object,System.Object&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr/SourceGenRegistry/#returns_1","title":"Returns","text":"<p>System.Boolean</p>"},{"location":"api/dev/NexusLabs.Needlr/TransientAttribute/","title":"TransientAttribute","text":""},{"location":"api/dev/NexusLabs.Needlr/TransientAttribute/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/TransientAttribute/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/TransientAttribute/#transientattribute-class","title":"TransientAttribute Class","text":"<p>Specifies that the decorated class should be registered with \\&lt;b&gt;Transient\\&lt;/b&gt; lifetime. Transient services are created fresh every time they are resolved from the container.</p> <pre><code>public sealed class TransientAttribute : System.Attribute\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 System.Attribute \ud83e\udc52 TransientAttribute</p>"},{"location":"api/dev/NexusLabs.Needlr/TransientAttribute/#example","title":"Example","text":"<pre><code>[Transient]\npublic class EmailMessageBuilder : IEmailMessageBuilder\n{\n    // New instance every time IEmailMessageBuilder is resolved\n}\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/TransientAttribute/#remarks","title":"Remarks","text":"<p>Use <code>[Transient]</code> for lightweight, stateless services that are cheap to construct and must not accumulate state across calls.</p> <p>Without this attribute, Needlr registers classes as Singleton by default. Apply <code>[Transient]</code> to override that default.</p>"},{"location":"api/dev/NexusLabs.Needlr/TypeExtensions/","title":"TypeExtensions","text":""},{"location":"api/dev/NexusLabs.Needlr/TypeExtensions/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/TypeExtensions/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/TypeExtensions/#typeextensions-class","title":"TypeExtensions Class","text":"<p>Extension methods for System.Type to provide additional type inspection capabilities.</p> <pre><code>public static class TypeExtensions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 TypeExtensions</p>"},{"location":"api/dev/NexusLabs.Needlr/TypeExtensions/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr/TypeExtensions/#typeextensionsisstaticthis-type-method","title":"TypeExtensions.IsStatic(this Type) Method","text":"<p>Determines whether the specified type is a static class.</p> <pre><code>public static bool IsStatic(this System.Type type);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/TypeExtensions/#parameters","title":"Parameters","text":"<p><code>type</code> System.Type</p> <p>The type to check.</p>"},{"location":"api/dev/NexusLabs.Needlr/TypeExtensions/#returns","title":"Returns","text":"<p>System.Boolean True if the type is static (abstract and sealed); otherwise, false.</p>"},{"location":"api/dev/NexusLabs.Needlr/VerificationBehavior/","title":"VerificationBehavior","text":""},{"location":"api/dev/NexusLabs.Needlr/VerificationBehavior/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/VerificationBehavior/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/VerificationBehavior/#verificationbehavior-enum","title":"VerificationBehavior Enum","text":"<p>Specifies the behavior when a verification issue is detected.</p> <pre><code>public enum VerificationBehavior\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/VerificationBehavior/#fields","title":"Fields","text":"<p><code>Silent</code> 0</p> <p>Ignore the issue silently.</p> <p></p> <p><code>Warn</code> 1</p> <p>Log a warning but continue.</p> <p></p> <p><code>Throw</code> 2</p> <p>Throw an exception to prevent the application from starting.</p>"},{"location":"api/dev/NexusLabs.Needlr/VerificationIssue/","title":"VerificationIssue","text":""},{"location":"api/dev/NexusLabs.Needlr/VerificationIssue/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/VerificationIssue/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/VerificationIssue/#verificationissue-class","title":"VerificationIssue Class","text":"<p>Represents a verification issue detected during container analysis.</p> <pre><code>public sealed record VerificationIssue : System.IEquatable&lt;NexusLabs.Needlr.VerificationIssue&gt;\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 VerificationIssue</p> <p>Implements System.IEquatable&lt;VerificationIssue&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr/VerificationIssue/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr/VerificationIssue/#verificationissueverificationissuetype-string-string-verificationbehavior-constructor","title":"VerificationIssue(VerificationIssueType, string, string, VerificationBehavior) Constructor","text":"<p>Represents a verification issue detected during container analysis.</p> <pre><code>public VerificationIssue(NexusLabs.Needlr.VerificationIssueType Type, string Message, string DetailedMessage, NexusLabs.Needlr.VerificationBehavior ConfiguredBehavior);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/VerificationIssue/#parameters","title":"Parameters","text":"<p><code>Type</code> VerificationIssueType</p> <p></p> <p><code>Message</code> System.String</p> <p></p> <p><code>DetailedMessage</code> System.String</p> <p></p> <p><code>ConfiguredBehavior</code> VerificationBehavior</p>"},{"location":"api/dev/NexusLabs.Needlr/VerificationIssue/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr/VerificationIssue/#verificationissueinvolvedtypes-property","title":"VerificationIssue.InvolvedTypes Property","text":"<p>Gets the service types involved in this issue.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;System.Type&gt; InvolvedTypes { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/VerificationIssue/#property-value","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr/VerificationIssueType/","title":"VerificationIssueType","text":""},{"location":"api/dev/NexusLabs.Needlr/VerificationIssueType/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/VerificationIssueType/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/VerificationIssueType/#verificationissuetype-enum","title":"VerificationIssueType Enum","text":"<p>The type of verification issue detected.</p> <pre><code>public enum VerificationIssueType\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/VerificationIssueType/#fields","title":"Fields","text":"<p><code>LifetimeMismatch</code> 0</p> <p>A longer-lived service depends on a shorter-lived service.</p> <p></p> <p><code>CircularDependency</code> 1</p> <p>A circular dependency was detected in the dependency graph.</p>"},{"location":"api/dev/NexusLabs.Needlr/VerificationOptions/","title":"VerificationOptions","text":""},{"location":"api/dev/NexusLabs.Needlr/VerificationOptions/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/VerificationOptions/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/VerificationOptions/#verificationoptions-class","title":"VerificationOptions Class","text":"<p>Options for controlling container verification behavior.</p> <pre><code>public sealed record VerificationOptions : System.IEquatable&lt;NexusLabs.Needlr.VerificationOptions&gt;\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 VerificationOptions</p> <p>Implements System.IEquatable&lt;VerificationOptions&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr/VerificationOptions/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr/VerificationOptions/#verificationoptionscirculardependencybehavior-property","title":"VerificationOptions.CircularDependencyBehavior Property","text":"<p>Gets or sets the behavior when circular dependencies are detected. Default is Throw.</p> <pre><code>public NexusLabs.Needlr.VerificationBehavior CircularDependencyBehavior { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/VerificationOptions/#property-value","title":"Property Value","text":"<p>VerificationBehavior</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/VerificationOptions/#verificationoptionsdefault-property","title":"VerificationOptions.Default Property","text":"<p>Default verification options - warns on lifetime mismatches, throws on circular dependencies.</p> <pre><code>public static NexusLabs.Needlr.VerificationOptions Default { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/VerificationOptions/#property-value_1","title":"Property Value","text":"<p>VerificationOptions</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/VerificationOptions/#verificationoptionsdisabled-property","title":"VerificationOptions.Disabled Property","text":"<p>Disabled verification - no checks performed.</p> <pre><code>public static NexusLabs.Needlr.VerificationOptions Disabled { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/VerificationOptions/#property-value_2","title":"Property Value","text":"<p>VerificationOptions</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/VerificationOptions/#verificationoptionsissuereporter-property","title":"VerificationOptions.IssueReporter Property","text":"<p>Gets or sets a callback for reporting verification issues. If null, issues are written to Console.Error.</p> <pre><code>public System.Action&lt;NexusLabs.Needlr.VerificationIssue&gt;? IssueReporter { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/VerificationOptions/#property-value_3","title":"Property Value","text":"<p>System.Action&lt;VerificationIssue&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/VerificationOptions/#verificationoptionslifetimemismatchbehavior-property","title":"VerificationOptions.LifetimeMismatchBehavior Property","text":"<p>Gets or sets the behavior when lifetime mismatches are detected. Default is Warn.</p> <pre><code>public NexusLabs.Needlr.VerificationBehavior LifetimeMismatchBehavior { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/VerificationOptions/#property-value_4","title":"Property Value","text":"<p>VerificationBehavior</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/VerificationOptions/#verificationoptionsstrict-property","title":"VerificationOptions.Strict Property","text":"<p>Strict verification options - throws on any verification issue.</p> <pre><code>public static NexusLabs.Needlr.VerificationOptions Strict { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/VerificationOptions/#property-value_5","title":"Property Value","text":"<p>VerificationOptions</p>"},{"location":"api/dev/NexusLabs.Needlr/VerificationOptionsBuilder/","title":"VerificationOptionsBuilder","text":""},{"location":"api/dev/NexusLabs.Needlr/VerificationOptionsBuilder/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/VerificationOptionsBuilder/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/VerificationOptionsBuilder/#verificationoptionsbuilder-class","title":"VerificationOptionsBuilder Class","text":"<p>Builder for creating VerificationOptions with a fluent API.</p> <pre><code>public sealed class VerificationOptionsBuilder\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 VerificationOptionsBuilder</p>"},{"location":"api/dev/NexusLabs.Needlr/VerificationOptionsBuilder/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr/VerificationOptionsBuilder/#verificationoptionsbuilderbuild-method","title":"VerificationOptionsBuilder.Build() Method","text":"<p>Builds the configured VerificationOptions.</p> <pre><code>public NexusLabs.Needlr.VerificationOptions Build();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/VerificationOptionsBuilder/#returns","title":"Returns","text":"<p>VerificationOptions</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/VerificationOptionsBuilder/#verificationoptionsbuilderdisabled-method","title":"VerificationOptionsBuilder.Disabled() Method","text":"<p>Disables all verification.</p> <pre><code>public NexusLabs.Needlr.VerificationOptionsBuilder Disabled();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/VerificationOptionsBuilder/#returns_1","title":"Returns","text":"<p>VerificationOptionsBuilder</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/VerificationOptionsBuilder/#verificationoptionsbuilderoncirculardependencyverificationbehavior-method","title":"VerificationOptionsBuilder.OnCircularDependency(VerificationBehavior) Method","text":"<p>Sets the behavior when circular dependencies are detected.</p> <pre><code>public NexusLabs.Needlr.VerificationOptionsBuilder OnCircularDependency(NexusLabs.Needlr.VerificationBehavior behavior);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/VerificationOptionsBuilder/#parameters","title":"Parameters","text":"<p><code>behavior</code> VerificationBehavior</p>"},{"location":"api/dev/NexusLabs.Needlr/VerificationOptionsBuilder/#returns_2","title":"Returns","text":"<p>VerificationOptionsBuilder</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/VerificationOptionsBuilder/#verificationoptionsbuilderonlifetimemismatchverificationbehavior-method","title":"VerificationOptionsBuilder.OnLifetimeMismatch(VerificationBehavior) Method","text":"<p>Sets the behavior when lifetime mismatches are detected.</p> <pre><code>public NexusLabs.Needlr.VerificationOptionsBuilder OnLifetimeMismatch(NexusLabs.Needlr.VerificationBehavior behavior);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/VerificationOptionsBuilder/#parameters_1","title":"Parameters","text":"<p><code>behavior</code> VerificationBehavior</p>"},{"location":"api/dev/NexusLabs.Needlr/VerificationOptionsBuilder/#returns_3","title":"Returns","text":"<p>VerificationOptionsBuilder</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/VerificationOptionsBuilder/#verificationoptionsbuilderreportissuestoactionverificationissue-method","title":"VerificationOptionsBuilder.ReportIssuesTo(Action&lt;VerificationIssue&gt;) Method","text":"<p>Sets a custom reporter for verification issues.</p> <pre><code>public NexusLabs.Needlr.VerificationOptionsBuilder ReportIssuesTo(System.Action&lt;NexusLabs.Needlr.VerificationIssue&gt; reporter);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/VerificationOptionsBuilder/#parameters_2","title":"Parameters","text":"<p><code>reporter</code> System.Action&lt;VerificationIssue&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr/VerificationOptionsBuilder/#returns_4","title":"Returns","text":"<p>VerificationOptionsBuilder</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/VerificationOptionsBuilder/#verificationoptionsbuilderstrict-method","title":"VerificationOptionsBuilder.Strict() Method","text":"<p>Throws on any verification issue.</p> <pre><code>public NexusLabs.Needlr.VerificationOptionsBuilder Strict();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/VerificationOptionsBuilder/#returns_5","title":"Returns","text":"<p>VerificationOptionsBuilder</p>"},{"location":"api/dev/NexusLabs.Needlr/VerificationResult/","title":"VerificationResult","text":""},{"location":"api/dev/NexusLabs.Needlr/VerificationResult/#nexuslabsneedlr","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/VerificationResult/#nexuslabsneedlr_1","title":"NexusLabs.Needlr","text":""},{"location":"api/dev/NexusLabs.Needlr/VerificationResult/#verificationresult-class","title":"VerificationResult Class","text":"<p>Result of container verification containing all detected issues.</p> <pre><code>public sealed record VerificationResult : System.IEquatable&lt;NexusLabs.Needlr.VerificationResult&gt;\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 VerificationResult</p> <p>Implements System.IEquatable&lt;VerificationResult&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr/VerificationResult/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr/VerificationResult/#verificationresultireadonlylistverificationissue-constructor","title":"VerificationResult(IReadOnlyList&lt;VerificationIssue&gt;) Constructor","text":"<p>Result of container verification containing all detected issues.</p> <pre><code>public VerificationResult(System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.VerificationIssue&gt; Issues);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/VerificationResult/#parameters","title":"Parameters","text":"<p><code>Issues</code> System.Collections.Generic.IReadOnlyList&lt;VerificationIssue&gt;</p> <p>The list of verification issues detected.</p>"},{"location":"api/dev/NexusLabs.Needlr/VerificationResult/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr/VerificationResult/#verificationresultissues-property","title":"VerificationResult.Issues Property","text":"<p>The list of verification issues detected.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.VerificationIssue&gt; Issues { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/VerificationResult/#property-value","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;VerificationIssue&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/VerificationResult/#verificationresultisvalid-property","title":"VerificationResult.IsValid Property","text":"<p>Gets whether the container configuration is valid (no errors).</p> <pre><code>public bool IsValid { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/VerificationResult/#property-value_1","title":"Property Value","text":"<p>System.Boolean</p>"},{"location":"api/dev/NexusLabs.Needlr/VerificationResult/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr/VerificationResult/#verificationresultthrowifinvalid-method","title":"VerificationResult.ThrowIfInvalid() Method","text":"<p>Throws ContainerVerificationException if any issues are present.</p> <pre><code>public void ThrowIfInvalid();\n</code></pre> <p></p>"},{"location":"api/dev/NexusLabs.Needlr/VerificationResult/#verificationresulttodetailedreport-method","title":"VerificationResult.ToDetailedReport() Method","text":"<p>Generates a detailed diagnostic report of all issues.</p> <pre><code>public string ToDetailedReport();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr/VerificationResult/#returns","title":"Returns","text":"<p>System.String</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/","title":"Index","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/#nexuslabsneedlragentframework-assembly","title":"NexusLabs.Needlr.AgentFramework Assembly","text":"Namespaces NexusLabs.Needlr.AgentFramework NexusLabs.Needlr.AgentFramework.FunctionScanners NexusLabs.Needlr.AgentFramework.Generated"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AIAgentBuilderPluginOptions/","title":"AIAgentBuilderPluginOptions","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AIAgentBuilderPluginOptions/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AIAgentBuilderPluginOptions/#nexuslabsneedlragentframework_1","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AIAgentBuilderPluginOptions/#aiagentbuilderpluginoptions-class","title":"AIAgentBuilderPluginOptions Class","text":"<p>Options passed to Configure(AIAgentBuilderPluginOptions) to allow plugins to participate in agent-builder configuration.</p> <pre><code>public sealed class AIAgentBuilderPluginOptions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 AIAgentBuilderPluginOptions</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AIAgentBuilderPluginOptions/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AIAgentBuilderPluginOptions/#aiagentbuilderpluginoptionsagentbuilder-property","title":"AIAgentBuilderPluginOptions.AgentBuilder Property","text":"<p>Gets the Microsoft.Agents.AI.AIAgentBuilder being configured.</p> <pre><code>public Microsoft.Agents.AI.AIAgentBuilder AgentBuilder { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AIAgentBuilderPluginOptions/#property-value","title":"Property Value","text":"<p>Microsoft.Agents.AI.AIAgentBuilder</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFactoryOptions/","title":"AgentFactoryOptions","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFactoryOptions/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFactoryOptions/#nexuslabsneedlragentframework_1","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFactoryOptions/#agentfactoryoptions-class","title":"AgentFactoryOptions Class","text":"<p>Per-agent configuration options passed to <code>IAgentFactory.CreateAgent(configure)</code>.</p> <pre><code>public sealed class AgentFactoryOptions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 AgentFactoryOptions</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFactoryOptions/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFactoryOptions/#agentfactoryoptionsdescription-property","title":"AgentFactoryOptions.Description Property","text":"<p>Gets or sets a human-readable description of this agent's purpose.</p> <pre><code>public string? Description { get; set; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFactoryOptions/#property-value","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFactoryOptions/#agentfactoryoptionsfunctiongroups-property","title":"AgentFactoryOptions.FunctionGroups Property","text":"<p>Gets or sets the named function groups to wire as tools for this agent. Groups are declared using AgentFunctionGroupAttribute on function classes and registered via <code>AddAgentFunctionGroupsFromAssemblies()</code> or <code>AddAgentFunctionGroupsFromGenerated()</code>. When null and FunctionTypes is also null, all registered function types are used.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;string&gt;? FunctionGroups { get; set; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFactoryOptions/#property-value_1","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;System.String&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFactoryOptions/#agentfactoryoptionsfunctiontypes-property","title":"AgentFactoryOptions.FunctionTypes Property","text":"<p>Gets or sets the subset of function types to wire as tools for this agent. When null and FunctionGroups is also null, all function types registered with the factory are used.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;? FunctionTypes { get; set; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFactoryOptions/#property-value_2","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFactoryOptions/#agentfactoryoptionsinstructions-property","title":"AgentFactoryOptions.Instructions Property","text":"<p>Gets or sets the system instructions for this specific agent. When set, overrides the default instructions configured on the factory.</p> <pre><code>public string? Instructions { get; set; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFactoryOptions/#property-value_3","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFactoryOptions/#agentfactoryoptionsname-property","title":"AgentFactoryOptions.Name Property","text":"<p>Gets or sets the agent's name. Used by MAF to populate <code>ExecutorId</code> in workflow events, making multi-agent output readable. When null, MAF assigns a generated identifier.</p> <pre><code>public string? Name { get; set; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFactoryOptions/#property-value_4","title":"Property Value","text":"<p>System.String</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkConfigureOptions/","title":"AgentFrameworkConfigureOptions","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkConfigureOptions/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkConfigureOptions/#nexuslabsneedlragentframework_1","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkConfigureOptions/#agentframeworkconfigureoptions-class","title":"AgentFrameworkConfigureOptions Class","text":"<p>Factory-level configuration options passed to NexusLabs.Needlr.AgentFramework.AgentFrameworkSyringeExtensions.Configure(NexusLabs.Needlr.AgentFramework.AgentFrameworkSyringe,System.Action{NexusLabs.Needlr.AgentFramework.AgentFrameworkConfigureOptions}) callbacks.</p> <pre><code>public sealed class AgentFrameworkConfigureOptions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 AgentFrameworkConfigureOptions</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkConfigureOptions/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkConfigureOptions/#agentframeworkconfigureoptionschatclientfactory-property","title":"AgentFrameworkConfigureOptions.ChatClientFactory Property","text":"<p>Gets or sets a factory that creates the Microsoft.Extensions.AI.IChatClient used by all agents built from this factory. When null, Microsoft.Extensions.AI.IChatClient is resolved from the DI container.</p> <pre><code>public System.Func&lt;System.IServiceProvider,Microsoft.Extensions.AI.IChatClient&gt;? ChatClientFactory { get; set; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkConfigureOptions/#property-value","title":"Property Value","text":"<p>System.Func&lt;System.IServiceProvider,Microsoft.Extensions.AI.IChatClient&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkConfigureOptions/#agentframeworkconfigureoptionsdefaultinstructions-property","title":"AgentFrameworkConfigureOptions.DefaultInstructions Property","text":"<p>Gets or sets the default system instructions applied to all agents unless overridden via Instructions.</p> <pre><code>public string? DefaultInstructions { get; set; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkConfigureOptions/#property-value_1","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkConfigureOptions/#agentframeworkconfigureoptionsserviceprovider-property","title":"AgentFrameworkConfigureOptions.ServiceProvider Property","text":"<p>Gets the service provider from the DI container. Use this to resolve configuration or services needed to create the Microsoft.Extensions.AI.IChatClient.</p> <pre><code>public System.IServiceProvider ServiceProvider { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkConfigureOptions/#property-value_2","title":"Property Value","text":"<p>System.IServiceProvider</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkFunctionGroupRegistry/","title":"AgentFrameworkFunctionGroupRegistry","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkFunctionGroupRegistry/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkFunctionGroupRegistry/#nexuslabsneedlragentframeworkgenerated","title":"NexusLabs.Needlr.AgentFramework.Generated","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkFunctionGroupRegistry/#agentframeworkfunctiongroupregistry-class","title":"AgentFrameworkFunctionGroupRegistry Class","text":"<p>Generated registry for Microsoft Agent Framework function groups discovered at compile time. Pass AllGroups to <code>AgentFrameworkSyringeExtensions.AddAgentFunctionGroupsFromGenerated</code>.</p> <pre><code>public static class AgentFrameworkFunctionGroupRegistry\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 AgentFrameworkFunctionGroupRegistry</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkFunctionGroupRegistry/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkFunctionGroupRegistry/#agentframeworkfunctiongroupregistryallgroups-property","title":"AgentFrameworkFunctionGroupRegistry.AllGroups Property","text":"<p>All function groups, mapping group name to the types in that group, discovered at compile time.</p> <pre><code>public static System.Collections.Generic.IReadOnlyDictionary&lt;string,System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;&gt; AllGroups { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkFunctionGroupRegistry/#property-value","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyDictionary&lt;System.String,System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkFunctionRegistry/","title":"AgentFrameworkFunctionRegistry","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkFunctionRegistry/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkFunctionRegistry/#nexuslabsneedlragentframeworkgenerated","title":"NexusLabs.Needlr.AgentFramework.Generated","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkFunctionRegistry/#agentframeworkfunctionregistry-class","title":"AgentFrameworkFunctionRegistry Class","text":"<p>Generated registry for Microsoft Agent Framework function types discovered at compile time. Pass AllFunctionTypes to <code>AgentFrameworkSyringeExtensions.AddAgentFunctionsFromGenerated</code>.</p> <pre><code>public static class AgentFrameworkFunctionRegistry\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 AgentFrameworkFunctionRegistry</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkFunctionRegistry/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkFunctionRegistry/#agentframeworkfunctionregistryallfunctiontypes-property","title":"AgentFrameworkFunctionRegistry.AllFunctionTypes Property","text":"<p>All types containing methods decorated with [AgentFunction], discovered at compile time.</p> <pre><code>public static System.Collections.Generic.IReadOnlyList&lt;System.Type&gt; AllFunctionTypes { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkFunctionRegistry/#property-value","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkFunctionRegistry/#agentframeworkfunctionregistrycount-property","title":"AgentFrameworkFunctionRegistry.Count Property","text":"<p>Gets the number of function types discovered at compile time.</p> <pre><code>public static int Count { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkFunctionRegistry/#property-value_1","title":"Property Value","text":"<p>System.Int32</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkGeneratedBootstrap/","title":"AgentFrameworkGeneratedBootstrap","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkGeneratedBootstrap/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkGeneratedBootstrap/#nexuslabsneedlragentframework_1","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkGeneratedBootstrap/#agentframeworkgeneratedbootstrap-class","title":"AgentFrameworkGeneratedBootstrap Class","text":"<p>Runtime bootstrap registry for source-generated Agent Framework components.</p> <pre><code>public static class AgentFrameworkGeneratedBootstrap\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 AgentFrameworkGeneratedBootstrap</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkGeneratedBootstrap/#remarks","title":"Remarks","text":"<p>The source generator emits a <code>[ModuleInitializer]</code> in the host assembly that calls NexusLabs.Needlr.AgentFramework.AgentFrameworkGeneratedBootstrap.Register(System.Func{System.Collections.Generic.IReadOnlyList{System.Type}},System.Func{System.Collections.Generic.IReadOnlyDictionary{System.String,System.Collections.Generic.IReadOnlyList{System.Type}}},System.Func{System.Collections.Generic.IReadOnlyList{System.Type}},System.Func{System.Collections.Generic.IReadOnlyDictionary{System.Type,System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.Type,System.String}}}},System.Func{System.Collections.Generic.IReadOnlyDictionary{System.String,System.Collections.Generic.IReadOnlyList{System.Type}}},System.Func{System.Collections.Generic.IReadOnlyDictionary{System.String,System.Collections.Generic.IReadOnlyList{System.Type}}}) with the generated type providers. <code>UsingAgentFramework()</code> checks this bootstrap and auto-populates function types, groups, and agent types without requiring any explicit <code>Add*FromGenerated()</code> calls.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkGeneratedBootstrap/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkGeneratedBootstrap/#agentframeworkgeneratedbootstrapregisteraifunctionprovideriaifunctionprovider-method","title":"AgentFrameworkGeneratedBootstrap.RegisterAIFunctionProvider(IAIFunctionProvider) Method","text":"<p>Registers the generated IAIFunctionProvider for this assembly. Called automatically by the generator-emitted <code>[ModuleInitializer]</code>.</p> <pre><code>public static void RegisterAIFunctionProvider(NexusLabs.Needlr.AgentFramework.IAIFunctionProvider provider);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkGeneratedBootstrap/#parameters","title":"Parameters","text":"<p><code>provider</code> IAIFunctionProvider</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkGeneratedBootstrap/#agentframeworkgeneratedbootstraptrygetagenttypesfuncireadonlylisttype-method","title":"AgentFrameworkGeneratedBootstrap.TryGetAgentTypes(Func&lt;IReadOnlyList&lt;Type&gt;&gt;) Method","text":"<p>Gets the combined agent type provider from all registered assemblies.</p> <pre><code>public static bool TryGetAgentTypes(out System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;&gt;? provider);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkGeneratedBootstrap/#parameters_1","title":"Parameters","text":"<p><code>provider</code> System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkGeneratedBootstrap/#returns","title":"Returns","text":"<p>System.Boolean</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkGeneratedBootstrap/#agentframeworkgeneratedbootstraptrygetaifunctionprovideriaifunctionprovider-method","title":"AgentFrameworkGeneratedBootstrap.TryGetAIFunctionProvider(IAIFunctionProvider) Method","text":"<p>Gets the registered IAIFunctionProvider, if one has been registered.</p> <pre><code>public static bool TryGetAIFunctionProvider(out NexusLabs.Needlr.AgentFramework.IAIFunctionProvider? provider);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkGeneratedBootstrap/#parameters_2","title":"Parameters","text":"<p><code>provider</code> IAIFunctionProvider</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkGeneratedBootstrap/#returns_1","title":"Returns","text":"<p>System.Boolean</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkGeneratedBootstrap/#agentframeworkgeneratedbootstraptrygetfunctiontypesfuncireadonlylisttype-method","title":"AgentFrameworkGeneratedBootstrap.TryGetFunctionTypes(Func&lt;IReadOnlyList&lt;Type&gt;&gt;) Method","text":"<p>Gets the combined function type provider from all registered assemblies.</p> <pre><code>public static bool TryGetFunctionTypes(out System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;&gt;? provider);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkGeneratedBootstrap/#parameters_3","title":"Parameters","text":"<p><code>provider</code> System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkGeneratedBootstrap/#returns_2","title":"Returns","text":"<p>System.Boolean</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkGeneratedBootstrap/#agentframeworkgeneratedbootstraptrygetgroupchatgroupsfuncireadonlydictionarystringireadonlylisttype-method","title":"AgentFrameworkGeneratedBootstrap.TryGetGroupChatGroups(Func&lt;IReadOnlyDictionary&lt;string,IReadOnlyList&lt;Type&gt;&gt;&gt;) Method","text":"<p>Gets the combined group chat groups provider from all registered assemblies.</p> <pre><code>public static bool TryGetGroupChatGroups(out System.Func&lt;System.Collections.Generic.IReadOnlyDictionary&lt;string,System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;&gt;&gt;? provider);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkGeneratedBootstrap/#parameters_4","title":"Parameters","text":"<p><code>provider</code> System.Func&lt;System.Collections.Generic.IReadOnlyDictionary&lt;System.String,System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;&gt;&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkGeneratedBootstrap/#returns_3","title":"Returns","text":"<p>System.Boolean</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkGeneratedBootstrap/#agentframeworkgeneratedbootstraptrygetgrouptypesfuncireadonlydictionarystringireadonlylisttype-method","title":"AgentFrameworkGeneratedBootstrap.TryGetGroupTypes(Func&lt;IReadOnlyDictionary&lt;string,IReadOnlyList&lt;Type&gt;&gt;&gt;) Method","text":"<p>Gets the combined function group provider from all registered assemblies.</p> <pre><code>public static bool TryGetGroupTypes(out System.Func&lt;System.Collections.Generic.IReadOnlyDictionary&lt;string,System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;&gt;&gt;? provider);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkGeneratedBootstrap/#parameters_5","title":"Parameters","text":"<p><code>provider</code> System.Func&lt;System.Collections.Generic.IReadOnlyDictionary&lt;System.String,System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;&gt;&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkGeneratedBootstrap/#returns_4","title":"Returns","text":"<p>System.Boolean</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkGeneratedBootstrap/#agentframeworkgeneratedbootstraptrygetsequentialtopologyfuncireadonlydictionarystringireadonlylisttype-method","title":"AgentFrameworkGeneratedBootstrap.TryGetSequentialTopology(Func&lt;IReadOnlyDictionary&lt;string,IReadOnlyList&lt;Type&gt;&gt;&gt;) Method","text":"<p>Gets the combined sequential topology provider from all registered assemblies.</p> <pre><code>public static bool TryGetSequentialTopology(out System.Func&lt;System.Collections.Generic.IReadOnlyDictionary&lt;string,System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;&gt;&gt;? provider);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkGeneratedBootstrap/#parameters_6","title":"Parameters","text":"<p><code>provider</code> System.Func&lt;System.Collections.Generic.IReadOnlyDictionary&lt;System.String,System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;&gt;&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkGeneratedBootstrap/#returns_5","title":"Returns","text":"<p>System.Boolean</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringe/","title":"AgentFrameworkSyringe","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringe/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringe/#nexuslabsneedlragentframework_1","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringe/#agentframeworksyringe-class","title":"AgentFrameworkSyringe Class","text":"<p>Fluent builder for configuring the Microsoft Agent Framework with Needlr function discovery.</p> <pre><code>public sealed record AgentFrameworkSyringe : System.IEquatable&lt;NexusLabs.Needlr.AgentFramework.AgentFrameworkSyringe&gt;\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 AgentFrameworkSyringe</p> <p>Implements System.IEquatable&lt;AgentFrameworkSyringe&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringe/#example","title":"Example","text":"<pre><code>// Obtained from SyringeAgentFrameworkExtensions.UsingAgentFramework()\nAgentFrameworkSyringe syringe = app.Services.UsingAgentFramework();\n\n// Register function types and build the factory\nIAgentFactory factory = syringe\n    .AddAgentFunctionsFromGenerated(GeneratedAgentFunctions.AllFunctionTypes)\n    .BuildAgentFactory();\n\n// Create agents from the factory\nvar supportAgent = factory.CreateAgent&lt;CustomerSupportAgent&gt;();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringe/#remarks","title":"Remarks","text":"<p>When the Needlr source generator is active (the common case), this class uses pre-built IAIFunctionProvider instances registered by the generated <code>[ModuleInitializer]</code>. No reflection is required in that path.</p> <p>When the source generator is not used, this class falls back to reflection to discover methods decorated with AgentFunctionAttribute. That path carries <code>[RequiresDynamicCode]</code> and is not NativeAOT-compatible.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringeExtensions/","title":"AgentFrameworkSyringeExtensions","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringeExtensions/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringeExtensions/#nexuslabsneedlragentframework_1","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringeExtensions/#agentframeworksyringeextensions-class","title":"AgentFrameworkSyringeExtensions Class","text":"<p>Extension methods for AgentFrameworkSyringe providing fluent configuration of the Microsoft Agent Framework integration.</p> <pre><code>public static class AgentFrameworkSyringeExtensions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 AgentFrameworkSyringeExtensions</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringeExtensions/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringeExtensions/#agentframeworksyringeextensionsaddagenttagentthis-agentframeworksyringe-method","title":"AgentFrameworkSyringeExtensions.AddAgent&lt;TAgent&gt;(this AgentFrameworkSyringe) Method","text":"<p>Registers a single declared agent type for string-based lookup via CreateAgent(string). The type must be decorated with NeedlrAiAgentAttribute.</p> <pre><code>public static NexusLabs.Needlr.AgentFramework.AgentFrameworkSyringe AddAgent&lt;TAgent&gt;(this NexusLabs.Needlr.AgentFramework.AgentFrameworkSyringe syringe)\n    where TAgent : class;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringeExtensions/#type-parameters","title":"Type parameters","text":"<p><code>TAgent</code></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringeExtensions/#parameters","title":"Parameters","text":"<p><code>syringe</code> AgentFrameworkSyringe</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringeExtensions/#returns","title":"Returns","text":"<p>AgentFrameworkSyringe</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringeExtensions/#agentframeworksyringeextensionsaddagentfunctiongroupsfromassembliesthis-agentframeworksyringe-method","title":"AgentFrameworkSyringeExtensions.AddAgentFunctionGroupsFromAssemblies(this AgentFrameworkSyringe) Method","text":"<p>Scans registered assemblies for classes decorated with AgentFunctionGroupAttribute and registers them by group name. Requires <code>UsingReflection()</code> to be configured.</p> <pre><code>public static NexusLabs.Needlr.AgentFramework.AgentFrameworkSyringe AddAgentFunctionGroupsFromAssemblies(this NexusLabs.Needlr.AgentFramework.AgentFrameworkSyringe syringe);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringeExtensions/#parameters_1","title":"Parameters","text":"<p><code>syringe</code> AgentFrameworkSyringe</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringeExtensions/#returns_1","title":"Returns","text":"<p>AgentFrameworkSyringe</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringeExtensions/#agentframeworksyringeextensionsaddagentfunctiongroupsfromassembliesthis-agentframeworksyringe-ireadonlylistassembly-method","title":"AgentFrameworkSyringeExtensions.AddAgentFunctionGroupsFromAssemblies(this AgentFrameworkSyringe, IReadOnlyList&lt;Assembly&gt;) Method","text":"<p>Scans the provided assemblies for classes decorated with AgentFunctionGroupAttribute and registers them by group name.</p> <pre><code>public static NexusLabs.Needlr.AgentFramework.AgentFrameworkSyringe AddAgentFunctionGroupsFromAssemblies(this NexusLabs.Needlr.AgentFramework.AgentFrameworkSyringe syringe, System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt; assemblies);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringeExtensions/#parameters_2","title":"Parameters","text":"<p><code>syringe</code> AgentFrameworkSyringe</p> <p></p> <p><code>assemblies</code> System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringeExtensions/#returns_2","title":"Returns","text":"<p>AgentFrameworkSyringe</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringeExtensions/#agentframeworksyringeextensionsaddagentfunctiongroupsfromgeneratedthis-agentframeworksyringe-ireadonlydictionarystringireadonlylisttype-method","title":"AgentFrameworkSyringeExtensions.AddAgentFunctionGroupsFromGenerated(this AgentFrameworkSyringe, IReadOnlyDictionary&lt;string,IReadOnlyList&lt;Type&gt;&gt;) Method","text":"<p>Adds agent function groups from a compile-time generated group map. This is the recommended approach for AOT/trimmed applications.</p> <pre><code>public static NexusLabs.Needlr.AgentFramework.AgentFrameworkSyringe AddAgentFunctionGroupsFromGenerated(this NexusLabs.Needlr.AgentFramework.AgentFrameworkSyringe syringe, System.Collections.Generic.IReadOnlyDictionary&lt;string,System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;&gt; groups);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringeExtensions/#parameters_3","title":"Parameters","text":"<p><code>syringe</code> AgentFrameworkSyringe</p> <p>The agent framework syringe to configure.</p> <p></p> <p><code>groups</code> System.Collections.Generic.IReadOnlyDictionary&lt;System.String,System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;&gt;</p> <p>Compile-time discovered group map, typically from the generated <code>AgentFrameworkFunctionGroupRegistry.AllGroups</code>.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringeExtensions/#returns_3","title":"Returns","text":"<p>AgentFrameworkSyringe</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringeExtensions/#agentframeworksyringeextensionsaddagentfunctionsfromgeneratedthis-agentframeworksyringe-ireadonlylisttype-method","title":"AgentFrameworkSyringeExtensions.AddAgentFunctionsFromGenerated(this AgentFrameworkSyringe, IReadOnlyList&lt;Type&gt;) Method","text":"<p>Adds agent functions from a compile-time generated list of types. This is the recommended approach for AOT/trimmed applications because the source generator discovers types at build time rather than runtime.</p> <pre><code>public static NexusLabs.Needlr.AgentFramework.AgentFrameworkSyringe AddAgentFunctionsFromGenerated(this NexusLabs.Needlr.AgentFramework.AgentFrameworkSyringe syringe, System.Collections.Generic.IReadOnlyList&lt;System.Type&gt; functionTypes);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringeExtensions/#parameters_4","title":"Parameters","text":"<p><code>syringe</code> AgentFrameworkSyringe</p> <p>The agent framework syringe to configure.</p> <p></p> <p><code>functionTypes</code> System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;</p> <p>Compile-time discovered function types, typically from the generated <code>NexusLabs.Needlr.Generated.AgentFrameworkFunctions.AllFunctionTypes</code>.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringeExtensions/#returns_4","title":"Returns","text":"<p>AgentFrameworkSyringe</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringeExtensions/#remarks","title":"Remarks","text":"<p>This overload performs no reflection for type discovery. The NexusLabs.Needlr.AgentFramework.AgentFactory still uses reflection when building Microsoft.Extensions.AI.AIFunction schema from method signatures \u2014 the same inherent limitation present in Microsoft.Extensions.AI.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringeExtensions/#agentframeworksyringeextensionsaddagentsfromgeneratedthis-agentframeworksyringe-ireadonlylisttype-method","title":"AgentFrameworkSyringeExtensions.AddAgentsFromGenerated(this AgentFrameworkSyringe, IReadOnlyList&lt;Type&gt;) Method","text":"<p>Registers a compile-time generated list of declared agent types for string-based lookup via CreateAgent(string). Typically called with the output of the generated <code>AgentRegistry.AllAgentTypes</code>.</p> <pre><code>public static NexusLabs.Needlr.AgentFramework.AgentFrameworkSyringe AddAgentsFromGenerated(this NexusLabs.Needlr.AgentFramework.AgentFrameworkSyringe syringe, System.Collections.Generic.IReadOnlyList&lt;System.Type&gt; agentTypes);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringeExtensions/#parameters_5","title":"Parameters","text":"<p><code>syringe</code> AgentFrameworkSyringe</p> <p></p> <p><code>agentTypes</code> System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringeExtensions/#returns_5","title":"Returns","text":"<p>AgentFrameworkSyringe</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringeExtensions/#agentframeworksyringeextensionsusingchatclientthis-agentframeworksyringe-ichatclient-method","title":"AgentFrameworkSyringeExtensions.UsingChatClient(this AgentFrameworkSyringe, IChatClient) Method","text":"<p>Sets the Microsoft.Extensions.AI.IChatClient used by all agents created from the factory. This is the preferred alternative to calling NexusLabs.Needlr.AgentFramework.AgentFrameworkSyringeExtensions.Configure(NexusLabs.Needlr.AgentFramework.AgentFrameworkSyringe,System.Action{NexusLabs.Needlr.AgentFramework.AgentFrameworkConfigureOptions}) and setting ChatClientFactory.</p> <pre><code>public static NexusLabs.Needlr.AgentFramework.AgentFrameworkSyringe UsingChatClient(this NexusLabs.Needlr.AgentFramework.AgentFrameworkSyringe syringe, Microsoft.Extensions.AI.IChatClient chatClient);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringeExtensions/#parameters_6","title":"Parameters","text":"<p><code>syringe</code> AgentFrameworkSyringe</p> <p></p> <p><code>chatClient</code> Microsoft.Extensions.AI.IChatClient</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringeExtensions/#returns_6","title":"Returns","text":"<p>AgentFrameworkSyringe</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringeExtensions/#agentframeworksyringeextensionsusingchatclientthis-agentframeworksyringe-funciserviceproviderichatclient-method","title":"AgentFrameworkSyringeExtensions.UsingChatClient(this AgentFrameworkSyringe, Func&lt;IServiceProvider,IChatClient&gt;) Method","text":"<p>Sets a factory that creates the Microsoft.Extensions.AI.IChatClient used by all agents. The factory receives the DI System.IServiceProvider for resolving dependencies.</p> <pre><code>public static NexusLabs.Needlr.AgentFramework.AgentFrameworkSyringe UsingChatClient(this NexusLabs.Needlr.AgentFramework.AgentFrameworkSyringe syringe, System.Func&lt;System.IServiceProvider,Microsoft.Extensions.AI.IChatClient&gt; chatClientFactory);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringeExtensions/#parameters_7","title":"Parameters","text":"<p><code>syringe</code> AgentFrameworkSyringe</p> <p></p> <p><code>chatClientFactory</code> System.Func&lt;System.IServiceProvider,Microsoft.Extensions.AI.IChatClient&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFrameworkSyringeExtensions/#returns_7","title":"Returns","text":"<p>AgentFrameworkSyringe</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFunctionAttribute/","title":"AgentFunctionAttribute","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFunctionAttribute/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFunctionAttribute/#nexuslabsneedlragentframework_1","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFunctionAttribute/#agentfunctionattribute-class","title":"AgentFunctionAttribute Class","text":"<p>Marks a method as an agent function that can be auto-discovered by Needlr and registered as an Microsoft.Extensions.AI.AIFunction tool for Microsoft Agent Framework agents.</p> <pre><code>public sealed class AgentFunctionAttribute : System.Attribute\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 System.Attribute \ud83e\udc52 AgentFunctionAttribute</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFunctionAttribute/#example","title":"Example","text":"<pre><code>public class OrderTools\n{\n    [AgentFunction]\n    [Description(\"Look up the status of an order by its ID\")]\n    public string GetOrderStatus(\n        [Description(\"The order identifier\")] string orderId)\n    {\n        return orderId == \"123\" ? \"Shipped\" : \"Processing\";\n    }\n}\n\n// Wire the function group to an agent:\n[NeedlrAiAgent(Instructions = \"Help users track their orders\")]\n[AgentFunctionGroup(typeof(OrderTools))]\npublic class OrderTrackingAgent { }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFunctionAttribute/#remarks","title":"Remarks","text":"<p>Apply this attribute to public methods on a class or static class. Needlr's scanners and source generator will discover all classes that contain at least one method decorated with <code>[AgentFunction]</code> and register them with the agent factory.</p> <p>Use System.ComponentModel.DescriptionAttribute to provide LLM-friendly descriptions for methods and parameters.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFunctionGroupAttribute/","title":"AgentFunctionGroupAttribute","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFunctionGroupAttribute/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFunctionGroupAttribute/#nexuslabsneedlragentframework_1","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFunctionGroupAttribute/#agentfunctiongroupattribute-class","title":"AgentFunctionGroupAttribute Class","text":"<p>Assigns a class to a named function group so that it can be wired to agents by group name rather than by explicit type reference.</p> <pre><code>public sealed class AgentFunctionGroupAttribute : System.Attribute\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 System.Attribute \ud83e\udc52 AgentFunctionGroupAttribute</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFunctionGroupAttribute/#example","title":"Example","text":"<pre><code>[AgentFunctionGroup(\"research\")]\npublic class GeographyFunctions { ... }\n\n[AgentFunctionGroup(\"research\")]\n[AgentFunctionGroup(\"general\")]\npublic class FactFunctions { ... }\n\n// At agent creation:\nagentFactory.CreateAgent(opts =&gt; opts.FunctionGroups = [\"research\"]);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFunctionGroupAttribute/#remarks","title":"Remarks","text":"<p>Apply this attribute to classes that contain methods decorated with AgentFunctionAttribute. Register groups using <code>AddAgentFunctionGroupsFromAssemblies()</code> or <code>AddAgentFunctionGroupsFromGenerated()</code>, then reference them in FunctionGroups at agent creation time.</p> <p>A class may belong to multiple groups by applying this attribute more than once.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFunctionGroupAttribute/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFunctionGroupAttribute/#agentfunctiongroupattributestring-constructor","title":"AgentFunctionGroupAttribute(string) Constructor","text":"<p>Initializes a new instance of AgentFunctionGroupAttribute.</p> <pre><code>public AgentFunctionGroupAttribute(string groupName);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFunctionGroupAttribute/#parameters","title":"Parameters","text":"<p><code>groupName</code> System.String</p> <p>The name of the group this class belongs to.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFunctionGroupAttribute/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFunctionGroupAttribute/#agentfunctiongroupattributegroupname-property","title":"AgentFunctionGroupAttribute.GroupName Property","text":"<p>Gets the name of the group this class belongs to.</p> <pre><code>public string GroupName { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentFunctionGroupAttribute/#property-value","title":"Property Value","text":"<p>System.String</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentGroupChatMemberAttribute/","title":"AgentGroupChatMemberAttribute","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentGroupChatMemberAttribute/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentGroupChatMemberAttribute/#nexuslabsneedlragentframework_1","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentGroupChatMemberAttribute/#agentgroupchatmemberattribute-class","title":"AgentGroupChatMemberAttribute Class","text":"<p>Declares that a NeedlrAiAgentAttribute-annotated agent participates in a named group chat workflow. Apply this attribute to include the agent in a round-robin group chat created via CreateGroupChatWorkflow(string, int).</p> <pre><code>public sealed class AgentGroupChatMemberAttribute : System.Attribute\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 System.Attribute \ud83e\udc52 AgentGroupChatMemberAttribute</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentGroupChatMemberAttribute/#remarks","title":"Remarks","text":"<p>When the <code>NexusLabs.Needlr.AgentFramework.Generators</code> package is referenced, the source generator emits a strongly-typed extension method (e.g. <code>CreateCodeReviewGroupChatWorkflow</code>) on IWorkflowFactory for each unique group name declared across all agent types. The generated method encapsulates the group name string so the composition root never references it directly.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentGroupChatMemberAttribute/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentGroupChatMemberAttribute/#agentgroupchatmemberattributestring-constructor","title":"AgentGroupChatMemberAttribute(string) Constructor","text":"<p>Initializes a new instance of AgentGroupChatMemberAttribute.</p> <pre><code>public AgentGroupChatMemberAttribute(string groupName);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentGroupChatMemberAttribute/#parameters","title":"Parameters","text":"<p><code>groupName</code> System.String</p> <p>The name of the group chat this agent participates in. Must match exactly (case-sensitive) when calling CreateGroupChatWorkflow(string, int). Use the generated extension method to avoid referencing the string directly.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentGroupChatMemberAttribute/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentGroupChatMemberAttribute/#agentgroupchatmemberattributegroupname-property","title":"AgentGroupChatMemberAttribute.GroupName Property","text":"<p>Gets the name of the group chat this agent participates in.</p> <pre><code>public string GroupName { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentGroupChatMemberAttribute/#property-value","title":"Property Value","text":"<p>System.String</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentGroupChatRegistry/","title":"AgentGroupChatRegistry","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentGroupChatRegistry/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentGroupChatRegistry/#nexuslabsneedlragentframeworkgenerated","title":"NexusLabs.Needlr.AgentFramework.Generated","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentGroupChatRegistry/#agentgroupchatregistry-class","title":"AgentGroupChatRegistry Class","text":"<p>Generated registry of agent group chat memberships declared via [AgentGroupChatMember] attributes.</p> <pre><code>public static class AgentGroupChatRegistry\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 AgentGroupChatRegistry</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentGroupChatRegistry/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentGroupChatRegistry/#agentgroupchatregistryallgroups-property","title":"AgentGroupChatRegistry.AllGroups Property","text":"<p>All group chat groups, mapping group name to the agent types in that group.</p> <pre><code>public static System.Collections.Generic.IReadOnlyDictionary&lt;string,System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;&gt; AllGroups { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentGroupChatRegistry/#property-value","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyDictionary&lt;System.String,System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentHandoffTopologyRegistry/","title":"AgentHandoffTopologyRegistry","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentHandoffTopologyRegistry/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentHandoffTopologyRegistry/#nexuslabsneedlragentframeworkgenerated","title":"NexusLabs.Needlr.AgentFramework.Generated","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentHandoffTopologyRegistry/#agenthandofftopologyregistry-class","title":"AgentHandoffTopologyRegistry Class","text":"<p>Generated registry of agent handoff topology declared via [AgentHandoffsTo] attributes.</p> <pre><code>public static class AgentHandoffTopologyRegistry\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 AgentHandoffTopologyRegistry</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentHandoffTopologyRegistry/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentHandoffTopologyRegistry/#agenthandofftopologyregistryallhandoffs-property","title":"AgentHandoffTopologyRegistry.AllHandoffs Property","text":"<p>All handoff relationships, mapping initial agent type to its declared handoff targets.</p> <pre><code>public static System.Collections.Generic.IReadOnlyDictionary&lt;System.Type,System.Collections.Generic.IReadOnlyList&lt;(System.Type TargetType,string? HandoffReason)&gt;&gt; AllHandoffs { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentHandoffTopologyRegistry/#property-value","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyDictionary&lt;System.Type,System.Collections.Generic.IReadOnlyList&lt;&lt;System.Type,System.String&gt;&gt;&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentHandoffsToAttribute/","title":"AgentHandoffsToAttribute","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentHandoffsToAttribute/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentHandoffsToAttribute/#nexuslabsneedlragentframework_1","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentHandoffsToAttribute/#agenthandoffstoattribute-class","title":"AgentHandoffsToAttribute Class","text":"<p>Declares a handoff target for a NeedlrAiAgentAttribute-annotated agent. Apply this attribute one or more times to specify which agents the decorated agent can hand off to when used as the initial agent in a handoff workflow via CreateHandoffWorkflow&lt;TInitialAgent&gt;().</p> <pre><code>public sealed class AgentHandoffsToAttribute : System.Attribute\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 System.Attribute \ud83e\udc52 AgentHandoffsToAttribute</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentHandoffsToAttribute/#example","title":"Example","text":"<pre><code>[NeedlrAiAgent(Instructions = \"Triage incoming customer requests.\")]\n[AgentHandoffsTo(typeof(BillingAgent),  \"Route billing or payment questions to the billing agent\")]\n[AgentHandoffsTo(typeof(SupportAgent),  \"Route general support requests to the support agent\")]\npublic class TriageAgent { }\n\n// The source generator emits:\n//   workflowFactory.CreateTriageAgentHandoffWorkflow()\n// which wires all handoffs without requiring direct type references at the call site.\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentHandoffsToAttribute/#remarks","title":"Remarks","text":"<p>When the <code>NexusLabs.Needlr.AgentFramework.Generators</code> package is referenced, the source generator emits a strongly-typed extension method (e.g. <code>CreateTriageHandoffWorkflow</code>) on IWorkflowFactory for each agent type that carries this attribute. The generated method encapsulates the agent type so the composition root requires no direct type references.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentHandoffsToAttribute/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentHandoffsToAttribute/#agenthandoffstoattributetype-string-constructor","title":"AgentHandoffsToAttribute(Type, string) Constructor","text":"<p>Initializes a new instance of AgentHandoffsToAttribute.</p> <pre><code>public AgentHandoffsToAttribute(System.Type targetAgentType, string? handoffReason=null);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentHandoffsToAttribute/#parameters","title":"Parameters","text":"<p><code>targetAgentType</code> System.Type</p> <p>The type of the target agent. Must be annotated with NeedlrAiAgentAttribute.</p> <p></p> <p><code>handoffReason</code> System.String</p> <p>A description of when the decorated agent should hand off to targetAgentType. Passed to the underlying MAF handoff builder as the tool description. When null, MAF derives the reason from the target agent's description or name.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentHandoffsToAttribute/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentHandoffsToAttribute/#agenthandoffstoattributehandoffreason-property","title":"AgentHandoffsToAttribute.HandoffReason Property","text":"<p>Gets the optional reason describing when to hand off to TargetAgentType.</p> <pre><code>public string? HandoffReason { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentHandoffsToAttribute/#property-value","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentHandoffsToAttribute/#agenthandoffstoattributetargetagenttype-property","title":"AgentHandoffsToAttribute.TargetAgentType Property","text":"<p>Gets the type of the target agent to hand off to.</p> <pre><code>public System.Type TargetAgentType { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentHandoffsToAttribute/#property-value_1","title":"Property Value","text":"<p>System.Type</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentNames/","title":"AgentNames","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentNames/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentNames/#nexuslabsneedlragentframeworkgenerated","title":"NexusLabs.Needlr.AgentFramework.Generated","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentNames/#agentnames-class","title":"AgentNames Class","text":"<p>String constants for agent type names discovered at compile time.</p> <pre><code>public static class AgentNames\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 AgentNames</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentRegistry/","title":"AgentRegistry","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentRegistry/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentRegistry/#nexuslabsneedlragentframeworkgenerated","title":"NexusLabs.Needlr.AgentFramework.Generated","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentRegistry/#agentregistry-class","title":"AgentRegistry Class","text":"<p>Generated registry for agent types declared with [NeedlrAiAgent], discovered at compile time.</p> <pre><code>public static class AgentRegistry\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 AgentRegistry</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentRegistry/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentRegistry/#agentregistryallagenttypes-property","title":"AgentRegistry.AllAgentTypes Property","text":"<p>All types decorated with [NeedlrAiAgent], discovered at compile time.</p> <pre><code>public static System.Collections.Generic.IReadOnlyList&lt;System.Type&gt; AllAgentTypes { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentRegistry/#property-value","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentRegistry/#agentregistrycount-property","title":"AgentRegistry.Count Property","text":"<p>Gets the number of agent types discovered at compile time.</p> <pre><code>public static int Count { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentRegistry/#property-value_1","title":"Property Value","text":"<p>System.Int32</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentSequenceMemberAttribute/","title":"AgentSequenceMemberAttribute","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentSequenceMemberAttribute/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentSequenceMemberAttribute/#nexuslabsneedlragentframework_1","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentSequenceMemberAttribute/#agentsequencememberattribute-class","title":"AgentSequenceMemberAttribute Class","text":"<p>Marks an agent class as a member of a named sequential pipeline, specifying its position. The source generator reads these declarations to emit a strongly-typed <code>Create{PipelineName}SequentialWorkflow()</code> extension method on IWorkflowFactory.</p> <pre><code>public sealed class AgentSequenceMemberAttribute : System.Attribute\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 System.Attribute \ud83e\udc52 AgentSequenceMemberAttribute</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentSequenceMemberAttribute/#example","title":"Example","text":"<pre><code>[NeedlrAiAgent(Instructions = \"Extract key facts from the user's input.\")]\n[AgentSequenceMember(\"ContentPipeline\", order: 0)]\npublic class ExtractorAgent { }\n\n[NeedlrAiAgent(Instructions = \"Summarize extracted facts into a concise paragraph.\")]\n[AgentSequenceMember(\"ContentPipeline\", order: 1)]\npublic class SummarizerAgent { }\n\n[NeedlrAiAgent(Instructions = \"Format the summary as a structured JSON report.\")]\n[AgentSequenceMember(\"ContentPipeline\", order: 2)]\npublic class FormatterAgent { }\n\n// The source generator emits:\n//   workflowFactory.CreateContentPipelineSequentialWorkflow()\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentSequenceMemberAttribute/#remarks","title":"Remarks","text":"<p>Apply multiple instances of this attribute on different agent classes with the same pipelineName to declare the full sequence. Agents are executed in ascending order \u2014 output from each agent is passed as input to the next.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentSequenceMemberAttribute/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentSequenceMemberAttribute/#agentsequencememberattributestring-int-constructor","title":"AgentSequenceMemberAttribute(string, int) Constructor","text":"<p>Marks an agent class as a member of a named sequential pipeline, specifying its position. The source generator reads these declarations to emit a strongly-typed <code>Create{PipelineName}SequentialWorkflow()</code> extension method on IWorkflowFactory.</p> <pre><code>public AgentSequenceMemberAttribute(string pipelineName, int order);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentSequenceMemberAttribute/#parameters","title":"Parameters","text":"<p><code>pipelineName</code> System.String</p> <p></p> <p><code>order</code> System.Int32</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentSequenceMemberAttribute/#example_1","title":"Example","text":"<pre><code>[NeedlrAiAgent(Instructions = \"Extract key facts from the user's input.\")]\n[AgentSequenceMember(\"ContentPipeline\", order: 0)]\npublic class ExtractorAgent { }\n\n[NeedlrAiAgent(Instructions = \"Summarize extracted facts into a concise paragraph.\")]\n[AgentSequenceMember(\"ContentPipeline\", order: 1)]\npublic class SummarizerAgent { }\n\n[NeedlrAiAgent(Instructions = \"Format the summary as a structured JSON report.\")]\n[AgentSequenceMember(\"ContentPipeline\", order: 2)]\npublic class FormatterAgent { }\n\n// The source generator emits:\n//   workflowFactory.CreateContentPipelineSequentialWorkflow()\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentSequenceMemberAttribute/#remarks_1","title":"Remarks","text":"<p>Apply multiple instances of this attribute on different agent classes with the same pipelineName to declare the full sequence. Agents are executed in ascending order \u2014 output from each agent is passed as input to the next.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentSequenceMemberAttribute/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentSequenceMemberAttribute/#agentsequencememberattributeorder-property","title":"AgentSequenceMemberAttribute.Order Property","text":"<p>The zero-based position of this agent within the pipeline sequence.</p> <pre><code>public int Order { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentSequenceMemberAttribute/#property-value","title":"Property Value","text":"<p>System.Int32</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentSequenceMemberAttribute/#agentsequencememberattributepipelinename-property","title":"AgentSequenceMemberAttribute.PipelineName Property","text":"<p>The name of the sequential pipeline this agent belongs to.</p> <pre><code>public string PipelineName { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentSequenceMemberAttribute/#property-value_1","title":"Property Value","text":"<p>System.String</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentSequentialTopologyRegistry/","title":"AgentSequentialTopologyRegistry","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentSequentialTopologyRegistry/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentSequentialTopologyRegistry/#nexuslabsneedlragentframeworkgenerated","title":"NexusLabs.Needlr.AgentFramework.Generated","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentSequentialTopologyRegistry/#agentsequentialtopologyregistry-class","title":"AgentSequentialTopologyRegistry Class","text":"<p>Generated registry of sequential pipeline memberships declared via [AgentSequenceMember] attributes. Agents within each pipeline are stored in ascending order value order.</p> <pre><code>public static class AgentSequentialTopologyRegistry\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 AgentSequentialTopologyRegistry</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentSequentialTopologyRegistry/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentSequentialTopologyRegistry/#agentsequentialtopologyregistryallpipelines-property","title":"AgentSequentialTopologyRegistry.AllPipelines Property","text":"<p>All sequential pipelines, mapping pipeline name to the ordered agent types.</p> <pre><code>public static System.Collections.Generic.IReadOnlyDictionary&lt;string,System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;&gt; AllPipelines { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentSequentialTopologyRegistry/#property-value","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyDictionary&lt;System.String,System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentTerminationConditionAttribute/","title":"AgentTerminationConditionAttribute","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentTerminationConditionAttribute/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentTerminationConditionAttribute/#nexuslabsneedlragentframework_1","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentTerminationConditionAttribute/#agentterminationconditionattribute-class","title":"AgentTerminationConditionAttribute Class","text":"<p>Declares a termination condition that is wired into the group chat manager for this agent (Layer 1). The condition is evaluated inside MAF's group chat loop, before the next agent turn starts, giving a clean early exit.</p> <pre><code>public sealed class AgentTerminationConditionAttribute : System.Attribute\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 System.Attribute \ud83e\udc52 AgentTerminationConditionAttribute</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentTerminationConditionAttribute/#remarks","title":"Remarks","text":"<p>Apply to a class also decorated with AgentGroupChatMemberAttribute. Multiple conditions may be stacked; OR semantics apply (first match stops the workflow).</p> <p>The <code>conditionType</code> must implement IWorkflowTerminationCondition. Constructor arguments for the condition are passed via <code>ctorArgs</code>.\\&lt;example&gt;   \\&lt;code&gt;             [AgentGroupChatMember(\"code-review\")]             [AgentTerminationCondition(typeof(KeywordTerminationCondition), \"APPROVED\")]             public class ApprovalAgent { }             \\&lt;/code&gt; \\&lt;/example&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentTerminationConditionAttribute/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentTerminationConditionAttribute/#agentterminationconditionattributetype-object-constructor","title":"AgentTerminationConditionAttribute(Type, object[]) Constructor","text":"<p>Initializes a new instance of AgentTerminationConditionAttribute.</p> <pre><code>public AgentTerminationConditionAttribute(System.Type conditionType, params object[] ctorArgs);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentTerminationConditionAttribute/#parameters","title":"Parameters","text":"<p><code>conditionType</code> System.Type</p> <p>The type that implements IWorkflowTerminationCondition. An instance is created at workflow construction time via System.Activator.CreateInstance(System.Type,System.Object[]) with ctorArgs.</p> <p></p> <p><code>ctorArgs</code> System.Object[]</p> <p>Arguments forwarded to the condition's constructor. May be empty if the condition has a parameterless constructor.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentTerminationConditionAttribute/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentTerminationConditionAttribute/#agentterminationconditionattributeconditiontype-property","title":"AgentTerminationConditionAttribute.ConditionType Property","text":"<p>Gets the type of the termination condition to instantiate.</p> <pre><code>public System.Type ConditionType { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentTerminationConditionAttribute/#property-value","title":"Property Value","text":"<p>System.Type</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentTerminationConditionAttribute/#agentterminationconditionattributectorargs-property","title":"AgentTerminationConditionAttribute.CtorArgs Property","text":"<p>Gets the constructor arguments forwarded when instantiating the condition.</p> <pre><code>public object[] CtorArgs { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/AgentTerminationConditionAttribute/#property-value_1","title":"Property Value","text":"<p>System.Object[]</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/GeneratedAgentFactoryExtensions/","title":"GeneratedAgentFactoryExtensions","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/GeneratedAgentFactoryExtensions/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/GeneratedAgentFactoryExtensions/#nexuslabsneedlragentframeworkgenerated","title":"NexusLabs.Needlr.AgentFramework.Generated","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/GeneratedAgentFactoryExtensions/#generatedagentfactoryextensions-class","title":"GeneratedAgentFactoryExtensions Class","text":"<p>Generated strongly-typed extension methods on IAgentFactory. Each method creates an agent from its <code>[NeedlrAiAgent]</code> declaration, eliminating magic strings and direct type references at the composition root.</p> <pre><code>public static class GeneratedAgentFactoryExtensions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 GeneratedAgentFactoryExtensions</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/GeneratedAgentFrameworkSyringeExtensions/","title":"GeneratedAgentFrameworkSyringeExtensions","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/GeneratedAgentFrameworkSyringeExtensions/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/GeneratedAgentFrameworkSyringeExtensions/#nexuslabsneedlragentframeworkgenerated","title":"NexusLabs.Needlr.AgentFramework.Generated","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/GeneratedAgentFrameworkSyringeExtensions/#generatedagentframeworksyringeextensions-class","title":"GeneratedAgentFrameworkSyringeExtensions Class","text":"<p>Generated strongly-typed extension methods on AgentFrameworkSyringe. Each method registers a named function group without requiring direct type references.</p> <pre><code>public static class GeneratedAgentFrameworkSyringeExtensions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 GeneratedAgentFrameworkSyringeExtensions</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/GeneratedAgentFunctionScanner/","title":"GeneratedAgentFunctionScanner","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/GeneratedAgentFunctionScanner/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/GeneratedAgentFunctionScanner/#nexuslabsneedlragentframeworkfunctionscanners","title":"NexusLabs.Needlr.AgentFramework.FunctionScanners","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/GeneratedAgentFunctionScanner/#generatedagentfunctionscanner-class","title":"GeneratedAgentFunctionScanner Class","text":"<p>Source-generation-friendly agent function scanner that uses compile-time generated function type lists.</p> <pre><code>public sealed class GeneratedAgentFunctionScanner : NexusLabs.Needlr.AgentFramework.IAgentFrameworkFunctionScanner\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 GeneratedAgentFunctionScanner</p> <p>Implements IAgentFrameworkFunctionScanner</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/GeneratedAgentFunctionScanner/#remarks","title":"Remarks","text":"<p>When using source generation, the generator emits a <code>NexusLabs.Needlr.Generated.AgentFrameworkFunctions</code> class with <code>AllFunctionTypes</code> containing all types with AgentFunctionAttribute methods.</p> <p>For AOT/trimmed applications, use AddAgentFunctionsFromGenerated(this AgentFrameworkSyringe, IReadOnlyList&lt;Type&gt;) directly (which requires no reflection for discovery) rather than this scanner.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/GroupNames/","title":"GroupNames","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/GroupNames/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/GroupNames/#nexuslabsneedlragentframeworkgenerated","title":"NexusLabs.Needlr.AgentFramework.Generated","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/GroupNames/#groupnames-class","title":"GroupNames Class","text":"<p>String constants for function group names discovered at compile time.</p> <pre><code>public static class GroupNames\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 GroupNames</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAIAgentBuilderPlugin/","title":"IAIAgentBuilderPlugin","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAIAgentBuilderPlugin/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAIAgentBuilderPlugin/#nexuslabsneedlragentframework_1","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAIAgentBuilderPlugin/#iaiagentbuilderplugin-interface","title":"IAIAgentBuilderPlugin Interface","text":"<p>Marker interface for classes that participate in configuring the agent builder pipeline (e.g., adding middleware layers).</p> <pre><code>public interface IAIAgentBuilderPlugin\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAIAgentBuilderPlugin/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAIAgentBuilderPlugin/#iaiagentbuilderpluginconfigureaiagentbuilderpluginoptions-method","title":"IAIAgentBuilderPlugin.Configure(AIAgentBuilderPluginOptions) Method","text":"<p>Called during agent factory initialisation to configure the agent builder.</p> <pre><code>void Configure(NexusLabs.Needlr.AgentFramework.AIAgentBuilderPluginOptions options);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAIAgentBuilderPlugin/#parameters","title":"Parameters","text":"<p><code>options</code> AIAgentBuilderPluginOptions</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAIFunctionProvider/","title":"IAIFunctionProvider","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAIFunctionProvider/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAIFunctionProvider/#nexuslabsneedlragentframework_1","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAIFunctionProvider/#iaifunctionprovider-interface","title":"IAIFunctionProvider Interface","text":"<p>Provides pre-built Microsoft.Extensions.AI.AIFunction instances for agent function types. Implemented by the source generator to eliminate reflection-based function discovery.</p> <pre><code>public interface IAIFunctionProvider\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAIFunctionProvider/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAIFunctionProvider/#iaifunctionprovidertrygetfunctionstype-iserviceprovider-ireadonlylistaifunction-method","title":"IAIFunctionProvider.TryGetFunctions(Type, IServiceProvider, IReadOnlyList&lt;AIFunction&gt;) Method","text":"<p>Attempts to retrieve the pre-built Microsoft.Extensions.AI.AIFunction instances for a given function type.</p> <pre><code>bool TryGetFunctions(System.Type functionType, System.IServiceProvider serviceProvider, out System.Collections.Generic.IReadOnlyList&lt;Microsoft.Extensions.AI.AIFunction&gt;? functions);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAIFunctionProvider/#parameters","title":"Parameters","text":"<p><code>functionType</code> System.Type</p> <p>The function class type to look up.</p> <p></p> <p><code>serviceProvider</code> System.IServiceProvider</p> <p>The service provider used to resolve the function class instance when needed. The provider handles instance creation to avoid reflection-based activation.</p> <p></p> <p><code>functions</code> System.Collections.Generic.IReadOnlyList&lt;Microsoft.Extensions.AI.AIFunction&gt;</p> <p>When this method returns <code>true</code>, contains the pre-built functions for the type.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAIFunctionProvider/#returns","title":"Returns","text":"<p>System.Boolean <code>true</code> if the provider has pre-built functions for functionType; otherwise <code>false</code>.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAgentFactory/","title":"IAgentFactory","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAgentFactory/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAgentFactory/#nexuslabsneedlragentframework_1","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAgentFactory/#iagentfactory-interface","title":"IAgentFactory Interface","text":"<p>Factory for creating configured Microsoft.Agents.AI.AIAgent instances with auto-discovered AgentFunctionAttribute tools wired up.</p> <pre><code>public interface IAgentFactory\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAgentFactory/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAgentFactory/#iagentfactorycreateagentstring-method","title":"IAgentFactory.CreateAgent(string) Method","text":"<p>Creates a new Microsoft.Agents.AI.AIAgent by looking up the registered type for agentClassName and reading its NeedlrAiAgentAttribute.</p> <pre><code>Microsoft.Agents.AI.AIAgent CreateAgent(string agentClassName);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAgentFactory/#parameters","title":"Parameters","text":"<p><code>agentClassName</code> System.String</p> <p>The simple class name of an agent type registered via <code>AddAgent&lt;T&gt;()</code>, <code>AddAgentsFromGenerated()</code>, or the source generator bootstrap.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAgentFactory/#returns","title":"Returns","text":"<p>Microsoft.Agents.AI.AIAgent</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAgentFactory/#exceptions","title":"Exceptions","text":"<p>System.InvalidOperationException Thrown when no agent with the given name is registered.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAgentFactory/#iagentfactorycreateagentactionagentfactoryoptions-method","title":"IAgentFactory.CreateAgent(Action&lt;AgentFactoryOptions&gt;) Method","text":"<p>Creates a new Microsoft.Agents.AI.AIAgent with the registered function tools applied.</p> <pre><code>Microsoft.Agents.AI.AIAgent CreateAgent(System.Action&lt;NexusLabs.Needlr.AgentFramework.AgentFactoryOptions&gt;? configure=null);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAgentFactory/#parameters_1","title":"Parameters","text":"<p><code>configure</code> System.Action&lt;AgentFactoryOptions&gt;</p> <p>Optional callback to configure per-agent options such as instructions or a subset of function types to wire for this specific agent instance.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAgentFactory/#returns_1","title":"Returns","text":"<p>Microsoft.Agents.AI.AIAgent A fully configured Microsoft.Agents.AI.AIAgent ready to run.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAgentFactory/#iagentfactorycreateagenttagent-method","title":"IAgentFactory.CreateAgent&lt;TAgent&gt;() Method","text":"<p>Creates a new Microsoft.Agents.AI.AIAgent by reading configuration directly from the NeedlrAiAgentAttribute on TAgent.</p> <pre><code>Microsoft.Agents.AI.AIAgent CreateAgent&lt;TAgent&gt;()\n    where TAgent : class;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAgentFactory/#type-parameters","title":"Type parameters","text":"<p><code>TAgent</code></p> <p>A class decorated with NeedlrAiAgentAttribute. The class name becomes the agent's <code>Name</code>.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAgentFactory/#returns_2","title":"Returns","text":"<p>Microsoft.Agents.AI.AIAgent</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAgentFactory/#exceptions_1","title":"Exceptions","text":"<p>System.InvalidOperationException Thrown when TAgent is not decorated with NeedlrAiAgentAttribute.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAgentFrameworkFunctionScanner/","title":"IAgentFrameworkFunctionScanner","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAgentFrameworkFunctionScanner/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAgentFrameworkFunctionScanner/#nexuslabsneedlragentframework_1","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAgentFrameworkFunctionScanner/#iagentframeworkfunctionscanner-interface","title":"IAgentFrameworkFunctionScanner Interface","text":"<p>Defines a scanner that discovers types containing AgentFunctionAttribute-decorated methods.</p> <pre><code>public interface IAgentFrameworkFunctionScanner\n</code></pre> <p>Derived \u21b3 GeneratedAgentFunctionScanner</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAgentFrameworkFunctionScanner/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAgentFrameworkFunctionScanner/#iagentframeworkfunctionscannerscanforfunctiontypes-method","title":"IAgentFrameworkFunctionScanner.ScanForFunctionTypes() Method","text":"<p>Scans for types that contain at least one method decorated with AgentFunctionAttribute.</p> <pre><code>System.Collections.Generic.IReadOnlyList&lt;System.Type&gt; ScanForFunctionTypes();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IAgentFrameworkFunctionScanner/#returns","title":"Returns","text":"<p>System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IWorkflowFactory/","title":"IWorkflowFactory","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IWorkflowFactory/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IWorkflowFactory/#nexuslabsneedlragentframework_1","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IWorkflowFactory/#iworkflowfactory-interface","title":"IWorkflowFactory Interface","text":"<p>Creates MAF Microsoft.Agents.AI.Workflows.Workflow instances from topology declared on agent classes via AgentHandoffsToAttribute, AgentGroupChatMemberAttribute, and AgentSequenceMemberAttribute. Registered in DI by <code>UsingAgentFramework()</code> \u2014 inject via constructor or resolve from <code>IServiceProvider</code>.</p> <pre><code>public interface IWorkflowFactory\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IWorkflowFactory/#remarks","title":"Remarks","text":"<p>When the <code>NexusLabs.Needlr.AgentFramework.Generators</code> source generator is used, strongly-typed extension methods are emitted directly into the agents assembly \u2014 for example, <code>CreateTriageHandoffWorkflow()</code>, <code>CreateCodeReviewGroupChatWorkflow()</code>, and <code>CreateContentPipelineSequentialWorkflow()</code>. These generated methods call the core CreateHandoffWorkflow&lt;TInitialAgent&gt;(), CreateGroupChatWorkflow(string, int), and CreateSequentialWorkflow(string) methods internally, encapsulating type references and pipeline name strings so the composition root requires neither.</p> <p>When the generator is not used, all three factory methods fall back to reading attributes via reflection.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IWorkflowFactory/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IWorkflowFactory/#iworkflowfactorycreategroupchatworkflowstring-int-method","title":"IWorkflowFactory.CreateGroupChatWorkflow(string, int) Method","text":"<p>Creates a round-robin group chat Microsoft.Agents.AI.Workflows.Workflow for the named group. All agent types decorated with <code>[AgentGroupChatMember()]</code> are included as participants.</p> <pre><code>Microsoft.Agents.AI.Workflows.Workflow CreateGroupChatWorkflow(string groupName, int maxIterations=10);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IWorkflowFactory/#parameters","title":"Parameters","text":"<p><code>groupName</code> System.String</p> <p>The group name. Must match the GroupName value (case-sensitive) on at least two agent types. Prefer using a generated extension method (e.g. <code>CreateCodeReviewGroupChatWorkflow()</code>) to avoid referencing this string directly.</p> <p></p> <p><code>maxIterations</code> System.Int32</p> <p>Maximum number of round-robin turns before the workflow terminates. Defaults to 10.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IWorkflowFactory/#returns","title":"Returns","text":"<p>Microsoft.Agents.AI.Workflows.Workflow A built Microsoft.Agents.AI.Workflows.Workflow ready to run via MAF's execution environment.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IWorkflowFactory/#exceptions","title":"Exceptions","text":"<p>System.InvalidOperationException Thrown when groupName has fewer than two registered members.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IWorkflowFactory/#iworkflowfactorycreatehandoffworkflowtinitialagent-method","title":"IWorkflowFactory.CreateHandoffWorkflow&lt;TInitialAgent&gt;() Method","text":"<p>Creates a handoff Microsoft.Agents.AI.Workflows.Workflow where TInitialAgent is the starting agent and its AgentHandoffsToAttribute declarations determine the available handoff targets.</p> <pre><code>Microsoft.Agents.AI.Workflows.Workflow CreateHandoffWorkflow&lt;TInitialAgent&gt;()\n    where TInitialAgent : class;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IWorkflowFactory/#type-parameters","title":"Type parameters","text":"<p><code>TInitialAgent</code></p> <p>The type of the initial agent. Must be annotated with both NeedlrAiAgentAttribute and at least one AgentHandoffsToAttribute.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IWorkflowFactory/#returns_1","title":"Returns","text":"<p>Microsoft.Agents.AI.Workflows.Workflow A built Microsoft.Agents.AI.Workflows.Workflow ready to run via MAF's execution environment.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IWorkflowFactory/#exceptions_1","title":"Exceptions","text":"<p>System.InvalidOperationException Thrown when TInitialAgent has no AgentHandoffsToAttribute attributes declared.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IWorkflowFactory/#iworkflowfactorycreatesequentialworkflowaiagent-method","title":"IWorkflowFactory.CreateSequentialWorkflow(AIAgent[]) Method","text":"<p>Creates a sequential pipeline Microsoft.Agents.AI.Workflows.Workflow where the output of each agent flows as input to the next agent in the sequence.</p> <pre><code>Microsoft.Agents.AI.Workflows.Workflow CreateSequentialWorkflow(params Microsoft.Agents.AI.AIAgent[] agents);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IWorkflowFactory/#parameters_1","title":"Parameters","text":"<p><code>agents</code> Microsoft.Agents.AI.AIAgent[]</p> <p>The agents to chain in order. Must contain at least one agent.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IWorkflowFactory/#returns_2","title":"Returns","text":"<p>Microsoft.Agents.AI.Workflows.Workflow A built Microsoft.Agents.AI.Workflows.Workflow ready to run via MAF's execution environment.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IWorkflowFactory/#iworkflowfactorycreatesequentialworkflowstring-method","title":"IWorkflowFactory.CreateSequentialWorkflow(string) Method","text":"<p>Creates a sequential pipeline Microsoft.Agents.AI.Workflows.Workflow from a named pipeline declared via AgentSequenceMemberAttribute. Agents are assembled in ascending order.</p> <pre><code>Microsoft.Agents.AI.Workflows.Workflow CreateSequentialWorkflow(string pipelineName);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IWorkflowFactory/#parameters_2","title":"Parameters","text":"<p><code>pipelineName</code> System.String</p> <p>The pipeline name. Must match the PipelineName value (case-sensitive) on at least one agent type. Prefer using a generated extension method (e.g. <code>CreateContentPipelineSequentialWorkflow()</code>) to avoid referencing this string directly.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IWorkflowFactory/#returns_3","title":"Returns","text":"<p>Microsoft.Agents.AI.Workflows.Workflow A built Microsoft.Agents.AI.Workflows.Workflow ready to run via MAF's execution environment.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IWorkflowFactory/#exceptions_2","title":"Exceptions","text":"<p>System.InvalidOperationException Thrown when pipelineName has no registered members.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IWorkflowTerminationCondition/","title":"IWorkflowTerminationCondition","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IWorkflowTerminationCondition/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IWorkflowTerminationCondition/#nexuslabsneedlragentframework_1","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IWorkflowTerminationCondition/#iworkflowterminationcondition-interface","title":"IWorkflowTerminationCondition Interface","text":"<p>Evaluates whether a workflow should terminate early after an agent response.</p> <pre><code>public interface IWorkflowTerminationCondition\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IWorkflowTerminationCondition/#remarks","title":"Remarks","text":"<p>Implement this interface to provide custom termination logic. Built-in implementations are available in the <code>NexusLabs.Needlr.AgentFramework.Workflows</code> package: - <code>KeywordTerminationCondition</code> \u2014 stops when a response contains a keyword. - <code>RegexTerminationCondition</code> \u2014 stops when a response matches a regex.</p> <p>Conditions are declared on agent classes via AgentTerminationConditionAttribute (Layer 1: group chat, fires before the next turn) or WorkflowRunTerminationConditionAttribute (Layer 2: any workflow type, fires via <code>RunAsync</code>).</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IWorkflowTerminationCondition/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IWorkflowTerminationCondition/#iworkflowterminationconditionshouldterminateterminationcontext-method","title":"IWorkflowTerminationCondition.ShouldTerminate(TerminationContext) Method","text":"<p>Determines whether the workflow should terminate after the given agent response.</p> <pre><code>bool ShouldTerminate(NexusLabs.Needlr.AgentFramework.TerminationContext context);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IWorkflowTerminationCondition/#parameters","title":"Parameters","text":"<p><code>context</code> TerminationContext</p> <p>Context for the completed agent turn.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/IWorkflowTerminationCondition/#returns","title":"Returns","text":"<p>System.Boolean true to stop the workflow; false to continue.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/NeedlrAiAgentAttribute/","title":"NeedlrAiAgentAttribute","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/NeedlrAiAgentAttribute/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/NeedlrAiAgentAttribute/#nexuslabsneedlragentframework_1","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/NeedlrAiAgentAttribute/#needlraiagentattribute-class","title":"NeedlrAiAgentAttribute Class","text":"<p>Marks a class as a declared agent type for Needlr's Agent Framework integration. Apply this attribute to a class to enable compile-time registration via the source generator and CreateAgent&lt;TAgent&gt;() lookup.</p> <pre><code>public sealed class NeedlrAiAgentAttribute : System.Attribute\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 System.Attribute \ud83e\udc52 NeedlrAiAgentAttribute</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/NeedlrAiAgentAttribute/#example","title":"Example","text":"<pre><code>[NeedlrAiAgent(\n    Instructions = \"You are a helpful customer support agent. Answer questions about orders.\",\n    Description = \"Customer support agent for order inquiries\")]\n[AgentHandoffsTo(typeof(BillingAgent), \"Escalate billing or payment questions to the billing agent\")]\npublic class CustomerSupportAgent\n{\n}\n\n// In your composition root:\nvar agentFactory = syringe.BuildAgentFactory();\nvar agent = agentFactory.CreateAgent&lt;CustomerSupportAgent&gt;();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/NeedlrAiAgentAttribute/#remarks","title":"Remarks","text":"<p>When the <code>NexusLabs.Needlr.AgentFramework.Generators</code> package is referenced, a <code>[ModuleInitializer]</code> is emitted that automatically registers the agent type with AgentFrameworkGeneratedBootstrap. <code>UsingAgentFramework()</code> then discovers and registers these types without any explicit <code>Add*FromGenerated()</code> calls.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/NeedlrAiAgentAttribute/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/NeedlrAiAgentAttribute/#needlraiagentattributedescription-property","title":"NeedlrAiAgentAttribute.Description Property","text":"<p>Gets or sets a human-readable description of this agent's purpose.</p> <pre><code>public string? Description { get; set; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/NeedlrAiAgentAttribute/#property-value","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/NeedlrAiAgentAttribute/#needlraiagentattributefunctiongroups-property","title":"NeedlrAiAgentAttribute.FunctionGroups Property","text":"<p>Gets or sets named function groups (registered via AgentFunctionGroupAttribute) whose types are wired as tools for this agent.</p> <pre><code>public string[]? FunctionGroups { get; set; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/NeedlrAiAgentAttribute/#property-value_1","title":"Property Value","text":"<p>System.String[]</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/NeedlrAiAgentAttribute/#needlraiagentattributefunctiontypes-property","title":"NeedlrAiAgentAttribute.FunctionTypes Property","text":"<p>Gets or sets the function types whose AgentFunctionAttribute-tagged methods are wired as tools for this agent. When null and FunctionGroups is also null, all registered function types are used.</p> <pre><code>public System.Type[]? FunctionTypes { get; set; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/NeedlrAiAgentAttribute/#property-value_2","title":"Property Value","text":"<p>System.Type[]</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/NeedlrAiAgentAttribute/#needlraiagentattributeinstructions-property","title":"NeedlrAiAgentAttribute.Instructions Property","text":"<p>Gets or sets the system prompt instructions for this agent.</p> <pre><code>public string? Instructions { get; set; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/NeedlrAiAgentAttribute/#property-value_3","title":"Property Value","text":"<p>System.String</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/NexusLabs.Needlr.AgentFramework.FunctionScanners/","title":"NexusLabs.Needlr.AgentFramework.FunctionScanners","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/NexusLabs.Needlr.AgentFramework.FunctionScanners/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/NexusLabs.Needlr.AgentFramework.FunctionScanners/#nexuslabsneedlragentframeworkfunctionscanners-namespace","title":"NexusLabs.Needlr.AgentFramework.FunctionScanners Namespace","text":"Classes GeneratedAgentFunctionScanner Source-generation-friendly agent function scanner that uses compile-time generated function type lists."},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/NexusLabs.Needlr.AgentFramework.Generated/","title":"NexusLabs.Needlr.AgentFramework.Generated","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/NexusLabs.Needlr.AgentFramework.Generated/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/NexusLabs.Needlr.AgentFramework.Generated/#nexuslabsneedlragentframeworkgenerated-namespace","title":"NexusLabs.Needlr.AgentFramework.Generated Namespace","text":"Classes AgentFrameworkFunctionGroupRegistry Generated registry for Microsoft Agent Framework function groups discovered at compile time. Pass AllGroups to <code>AgentFrameworkSyringeExtensions.AddAgentFunctionGroupsFromGenerated</code>. AgentFrameworkFunctionRegistry Generated registry for Microsoft Agent Framework function types discovered at compile time. Pass AllFunctionTypes to <code>AgentFrameworkSyringeExtensions.AddAgentFunctionsFromGenerated</code>. AgentGroupChatRegistry Generated registry of agent group chat memberships declared via [AgentGroupChatMember] attributes. AgentHandoffTopologyRegistry Generated registry of agent handoff topology declared via [AgentHandoffsTo] attributes. AgentNames String constants for agent type names discovered at compile time. AgentRegistry Generated registry for agent types declared with [NeedlrAiAgent], discovered at compile time. AgentSequentialTopologyRegistry Generated registry of sequential pipeline memberships declared via [AgentSequenceMember] attributes. Agents within each pipeline are stored in ascending order value order. GeneratedAgentFactoryExtensions Generated strongly-typed extension methods on IAgentFactory. Each method creates an agent from its <code>[NeedlrAiAgent]</code> declaration, eliminating magic strings and direct type references at the composition root. GeneratedAgentFrameworkSyringeExtensions Generated strongly-typed extension methods on AgentFrameworkSyringe. Each method registers a named function group without requiring direct type references. GroupNames String constants for function group names discovered at compile time. PipelineNames String constants for sequential pipeline names discovered at compile time. ServiceCatalog Compile-time service catalog containing all discovered registrations. TypeRegistry Compile-time generated registry of injectable types and plugins. This eliminates the need for runtime reflection-based type discovery. WorkflowFactoryExtensions Generated strongly-typed extension methods on IWorkflowFactory. Each method encapsulates an agent type or group name so the composition root requires no direct agent type references or magic strings."},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/NexusLabs.Needlr.AgentFramework/","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/NexusLabs.Needlr.AgentFramework/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/NexusLabs.Needlr.AgentFramework/#nexuslabsneedlragentframework-namespace","title":"NexusLabs.Needlr.AgentFramework Namespace","text":"Classes AgentFactoryOptions Per-agent configuration options passed to <code>IAgentFactory.CreateAgent(configure)</code>. AgentFrameworkConfigureOptions Factory-level configuration options passed to NexusLabs.Needlr.AgentFramework.AgentFrameworkSyringeExtensions.Configure(NexusLabs.Needlr.AgentFramework.AgentFrameworkSyringe,System.Action{NexusLabs.Needlr.AgentFramework.AgentFrameworkConfigureOptions}) callbacks. AgentFrameworkGeneratedBootstrap Runtime bootstrap registry for source-generated Agent Framework components. AgentFrameworkSyringe Fluent builder for configuring the Microsoft Agent Framework with Needlr function discovery. AgentFrameworkSyringeExtensions Extension methods for AgentFrameworkSyringe providing fluent configuration of the Microsoft Agent Framework integration. AgentFunctionAttribute Marks a method as an agent function that can be auto-discovered by Needlr and registered as an Microsoft.Extensions.AI.AIFunction tool for Microsoft Agent Framework agents. AgentFunctionGroupAttribute Assigns a class to a named function group so that it can be wired to agents by group name rather than by explicit type reference. AgentGroupChatMemberAttribute Declares that a NeedlrAiAgentAttribute-annotated agent participates in a named group chat workflow. Apply this attribute to include the agent in a round-robin group chat created via CreateGroupChatWorkflow(string, int). AgentHandoffsToAttribute Declares a handoff target for a NeedlrAiAgentAttribute-annotated agent. Apply this attribute one or more times to specify which agents the decorated agent can hand off to when used as the initial agent in a handoff workflow via CreateHandoffWorkflow&lt;TInitialAgent&gt;(). AgentSequenceMemberAttribute Marks an agent class as a member of a named sequential pipeline, specifying its position. The source generator reads these declarations to emit a strongly-typed <code>Create{PipelineName}SequentialWorkflow()</code> extension method on IWorkflowFactory. AgentTerminationConditionAttribute Declares a termination condition that is wired into the group chat manager for this agent (Layer 1). The condition is evaluated inside MAF's group chat loop, before the next agent turn starts, giving a clean early exit. AIAgentBuilderPluginOptions Options passed to Configure(AIAgentBuilderPluginOptions) to allow plugins to participate in agent-builder configuration. NeedlrAiAgentAttribute Marks a class as a declared agent type for Needlr's Agent Framework integration. Apply this attribute to a class to enable compile-time registration via the source generator and CreateAgent&lt;TAgent&gt;() lookup. SyringeExtensionsForAgentFramework Extension methods for NexusLabs.Needlr.Injection.ConfiguredSyringe that enable registering Microsoft Agent Framework infrastructure (namely IAgentFactory) as part of the Needlr build pipeline. TerminationContext Provides context to an IWorkflowTerminationCondition when evaluating whether a workflow should stop after an agent's response. WorkflowRunTerminationConditionAttribute Declares a termination condition that is evaluated by Needlr's <code>RunAsync</code> execution helpers after each completed agent turn (Layer 2). Unlike AgentTerminationConditionAttribute, this works with all workflow types (group chat, handoff, sequential). Interfaces IAgentFactory Factory for creating configured Microsoft.Agents.AI.AIAgent instances with auto-discovered AgentFunctionAttribute tools wired up. IAgentFrameworkFunctionScanner Defines a scanner that discovers types containing AgentFunctionAttribute-decorated methods. IAIAgentBuilderPlugin Marker interface for classes that participate in configuring the agent builder pipeline (e.g., adding middleware layers). IAIFunctionProvider Provides pre-built Microsoft.Extensions.AI.AIFunction instances for agent function types. Implemented by the source generator to eliminate reflection-based function discovery. IWorkflowFactory Creates MAF Microsoft.Agents.AI.Workflows.Workflow instances from topology declared on agent classes via AgentHandoffsToAttribute, AgentGroupChatMemberAttribute, and AgentSequenceMemberAttribute. Registered in DI by <code>UsingAgentFramework()</code> \u2014 inject via constructor or resolve from <code>IServiceProvider</code>. IWorkflowTerminationCondition Evaluates whether a workflow should terminate early after an agent response."},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/PipelineNames/","title":"PipelineNames","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/PipelineNames/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/PipelineNames/#nexuslabsneedlragentframeworkgenerated","title":"NexusLabs.Needlr.AgentFramework.Generated","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/PipelineNames/#pipelinenames-class","title":"PipelineNames Class","text":"<p>String constants for sequential pipeline names discovered at compile time.</p> <pre><code>public static class PipelineNames\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 PipelineNames</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/ServiceCatalog/","title":"ServiceCatalog","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/ServiceCatalog/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/ServiceCatalog/#nexuslabsneedlragentframeworkgenerated","title":"NexusLabs.Needlr.AgentFramework.Generated","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/ServiceCatalog/#servicecatalog-class","title":"ServiceCatalog Class","text":"<p>Compile-time service catalog containing all discovered registrations.</p> <pre><code>public sealed class ServiceCatalog : NexusLabs.Needlr.Catalog.IServiceCatalog\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 ServiceCatalog</p> <p>Implements NexusLabs.Needlr.Catalog.IServiceCatalog</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/ServiceCatalog/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/ServiceCatalog/#servicecatalogassemblyname-property","title":"ServiceCatalog.AssemblyName Property","text":"<p>Gets the assembly name this catalog was generated for.</p> <pre><code>public string AssemblyName { get; }\n</code></pre> <p>Implements AssemblyName</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/ServiceCatalog/#property-value","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/ServiceCatalog/#servicecatalogdecorators-property","title":"ServiceCatalog.Decorators Property","text":"<p>Gets all discovered decorator registrations.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.DecoratorCatalogEntry&gt; Decorators { get; }\n</code></pre> <p>Implements Decorators</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/ServiceCatalog/#property-value_1","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.DecoratorCatalogEntry&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/ServiceCatalog/#servicecataloggeneratedat-property","title":"ServiceCatalog.GeneratedAt Property","text":"<p>Gets the UTC timestamp when this catalog was generated.</p> <pre><code>public string GeneratedAt { get; }\n</code></pre> <p>Implements GeneratedAt</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/ServiceCatalog/#property-value_2","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/ServiceCatalog/#servicecataloghostedservices-property","title":"ServiceCatalog.HostedServices Property","text":"<p>Gets all discovered hosted service registrations.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.HostedServiceCatalogEntry&gt; HostedServices { get; }\n</code></pre> <p>Implements HostedServices</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/ServiceCatalog/#property-value_3","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.HostedServiceCatalogEntry&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/ServiceCatalog/#servicecataloginterceptedservices-property","title":"ServiceCatalog.InterceptedServices Property","text":"<p>Gets all discovered intercepted service registrations.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.InterceptedServiceCatalogEntry&gt; InterceptedServices { get; }\n</code></pre> <p>Implements InterceptedServices</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/ServiceCatalog/#property-value_4","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.InterceptedServiceCatalogEntry&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/ServiceCatalog/#servicecatalogoptions-property","title":"ServiceCatalog.Options Property","text":"<p>Gets all discovered options/configuration bindings.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.OptionsCatalogEntry&gt; Options { get; }\n</code></pre> <p>Implements Options</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/ServiceCatalog/#property-value_5","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.OptionsCatalogEntry&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/ServiceCatalog/#servicecatalogplugins-property","title":"ServiceCatalog.Plugins Property","text":"<p>Gets all discovered plugin registrations.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.PluginCatalogEntry&gt; Plugins { get; }\n</code></pre> <p>Implements Plugins</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/ServiceCatalog/#property-value_6","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.PluginCatalogEntry&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/ServiceCatalog/#servicecatalogservices-property","title":"ServiceCatalog.Services Property","text":"<p>Gets all discovered service registrations.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.ServiceCatalogEntry&gt; Services { get; }\n</code></pre> <p>Implements Services</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/ServiceCatalog/#property-value_7","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.ServiceCatalogEntry&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/SyringeExtensionsForAgentFramework/","title":"SyringeExtensionsForAgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/SyringeExtensionsForAgentFramework/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/SyringeExtensionsForAgentFramework/#nexuslabsneedlragentframework_1","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/SyringeExtensionsForAgentFramework/#syringeextensionsforagentframework-class","title":"SyringeExtensionsForAgentFramework Class","text":"<p>Extension methods for NexusLabs.Needlr.Injection.ConfiguredSyringe that enable registering Microsoft Agent Framework infrastructure (namely IAgentFactory) as part of the Needlr build pipeline.</p> <pre><code>public static class SyringeExtensionsForAgentFramework\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 SyringeExtensionsForAgentFramework</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/SyringeExtensionsForAgentFramework/#remarks","title":"Remarks","text":"<p>These helpers defer service registration using the Syringe post-plugin registration callback so that function discovery and registration are completed before the agent factory is added.</p> <p>When the Needlr source generator is active, the generated <code>[ModuleInitializer]</code> registers an IAIFunctionProvider that is used instead of reflection. This makes the integration NativeAOT-compatible without any code changes.</p> <p>When the source generator is not used, the integration falls back to reflection-based Microsoft.Extensions.AI.AIFunction schema generation, which requires dynamic code.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/SyringeExtensionsForAgentFramework/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/SyringeExtensionsForAgentFramework/#syringeextensionsforagentframeworkusingagentframeworkthis-configuredsyringe-method","title":"SyringeExtensionsForAgentFramework.UsingAgentFramework(this ConfiguredSyringe) Method","text":"<p>Registers an IAgentFactory built via a AgentFrameworkSyringe instance.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UsingAgentFramework(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/SyringeExtensionsForAgentFramework/#parameters","title":"Parameters","text":"<p><code>syringe</code> NexusLabs.Needlr.Injection.ConfiguredSyringe</p> <p>The NexusLabs.Needlr.Injection.ConfiguredSyringe to augment with the registration.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/SyringeExtensionsForAgentFramework/#returns","title":"Returns","text":"<p>NexusLabs.Needlr.Injection.ConfiguredSyringe A new NexusLabs.Needlr.Injection.ConfiguredSyringe instance containing the registration.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/SyringeExtensionsForAgentFramework/#syringeextensionsforagentframeworkusingagentframeworkthis-configuredsyringe-funcagentframeworksyringeagentframeworksyringe-method","title":"SyringeExtensionsForAgentFramework.UsingAgentFramework(this ConfiguredSyringe, Func&lt;AgentFrameworkSyringe,AgentFrameworkSyringe&gt;) Method","text":"<p>Registers an IAgentFactory built via a configurable AgentFrameworkSyringe instance.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UsingAgentFramework(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe, System.Func&lt;NexusLabs.Needlr.AgentFramework.AgentFrameworkSyringe,NexusLabs.Needlr.AgentFramework.AgentFrameworkSyringe&gt; configure);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/SyringeExtensionsForAgentFramework/#parameters_1","title":"Parameters","text":"<p><code>syringe</code> NexusLabs.Needlr.Injection.ConfiguredSyringe</p> <p>The NexusLabs.Needlr.Injection.ConfiguredSyringe to augment with the registration.</p> <p></p> <p><code>configure</code> System.Func&lt;AgentFrameworkSyringe,AgentFrameworkSyringe&gt;</p> <p>A delegate that receives a pre-initialized AgentFrameworkSyringe (with its NexusLabs.Needlr.AgentFramework.AgentFrameworkSyringe.ServiceProvider set) and returns the configured instance used to build the agent factory.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/SyringeExtensionsForAgentFramework/#returns_1","title":"Returns","text":"<p>NexusLabs.Needlr.Injection.ConfiguredSyringe A new NexusLabs.Needlr.Injection.ConfiguredSyringe instance containing the registration.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/SyringeExtensionsForAgentFramework/#syringeextensionsforagentframeworkusingagentframeworkthis-configuredsyringe-funcagentframeworksyringe-method","title":"SyringeExtensionsForAgentFramework.UsingAgentFramework(this ConfiguredSyringe, Func&lt;AgentFrameworkSyringe&gt;) Method","text":"<p>Registers an IAgentFactory built via an AgentFrameworkSyringe created by the supplied delegate.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UsingAgentFramework(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe, System.Func&lt;NexusLabs.Needlr.AgentFramework.AgentFrameworkSyringe&gt; configure);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/SyringeExtensionsForAgentFramework/#parameters_2","title":"Parameters","text":"<p><code>syringe</code> NexusLabs.Needlr.Injection.ConfiguredSyringe</p> <p>The NexusLabs.Needlr.Injection.ConfiguredSyringe to augment with the registration.</p> <p></p> <p><code>configure</code> System.Func&lt;AgentFrameworkSyringe&gt;</p> <p>A factory that creates a fully-configured AgentFrameworkSyringe used to build the agent factory. Useful when configuration does not need the service provider.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/SyringeExtensionsForAgentFramework/#returns_2","title":"Returns","text":"<p>NexusLabs.Needlr.Injection.ConfiguredSyringe A new NexusLabs.Needlr.Injection.ConfiguredSyringe instance containing the registration.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/TerminationContext/","title":"TerminationContext","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/TerminationContext/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/TerminationContext/#nexuslabsneedlragentframework_1","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/TerminationContext/#terminationcontext-class","title":"TerminationContext Class","text":"<p>Provides context to an IWorkflowTerminationCondition when evaluating whether a workflow should stop after an agent's response.</p> <pre><code>public sealed class TerminationContext\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 TerminationContext</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/TerminationContext/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/TerminationContext/#terminationcontextagentid-property","title":"TerminationContext.AgentId Property","text":"<p>Gets the executor ID of the agent that produced this response.</p> <pre><code>public string AgentId { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/TerminationContext/#property-value","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/TerminationContext/#terminationcontextconversationhistory-property","title":"TerminationContext.ConversationHistory Property","text":"<p>Gets the accumulated conversation history up to and including this turn. Each entry corresponds to one completed agent response.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;Microsoft.Extensions.AI.ChatMessage&gt; ConversationHistory { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/TerminationContext/#property-value_1","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;Microsoft.Extensions.AI.ChatMessage&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/TerminationContext/#terminationcontextresponsetext-property","title":"TerminationContext.ResponseText Property","text":"<p>Gets the complete response text emitted by the agent for this turn.</p> <pre><code>public string ResponseText { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/TerminationContext/#property-value_2","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/TerminationContext/#terminationcontextturncount-property","title":"TerminationContext.TurnCount Property","text":"<p>Gets the number of agent turns completed so far (1-based).</p> <pre><code>public int TurnCount { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/TerminationContext/#property-value_3","title":"Property Value","text":"<p>System.Int32</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/TerminationContext/#terminationcontextusage-property","title":"TerminationContext.Usage Property","text":"<p>Gets token usage for this turn, if reported by the model. May be null when the model does not return usage metadata.</p> <pre><code>public Microsoft.Extensions.AI.UsageDetails? Usage { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/TerminationContext/#property-value_4","title":"Property Value","text":"<p>Microsoft.Extensions.AI.UsageDetails</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/TypeRegistry/","title":"TypeRegistry","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/TypeRegistry/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/TypeRegistry/#nexuslabsneedlragentframeworkgenerated","title":"NexusLabs.Needlr.AgentFramework.Generated","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/TypeRegistry/#typeregistry-class","title":"TypeRegistry Class","text":"<p>Compile-time generated registry of injectable types and plugins. This eliminates the need for runtime reflection-based type discovery.</p> <pre><code>public static class TypeRegistry\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 TypeRegistry</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/TypeRegistry/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/TypeRegistry/#typeregistryapplydecoratorsiservicecollection-method","title":"TypeRegistry.ApplyDecorators(IServiceCollection) Method","text":"<p>Applies all discovered decorators, interceptors, and hosted services to the service collection. Decorators are applied in order, with lower Order values applied first (closer to the original service).</p> <pre><code>public static void ApplyDecorators(Microsoft.Extensions.DependencyInjection.IServiceCollection services);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/TypeRegistry/#parameters","title":"Parameters","text":"<p><code>services</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service collection to apply decorators to.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/TypeRegistry/#typeregistrygetinjectabletypes-method","title":"TypeRegistry.GetInjectableTypes() Method","text":"<p>Gets all injectable types discovered at compile time.</p> <pre><code>public static System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.InjectableTypeInfo&gt; GetInjectableTypes();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/TypeRegistry/#returns","title":"Returns","text":"<p>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.InjectableTypeInfo&gt; A read-only list of injectable type information.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/TypeRegistry/#typeregistrygetplugintypes-method","title":"TypeRegistry.GetPluginTypes() Method","text":"<p>Gets all plugin types discovered at compile time.</p> <pre><code>public static System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.PluginTypeInfo&gt; GetPluginTypes();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/TypeRegistry/#returns_1","title":"Returns","text":"<p>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.PluginTypeInfo&gt; A read-only list of plugin type information.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/WorkflowFactoryExtensions/","title":"WorkflowFactoryExtensions","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/WorkflowFactoryExtensions/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/WorkflowFactoryExtensions/#nexuslabsneedlragentframeworkgenerated","title":"NexusLabs.Needlr.AgentFramework.Generated","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/WorkflowFactoryExtensions/#workflowfactoryextensions-class","title":"WorkflowFactoryExtensions Class","text":"<p>Generated strongly-typed extension methods on IWorkflowFactory. Each method encapsulates an agent type or group name so the composition root requires no direct agent type references or magic strings.</p> <pre><code>public static class WorkflowFactoryExtensions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 WorkflowFactoryExtensions</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/WorkflowRunTerminationConditionAttribute/","title":"WorkflowRunTerminationConditionAttribute","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/WorkflowRunTerminationConditionAttribute/#nexuslabsneedlragentframework","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/WorkflowRunTerminationConditionAttribute/#nexuslabsneedlragentframework_1","title":"NexusLabs.Needlr.AgentFramework","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/WorkflowRunTerminationConditionAttribute/#workflowrunterminationconditionattribute-class","title":"WorkflowRunTerminationConditionAttribute Class","text":"<p>Declares a termination condition that is evaluated by Needlr's <code>RunAsync</code> execution helpers after each completed agent turn (Layer 2). Unlike AgentTerminationConditionAttribute, this works with all workflow types (group chat, handoff, sequential).</p> <pre><code>public sealed class WorkflowRunTerminationConditionAttribute : System.Attribute\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 System.Attribute \ud83e\udc52 WorkflowRunTerminationConditionAttribute</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/WorkflowRunTerminationConditionAttribute/#remarks","title":"Remarks","text":"<p>Apply to any agent class. Multiple conditions may be stacked; OR semantics apply (first match stops the workflow). Conditions from all agents in the workflow are merged; a condition fires only when the agent it is declared on produces the matching response.</p> <p>The <code>conditionType</code> must implement IWorkflowTerminationCondition. Constructor arguments are passed via <code>ctorArgs</code>.</p> <p>For group chat workflows, prefer AgentTerminationConditionAttribute \u2014 it fires before the next turn starts, which is a cleaner stop than Layer 2 (which fires after the response is fully emitted).\\&lt;example&gt;   \\&lt;code&gt;             // Stop a sequential pipeline early on extraction failure             [AgentSequenceMember(\"content-pipeline\", Order = 1)]             [WorkflowRunTerminationCondition(typeof(KeywordTerminationCondition), \"EXTRACTION_FAILED\")]             public class ContentExtractorAgent { }             \\&lt;/code&gt; \\&lt;/example&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/WorkflowRunTerminationConditionAttribute/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/WorkflowRunTerminationConditionAttribute/#workflowrunterminationconditionattributetype-object-constructor","title":"WorkflowRunTerminationConditionAttribute(Type, object[]) Constructor","text":"<p>Initializes a new instance of WorkflowRunTerminationConditionAttribute.</p> <pre><code>public WorkflowRunTerminationConditionAttribute(System.Type conditionType, params object[] ctorArgs);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/WorkflowRunTerminationConditionAttribute/#parameters","title":"Parameters","text":"<p><code>conditionType</code> System.Type</p> <p>The type that implements IWorkflowTerminationCondition. An instance is created at workflow construction time via System.Activator.CreateInstance(System.Type,System.Object[]) with ctorArgs.</p> <p></p> <p><code>ctorArgs</code> System.Object[]</p> <p>Arguments forwarded to the condition's constructor. May be empty if the condition has a parameterless constructor.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/WorkflowRunTerminationConditionAttribute/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/WorkflowRunTerminationConditionAttribute/#workflowrunterminationconditionattributeconditiontype-property","title":"WorkflowRunTerminationConditionAttribute.ConditionType Property","text":"<p>Gets the type of the termination condition to instantiate.</p> <pre><code>public System.Type ConditionType { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/WorkflowRunTerminationConditionAttribute/#property-value","title":"Property Value","text":"<p>System.Type</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/WorkflowRunTerminationConditionAttribute/#workflowrunterminationconditionattributectorargs-property","title":"WorkflowRunTerminationConditionAttribute.CtorArgs Property","text":"<p>Gets the constructor arguments forwarded when instantiating the condition.</p> <pre><code>public object[] CtorArgs { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework/WorkflowRunTerminationConditionAttribute/#property-value_1","title":"Property Value","text":"<p>System.Object[]</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/","title":"Index","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/#nexuslabsneedlragentframeworkanalyzers-namespace","title":"NexusLabs.Needlr.AgentFramework.Analyzers Namespace","text":"Classes AgentCyclicHandoffAnalyzer Analyzer that detects cyclic handoff chains in <code>[AgentHandoffsTo]</code> topology declarations. AgentFunctionDescriptionAnalyzer Analyzer that detects <code>[AgentFunction]</code> methods and their parameters that are missing <code>[System.ComponentModel.Description]</code> attributes. AgentFunctionGroupReferenceAnalyzer Analyzer that validates <code>FunctionGroups</code> references in <code>[NeedlrAiAgent]</code> declarations. AgentFunctionTypesMiswiredAnalyzer Analyzer that detects types listed in <code>FunctionTypes</code> on <code>[NeedlrAiAgent]</code> that have no <code>[AgentFunction]</code> methods, causing the agent to silently receive zero tools. AgentGroupChatSingletonAnalyzer Analyzer that validates <code>[AgentGroupChatMember]</code> group declarations. AgentOrphanAnalyzer Analyzer that detects agent types that participate in no topology declaration. AgentSequenceOrderAnalyzer Analyzer that validates <code>Order</code> values within <code>[AgentSequenceMember]</code> pipeline declarations. AgentTopologyAnalyzer Analyzer that validates <code>[AgentHandoffsTo]</code> topology declarations. MafDiagnosticDescriptors Contains diagnostic descriptors for all Needlr Agent Framework analyzers. MafDiagnosticIds Contains diagnostic IDs for all Needlr Agent Framework analyzers. TerminationConditionAnalyzer Analyzer that validates termination condition declarations on agent classes."},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/AgentCyclicHandoffAnalyzer/","title":"AgentCyclicHandoffAnalyzer","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/AgentCyclicHandoffAnalyzer/#nexuslabsneedlragentframeworkanalyzers","title":"NexusLabs.Needlr.AgentFramework.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/AgentCyclicHandoffAnalyzer/#agentcyclichandoffanalyzer-class","title":"AgentCyclicHandoffAnalyzer Class","text":"<p>Analyzer that detects cyclic handoff chains in <code>[AgentHandoffsTo]</code> topology declarations.</p> <pre><code>public sealed class AgentCyclicHandoffAnalyzer\n</code></pre> <p>Inheritance Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer \ud83e\udc52 AgentCyclicHandoffAnalyzer</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/AgentCyclicHandoffAnalyzer/#remarks","title":"Remarks","text":"<p>\\&lt;b&gt;NDLRMAF004\\&lt;/b&gt; (Warning): A cycle was found in the agent handoff graph \u2014 for example A \u2192 B \u2192 A.             While MAF may handle runtime termination conditions, a cycle is almost always a topology design error.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/AgentFunctionDescriptionAnalyzer/","title":"AgentFunctionDescriptionAnalyzer","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/AgentFunctionDescriptionAnalyzer/#nexuslabsneedlragentframeworkanalyzers","title":"NexusLabs.Needlr.AgentFramework.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/AgentFunctionDescriptionAnalyzer/#agentfunctiondescriptionanalyzer-class","title":"AgentFunctionDescriptionAnalyzer Class","text":"<p>Analyzer that detects <code>[AgentFunction]</code> methods and their parameters that are missing <code>[System.ComponentModel.Description]</code> attributes.</p> <pre><code>public sealed class AgentFunctionDescriptionAnalyzer\n</code></pre> <p>Inheritance Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer \ud83e\udc52 AgentFunctionDescriptionAnalyzer</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/AgentFunctionDescriptionAnalyzer/#remarks","title":"Remarks","text":"<p>\\&lt;b&gt;NDLRMAF012\\&lt;/b&gt; (Warning): An <code>[AgentFunction]</code> method has no <code>[Description]</code>.\\&lt;b&gt;NDLRMAF013\\&lt;/b&gt; (Warning): A non-<code>CancellationToken</code> parameter of an <code>[AgentFunction]</code>             method has no <code>[Description]</code>.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/AgentFunctionGroupReferenceAnalyzer/","title":"AgentFunctionGroupReferenceAnalyzer","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/AgentFunctionGroupReferenceAnalyzer/#nexuslabsneedlragentframeworkanalyzers","title":"NexusLabs.Needlr.AgentFramework.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/AgentFunctionGroupReferenceAnalyzer/#agentfunctiongroupreferenceanalyzer-class","title":"AgentFunctionGroupReferenceAnalyzer Class","text":"<p>Analyzer that validates <code>FunctionGroups</code> references in <code>[NeedlrAiAgent]</code> declarations.</p> <pre><code>public sealed class AgentFunctionGroupReferenceAnalyzer\n</code></pre> <p>Inheritance Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer \ud83e\udc52 AgentFunctionGroupReferenceAnalyzer</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/AgentFunctionGroupReferenceAnalyzer/#remarks","title":"Remarks","text":"<p>\\&lt;b&gt;NDLRMAF005\\&lt;/b&gt; (Warning): An agent declares a <code>FunctionGroups</code> entry whose name does not             match any class decorated with <code>[AgentFunctionGroup]</code> in this compilation. The agent will             silently receive zero tools from that group at runtime.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/AgentFunctionTypesMiswiredAnalyzer/","title":"AgentFunctionTypesMiswiredAnalyzer","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/AgentFunctionTypesMiswiredAnalyzer/#nexuslabsneedlragentframeworkanalyzers","title":"NexusLabs.Needlr.AgentFramework.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/AgentFunctionTypesMiswiredAnalyzer/#agentfunctiontypesmiswiredanalyzer-class","title":"AgentFunctionTypesMiswiredAnalyzer Class","text":"<p>Analyzer that detects types listed in <code>FunctionTypes</code> on <code>[NeedlrAiAgent]</code> that have no <code>[AgentFunction]</code> methods, causing the agent to silently receive zero tools.</p> <pre><code>public sealed class AgentFunctionTypesMiswiredAnalyzer\n</code></pre> <p>Inheritance Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer \ud83e\udc52 AgentFunctionTypesMiswiredAnalyzer</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/AgentFunctionTypesMiswiredAnalyzer/#remarks","title":"Remarks","text":"<p>\\&lt;b&gt;NDLRMAF014\\&lt;/b&gt; (Warning): A type in <code>FunctionTypes</code> has no <code>[AgentFunction]</code> methods.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/AgentGroupChatSingletonAnalyzer/","title":"AgentGroupChatSingletonAnalyzer","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/AgentGroupChatSingletonAnalyzer/#nexuslabsneedlragentframeworkanalyzers","title":"NexusLabs.Needlr.AgentFramework.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/AgentGroupChatSingletonAnalyzer/#agentgroupchatsingletonanalyzer-class","title":"AgentGroupChatSingletonAnalyzer Class","text":"<p>Analyzer that validates <code>[AgentGroupChatMember]</code> group declarations.</p> <pre><code>public sealed class AgentGroupChatSingletonAnalyzer\n</code></pre> <p>Inheritance Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer \ud83e\udc52 AgentGroupChatSingletonAnalyzer</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/AgentGroupChatSingletonAnalyzer/#remarks","title":"Remarks","text":"<p>\\&lt;b&gt;NDLRMAF002\\&lt;/b&gt; (Error): A named group chat has fewer than two members in this compilation.             <code>IWorkflowFactory.CreateGroupChatWorkflow</code> throws at runtime when this condition is met.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/AgentOrphanAnalyzer/","title":"AgentOrphanAnalyzer","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/AgentOrphanAnalyzer/#nexuslabsneedlragentframeworkanalyzers","title":"NexusLabs.Needlr.AgentFramework.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/AgentOrphanAnalyzer/#agentorphananalyzer-class","title":"AgentOrphanAnalyzer Class","text":"<p>Analyzer that detects agent types that participate in no topology declaration.</p> <pre><code>public sealed class AgentOrphanAnalyzer\n</code></pre> <p>Inheritance Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer \ud83e\udc52 AgentOrphanAnalyzer</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/AgentOrphanAnalyzer/#remarks","title":"Remarks","text":"<p>\\&lt;b&gt;NDLRMAF008\\&lt;/b&gt; (Info): A class decorated with <code>[NeedlrAiAgent]</code> is not referenced in any             topology attribute (<code>[AgentHandoffsTo]</code>, <code>[AgentGroupChatMember]</code>, or             <code>[AgentSequenceMember]</code>). This may indicate an orphaned or work-in-progress agent.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/AgentSequenceOrderAnalyzer/","title":"AgentSequenceOrderAnalyzer","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/AgentSequenceOrderAnalyzer/#nexuslabsneedlragentframeworkanalyzers","title":"NexusLabs.Needlr.AgentFramework.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/AgentSequenceOrderAnalyzer/#agentsequenceorderanalyzer-class","title":"AgentSequenceOrderAnalyzer Class","text":"<p>Analyzer that validates <code>Order</code> values within <code>[AgentSequenceMember]</code> pipeline declarations.</p> <pre><code>public sealed class AgentSequenceOrderAnalyzer\n</code></pre> <p>Inheritance Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer \ud83e\udc52 AgentSequenceOrderAnalyzer</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/AgentSequenceOrderAnalyzer/#remarks","title":"Remarks","text":"<p>NDLRMAF006 (Error): Two or more agents in the same pipeline declare the same <code>Order</code> value.</p> <p>NDLRMAF007 (Warning): The <code>Order</code> values in a pipeline are not contiguous \u2014 a gap exists.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/AgentTopologyAnalyzer/","title":"AgentTopologyAnalyzer","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/AgentTopologyAnalyzer/#nexuslabsneedlragentframeworkanalyzers","title":"NexusLabs.Needlr.AgentFramework.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/AgentTopologyAnalyzer/#agenttopologyanalyzer-class","title":"AgentTopologyAnalyzer Class","text":"<p>Analyzer that validates <code>[AgentHandoffsTo]</code> topology declarations.</p> <pre><code>public sealed class AgentTopologyAnalyzer\n</code></pre> <p>Inheritance Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer \ud83e\udc52 AgentTopologyAnalyzer</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/AgentTopologyAnalyzer/#remarks","title":"Remarks","text":"<p>NDLRMAF001 (Error): The target type referenced by <code>[AgentHandoffsTo(typeof(X))]</code> is not             decorated with <code>[NeedlrAiAgent]</code>. Handoff targets must be registered agent types.</p> <p>NDLRMAF003 (Warning): The class carrying <code>[AgentHandoffsTo]</code> is not itself decorated with             <code>[NeedlrAiAgent]</code>. The initial agent in a handoff workflow must be a declared agent.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticDescriptors/","title":"MafDiagnosticDescriptors","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticDescriptors/#nexuslabsneedlragentframeworkanalyzers","title":"NexusLabs.Needlr.AgentFramework.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticDescriptors/#mafdiagnosticdescriptors-class","title":"MafDiagnosticDescriptors Class","text":"<p>Contains diagnostic descriptors for all Needlr Agent Framework analyzers.</p> <pre><code>public static class MafDiagnosticDescriptors\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 MafDiagnosticDescriptors</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticDescriptors/#fields","title":"Fields","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticDescriptors/#mafdiagnosticdescriptorsagentfunctionmissingdescription-field","title":"MafDiagnosticDescriptors.AgentFunctionMissingDescription Field","text":"<p>NDLRMAF012: <code>[AgentFunction]</code> method has no <code>[Description]</code> attribute.</p> <pre><code>public static readonly DiagnosticDescriptor AgentFunctionMissingDescription;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticDescriptors/#field-value","title":"Field Value","text":"<p>Microsoft.CodeAnalysis.DiagnosticDescriptor</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticDescriptors/#mafdiagnosticdescriptorsagentfunctionparametermissingdescription-field","title":"MafDiagnosticDescriptors.AgentFunctionParameterMissingDescription Field","text":"<p>NDLRMAF013: Parameter of an <code>[AgentFunction]</code> method is missing a <code>[Description]</code> attribute.</p> <pre><code>public static readonly DiagnosticDescriptor AgentFunctionParameterMissingDescription;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticDescriptors/#field-value_1","title":"Field Value","text":"<p>Microsoft.CodeAnalysis.DiagnosticDescriptor</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticDescriptors/#mafdiagnosticdescriptorsagentfunctiontypesmiswired-field","title":"MafDiagnosticDescriptors.AgentFunctionTypesMiswired Field","text":"<p>NDLRMAF014: A type in <code>FunctionTypes</code> on <code>[NeedlrAiAgent]</code> has no <code>[AgentFunction]</code> methods.</p> <pre><code>public static readonly DiagnosticDescriptor AgentFunctionTypesMiswired;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticDescriptors/#field-value_2","title":"Field Value","text":"<p>Microsoft.CodeAnalysis.DiagnosticDescriptor</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticDescriptors/#mafdiagnosticdescriptorscyclichandoffchain-field","title":"MafDiagnosticDescriptors.CyclicHandoffChain Field","text":"<p>NDLRMAF004: A cyclic handoff chain was detected.</p> <pre><code>public static readonly DiagnosticDescriptor CyclicHandoffChain;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticDescriptors/#field-value_3","title":"Field Value","text":"<p>Microsoft.CodeAnalysis.DiagnosticDescriptor</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticDescriptors/#mafdiagnosticdescriptorsduplicatesequenceorder-field","title":"MafDiagnosticDescriptors.DuplicateSequenceOrder Field","text":"<p>NDLRMAF006: Duplicate Order value within the same [AgentSequenceMember] pipeline.</p> <pre><code>public static readonly DiagnosticDescriptor DuplicateSequenceOrder;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticDescriptors/#field-value_4","title":"Field Value","text":"<p>Microsoft.CodeAnalysis.DiagnosticDescriptor</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticDescriptors/#mafdiagnosticdescriptorsgapinsequenceorder-field","title":"MafDiagnosticDescriptors.GapInSequenceOrder Field","text":"<p>NDLRMAF007: Gap in Order sequence within the same [AgentSequenceMember] pipeline.</p> <pre><code>public static readonly DiagnosticDescriptor GapInSequenceOrder;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticDescriptors/#field-value_5","title":"Field Value","text":"<p>Microsoft.CodeAnalysis.DiagnosticDescriptor</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticDescriptors/#mafdiagnosticdescriptorsgroupchattoofewmembers-field","title":"MafDiagnosticDescriptors.GroupChatTooFewMembers Field","text":"<p>NDLRMAF002: <code>[AgentGroupChatMember(\"g\")]</code> group \"g\" has fewer than two members.</p> <pre><code>public static readonly DiagnosticDescriptor GroupChatTooFewMembers;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticDescriptors/#field-value_6","title":"Field Value","text":"<p>Microsoft.CodeAnalysis.DiagnosticDescriptor</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticDescriptors/#mafdiagnosticdescriptorshandoffstosourcenotneedlragent-field","title":"MafDiagnosticDescriptors.HandoffsToSourceNotNeedlrAgent Field","text":"<p>NDLRMAF003: A class has <code>[AgentHandoffsTo]</code> but is not decorated with <code>[NeedlrAiAgent]</code>.</p> <pre><code>public static readonly DiagnosticDescriptor HandoffsToSourceNotNeedlrAgent;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticDescriptors/#field-value_7","title":"Field Value","text":"<p>Microsoft.CodeAnalysis.DiagnosticDescriptor</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticDescriptors/#mafdiagnosticdescriptorshandoffstotargetnotneedlragent-field","title":"MafDiagnosticDescriptors.HandoffsToTargetNotNeedlrAgent Field","text":"<p>NDLRMAF001: <code>[AgentHandoffsTo(typeof(X))]</code> target type X is not decorated with <code>[NeedlrAiAgent]</code>.</p> <pre><code>public static readonly DiagnosticDescriptor HandoffsToTargetNotNeedlrAgent;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticDescriptors/#field-value_8","title":"Field Value","text":"<p>Microsoft.CodeAnalysis.DiagnosticDescriptor</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticDescriptors/#mafdiagnosticdescriptorsorphanagent-field","title":"MafDiagnosticDescriptors.OrphanAgent Field","text":"<p>NDLRMAF008: Agent participates in no topology declaration.</p> <pre><code>public static readonly DiagnosticDescriptor OrphanAgent;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticDescriptors/#field-value_9","title":"Field Value","text":"<p>Microsoft.CodeAnalysis.DiagnosticDescriptor</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticDescriptors/#mafdiagnosticdescriptorspreferagentterminationconditionforgroupchat-field","title":"MafDiagnosticDescriptors.PreferAgentTerminationConditionForGroupChat Field","text":"<p>NDLRMAF011: Prefer <code>[AgentTerminationCondition]</code> over <code>[WorkflowRunTerminationCondition]</code> for group chat members.</p> <pre><code>public static readonly DiagnosticDescriptor PreferAgentTerminationConditionForGroupChat;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticDescriptors/#field-value_10","title":"Field Value","text":"<p>Microsoft.CodeAnalysis.DiagnosticDescriptor</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticDescriptors/#mafdiagnosticdescriptorsterminationconditiontypeinvalid-field","title":"MafDiagnosticDescriptors.TerminationConditionTypeInvalid Field","text":"<p>NDLRMAF010: Condition type does not implement <code>IWorkflowTerminationCondition</code>.</p> <pre><code>public static readonly DiagnosticDescriptor TerminationConditionTypeInvalid;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticDescriptors/#field-value_11","title":"Field Value","text":"<p>Microsoft.CodeAnalysis.DiagnosticDescriptor</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticDescriptors/#mafdiagnosticdescriptorsunresolvedfunctiongroupreference-field","title":"MafDiagnosticDescriptors.UnresolvedFunctionGroupReference Field","text":"<p>NDLRMAF005: An agent declares a FunctionGroups entry with no matching [AgentFunctionGroup] class.</p> <pre><code>public static readonly DiagnosticDescriptor UnresolvedFunctionGroupReference;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticDescriptors/#field-value_12","title":"Field Value","text":"<p>Microsoft.CodeAnalysis.DiagnosticDescriptor</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticDescriptors/#mafdiagnosticdescriptorsworkflowrunterminationconditiononnonagent-field","title":"MafDiagnosticDescriptors.WorkflowRunTerminationConditionOnNonAgent Field","text":"<p>NDLRMAF009: <code>[WorkflowRunTerminationCondition]</code> declared on a non-agent class.</p> <pre><code>public static readonly DiagnosticDescriptor WorkflowRunTerminationConditionOnNonAgent;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticDescriptors/#field-value_13","title":"Field Value","text":"<p>Microsoft.CodeAnalysis.DiagnosticDescriptor</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticIds/","title":"MafDiagnosticIds","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticIds/#nexuslabsneedlragentframeworkanalyzers","title":"NexusLabs.Needlr.AgentFramework.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticIds/#mafdiagnosticids-class","title":"MafDiagnosticIds Class","text":"<p>Contains diagnostic IDs for all Needlr Agent Framework analyzers.</p> <pre><code>public static class MafDiagnosticIds\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 MafDiagnosticIds</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticIds/#remarks","title":"Remarks","text":"<p>Agent Framework analyzer codes use the NDLRMAF prefix.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticIds/#fields","title":"Fields","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticIds/#mafdiagnosticidsagentfunctionmissingdescription-field","title":"MafDiagnosticIds.AgentFunctionMissingDescription Field","text":"<p>NDLRMAF012: A method decorated with <code>[AgentFunction]</code> has no <code>[System.ComponentModel.Description]</code> attribute.</p> <pre><code>public const string AgentFunctionMissingDescription = \"NDLRMAF012\";\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticIds/#field-value","title":"Field Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticIds/#mafdiagnosticidsagentfunctionparametermissingdescription-field","title":"MafDiagnosticIds.AgentFunctionParameterMissingDescription Field","text":"<p>NDLRMAF013: A parameter of an <code>[AgentFunction]</code> method (other than <code>CancellationToken</code>) has no <code>[System.ComponentModel.Description]</code> attribute.</p> <pre><code>public const string AgentFunctionParameterMissingDescription = \"NDLRMAF013\";\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticIds/#field-value_1","title":"Field Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticIds/#mafdiagnosticidsagentfunctiontypesmiswired-field","title":"MafDiagnosticIds.AgentFunctionTypesMiswired Field","text":"<p>NDLRMAF014: A type listed in <code>FunctionTypes</code> on a <code>[NeedlrAiAgent]</code> has no methods decorated with <code>[AgentFunction]</code>, so the agent silently receives zero tools from that type.</p> <pre><code>public const string AgentFunctionTypesMiswired = \"NDLRMAF014\";\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticIds/#field-value_2","title":"Field Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticIds/#mafdiagnosticidscyclichandoffchain-field","title":"MafDiagnosticIds.CyclicHandoffChain Field","text":"<p>NDLRMAF004: A cyclic handoff chain was detected (e.g. A \u2192 B \u2192 A).</p> <pre><code>public const string CyclicHandoffChain = \"NDLRMAF004\";\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticIds/#field-value_3","title":"Field Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticIds/#mafdiagnosticidsduplicatesequenceorder-field","title":"MafDiagnosticIds.DuplicateSequenceOrder Field","text":"<p>NDLRMAF006: Two or more agents in the same <code>[AgentSequenceMember]</code> pipeline declare the same <code>Order</code> value.</p> <pre><code>public const string DuplicateSequenceOrder = \"NDLRMAF006\";\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticIds/#field-value_4","title":"Field Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticIds/#mafdiagnosticidsgapinsequenceorder-field","title":"MafDiagnosticIds.GapInSequenceOrder Field","text":"<p>NDLRMAF007: The <code>Order</code> values within a named <code>[AgentSequenceMember]</code> pipeline are not contiguous (a gap exists).</p> <pre><code>public const string GapInSequenceOrder = \"NDLRMAF007\";\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticIds/#field-value_5","title":"Field Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticIds/#mafdiagnosticidsgroupchattoofewmembers-field","title":"MafDiagnosticIds.GroupChatTooFewMembers Field","text":"<p>NDLRMAF002: <code>[AgentGroupChatMember(\"g\")]</code> group \"g\" has fewer than two members in this compilation.</p> <pre><code>public const string GroupChatTooFewMembers = \"NDLRMAF002\";\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticIds/#field-value_6","title":"Field Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticIds/#mafdiagnosticidshandoffstosourcenotneedlragent-field","title":"MafDiagnosticIds.HandoffsToSourceNotNeedlrAgent Field","text":"<p>NDLRMAF003: A class has <code>[AgentHandoffsTo]</code> but is not itself decorated with <code>[NeedlrAiAgent]</code>.</p> <pre><code>public const string HandoffsToSourceNotNeedlrAgent = \"NDLRMAF003\";\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticIds/#field-value_7","title":"Field Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticIds/#mafdiagnosticidshandoffstotargetnotneedlragent-field","title":"MafDiagnosticIds.HandoffsToTargetNotNeedlrAgent Field","text":"<p>NDLRMAF001: <code>[AgentHandoffsTo(typeof(X))]</code> target type X is not decorated with <code>[NeedlrAiAgent]</code>.</p> <pre><code>public const string HandoffsToTargetNotNeedlrAgent = \"NDLRMAF001\";\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticIds/#field-value_8","title":"Field Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticIds/#mafdiagnosticidsorphanagent-field","title":"MafDiagnosticIds.OrphanAgent Field","text":"<p>NDLRMAF008: A class decorated with <code>[NeedlrAiAgent]</code> participates in no topology declaration (<code>[AgentHandoffsTo]</code>, <code>[AgentGroupChatMember]</code>, or <code>[AgentSequenceMember]</code>).</p> <pre><code>public const string OrphanAgent = \"NDLRMAF008\";\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticIds/#field-value_9","title":"Field Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticIds/#mafdiagnosticidspreferagentterminationconditionforgroupchat-field","title":"MafDiagnosticIds.PreferAgentTerminationConditionForGroupChat Field","text":"<p>NDLRMAF011: <code>[WorkflowRunTerminationCondition]</code> is declared on a <code>[AgentGroupChatMember]</code> class; prefer <code>[AgentTerminationCondition]</code> for group chat members.</p> <pre><code>public const string PreferAgentTerminationConditionForGroupChat = \"NDLRMAF011\";\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticIds/#field-value_10","title":"Field Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticIds/#mafdiagnosticidsterminationconditiontypeinvalid-field","title":"MafDiagnosticIds.TerminationConditionTypeInvalid Field","text":"<p>NDLRMAF010: The <code>conditionType</code> passed to <code>[WorkflowRunTerminationCondition]</code> or <code>[AgentTerminationCondition]</code> does not implement <code>IWorkflowTerminationCondition</code>.</p> <pre><code>public const string TerminationConditionTypeInvalid = \"NDLRMAF010\";\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticIds/#field-value_11","title":"Field Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticIds/#mafdiagnosticidsunresolvedfunctiongroupreference-field","title":"MafDiagnosticIds.UnresolvedFunctionGroupReference Field","text":"<p>NDLRMAF005: An agent declares a <code>FunctionGroups</code> entry whose name has no matching <code>[AgentFunctionGroup(\"name\")]</code> class in this compilation.</p> <pre><code>public const string UnresolvedFunctionGroupReference = \"NDLRMAF005\";\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticIds/#field-value_12","title":"Field Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticIds/#mafdiagnosticidsworkflowrunterminationconditiononnonagent-field","title":"MafDiagnosticIds.WorkflowRunTerminationConditionOnNonAgent Field","text":"<p>NDLRMAF009: <code>[WorkflowRunTerminationCondition]</code> is declared on a class that is not decorated with <code>[NeedlrAiAgent]</code>.</p> <pre><code>public const string WorkflowRunTerminationConditionOnNonAgent = \"NDLRMAF009\";\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/MafDiagnosticIds/#field-value_13","title":"Field Value","text":"<p>System.String</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/NexusLabs.Needlr.AgentFramework.Analyzers/","title":"NexusLabs.Needlr.AgentFramework.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/NexusLabs.Needlr.AgentFramework.Analyzers/#nexuslabsneedlragentframeworkanalyzers-namespace","title":"NexusLabs.Needlr.AgentFramework.Analyzers Namespace","text":"Classes AgentCyclicHandoffAnalyzer Analyzer that detects cyclic handoff chains in <code>[AgentHandoffsTo]</code> topology declarations. AgentFunctionDescriptionAnalyzer Analyzer that detects <code>[AgentFunction]</code> methods and their parameters that are missing <code>[System.ComponentModel.Description]</code> attributes. AgentFunctionGroupReferenceAnalyzer Analyzer that validates <code>FunctionGroups</code> references in <code>[NeedlrAiAgent]</code> declarations. AgentFunctionTypesMiswiredAnalyzer Analyzer that detects types listed in <code>FunctionTypes</code> on <code>[NeedlrAiAgent]</code> that have no <code>[AgentFunction]</code> methods, causing the agent to silently receive zero tools. AgentGroupChatSingletonAnalyzer Analyzer that validates <code>[AgentGroupChatMember]</code> group declarations. AgentOrphanAnalyzer Analyzer that detects agent types that participate in no topology declaration. AgentSequenceOrderAnalyzer Analyzer that validates <code>Order</code> values within <code>[AgentSequenceMember]</code> pipeline declarations. AgentTopologyAnalyzer Analyzer that validates <code>[AgentHandoffsTo]</code> topology declarations. MafDiagnosticDescriptors Contains diagnostic descriptors for all Needlr Agent Framework analyzers. MafDiagnosticIds Contains diagnostic IDs for all Needlr Agent Framework analyzers. TerminationConditionAnalyzer Analyzer that validates termination condition declarations on agent classes."},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/TerminationConditionAnalyzer/","title":"TerminationConditionAnalyzer","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/TerminationConditionAnalyzer/#nexuslabsneedlragentframeworkanalyzers","title":"NexusLabs.Needlr.AgentFramework.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/TerminationConditionAnalyzer/#terminationconditionanalyzer-class","title":"TerminationConditionAnalyzer Class","text":"<p>Analyzer that validates termination condition declarations on agent classes.</p> <pre><code>public sealed class TerminationConditionAnalyzer\n</code></pre> <p>Inheritance Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer \ud83e\udc52 TerminationConditionAnalyzer</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Analyzers/TerminationConditionAnalyzer/#remarks","title":"Remarks","text":"<p>\\&lt;b&gt;NDLRMAF009\\&lt;/b&gt; (Warning): <code>[WorkflowRunTerminationCondition]</code> is declared on a class             that is not also decorated with <code>[NeedlrAiAgent]</code>.\\&lt;b&gt;NDLRMAF010\\&lt;/b&gt; (Error): The <code>conditionType</code> passed to             <code>[WorkflowRunTerminationCondition]</code> or <code>[AgentTerminationCondition]</code> does not             implement <code>IWorkflowTerminationCondition</code>.\\&lt;b&gt;NDLRMAF011\\&lt;/b&gt; (Info): <code>[WorkflowRunTerminationCondition]</code> is declared on a             <code>[AgentGroupChatMember]</code>; prefer <code>[AgentTerminationCondition]</code> for group chats.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Generators/","title":"Index","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Generators/#nexuslabsneedlragentframeworkgenerators-namespace","title":"NexusLabs.Needlr.AgentFramework.Generators Namespace","text":"Classes AgentFrameworkFunctionRegistryGenerator Source generator for Microsoft Agent Framework functions. Discovers classes with [AgentFunction] methods and generates a compile-time type registry. Also discovers classes with [AgentFunctionGroup] attributes and generates a group registry. Also discovers classes with [NeedlrAiAgent] attributes and generates an agent registry. Always emits a [ModuleInitializer] that auto-registers all discovered types with AgentFrameworkGeneratedBootstrap on assembly load."},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Generators/AgentFrameworkFunctionRegistryGenerator/","title":"AgentFrameworkFunctionRegistryGenerator","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Generators/AgentFrameworkFunctionRegistryGenerator/#nexuslabsneedlragentframeworkgenerators","title":"NexusLabs.Needlr.AgentFramework.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Generators/AgentFrameworkFunctionRegistryGenerator/#agentframeworkfunctionregistrygenerator-class","title":"AgentFrameworkFunctionRegistryGenerator Class","text":"<p>Source generator for Microsoft Agent Framework functions. Discovers classes with [AgentFunction] methods and generates a compile-time type registry. Also discovers classes with [AgentFunctionGroup] attributes and generates a group registry. Also discovers classes with [NeedlrAiAgent] attributes and generates an agent registry. Always emits a [ModuleInitializer] that auto-registers all discovered types with AgentFrameworkGeneratedBootstrap on assembly load.</p> <pre><code>public class AgentFrameworkFunctionRegistryGenerator\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 Microsoft.CodeAnalysis.IIncrementalGenerator \ud83e\udc52 AgentFrameworkFunctionRegistryGenerator</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Generators/NexusLabs.Needlr.AgentFramework.Generators/","title":"NexusLabs.Needlr.AgentFramework.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Generators/NexusLabs.Needlr.AgentFramework.Generators/#nexuslabsneedlragentframeworkgenerators-namespace","title":"NexusLabs.Needlr.AgentFramework.Generators Namespace","text":"Classes AgentFrameworkFunctionRegistryGenerator Source generator for Microsoft Agent Framework functions. Discovers classes with [AgentFunction] methods and generates a compile-time type registry. Also discovers classes with [AgentFunctionGroup] attributes and generates a group registry. Also discovers classes with [NeedlrAiAgent] attributes and generates an agent registry. Always emits a [ModuleInitializer] that auto-registers all discovered types with AgentFrameworkGeneratedBootstrap on assembly load."},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/","title":"Index","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/#nexuslabsneedlragentframeworkworkflows-namespace","title":"NexusLabs.Needlr.AgentFramework.Workflows Namespace","text":"Classes AgentFactoryWorkflowExtensions Extension methods on NexusLabs.Needlr.AgentFramework.IAgentFactory for building MAF handoff workflow topologies. KeywordTerminationCondition Terminates a workflow when an agent's response contains a specified keyword. RegexTerminationCondition Terminates a workflow when an agent's response matches a specified regular expression pattern. StreamingRunWorkflowExtensions Extension methods on Microsoft.Agents.AI.Workflows.StreamingRun and Microsoft.Agents.AI.Workflows.Workflow for collecting agent responses."},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/AgentFactoryWorkflowExtensions/","title":"AgentFactoryWorkflowExtensions","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/AgentFactoryWorkflowExtensions/#nexuslabsneedlragentframeworkworkflows","title":"NexusLabs.Needlr.AgentFramework.Workflows","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/AgentFactoryWorkflowExtensions/#agentfactoryworkflowextensions-class","title":"AgentFactoryWorkflowExtensions Class","text":"<p>Extension methods on NexusLabs.Needlr.AgentFramework.IAgentFactory for building MAF handoff workflow topologies.</p> <pre><code>public static class AgentFactoryWorkflowExtensions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 AgentFactoryWorkflowExtensions</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/AgentFactoryWorkflowExtensions/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/AgentFactoryWorkflowExtensions/#agentfactoryworkflowextensionsbuildhandoffworkflowthis-iagentfactory-aiagent-aiagent-method","title":"AgentFactoryWorkflowExtensions.BuildHandoffWorkflow(this IAgentFactory, AIAgent, AIAgent[]) Method","text":"<p>Builds a handoff workflow where initialAgent routes to one of the handoffTargets based on LLM-driven tool-call decisions.</p> <pre><code>public static Microsoft.Agents.AI.Workflows.Workflow BuildHandoffWorkflow(this NexusLabs.Needlr.AgentFramework.IAgentFactory agentFactory, Microsoft.Agents.AI.AIAgent initialAgent, params Microsoft.Agents.AI.AIAgent[] handoffTargets);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/AgentFactoryWorkflowExtensions/#parameters","title":"Parameters","text":"<p><code>agentFactory</code> NexusLabs.Needlr.AgentFramework.IAgentFactory</p> <p></p> <p><code>initialAgent</code> Microsoft.Agents.AI.AIAgent</p> <p></p> <p><code>handoffTargets</code> Microsoft.Agents.AI.AIAgent[]</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/AgentFactoryWorkflowExtensions/#returns","title":"Returns","text":"<p>Microsoft.Agents.AI.Workflows.Workflow</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/AgentFactoryWorkflowExtensions/#remarks","title":"Remarks","text":"<p>This is an ergonomic wrapper over the raw MAF handoff builder, which requires passing initialAgent twice \u2014 once to <code>CreateHandoffBuilderWith</code> and again as the <code>from</code> argument in <code>WithHandoffs</code>.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/KeywordTerminationCondition/","title":"KeywordTerminationCondition","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/KeywordTerminationCondition/#nexuslabsneedlragentframeworkworkflows","title":"NexusLabs.Needlr.AgentFramework.Workflows","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/KeywordTerminationCondition/#keywordterminationcondition-class","title":"KeywordTerminationCondition Class","text":"<p>Terminates a workflow when an agent's response contains a specified keyword.</p> <pre><code>public sealed class KeywordTerminationCondition : NexusLabs.Needlr.AgentFramework.IWorkflowTerminationCondition\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 KeywordTerminationCondition</p> <p>Implements NexusLabs.Needlr.AgentFramework.IWorkflowTerminationCondition</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/KeywordTerminationCondition/#remarks","title":"Remarks","text":"<p>The check is a simple substring match (case-insensitive by default). To restrict the condition to a specific agent, provide the agent's name or executor ID via the <code>agentId</code> constructor parameter.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/KeywordTerminationCondition/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/KeywordTerminationCondition/#keywordterminationconditionstring-constructor","title":"KeywordTerminationCondition(string) Constructor","text":"<p>Initializes a new instance that fires when \\&lt;em&gt;any\\&lt;/em&gt; agent's response contains keyword (case-insensitive).</p> <pre><code>public KeywordTerminationCondition(string keyword);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/KeywordTerminationCondition/#parameters","title":"Parameters","text":"<p><code>keyword</code> System.String</p> <p>The keyword to look for in the response text.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/KeywordTerminationCondition/#keywordterminationconditionstring-string-constructor","title":"KeywordTerminationCondition(string, string) Constructor","text":"<p>Initializes a new instance that fires when a specific agent's response contains keyword.</p> <pre><code>public KeywordTerminationCondition(string keyword, string? agentId);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/KeywordTerminationCondition/#parameters_1","title":"Parameters","text":"<p><code>keyword</code> System.String</p> <p>The keyword to look for in the response text.</p> <p></p> <p><code>agentId</code> System.String</p> <p>The agent name or executor ID to restrict the match to, or null to match any agent.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/KeywordTerminationCondition/#keywordterminationconditionstring-string-stringcomparison-constructor","title":"KeywordTerminationCondition(string, string, StringComparison) Constructor","text":"<p>Initializes a new instance with full control over agent filtering and comparison.</p> <pre><code>public KeywordTerminationCondition(string keyword, string? agentId, System.StringComparison comparison);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/KeywordTerminationCondition/#parameters_2","title":"Parameters","text":"<p><code>keyword</code> System.String</p> <p>The keyword to look for in the response text.</p> <p></p> <p><code>agentId</code> System.String</p> <p>The agent name or executor ID to restrict the match to, or null to match any agent.</p> <p></p> <p><code>comparison</code> System.StringComparison</p> <p>The string comparison used when searching for the keyword.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/KeywordTerminationCondition/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/KeywordTerminationCondition/#keywordterminationconditionshouldterminateterminationcontext-method","title":"KeywordTerminationCondition.ShouldTerminate(TerminationContext) Method","text":"<p>Determines whether the workflow should terminate after the given agent response.</p> <pre><code>public bool ShouldTerminate(NexusLabs.Needlr.AgentFramework.TerminationContext context);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/KeywordTerminationCondition/#parameters_3","title":"Parameters","text":"<p><code>context</code> NexusLabs.Needlr.AgentFramework.TerminationContext</p> <p>Context for the completed agent turn.</p> <p>Implements ShouldTerminate(TerminationContext)</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/KeywordTerminationCondition/#returns","title":"Returns","text":"<p>System.Boolean true to stop the workflow; false to continue.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/NexusLabs.Needlr.AgentFramework.Workflows/","title":"NexusLabs.Needlr.AgentFramework.Workflows","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/NexusLabs.Needlr.AgentFramework.Workflows/#nexuslabsneedlragentframeworkworkflows-namespace","title":"NexusLabs.Needlr.AgentFramework.Workflows Namespace","text":"Classes AgentFactoryWorkflowExtensions Extension methods on NexusLabs.Needlr.AgentFramework.IAgentFactory for building MAF handoff workflow topologies. KeywordTerminationCondition Terminates a workflow when an agent's response contains a specified keyword. RegexTerminationCondition Terminates a workflow when an agent's response matches a specified regular expression pattern. StreamingRunWorkflowExtensions Extension methods on Microsoft.Agents.AI.Workflows.StreamingRun and Microsoft.Agents.AI.Workflows.Workflow for collecting agent responses."},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/RegexTerminationCondition/","title":"RegexTerminationCondition","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/RegexTerminationCondition/#nexuslabsneedlragentframeworkworkflows","title":"NexusLabs.Needlr.AgentFramework.Workflows","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/RegexTerminationCondition/#regexterminationcondition-class","title":"RegexTerminationCondition Class","text":"<p>Terminates a workflow when an agent's response matches a specified regular expression pattern.</p> <pre><code>public sealed class RegexTerminationCondition : NexusLabs.Needlr.AgentFramework.IWorkflowTerminationCondition\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 RegexTerminationCondition</p> <p>Implements NexusLabs.Needlr.AgentFramework.IWorkflowTerminationCondition</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/RegexTerminationCondition/#remarks","title":"Remarks","text":"<p>Matching is performed against the full response text of each completed agent turn. To restrict the condition to a specific agent, provide the agent's name or executor ID via the <code>agentId</code> constructor parameter.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/RegexTerminationCondition/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/RegexTerminationCondition/#regexterminationconditionstring-constructor","title":"RegexTerminationCondition(string) Constructor","text":"<p>Initializes a new instance that fires when \\&lt;em&gt;any\\&lt;/em&gt; agent's response matches pattern (case-insensitive, single-line).</p> <pre><code>public RegexTerminationCondition(string pattern);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/RegexTerminationCondition/#parameters","title":"Parameters","text":"<p><code>pattern</code> System.String</p> <p>The regular expression pattern to match against response text.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/RegexTerminationCondition/#regexterminationconditionstring-string-constructor","title":"RegexTerminationCondition(string, string) Constructor","text":"<p>Initializes a new instance that fires when a specific agent's response matches pattern.</p> <pre><code>public RegexTerminationCondition(string pattern, string? agentId);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/RegexTerminationCondition/#parameters_1","title":"Parameters","text":"<p><code>pattern</code> System.String</p> <p>The regular expression pattern to match against response text.</p> <p></p> <p><code>agentId</code> System.String</p> <p>The agent name or executor ID to restrict the match to, or null to match any agent.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/RegexTerminationCondition/#regexterminationconditionstring-string-regexoptions-constructor","title":"RegexTerminationCondition(string, string, RegexOptions) Constructor","text":"<p>Initializes a new instance with full control over agent filtering and regex options.</p> <pre><code>public RegexTerminationCondition(string pattern, string? agentId, System.Text.RegularExpressions.RegexOptions options);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/RegexTerminationCondition/#parameters_2","title":"Parameters","text":"<p><code>pattern</code> System.String</p> <p>The regular expression pattern to match against response text.</p> <p></p> <p><code>agentId</code> System.String</p> <p>The agent name or executor ID to restrict the match to, or null to match any agent.</p> <p></p> <p><code>options</code> System.Text.RegularExpressions.RegexOptions</p> <p>Regex options applied when compiling and evaluating the pattern.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/RegexTerminationCondition/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/RegexTerminationCondition/#regexterminationconditionshouldterminateterminationcontext-method","title":"RegexTerminationCondition.ShouldTerminate(TerminationContext) Method","text":"<p>Determines whether the workflow should terminate after the given agent response.</p> <pre><code>public bool ShouldTerminate(NexusLabs.Needlr.AgentFramework.TerminationContext context);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/RegexTerminationCondition/#parameters_3","title":"Parameters","text":"<p><code>context</code> NexusLabs.Needlr.AgentFramework.TerminationContext</p> <p>Context for the completed agent turn.</p> <p>Implements ShouldTerminate(TerminationContext)</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/RegexTerminationCondition/#returns","title":"Returns","text":"<p>System.Boolean true to stop the workflow; false to continue.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/StreamingRunWorkflowExtensions/","title":"StreamingRunWorkflowExtensions","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/StreamingRunWorkflowExtensions/#nexuslabsneedlragentframeworkworkflows","title":"NexusLabs.Needlr.AgentFramework.Workflows","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/StreamingRunWorkflowExtensions/#streamingrunworkflowextensions-class","title":"StreamingRunWorkflowExtensions Class","text":"<p>Extension methods on Microsoft.Agents.AI.Workflows.StreamingRun and Microsoft.Agents.AI.Workflows.Workflow for collecting agent responses.</p> <pre><code>public static class StreamingRunWorkflowExtensions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 StreamingRunWorkflowExtensions</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/StreamingRunWorkflowExtensions/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/StreamingRunWorkflowExtensions/#streamingrunworkflowextensionscollectagentresponsesasyncthis-streamingrun-cancellationtoken-method","title":"StreamingRunWorkflowExtensions.CollectAgentResponsesAsync(this StreamingRun, CancellationToken) Method","text":"<p>Collects all agent response text from a streaming run, grouped by executor ID.</p> <pre><code>public static System.Threading.Tasks.Task&lt;System.Collections.Generic.IReadOnlyDictionary&lt;string,string&gt;&gt; CollectAgentResponsesAsync(this Microsoft.Agents.AI.Workflows.StreamingRun run, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/StreamingRunWorkflowExtensions/#parameters","title":"Parameters","text":"<p><code>run</code> Microsoft.Agents.AI.Workflows.StreamingRun</p> <p></p> <p><code>cancellationToken</code> System.Threading.CancellationToken</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/StreamingRunWorkflowExtensions/#returns","title":"Returns","text":"<p>System.Threading.Tasks.Task&lt;System.Collections.Generic.IReadOnlyDictionary&lt;System.String,System.String&gt;&gt; A dictionary mapping each agent's executor ID to its complete response text. Agents that emitted no text produce no entry.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/StreamingRunWorkflowExtensions/#streamingrunworkflowextensionsrunasyncthis-workflow-chatmessage-ireadonlylistiworkflowterminationcondition-cancellationtoken-method","title":"StreamingRunWorkflowExtensions.RunAsync(this Workflow, ChatMessage, IReadOnlyList&lt;IWorkflowTerminationCondition&gt;, CancellationToken) Method","text":"<p>Creates a streaming execution of the workflow, sends the message, collects all agent responses, and stops early when any termination condition is met.</p> <pre><code>public static System.Threading.Tasks.Task&lt;System.Collections.Generic.IReadOnlyDictionary&lt;string,string&gt;&gt; RunAsync(this Microsoft.Agents.AI.Workflows.Workflow workflow, Microsoft.Extensions.AI.ChatMessage message, System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.AgentFramework.IWorkflowTerminationCondition&gt;? terminationConditions, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/StreamingRunWorkflowExtensions/#parameters_1","title":"Parameters","text":"<p><code>workflow</code> Microsoft.Agents.AI.Workflows.Workflow</p> <p>The workflow to execute.</p> <p></p> <p><code>message</code> Microsoft.Extensions.AI.ChatMessage</p> <p>The chat message to send to the workflow.</p> <p></p> <p><code>terminationConditions</code> System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.AgentFramework.IWorkflowTerminationCondition&gt;</p> <p>Conditions evaluated after each completed agent turn. The first condition that returns true causes the loop to stop and remaining responses to be discarded. Pass an empty collection (or null) to disable Layer 2 termination.</p> <p></p> <p><code>cancellationToken</code> System.Threading.CancellationToken</p> <p>Optional cancellation token.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/StreamingRunWorkflowExtensions/#returns_1","title":"Returns","text":"<p>System.Threading.Tasks.Task&lt;System.Collections.Generic.IReadOnlyDictionary&lt;System.String,System.String&gt;&gt; A dictionary mapping each agent's executor ID to its complete response text up to the point of termination. Agents that emitted no text produce no entry.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/StreamingRunWorkflowExtensions/#streamingrunworkflowextensionsrunasyncthis-workflow-chatmessage-cancellationtoken-method","title":"StreamingRunWorkflowExtensions.RunAsync(this Workflow, ChatMessage, CancellationToken) Method","text":"<p>Creates a streaming execution of the workflow, sends the message, and collects all agent responses.</p> <pre><code>public static System.Threading.Tasks.Task&lt;System.Collections.Generic.IReadOnlyDictionary&lt;string,string&gt;&gt; RunAsync(this Microsoft.Agents.AI.Workflows.Workflow workflow, Microsoft.Extensions.AI.ChatMessage message, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/StreamingRunWorkflowExtensions/#parameters_2","title":"Parameters","text":"<p><code>workflow</code> Microsoft.Agents.AI.Workflows.Workflow</p> <p>The workflow to execute.</p> <p></p> <p><code>message</code> Microsoft.Extensions.AI.ChatMessage</p> <p>The chat message to send to the workflow.</p> <p></p> <p><code>cancellationToken</code> System.Threading.CancellationToken</p> <p>Optional cancellation token.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/StreamingRunWorkflowExtensions/#returns_2","title":"Returns","text":"<p>System.Threading.Tasks.Task&lt;System.Collections.Generic.IReadOnlyDictionary&lt;System.String,System.String&gt;&gt; A dictionary mapping each agent's executor ID to its complete response text. Agents that emitted no text produce no entry.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/StreamingRunWorkflowExtensions/#streamingrunworkflowextensionsrunasyncthis-workflow-string-ireadonlylistiworkflowterminationcondition-cancellationtoken-method","title":"StreamingRunWorkflowExtensions.RunAsync(this Workflow, string, IReadOnlyList&lt;IWorkflowTerminationCondition&gt;, CancellationToken) Method","text":"<p>Creates a streaming execution of the workflow, sends the message, collects all agent responses, and stops early when any termination condition is met.</p> <pre><code>public static System.Threading.Tasks.Task&lt;System.Collections.Generic.IReadOnlyDictionary&lt;string,string&gt;&gt; RunAsync(this Microsoft.Agents.AI.Workflows.Workflow workflow, string message, System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.AgentFramework.IWorkflowTerminationCondition&gt;? terminationConditions, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/StreamingRunWorkflowExtensions/#parameters_3","title":"Parameters","text":"<p><code>workflow</code> Microsoft.Agents.AI.Workflows.Workflow</p> <p>The workflow to execute.</p> <p></p> <p><code>message</code> System.String</p> <p>The user message to send to the workflow.</p> <p></p> <p><code>terminationConditions</code> System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.AgentFramework.IWorkflowTerminationCondition&gt;</p> <p>Conditions evaluated after each completed agent turn. The first condition that returns true causes the loop to stop and remaining responses to be discarded. Pass an empty collection (or null) to disable Layer 2 termination.</p> <p></p> <p><code>cancellationToken</code> System.Threading.CancellationToken</p> <p>Optional cancellation token.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/StreamingRunWorkflowExtensions/#returns_3","title":"Returns","text":"<p>System.Threading.Tasks.Task&lt;System.Collections.Generic.IReadOnlyDictionary&lt;System.String,System.String&gt;&gt; A dictionary mapping each agent's executor ID to its complete response text up to the point of termination. Agents that emitted no text produce no entry.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/StreamingRunWorkflowExtensions/#streamingrunworkflowextensionsrunasyncthis-workflow-string-cancellationtoken-method","title":"StreamingRunWorkflowExtensions.RunAsync(this Workflow, string, CancellationToken) Method","text":"<p>Creates a streaming execution of the workflow, sends the message, and collects all agent responses.</p> <pre><code>public static System.Threading.Tasks.Task&lt;System.Collections.Generic.IReadOnlyDictionary&lt;string,string&gt;&gt; RunAsync(this Microsoft.Agents.AI.Workflows.Workflow workflow, string message, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/StreamingRunWorkflowExtensions/#parameters_4","title":"Parameters","text":"<p><code>workflow</code> Microsoft.Agents.AI.Workflows.Workflow</p> <p>The workflow to execute.</p> <p></p> <p><code>message</code> System.String</p> <p>The user message to send to the workflow.</p> <p></p> <p><code>cancellationToken</code> System.Threading.CancellationToken</p> <p>Optional cancellation token.</p>"},{"location":"api/dev/NexusLabs.Needlr.AgentFramework.Workflows/StreamingRunWorkflowExtensions/#returns_4","title":"Returns","text":"<p>System.Threading.Tasks.Task&lt;System.Collections.Generic.IReadOnlyDictionary&lt;System.String,System.String&gt;&gt; A dictionary mapping each agent's executor ID to its complete response text. Agents that emitted no text produce no entry.</p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/","title":"Index","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/#nexuslabsneedlranalyzers","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/#nexuslabsneedlranalyzers-assembly","title":"NexusLabs.Needlr.Analyzers Assembly","text":"Namespaces NexusLabs.Needlr.Analyzers NexusLabs.Needlr.Roslyn.Shared"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/CircularDependencyAnalyzer/","title":"CircularDependencyAnalyzer","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/CircularDependencyAnalyzer/#nexuslabsneedlranalyzers","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/CircularDependencyAnalyzer/#nexuslabsneedlranalyzers_1","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/CircularDependencyAnalyzer/#circulardependencyanalyzer-class","title":"CircularDependencyAnalyzer Class","text":"<p>Analyzer that detects circular dependencies in service registrations. A circular dependency occurs when a service directly or indirectly depends on itself.</p> <pre><code>public sealed class CircularDependencyAnalyzer\n</code></pre> <p>Inheritance Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer \ud83e\udc52 CircularDependencyAnalyzer</p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/CircularDependencyAnalyzer/#remarks","title":"Remarks","text":"<p>Examples: - A \u2192 B \u2192 A (direct cycle) - A \u2192 B \u2192 C \u2192 A (indirect cycle)</p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/CollectionResolutionAnalyzer/","title":"CollectionResolutionAnalyzer","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/CollectionResolutionAnalyzer/#nexuslabsneedlranalyzers","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/CollectionResolutionAnalyzer/#nexuslabsneedlranalyzers_1","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/CollectionResolutionAnalyzer/#collectionresolutionanalyzer-class","title":"CollectionResolutionAnalyzer Class","text":"<p>Analyzer that detects IEnumerable\\&lt;T&gt; dependencies where no implementations of T are discovered by source generation. Only active when [assembly: GenerateTypeRegistry] is present.</p> <pre><code>public sealed class CollectionResolutionAnalyzer\n</code></pre> <p>Inheritance Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer \ud83e\udc52 CollectionResolutionAnalyzer</p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DeferToContainerInGeneratedCodeAnalyzer/","title":"DeferToContainerInGeneratedCodeAnalyzer","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DeferToContainerInGeneratedCodeAnalyzer/#nexuslabsneedlranalyzers","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DeferToContainerInGeneratedCodeAnalyzer/#nexuslabsneedlranalyzers_1","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DeferToContainerInGeneratedCodeAnalyzer/#defertocontaineringeneratedcodeanalyzer-class","title":"DeferToContainerInGeneratedCodeAnalyzer Class","text":"<p>Analyzer that detects [DeferToContainer] attributes placed in generated code.</p> <pre><code>public sealed class DeferToContainerInGeneratedCodeAnalyzer\n</code></pre> <p>Inheritance Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer \ud83e\udc52 DeferToContainerInGeneratedCodeAnalyzer</p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DeferToContainerInGeneratedCodeAnalyzer/#remarks","title":"Remarks","text":"<p>Source generators run in isolation and cannot see output from other generators. If another generator adds [DeferToContainer] to a partial class, Needlr's TypeRegistryGenerator will not see it and will generate incorrect factory code.</p> <p>This analyzer runs after all generators complete and can detect this scenario, warning users to move the attribute to their original source file.</p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticDescriptors/","title":"DiagnosticDescriptors","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticDescriptors/#nexuslabsneedlranalyzers","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticDescriptors/#nexuslabsneedlranalyzers_1","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticDescriptors/#diagnosticdescriptors-class","title":"DiagnosticDescriptors Class","text":"<p>Contains diagnostic descriptors for all Needlr analyzers.</p> <pre><code>public static class DiagnosticDescriptors\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 DiagnosticDescriptors</p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticDescriptors/#fields","title":"Fields","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticDescriptors/#diagnosticdescriptorscirculardependency-field","title":"DiagnosticDescriptors.CircularDependency Field","text":"<p>NDLRCOR006: Circular dependency detected in service registration.</p> <pre><code>public static readonly DiagnosticDescriptor CircularDependency;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticDescriptors/#field-value","title":"Field Value","text":"<p>Microsoft.CodeAnalysis.DiagnosticDescriptor</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticDescriptors/#diagnosticdescriptorscollectionresolutionempty-field","title":"DiagnosticDescriptors.CollectionResolutionEmpty Field","text":"<p>NDLRCOR010: IEnumerable\\&lt;T&gt; has no implementations discovered.</p> <pre><code>public static readonly DiagnosticDescriptor CollectionResolutionEmpty;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticDescriptors/#field-value_1","title":"Field Value","text":"<p>Microsoft.CodeAnalysis.DiagnosticDescriptor</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticDescriptors/#diagnosticdescriptorsdefertocontaineringeneratedcode-field","title":"DiagnosticDescriptors.DeferToContainerInGeneratedCode Field","text":"<p>NDLRCOR003: DeferToContainer attribute in generated code.</p> <pre><code>public static readonly DiagnosticDescriptor DeferToContainerInGeneratedCode;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticDescriptors/#field-value_2","title":"Field Value","text":"<p>Microsoft.CodeAnalysis.DiagnosticDescriptor</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticDescriptors/#diagnosticdescriptorsdisposablecaptivedependency-field","title":"DiagnosticDescriptors.DisposableCaptiveDependency Field","text":"<p>NDLRCOR012: Disposable captive dependency - longer-lived service holds IDisposable with shorter lifetime.</p> <pre><code>public static readonly DiagnosticDescriptor DisposableCaptiveDependency;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticDescriptors/#field-value_3","title":"Field Value","text":"<p>Microsoft.CodeAnalysis.DiagnosticDescriptor</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticDescriptors/#diagnosticdescriptorsdonotautoregisteronpluginclass-field","title":"DiagnosticDescriptors.DoNotAutoRegisterOnPluginClass Field","text":"<p>NDLRCOR016: [DoNotAutoRegister] applied directly to a plugin class is redundant.</p> <pre><code>public static readonly DiagnosticDescriptor DoNotAutoRegisterOnPluginClass;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticDescriptors/#field-value_4","title":"Field Value","text":"<p>Microsoft.CodeAnalysis.DiagnosticDescriptor</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticDescriptors/#diagnosticdescriptorsglobalnamespacetypenotdiscovered-field","title":"DiagnosticDescriptors.GlobalNamespaceTypeNotDiscovered Field","text":"<p>NDLRCOR004: Injectable type in global namespace may not be discovered.</p> <pre><code>public static readonly DiagnosticDescriptor GlobalNamespaceTypeNotDiscovered;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticDescriptors/#field-value_5","title":"Field Value","text":"<p>Microsoft.CodeAnalysis.DiagnosticDescriptor</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticDescriptors/#diagnosticdescriptorsinterceptonclasswithoutinterfaces-field","title":"DiagnosticDescriptors.InterceptOnClassWithoutInterfaces Field","text":"<p>NDLRCOR008: [Intercept] applied to class without interfaces.</p> <pre><code>public static readonly DiagnosticDescriptor InterceptOnClassWithoutInterfaces;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticDescriptors/#field-value_6","title":"Field Value","text":"<p>Microsoft.CodeAnalysis.DiagnosticDescriptor</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticDescriptors/#diagnosticdescriptorsintercepttypemustimplementinterface-field","title":"DiagnosticDescriptors.InterceptTypeMustImplementInterface Field","text":"<p>NDLRCOR007: Intercept attribute type must implement IMethodInterceptor.</p> <pre><code>public static readonly DiagnosticDescriptor InterceptTypeMustImplementInterface;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticDescriptors/#field-value_7","title":"Field Value","text":"<p>Microsoft.CodeAnalysis.DiagnosticDescriptor</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticDescriptors/#diagnosticdescriptorskeyedserviceunknownkey-field","title":"DiagnosticDescriptors.KeyedServiceUnknownKey Field","text":"<p>NDLRCOR011: [FromKeyedServices] references a key with no known registration.</p> <pre><code>public static readonly DiagnosticDescriptor KeyedServiceUnknownKey;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticDescriptors/#field-value_8","title":"Field Value","text":"<p>Microsoft.CodeAnalysis.DiagnosticDescriptor</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticDescriptors/#diagnosticdescriptorslazyresolutionunknown-field","title":"DiagnosticDescriptors.LazyResolutionUnknown Field","text":"<p>NDLRCOR009: Lazy\\&lt;T&gt; references type not discovered by source generation.</p> <pre><code>public static readonly DiagnosticDescriptor LazyResolutionUnknown;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticDescriptors/#field-value_9","title":"Field Value","text":"<p>Microsoft.CodeAnalysis.DiagnosticDescriptor</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticDescriptors/#diagnosticdescriptorslifetimemismatch-field","title":"DiagnosticDescriptors.LifetimeMismatch Field","text":"<p>NDLRCOR005: Lifetime mismatch - longer-lived service depends on shorter-lived service.</p> <pre><code>public static readonly DiagnosticDescriptor LifetimeMismatch;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticDescriptors/#field-value_10","title":"Field Value","text":"<p>Microsoft.CodeAnalysis.DiagnosticDescriptor</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticDescriptors/#diagnosticdescriptorspluginhasconstructordependencies-field","title":"DiagnosticDescriptors.PluginHasConstructorDependencies Field","text":"<p>NDLRCOR002: Plugin has constructor dependencies.</p> <pre><code>public static readonly DiagnosticDescriptor PluginHasConstructorDependencies;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticDescriptors/#field-value_11","title":"Field Value","text":"<p>Microsoft.CodeAnalysis.DiagnosticDescriptor</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticDescriptors/#diagnosticdescriptorsreflectioninaotproject-field","title":"DiagnosticDescriptors.ReflectionInAotProject Field","text":"<p>NDLRCOR001: Reflection API used in AOT project.</p> <pre><code>public static readonly DiagnosticDescriptor ReflectionInAotProject;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticDescriptors/#field-value_12","title":"Field Value","text":"<p>Microsoft.CodeAnalysis.DiagnosticDescriptor</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticDescriptors/#diagnosticdescriptorsregisterastypeargnotimplemented-field","title":"DiagnosticDescriptors.RegisterAsTypeArgNotImplemented Field","text":"<p>NDLRCOR015: [RegisterAs\\&lt;T&gt;] type argument must be an interface implemented by the class.</p> <pre><code>public static readonly DiagnosticDescriptor RegisterAsTypeArgNotImplemented;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticDescriptors/#field-value_13","title":"Field Value","text":"<p>Microsoft.CodeAnalysis.DiagnosticDescriptor</p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/","title":"DiagnosticIds","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/#nexuslabsneedlranalyzers","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/#nexuslabsneedlranalyzers_1","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/#diagnosticids-class","title":"DiagnosticIds Class","text":"<p>Contains diagnostic IDs for all Needlr core analyzers.</p> <pre><code>public static class DiagnosticIds\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 DiagnosticIds</p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/#remarks","title":"Remarks","text":"<p>Core analyzer codes use the NDLRCOR prefix.</p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/#fields","title":"Fields","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/#diagnosticidscirculardependency-field","title":"DiagnosticIds.CircularDependency Field","text":"<p>NDLRCOR006: Circular dependency detected in service registration.</p> <pre><code>public const string CircularDependency = \"NDLRCOR006\";\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/#field-value","title":"Field Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/#diagnosticidscollectionresolutionempty-field","title":"DiagnosticIds.CollectionResolutionEmpty Field","text":"<p>NDLRCOR010: IEnumerable\\&lt;T&gt; has no implementations discovered by source generation.</p> <pre><code>public const string CollectionResolutionEmpty = \"NDLRCOR010\";\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/#field-value_1","title":"Field Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/#diagnosticidsdefertocontaineringeneratedcode-field","title":"DiagnosticIds.DeferToContainerInGeneratedCode Field","text":"<p>NDLRCOR003: DeferToContainer attribute in generated code.</p> <pre><code>public const string DeferToContainerInGeneratedCode = \"NDLRCOR003\";\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/#field-value_2","title":"Field Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/#diagnosticidsdisposablecaptivedependency-field","title":"DiagnosticIds.DisposableCaptiveDependency Field","text":"<p>NDLRCOR012: Disposable captive dependency - longer-lived service holds IDisposable with shorter lifetime.</p> <pre><code>public const string DisposableCaptiveDependency = \"NDLRCOR012\";\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/#field-value_3","title":"Field Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/#diagnosticidsdonotautoregisteronpluginclass-field","title":"DiagnosticIds.DoNotAutoRegisterOnPluginClass Field","text":"<p>NDLRCOR016: [DoNotAutoRegister] applied directly to a plugin class is redundant.</p> <pre><code>public const string DoNotAutoRegisterOnPluginClass = \"NDLRCOR016\";\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/#field-value_4","title":"Field Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/#diagnosticidsglobalnamespacetypenotdiscovered-field","title":"DiagnosticIds.GlobalNamespaceTypeNotDiscovered Field","text":"<p>NDLRCOR004: Injectable type in global namespace may not be discovered.</p> <pre><code>public const string GlobalNamespaceTypeNotDiscovered = \"NDLRCOR004\";\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/#field-value_5","title":"Field Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/#diagnosticidsinterceptonclasswithoutinterfaces-field","title":"DiagnosticIds.InterceptOnClassWithoutInterfaces Field","text":"<p>NDLRCOR008: [Intercept] applied to class without interfaces.</p> <pre><code>public const string InterceptOnClassWithoutInterfaces = \"NDLRCOR008\";\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/#field-value_6","title":"Field Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/#diagnosticidsintercepttypemustimplementinterface-field","title":"DiagnosticIds.InterceptTypeMustImplementInterface Field","text":"<p>NDLRCOR007: Intercept attribute type must implement IMethodInterceptor.</p> <pre><code>public const string InterceptTypeMustImplementInterface = \"NDLRCOR007\";\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/#field-value_7","title":"Field Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/#diagnosticidskeyedserviceunknownkey-field","title":"DiagnosticIds.KeyedServiceUnknownKey Field","text":"<p>NDLRCOR011: [FromKeyedServices] references a key with no known registration.</p> <pre><code>public const string KeyedServiceUnknownKey = \"NDLRCOR011\";\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/#field-value_8","title":"Field Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/#diagnosticidslazyresolutionunknown-field","title":"DiagnosticIds.LazyResolutionUnknown Field","text":"<p>NDLRCOR009: Lazy\\&lt;T&gt; references type not discovered by source generation.</p> <pre><code>public const string LazyResolutionUnknown = \"NDLRCOR009\";\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/#field-value_9","title":"Field Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/#diagnosticidslifetimemismatch-field","title":"DiagnosticIds.LifetimeMismatch Field","text":"<p>NDLRCOR005: Lifetime mismatch - longer-lived service depends on shorter-lived service.</p> <pre><code>public const string LifetimeMismatch = \"NDLRCOR005\";\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/#field-value_10","title":"Field Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/#diagnosticidspluginhasconstructordependencies-field","title":"DiagnosticIds.PluginHasConstructorDependencies Field","text":"<p>NDLRCOR002: Plugin has constructor dependencies.</p> <pre><code>public const string PluginHasConstructorDependencies = \"NDLRCOR002\";\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/#field-value_11","title":"Field Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/#diagnosticidsreflectioninaotproject-field","title":"DiagnosticIds.ReflectionInAotProject Field","text":"<p>NDLRCOR001: Reflection API used in AOT project.</p> <pre><code>public const string ReflectionInAotProject = \"NDLRCOR001\";\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/#field-value_12","title":"Field Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/#diagnosticidsregisterastypeargnotimplemented-field","title":"DiagnosticIds.RegisterAsTypeArgNotImplemented Field","text":"<p>NDLRCOR015: [RegisterAs\\&lt;T&gt;] type argument must be an interface implemented by the class.</p> <pre><code>public const string RegisterAsTypeArgNotImplemented = \"NDLRCOR015\";\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DiagnosticIds/#field-value_13","title":"Field Value","text":"<p>System.String</p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DisposableCaptiveDependencyAnalyzer/","title":"DisposableCaptiveDependencyAnalyzer","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DisposableCaptiveDependencyAnalyzer/#nexuslabsneedlranalyzers","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DisposableCaptiveDependencyAnalyzer/#nexuslabsneedlranalyzers_1","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DisposableCaptiveDependencyAnalyzer/#disposablecaptivedependencyanalyzer-class","title":"DisposableCaptiveDependencyAnalyzer Class","text":"<p>Analyzer that detects when a longer-lived service holds a reference to a shorter-lived IDisposable. This is a more severe form of captive dependency because the disposed object will still be referenced.</p> <pre><code>public sealed class DisposableCaptiveDependencyAnalyzer\n</code></pre> <p>Inheritance Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer \ud83e\udc52 DisposableCaptiveDependencyAnalyzer</p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DisposableCaptiveDependencyAnalyzer/#remarks","title":"Remarks","text":"<p>This analyzer is conservative to avoid false positives: - Only fires when both consumer and dependency have explicit lifetime attributes - Only fires when the dependency type itself (not just interface) implements IDisposable/IAsyncDisposable - Does not fire for factory patterns (Func\\&lt;T&gt;, Lazy\\&lt;T&gt;, IServiceScopeFactory)</p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DoNotAutoRegisterOnPluginAnalyzer/","title":"DoNotAutoRegisterOnPluginAnalyzer","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DoNotAutoRegisterOnPluginAnalyzer/#nexuslabsneedlranalyzers","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DoNotAutoRegisterOnPluginAnalyzer/#nexuslabsneedlranalyzers_1","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/DoNotAutoRegisterOnPluginAnalyzer/#donotautoregisteronpluginanalyzer-class","title":"DoNotAutoRegisterOnPluginAnalyzer Class","text":"<p>Analyzer that warns when [DoNotAutoRegister] is applied directly to a class that implements a Needlr plugin interface.</p> <pre><code>public sealed class DoNotAutoRegisterOnPluginAnalyzer\n</code></pre> <p>Inheritance Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer \ud83e\udc52 DoNotAutoRegisterOnPluginAnalyzer</p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/GlobalNamespaceTypeAnalyzer/","title":"GlobalNamespaceTypeAnalyzer","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/GlobalNamespaceTypeAnalyzer/#nexuslabsneedlranalyzers","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/GlobalNamespaceTypeAnalyzer/#nexuslabsneedlranalyzers_1","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/GlobalNamespaceTypeAnalyzer/#globalnamespacetypeanalyzer-class","title":"GlobalNamespaceTypeAnalyzer Class","text":"<p>Analyzer that detects injectable types in the global namespace that won't be discovered when IncludeNamespacePrefixes is set without an empty string.</p> <pre><code>public sealed class GlobalNamespaceTypeAnalyzer\n</code></pre> <p>Inheritance Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer \ud83e\udc52 GlobalNamespaceTypeAnalyzer</p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/InterceptAttributeAnalyzer/","title":"InterceptAttributeAnalyzer","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/InterceptAttributeAnalyzer/#nexuslabsneedlranalyzers","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/InterceptAttributeAnalyzer/#nexuslabsneedlranalyzers_1","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/InterceptAttributeAnalyzer/#interceptattributeanalyzer-class","title":"InterceptAttributeAnalyzer Class","text":"<p>Analyzer that validates [Intercept] attribute usage: - NDLRCOR007: Intercept type must implement IMethodInterceptor - NDLRCOR008: [Intercept] applied to class without interfaces</p> <pre><code>public sealed class InterceptAttributeAnalyzer\n</code></pre> <p>Inheritance Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer \ud83e\udc52 InterceptAttributeAnalyzer</p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/KeyedServiceResolutionAnalyzer/","title":"KeyedServiceResolutionAnalyzer","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/KeyedServiceResolutionAnalyzer/#nexuslabsneedlranalyzers","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/KeyedServiceResolutionAnalyzer/#nexuslabsneedlranalyzers_1","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/KeyedServiceResolutionAnalyzer/#keyedserviceresolutionanalyzer-class","title":"KeyedServiceResolutionAnalyzer Class","text":"<p>Analyzer that validates [FromKeyedServices] usage against discovered [Keyed] registrations. Reports Info-level diagnostic when a key is not found in statically-discovered registrations. Only active when [assembly: GenerateTypeRegistry] is present.</p> <pre><code>public sealed class KeyedServiceResolutionAnalyzer\n</code></pre> <p>Inheritance Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer \ud83e\udc52 KeyedServiceResolutionAnalyzer</p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/KeyedServiceResolutionAnalyzer/#remarks","title":"Remarks","text":"<p>This analyzer collects all [Keyed(\"key\")] attributes from types in the compilation and validates that [FromKeyedServices(\"key\")] parameters reference known keys.</p> <p>Keys registered via plugins at runtime cannot be validated at compile time. Users can suppress this diagnostic for such cases.</p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/LazyResolutionAnalyzer/","title":"LazyResolutionAnalyzer","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/LazyResolutionAnalyzer/#nexuslabsneedlranalyzers","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/LazyResolutionAnalyzer/#nexuslabsneedlranalyzers_1","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/LazyResolutionAnalyzer/#lazyresolutionanalyzer-class","title":"LazyResolutionAnalyzer Class","text":"<p>Analyzer that detects Lazy\\&lt;T&gt; dependencies where T is not discovered by source generation. Only active when [assembly: GenerateTypeRegistry] is present.</p> <pre><code>public sealed class LazyResolutionAnalyzer\n</code></pre> <p>Inheritance Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer \ud83e\udc52 LazyResolutionAnalyzer</p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/LifetimeMismatchAnalyzer/","title":"LifetimeMismatchAnalyzer","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/LifetimeMismatchAnalyzer/#nexuslabsneedlranalyzers","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/LifetimeMismatchAnalyzer/#nexuslabsneedlranalyzers_1","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/LifetimeMismatchAnalyzer/#lifetimemismatchanalyzer-class","title":"LifetimeMismatchAnalyzer Class","text":"<p>Analyzer that detects lifetime mismatches in service registrations. A lifetime mismatch occurs when a longer-lived service depends on a shorter-lived service.</p> <pre><code>public sealed class LifetimeMismatchAnalyzer\n</code></pre> <p>Inheritance Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer \ud83e\udc52 LifetimeMismatchAnalyzer</p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/LifetimeMismatchAnalyzer/#remarks","title":"Remarks","text":"<p>Examples of mismatches: - Singleton depends on Scoped \u2192 captive dependency - Singleton depends on Transient \u2192 captive dependency - Scoped depends on Transient \u2192 captive dependency</p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/NexusLabs.Needlr.Analyzers/","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/NexusLabs.Needlr.Analyzers/#nexuslabsneedlranalyzers","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/NexusLabs.Needlr.Analyzers/#nexuslabsneedlranalyzers-namespace","title":"NexusLabs.Needlr.Analyzers Namespace","text":"Classes CircularDependencyAnalyzer Analyzer that detects circular dependencies in service registrations. A circular dependency occurs when a service directly or indirectly depends on itself. CollectionResolutionAnalyzer Analyzer that detects IEnumerable\\&lt;T&gt; dependencies where no implementations of T are discovered by source generation. Only active when [assembly: GenerateTypeRegistry] is present. DeferToContainerInGeneratedCodeAnalyzer Analyzer that detects [DeferToContainer] attributes placed in generated code. DiagnosticDescriptors Contains diagnostic descriptors for all Needlr analyzers. DiagnosticIds Contains diagnostic IDs for all Needlr core analyzers. DisposableCaptiveDependencyAnalyzer Analyzer that detects when a longer-lived service holds a reference to a shorter-lived IDisposable. This is a more severe form of captive dependency because the disposed object will still be referenced. DoNotAutoRegisterOnPluginAnalyzer Analyzer that warns when [DoNotAutoRegister] is applied directly to a class that implements a Needlr plugin interface. GlobalNamespaceTypeAnalyzer Analyzer that detects injectable types in the global namespace that won't be discovered when IncludeNamespacePrefixes is set without an empty string. InterceptAttributeAnalyzer Analyzer that validates [Intercept] attribute usage: - NDLRCOR007: Intercept type must implement IMethodInterceptor - NDLRCOR008: [Intercept] applied to class without interfaces KeyedServiceResolutionAnalyzer Analyzer that validates [FromKeyedServices] usage against discovered [Keyed] registrations. Reports Info-level diagnostic when a key is not found in statically-discovered registrations. Only active when [assembly: GenerateTypeRegistry] is present. LazyResolutionAnalyzer Analyzer that detects Lazy\\&lt;T&gt; dependencies where T is not discovered by source generation. Only active when [assembly: GenerateTypeRegistry] is present. LifetimeMismatchAnalyzer Analyzer that detects lifetime mismatches in service registrations. A lifetime mismatch occurs when a longer-lived service depends on a shorter-lived service. PluginConstructorDependenciesAnalyzer Analyzer that detects plugin implementations with constructor dependencies. ReflectionInAotProjectAnalyzer Analyzer that detects reflection-based Needlr API usage in AOT-enabled projects. RegisterAsAttributeAnalyzer Analyzer that validates [RegisterAs\\&lt;T&gt;] attribute usage: - NDLRCOR015: Type argument T is not an interface implemented by the class"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/NexusLabs.Needlr.Roslyn.Shared/","title":"NexusLabs.Needlr.Roslyn.Shared","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/NexusLabs.Needlr.Roslyn.Shared/#nexuslabsneedlranalyzers","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/NexusLabs.Needlr.Roslyn.Shared/#nexuslabsneedlrroslynshared-namespace","title":"NexusLabs.Needlr.Roslyn.Shared Namespace","text":"Classes TypeDiscoveryHelper Shared helper utilities for discovering injectable types from Roslyn symbols. Used by both Generators and Analyzers to ensure consistent type discovery logic."},{"location":"api/dev/NexusLabs.Needlr.Analyzers/PluginConstructorDependenciesAnalyzer/","title":"PluginConstructorDependenciesAnalyzer","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/PluginConstructorDependenciesAnalyzer/#nexuslabsneedlranalyzers","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/PluginConstructorDependenciesAnalyzer/#nexuslabsneedlranalyzers_1","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/PluginConstructorDependenciesAnalyzer/#pluginconstructordependenciesanalyzer-class","title":"PluginConstructorDependenciesAnalyzer Class","text":"<p>Analyzer that detects plugin implementations with constructor dependencies.</p> <pre><code>public sealed class PluginConstructorDependenciesAnalyzer\n</code></pre> <p>Inheritance Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer \ud83e\udc52 PluginConstructorDependenciesAnalyzer</p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/ReflectionInAotProjectAnalyzer/","title":"ReflectionInAotProjectAnalyzer","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/ReflectionInAotProjectAnalyzer/#nexuslabsneedlranalyzers","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/ReflectionInAotProjectAnalyzer/#nexuslabsneedlranalyzers_1","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/ReflectionInAotProjectAnalyzer/#reflectioninaotprojectanalyzer-class","title":"ReflectionInAotProjectAnalyzer Class","text":"<p>Analyzer that detects reflection-based Needlr API usage in AOT-enabled projects.</p> <pre><code>public sealed class ReflectionInAotProjectAnalyzer\n</code></pre> <p>Inheritance Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer \ud83e\udc52 ReflectionInAotProjectAnalyzer</p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/RegisterAsAttributeAnalyzer/","title":"RegisterAsAttributeAnalyzer","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/RegisterAsAttributeAnalyzer/#nexuslabsneedlranalyzers","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/RegisterAsAttributeAnalyzer/#nexuslabsneedlranalyzers_1","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/RegisterAsAttributeAnalyzer/#registerasattributeanalyzer-class","title":"RegisterAsAttributeAnalyzer Class","text":"<p>Analyzer that validates [RegisterAs\\&lt;T&gt;] attribute usage: - NDLRCOR015: Type argument T is not an interface implemented by the class</p> <pre><code>public sealed class RegisterAsAttributeAnalyzer\n</code></pre> <p>Inheritance Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer \ud83e\udc52 RegisterAsAttributeAnalyzer</p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/TypeDiscoveryHelper/","title":"TypeDiscoveryHelper","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/TypeDiscoveryHelper/#nexuslabsneedlranalyzers","title":"NexusLabs.Needlr.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/TypeDiscoveryHelper/#nexuslabsneedlrroslynshared","title":"NexusLabs.Needlr.Roslyn.Shared","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/TypeDiscoveryHelper/#typediscoveryhelper-class","title":"TypeDiscoveryHelper Class","text":"<p>Shared helper utilities for discovering injectable types from Roslyn symbols. Used by both Generators and Analyzers to ensure consistent type discovery logic.</p> <pre><code>public static class TypeDiscoveryHelper\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 TypeDiscoveryHelper</p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/TypeDiscoveryHelper/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Analyzers/TypeDiscoveryHelper/#typediscoveryhelperhasdonotautoregisterattributeinamedtypesymbol-method","title":"TypeDiscoveryHelper.HasDoNotAutoRegisterAttribute(INamedTypeSymbol) Method","text":"<p>Checks if a type has the [DoNotAutoRegister] attribute (directly or on interfaces).</p> <pre><code>public static bool HasDoNotAutoRegisterAttribute(INamedTypeSymbol typeSymbol);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/TypeDiscoveryHelper/#parameters","title":"Parameters","text":"<p><code>typeSymbol</code> Microsoft.CodeAnalysis.INamedTypeSymbol</p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/TypeDiscoveryHelper/#returns","title":"Returns","text":"<p>System.Boolean</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/TypeDiscoveryHelper/#typediscoveryhelperhasdonotautoregisterattributedirectinamedtypesymbol-method","title":"TypeDiscoveryHelper.HasDoNotAutoRegisterAttributeDirect(INamedTypeSymbol) Method","text":"<p>Checks if a type has the [DoNotAutoRegister] or [DoNotInject] attribute directly applied.</p> <pre><code>public static bool HasDoNotAutoRegisterAttributeDirect(INamedTypeSymbol typeSymbol);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/TypeDiscoveryHelper/#parameters_1","title":"Parameters","text":"<p><code>typeSymbol</code> Microsoft.CodeAnalysis.INamedTypeSymbol</p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/TypeDiscoveryHelper/#returns_1","title":"Returns","text":"<p>System.Boolean</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/TypeDiscoveryHelper/#typediscoveryhelperhasunsatisfiedrequiredmembersinamedtypesymbol-method","title":"TypeDiscoveryHelper.HasUnsatisfiedRequiredMembers(INamedTypeSymbol) Method","text":"<p>Checks if a type has required members that aren't satisfied by any constructor with [SetsRequiredMembers] attribute.</p> <pre><code>public static bool HasUnsatisfiedRequiredMembers(INamedTypeSymbol typeSymbol);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/TypeDiscoveryHelper/#parameters_2","title":"Parameters","text":"<p><code>typeSymbol</code> Microsoft.CodeAnalysis.INamedTypeSymbol</p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/TypeDiscoveryHelper/#returns_2","title":"Returns","text":"<p>System.Boolean</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/TypeDiscoveryHelper/#typediscoveryhelperinheritsfrominamedtypesymbol-string-method","title":"TypeDiscoveryHelper.InheritsFrom(INamedTypeSymbol, string) Method","text":"<p>Checks if a type inherits from a base type by name.</p> <pre><code>public static bool InheritsFrom(INamedTypeSymbol typeSymbol, string baseTypeName);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/TypeDiscoveryHelper/#parameters_3","title":"Parameters","text":"<p><code>typeSymbol</code> Microsoft.CodeAnalysis.INamedTypeSymbol</p> <p></p> <p><code>baseTypeName</code> System.String</p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/TypeDiscoveryHelper/#returns_3","title":"Returns","text":"<p>System.Boolean</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/TypeDiscoveryHelper/#typediscoveryhelperisaccessiblefromgeneratedcodeinamedtypesymbol-bool-method","title":"TypeDiscoveryHelper.IsAccessibleFromGeneratedCode(INamedTypeSymbol, bool) Method","text":"<p>Checks if a type is accessible from generated code. For types in the current assembly, internal and public types are accessible. For types in referenced assemblies, only public types are accessible.</p> <pre><code>public static bool IsAccessibleFromGeneratedCode(INamedTypeSymbol typeSymbol, bool isCurrentAssembly);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/TypeDiscoveryHelper/#parameters_4","title":"Parameters","text":"<p><code>typeSymbol</code> Microsoft.CodeAnalysis.INamedTypeSymbol</p> <p></p> <p><code>isCurrentAssembly</code> System.Boolean</p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/TypeDiscoveryHelper/#returns_4","title":"Returns","text":"<p>System.Boolean</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/TypeDiscoveryHelper/#typediscoveryhelperiscompilergeneratedinamedtypesymbol-method","title":"TypeDiscoveryHelper.IsCompilerGenerated(INamedTypeSymbol) Method","text":"<p>Checks if a type is compiler-generated.</p> <pre><code>public static bool IsCompilerGenerated(INamedTypeSymbol typeSymbol);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/TypeDiscoveryHelper/#parameters_5","title":"Parameters","text":"<p><code>typeSymbol</code> Microsoft.CodeAnalysis.INamedTypeSymbol</p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/TypeDiscoveryHelper/#returns_5","title":"Returns","text":"<p>System.Boolean</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/TypeDiscoveryHelper/#typediscoveryhelperisinjectabletypeinamedtypesymbol-bool-method","title":"TypeDiscoveryHelper.IsInjectableType(INamedTypeSymbol, bool) Method","text":"<p>Determines whether a type symbol represents a concrete injectable type.</p> <pre><code>public static bool IsInjectableType(INamedTypeSymbol typeSymbol, bool isCurrentAssembly=false);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/TypeDiscoveryHelper/#parameters_6","title":"Parameters","text":"<p><code>typeSymbol</code> Microsoft.CodeAnalysis.INamedTypeSymbol</p> <p>The type symbol to check.</p> <p></p> <p><code>isCurrentAssembly</code> System.Boolean</p> <p>True if the type is from the current compilation's assembly (allows internal types).</p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/TypeDiscoveryHelper/#returns_6","title":"Returns","text":"<p>System.Boolean True if the type is a valid injectable type; otherwise, false.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/TypeDiscoveryHelper/#typediscoveryhelperissystemtypeinamedtypesymbol-method","title":"TypeDiscoveryHelper.IsSystemType(INamedTypeSymbol) Method","text":"<p>Checks if a type is from the System namespace or system assemblies.</p> <pre><code>public static bool IsSystemType(INamedTypeSymbol typeSymbol);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/TypeDiscoveryHelper/#parameters_7","title":"Parameters","text":"<p><code>typeSymbol</code> Microsoft.CodeAnalysis.INamedTypeSymbol</p>"},{"location":"api/dev/NexusLabs.Needlr.Analyzers/TypeDiscoveryHelper/#returns_7","title":"Returns","text":"<p>System.Boolean</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/","title":"Index","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/#nexuslabsneedlraspnet-namespace","title":"NexusLabs.Needlr.AspNet Namespace","text":"Classes CreateWebApplicationOptions Represents options for creating a web application with logging configuration. CreateWebApplicationOptionsExtensions Provides extension methods for configuring CreateWebApplicationOptions. IWebApplicationFactoryExtensions Extension methods for IWebApplicationFactory providing convenient overloads for creating web applications. ServiceCollectionBuilderExtensions Extension methods for NexusLabs.Needlr.Injection.IServiceProviderBuilder to build service providers without explicit configuration. SyringeAspNetExtensions Extension methods for configuring NexusLabs.Needlr.Injection.ConfiguredSyringe instances with ASP.NET Core functionality. WebApplicationBuilderPluginOptions Options provided to IWebApplicationBuilderPlugin implementations during configuration. Contains the web application builder, discovered assemblies, logger, and plugin factory. WebApplicationFactory Default implementation of IWebApplicationFactory that creates and configures ASP.NET Core web applications. Handles service registration, plugin execution, and the complete application build lifecycle. WebApplicationPluginOptions Options provided to IWebApplicationPlugin implementations during configuration. Contains the built web application, discovered assemblies, and plugin factory. WebApplicationSyringe Provides a fluent API for configuring and building web applications using Needlr. Wraps a ConfiguredSyringe with additional web application functionality. WebApplicationSyringeExtensions Extension methods for configuring WebApplicationSyringe instances. Provides only web application specific configuration methods. Interfaces IWebApplicationBuilderPlugin Defines a plugin that configures the Microsoft.AspNetCore.Builder.WebApplicationBuilder before the application is built. Implement this interface to add services, configure logging, or modify the builder during application startup. IWebApplicationFactory Factory interface for creating configured Microsoft.AspNetCore.Builder.WebApplication instances. Handles the full application lifecycle including service registration, plugin execution, and configuration. IWebApplicationPlugin Defines a plugin that configures the Microsoft.AspNetCore.Builder.WebApplication after it has been built. Implement this interface to add middleware, configure endpoints, or perform other post-build configuration."},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/","title":"CreateWebApplicationOptions","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#nexuslabsneedlraspnet","title":"NexusLabs.Needlr.AspNet","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#createwebapplicationoptions-class","title":"CreateWebApplicationOptions Class","text":"<p>Represents options for creating a web application with logging configuration.</p> <pre><code>public sealed record CreateWebApplicationOptions : System.IEquatable&lt;NexusLabs.Needlr.AspNet.CreateWebApplicationOptions&gt;\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 CreateWebApplicationOptions</p> <p>Implements System.IEquatable&lt;CreateWebApplicationOptions&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#createwebapplicationoptionswebapplicationoptions-constructor","title":"CreateWebApplicationOptions(WebApplicationOptions) Constructor","text":"<p>Initializes a new instance of the CreateWebApplicationOptions  record with a Microsoft.Extensions.Logging.Abstractions.NullLogger.</p> <pre><code>public CreateWebApplicationOptions(Microsoft.AspNetCore.Builder.WebApplicationOptions options);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#parameters","title":"Parameters","text":"<p><code>options</code> Microsoft.AspNetCore.Builder.WebApplicationOptions</p> <p>The web application options to use.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#exceptions","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when options is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#createwebapplicationoptionswebapplicationoptions-ilogger-constructor","title":"CreateWebApplicationOptions(WebApplicationOptions, ILogger) Constructor","text":"<p>Initializes a new instance of the CreateWebApplicationOptions  record with a Microsoft.Extensions.Logging.Abstractions.NullLogger.</p> <pre><code>public CreateWebApplicationOptions(Microsoft.AspNetCore.Builder.WebApplicationOptions options, Microsoft.Extensions.Logging.ILogger logger);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#parameters_1","title":"Parameters","text":"<p><code>options</code> Microsoft.AspNetCore.Builder.WebApplicationOptions</p> <p>The web application options to use.</p> <p></p> <p><code>logger</code> Microsoft.Extensions.Logging.ILogger</p> <p>The logger instance to use for logging during application creation.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#exceptions_1","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when options or logger is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#createwebapplicationoptionswebapplicationoptions-actioniservicecollection-constructor","title":"CreateWebApplicationOptions(WebApplicationOptions, Action&lt;IServiceCollection&gt;) Constructor","text":"<p>Initializes a new instance of the CreateWebApplicationOptions  record with a Microsoft.Extensions.Logging.Abstractions.NullLogger.</p> <pre><code>public CreateWebApplicationOptions(Microsoft.AspNetCore.Builder.WebApplicationOptions options, System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt; postPluginRegistrationCallback);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#parameters_2","title":"Parameters","text":"<p><code>options</code> Microsoft.AspNetCore.Builder.WebApplicationOptions</p> <p>The web application options to use.</p> <p></p> <p><code>postPluginRegistrationCallback</code> System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;</p> <p>The callback to execute after plugin registration, allowing for additional service configuration.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#exceptions_2","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when options, or postPluginRegistrationCallback is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#createwebapplicationoptionswebapplicationoptions-actioniservicecollection-ilogger-constructor","title":"CreateWebApplicationOptions(WebApplicationOptions, Action&lt;IServiceCollection&gt;, ILogger) Constructor","text":"<p>Initializes a new instance of the CreateWebApplicationOptions  record with a Microsoft.Extensions.Logging.Abstractions.NullLogger.</p> <pre><code>public CreateWebApplicationOptions(Microsoft.AspNetCore.Builder.WebApplicationOptions options, System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt; postPluginRegistrationCallback, Microsoft.Extensions.Logging.ILogger logger);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#parameters_3","title":"Parameters","text":"<p><code>options</code> Microsoft.AspNetCore.Builder.WebApplicationOptions</p> <p>The web application options to use.</p> <p></p> <p><code>postPluginRegistrationCallback</code> System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;</p> <p>The callback to execute after plugin registration, allowing for additional service configuration.</p> <p></p> <p><code>logger</code> Microsoft.Extensions.Logging.ILogger</p> <p>The logger instance to use for logging during application creation.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#exceptions_3","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when options, postPluginRegistrationCallback,  or logger is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#createwebapplicationoptionswebapplicationoptions-ienumerableactioniservicecollection-constructor","title":"CreateWebApplicationOptions(WebApplicationOptions, IEnumerable&lt;Action&lt;IServiceCollection&gt;&gt;) Constructor","text":"<p>Initializes a new instance with pre-plugin registration callbacks.</p> <pre><code>public CreateWebApplicationOptions(Microsoft.AspNetCore.Builder.WebApplicationOptions options, System.Collections.Generic.IEnumerable&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; prePluginRegistrationCallbacks);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#parameters_4","title":"Parameters","text":"<p><code>options</code> Microsoft.AspNetCore.Builder.WebApplicationOptions</p> <p>The web application options to use.</p> <p></p> <p><code>prePluginRegistrationCallbacks</code> System.Collections.Generic.IEnumerable&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p>Callbacks to execute before plugin registration.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#exceptions_4","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when options or prePluginRegistrationCallbacks is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#createwebapplicationoptionswebapplicationoptions-ienumerableactioniservicecollection-ilogger-constructor","title":"CreateWebApplicationOptions(WebApplicationOptions, IEnumerable&lt;Action&lt;IServiceCollection&gt;&gt;, ILogger) Constructor","text":"<p>Initializes a new instance with pre-plugin registration callbacks and logger.</p> <pre><code>public CreateWebApplicationOptions(Microsoft.AspNetCore.Builder.WebApplicationOptions options, System.Collections.Generic.IEnumerable&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; prePluginRegistrationCallbacks, Microsoft.Extensions.Logging.ILogger logger);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#parameters_5","title":"Parameters","text":"<p><code>options</code> Microsoft.AspNetCore.Builder.WebApplicationOptions</p> <p>The web application options to use.</p> <p></p> <p><code>prePluginRegistrationCallbacks</code> System.Collections.Generic.IEnumerable&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p>Callbacks to execute before plugin registration.</p> <p></p> <p><code>logger</code> Microsoft.Extensions.Logging.ILogger</p> <p>The logger instance to use for logging during application creation.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#exceptions_5","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when a parameter is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#createwebapplicationoptionswebapplicationoptions-ienumerableactioniservicecollection-ienumerableactioniservicecollection-constructor","title":"CreateWebApplicationOptions(WebApplicationOptions, IEnumerable&lt;Action&lt;IServiceCollection&gt;&gt;, IEnumerable&lt;Action&lt;IServiceCollection&gt;&gt;) Constructor","text":"<p>Initializes a new instance with pre- and post-plugin registration callbacks.</p> <pre><code>public CreateWebApplicationOptions(Microsoft.AspNetCore.Builder.WebApplicationOptions options, System.Collections.Generic.IEnumerable&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; prePluginRegistrationCallbacks, System.Collections.Generic.IEnumerable&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; postPluginRegistrationCallbacks);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#parameters_6","title":"Parameters","text":"<p><code>options</code> Microsoft.AspNetCore.Builder.WebApplicationOptions</p> <p>The web application options to use.</p> <p></p> <p><code>prePluginRegistrationCallbacks</code> System.Collections.Generic.IEnumerable&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p>Callbacks to execute before plugin registration.</p> <p></p> <p><code>postPluginRegistrationCallbacks</code> System.Collections.Generic.IEnumerable&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p>Callbacks to execute after plugin registration.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#exceptions_6","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when a parameter is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#createwebapplicationoptionswebapplicationoptions-ienumerableactioniservicecollection-ienumerableactioniservicecollection-ilogger-constructor","title":"CreateWebApplicationOptions(WebApplicationOptions, IEnumerable&lt;Action&lt;IServiceCollection&gt;&gt;, IEnumerable&lt;Action&lt;IServiceCollection&gt;&gt;, ILogger) Constructor","text":"<p>Initializes a new instance with pre- and post-plugin registration callbacks and logger.</p> <pre><code>public CreateWebApplicationOptions(Microsoft.AspNetCore.Builder.WebApplicationOptions options, System.Collections.Generic.IEnumerable&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; prePluginRegistrationCallbacks, System.Collections.Generic.IEnumerable&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; postPluginRegistrationCallbacks, Microsoft.Extensions.Logging.ILogger logger);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#parameters_7","title":"Parameters","text":"<p><code>options</code> Microsoft.AspNetCore.Builder.WebApplicationOptions</p> <p>The web application options to use.</p> <p></p> <p><code>prePluginRegistrationCallbacks</code> System.Collections.Generic.IEnumerable&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p>Callbacks to execute before plugin registration.</p> <p></p> <p><code>postPluginRegistrationCallbacks</code> System.Collections.Generic.IEnumerable&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p>Callbacks to execute after plugin registration.</p> <p></p> <p><code>logger</code> Microsoft.Extensions.Logging.ILogger</p> <p>The logger instance to use for logging during application creation.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#exceptions_7","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when a parameter is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#createwebapplicationoptionswebapplicationoptions-ireadonlylistactioniservicecollection-ilogger-constructor","title":"CreateWebApplicationOptions(WebApplicationOptions, IReadOnlyList&lt;Action&lt;IServiceCollection&gt;&gt;, ILogger) Constructor","text":"<p>Represents options for creating a web application with logging configuration.</p> <pre><code>public CreateWebApplicationOptions(Microsoft.AspNetCore.Builder.WebApplicationOptions Options, System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; PostPluginRegistrationCallbacks, Microsoft.Extensions.Logging.ILogger Logger);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#parameters_8","title":"Parameters","text":"<p><code>Options</code> Microsoft.AspNetCore.Builder.WebApplicationOptions</p> <p>The web application options to use when creating the application.</p> <p></p> <p><code>PostPluginRegistrationCallbacks</code> System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p>The callbacks to execute after plugin registration, allowing for additional service configuration.</p> <p></p> <p><code>Logger</code> Microsoft.Extensions.Logging.ILogger</p> <p>The logger instance to use for logging during application creation.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#createwebapplicationoptionsdefault-property","title":"CreateWebApplicationOptions.Default Property","text":"<p>Gets the default instance of CreateWebApplicationOptions with empty  Microsoft.AspNetCore.Builder.WebApplicationOptions and a Microsoft.Extensions.Logging.Abstractions.NullLogger.</p> <pre><code>public static NexusLabs.Needlr.AspNet.CreateWebApplicationOptions Default { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#property-value","title":"Property Value","text":"<p>CreateWebApplicationOptions</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#createwebapplicationoptionslogger-property","title":"CreateWebApplicationOptions.Logger Property","text":"<p>The logger instance to use for logging during application creation.</p> <pre><code>public Microsoft.Extensions.Logging.ILogger Logger { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#property-value_1","title":"Property Value","text":"<p>Microsoft.Extensions.Logging.ILogger</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#createwebapplicationoptionsoptions-property","title":"CreateWebApplicationOptions.Options Property","text":"<p>The web application options to use when creating the application.</p> <pre><code>public Microsoft.AspNetCore.Builder.WebApplicationOptions Options { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#property-value_2","title":"Property Value","text":"<p>Microsoft.AspNetCore.Builder.WebApplicationOptions</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#createwebapplicationoptionspostpluginregistrationcallbacks-property","title":"CreateWebApplicationOptions.PostPluginRegistrationCallbacks Property","text":"<p>The callbacks to execute after plugin registration, allowing for additional service configuration.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; PostPluginRegistrationCallbacks { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#property-value_3","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#createwebapplicationoptionsprepluginregistrationcallbacks-property","title":"CreateWebApplicationOptions.PrePluginRegistrationCallbacks Property","text":"<p>Callbacks to execute before plugin registration to allow configuring the service collection.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; PrePluginRegistrationCallbacks { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptions/#property-value_4","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/","title":"CreateWebApplicationOptionsExtensions","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#nexuslabsneedlraspnet","title":"NexusLabs.Needlr.AspNet","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#createwebapplicationoptionsextensions-class","title":"CreateWebApplicationOptionsExtensions Class","text":"<p>Provides extension methods for configuring CreateWebApplicationOptions.</p> <pre><code>public static class CreateWebApplicationOptionsExtensions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 CreateWebApplicationOptionsExtensions</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#createwebapplicationoptionsextensionsusingapplicationnamethis-createwebapplicationoptions-string-method","title":"CreateWebApplicationOptionsExtensions.UsingApplicationName(this CreateWebApplicationOptions, string) Method","text":"<p>Configures the options to use the specified application name.</p> <pre><code>public static NexusLabs.Needlr.AspNet.CreateWebApplicationOptions UsingApplicationName(this NexusLabs.Needlr.AspNet.CreateWebApplicationOptions options, string applicationName);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#parameters","title":"Parameters","text":"<p><code>options</code> CreateWebApplicationOptions</p> <p>The options to configure.</p> <p></p> <p><code>applicationName</code> System.String</p> <p>The application name to use.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#returns","title":"Returns","text":"<p>CreateWebApplicationOptions A new instance of CreateWebApplicationOptions with the application name configured.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#exceptions","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when options or applicationName is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#createwebapplicationoptionsextensionsusingcliargsthis-createwebapplicationoptions-string-method","title":"CreateWebApplicationOptionsExtensions.UsingCliArgs(this CreateWebApplicationOptions, string[]) Method","text":"<p>Configures the options to use the specified command line arguments.</p> <pre><code>public static NexusLabs.Needlr.AspNet.CreateWebApplicationOptions UsingCliArgs(this NexusLabs.Needlr.AspNet.CreateWebApplicationOptions options, string[] args);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#parameters_1","title":"Parameters","text":"<p><code>options</code> CreateWebApplicationOptions</p> <p>The options to configure.</p> <p></p> <p><code>args</code> System.String[]</p> <p>The command line arguments to use.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#returns_1","title":"Returns","text":"<p>CreateWebApplicationOptions A new instance of CreateWebApplicationOptions with the command line arguments configured.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#exceptions_1","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when options or args is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#createwebapplicationoptionsextensionsusingpostpluginregistrationcallbackthis-createwebapplicationoptions-actioniservicecollection-method","title":"CreateWebApplicationOptionsExtensions.UsingPostPluginRegistrationCallback(this CreateWebApplicationOptions, Action&lt;IServiceCollection&gt;) Method","text":"<p>Adds a post-plugin registration callback to the options.</p> <pre><code>public static NexusLabs.Needlr.AspNet.CreateWebApplicationOptions UsingPostPluginRegistrationCallback(this NexusLabs.Needlr.AspNet.CreateWebApplicationOptions options, System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt; callback);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#parameters_2","title":"Parameters","text":"<p><code>options</code> CreateWebApplicationOptions</p> <p>The options to configure.</p> <p></p> <p><code>callback</code> System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;</p> <p>The callback to add for post-plugin registration.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#returns_2","title":"Returns","text":"<p>CreateWebApplicationOptions A new instance of CreateWebApplicationOptions with the callback added.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#exceptions_2","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when options or callback is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#createwebapplicationoptionsextensionsusingpostpluginregistrationcallbacksthis-createwebapplicationoptions-actioniservicecollection-method","title":"CreateWebApplicationOptionsExtensions.UsingPostPluginRegistrationCallbacks(this CreateWebApplicationOptions, Action&lt;IServiceCollection&gt;[]) Method","text":"<p>Adds multiple post-plugin registration callbacks to the options.</p> <pre><code>public static NexusLabs.Needlr.AspNet.CreateWebApplicationOptions UsingPostPluginRegistrationCallbacks(this NexusLabs.Needlr.AspNet.CreateWebApplicationOptions options, params System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;[] callbacks);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#parameters_3","title":"Parameters","text":"<p><code>options</code> CreateWebApplicationOptions</p> <p>The options to configure.</p> <p></p> <p><code>callbacks</code> System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;[]</p> <p>The callbacks to add for post-plugin registration.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#returns_3","title":"Returns","text":"<p>CreateWebApplicationOptions A new instance of CreateWebApplicationOptions with the callbacks added.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#exceptions_3","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when options or callbacks is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#createwebapplicationoptionsextensionsusingpostpluginregistrationcallbacksthis-createwebapplicationoptions-ienumerableactioniservicecollection-method","title":"CreateWebApplicationOptionsExtensions.UsingPostPluginRegistrationCallbacks(this CreateWebApplicationOptions, IEnumerable&lt;Action&lt;IServiceCollection&gt;&gt;) Method","text":"<p>Adds multiple post-plugin registration callbacks to the options.</p> <pre><code>public static NexusLabs.Needlr.AspNet.CreateWebApplicationOptions UsingPostPluginRegistrationCallbacks(this NexusLabs.Needlr.AspNet.CreateWebApplicationOptions options, System.Collections.Generic.IEnumerable&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; callbacks);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#parameters_4","title":"Parameters","text":"<p><code>options</code> CreateWebApplicationOptions</p> <p>The options to configure.</p> <p></p> <p><code>callbacks</code> System.Collections.Generic.IEnumerable&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p>The callbacks to add for post-plugin registration.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#returns_4","title":"Returns","text":"<p>CreateWebApplicationOptions A new instance of CreateWebApplicationOptions with the callbacks added.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#exceptions_4","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when options or callbacks is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#createwebapplicationoptionsextensionsusingprepluginregistrationcallbackthis-createwebapplicationoptions-actioniservicecollection-method","title":"CreateWebApplicationOptionsExtensions.UsingPrePluginRegistrationCallback(this CreateWebApplicationOptions, Action&lt;IServiceCollection&gt;) Method","text":"<p>Adds a pre-plugin registration callback to the options.</p> <pre><code>public static NexusLabs.Needlr.AspNet.CreateWebApplicationOptions UsingPrePluginRegistrationCallback(this NexusLabs.Needlr.AspNet.CreateWebApplicationOptions options, System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt; callback);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#parameters_5","title":"Parameters","text":"<p><code>options</code> CreateWebApplicationOptions</p> <p>The options to configure.</p> <p></p> <p><code>callback</code> System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;</p> <p>The callback to add for pre-plugin registration.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#returns_5","title":"Returns","text":"<p>CreateWebApplicationOptions A new instance of CreateWebApplicationOptions with the callback added.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#exceptions_5","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when options or callback is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#createwebapplicationoptionsextensionsusingprepluginregistrationcallbacksthis-createwebapplicationoptions-actioniservicecollection-method","title":"CreateWebApplicationOptionsExtensions.UsingPrePluginRegistrationCallbacks(this CreateWebApplicationOptions, Action&lt;IServiceCollection&gt;[]) Method","text":"<p>Adds multiple pre-plugin registration callbacks to the options.</p> <pre><code>public static NexusLabs.Needlr.AspNet.CreateWebApplicationOptions UsingPrePluginRegistrationCallbacks(this NexusLabs.Needlr.AspNet.CreateWebApplicationOptions options, params System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;[] callbacks);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#parameters_6","title":"Parameters","text":"<p><code>options</code> CreateWebApplicationOptions</p> <p>The options to configure.</p> <p></p> <p><code>callbacks</code> System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;[]</p> <p>The callbacks to add for pre-plugin registration.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#returns_6","title":"Returns","text":"<p>CreateWebApplicationOptions A new instance of CreateWebApplicationOptions with the callbacks added.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#exceptions_6","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when options or callbacks is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#createwebapplicationoptionsextensionsusingprepluginregistrationcallbacksthis-createwebapplicationoptions-ienumerableactioniservicecollection-method","title":"CreateWebApplicationOptionsExtensions.UsingPrePluginRegistrationCallbacks(this CreateWebApplicationOptions, IEnumerable&lt;Action&lt;IServiceCollection&gt;&gt;) Method","text":"<p>Adds multiple pre-plugin registration callbacks to the options.</p> <pre><code>public static NexusLabs.Needlr.AspNet.CreateWebApplicationOptions UsingPrePluginRegistrationCallbacks(this NexusLabs.Needlr.AspNet.CreateWebApplicationOptions options, System.Collections.Generic.IEnumerable&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; callbacks);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#parameters_7","title":"Parameters","text":"<p><code>options</code> CreateWebApplicationOptions</p> <p>The options to configure.</p> <p></p> <p><code>callbacks</code> System.Collections.Generic.IEnumerable&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p>The callbacks to add for pre-plugin registration.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#returns_7","title":"Returns","text":"<p>CreateWebApplicationOptions A new instance of CreateWebApplicationOptions with the callbacks added.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#exceptions_7","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when options or callbacks is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#createwebapplicationoptionsextensionsusingstartupconsoleloggerthis-createwebapplicationoptions-string-loglevel-method","title":"CreateWebApplicationOptionsExtensions.UsingStartupConsoleLogger(this CreateWebApplicationOptions, string, LogLevel) Method","text":"<p>Configures the options to use a console logger for startup logging.</p> <pre><code>public static NexusLabs.Needlr.AspNet.CreateWebApplicationOptions UsingStartupConsoleLogger(this NexusLabs.Needlr.AspNet.CreateWebApplicationOptions options, string name=\"Startup\", Microsoft.Extensions.Logging.LogLevel level=Microsoft.Extensions.Logging.LogLevel.Debug);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#parameters_8","title":"Parameters","text":"<p><code>options</code> CreateWebApplicationOptions</p> <p>The options to configure.</p> <p></p> <p><code>name</code> System.String</p> <p>The name of the logger. Defaults to \"Startup\".</p> <p></p> <p><code>level</code> Microsoft.Extensions.Logging.LogLevel</p> <p>The minimum log level. Defaults to Microsoft.Extensions.Logging.LogLevel.Debug.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#returns_8","title":"Returns","text":"<p>CreateWebApplicationOptions A new instance of CreateWebApplicationOptions with the console logger configured.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/CreateWebApplicationOptionsExtensions/#exceptions_8","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when options is null.</p> <p>System.ArgumentException Thrown when name is null or whitespace.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/IWebApplicationBuilderPlugin/","title":"IWebApplicationBuilderPlugin","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/IWebApplicationBuilderPlugin/#nexuslabsneedlraspnet","title":"NexusLabs.Needlr.AspNet","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/IWebApplicationBuilderPlugin/#iwebapplicationbuilderplugin-interface","title":"IWebApplicationBuilderPlugin Interface","text":"<p>Defines a plugin that configures the Microsoft.AspNetCore.Builder.WebApplicationBuilder before the application is built. Implement this interface to add services, configure logging, or modify the builder during application startup.</p> <pre><code>public interface IWebApplicationBuilderPlugin\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/IWebApplicationBuilderPlugin/#remarks","title":"Remarks","text":"<p>Do not apply NexusLabs.Needlr.DoNotAutoRegisterAttribute directly to an implementing class. This interface already carries the attribute to prevent DI registration of the interface itself; adding it to the class too is redundant and was historically a silent bug that suppressed plugin discovery. Analyzer NDLRCOR016 will warn you if you do this.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/IWebApplicationFactory/","title":"IWebApplicationFactory","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/IWebApplicationFactory/#nexuslabsneedlraspnet","title":"NexusLabs.Needlr.AspNet","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/IWebApplicationFactory/#iwebapplicationfactory-interface","title":"IWebApplicationFactory Interface","text":"<p>Factory interface for creating configured Microsoft.AspNetCore.Builder.WebApplication instances. Handles the full application lifecycle including service registration, plugin execution, and configuration.</p> <pre><code>public interface IWebApplicationFactory\n</code></pre> <p>Derived \u21b3 WebApplicationFactory</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/IWebApplicationFactoryExtensions/","title":"IWebApplicationFactoryExtensions","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/IWebApplicationFactoryExtensions/#nexuslabsneedlraspnet","title":"NexusLabs.Needlr.AspNet","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/IWebApplicationFactoryExtensions/#iwebapplicationfactoryextensions-class","title":"IWebApplicationFactoryExtensions Class","text":"<p>Extension methods for IWebApplicationFactory providing convenient overloads for creating web applications.</p> <pre><code>public static class IWebApplicationFactoryExtensions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 IWebApplicationFactoryExtensions</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/IWebApplicationFactoryExtensions/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/IWebApplicationFactoryExtensions/#iwebapplicationfactoryextensionscreatethis-iwebapplicationfactory-createwebapplicationoptions-method","title":"IWebApplicationFactoryExtensions.Create(this IWebApplicationFactory, CreateWebApplicationOptions) Method","text":"<p>Creates a web application using the specified options with default configuration.</p> <pre><code>public static Microsoft.AspNetCore.Builder.WebApplication Create(this NexusLabs.Needlr.AspNet.IWebApplicationFactory factory, NexusLabs.Needlr.AspNet.CreateWebApplicationOptions options);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/IWebApplicationFactoryExtensions/#parameters","title":"Parameters","text":"<p><code>factory</code> IWebApplicationFactory</p> <p>The web application factory.</p> <p></p> <p><code>options</code> CreateWebApplicationOptions</p> <p>The options for creating the web application.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/IWebApplicationFactoryExtensions/#returns","title":"Returns","text":"<p>Microsoft.AspNetCore.Builder.WebApplication A configured Microsoft.AspNetCore.Builder.WebApplication.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/IWebApplicationFactoryExtensions/#iwebapplicationfactoryextensionscreatethis-iwebapplicationfactory-createwebapplicationoptions-actionwebapplicationbuildercreatewebapplicationoptions-method","title":"IWebApplicationFactoryExtensions.Create(this IWebApplicationFactory, CreateWebApplicationOptions, Action&lt;WebApplicationBuilder,CreateWebApplicationOptions&gt;) Method","text":"<p>Creates a web application using the specified options and a configuration callback.</p> <pre><code>public static Microsoft.AspNetCore.Builder.WebApplication Create(this NexusLabs.Needlr.AspNet.IWebApplicationFactory factory, NexusLabs.Needlr.AspNet.CreateWebApplicationOptions options, System.Action&lt;Microsoft.AspNetCore.Builder.WebApplicationBuilder,NexusLabs.Needlr.AspNet.CreateWebApplicationOptions&gt;? configureCallback);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/IWebApplicationFactoryExtensions/#parameters_1","title":"Parameters","text":"<p><code>factory</code> IWebApplicationFactory</p> <p>The web application factory.</p> <p></p> <p><code>options</code> CreateWebApplicationOptions</p> <p>The options for creating the web application.</p> <p></p> <p><code>configureCallback</code> System.Action&lt;Microsoft.AspNetCore.Builder.WebApplicationBuilder,CreateWebApplicationOptions&gt;</p> <p>Optional callback to configure the web application builder.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/IWebApplicationFactoryExtensions/#returns_1","title":"Returns","text":"<p>Microsoft.AspNetCore.Builder.WebApplication A configured Microsoft.AspNetCore.Builder.WebApplication.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/IWebApplicationPlugin/","title":"IWebApplicationPlugin","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/IWebApplicationPlugin/#nexuslabsneedlraspnet","title":"NexusLabs.Needlr.AspNet","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/IWebApplicationPlugin/#iwebapplicationplugin-interface","title":"IWebApplicationPlugin Interface","text":"<p>Defines a plugin that configures the Microsoft.AspNetCore.Builder.WebApplication after it has been built. Implement this interface to add middleware, configure endpoints, or perform other post-build configuration.</p> <pre><code>public interface IWebApplicationPlugin\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/IWebApplicationPlugin/#remarks","title":"Remarks","text":"<p>Do not apply NexusLabs.Needlr.DoNotAutoRegisterAttribute directly to an implementing class. This interface already carries the attribute to prevent DI registration of the interface itself; adding it to the class too is redundant and was historically a silent bug that suppressed plugin discovery. Analyzer NDLRCOR016 will warn you if you do this.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/NexusLabs.Needlr.AspNet/","title":"NexusLabs.Needlr.AspNet","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/NexusLabs.Needlr.AspNet/#nexuslabsneedlraspnet-namespace","title":"NexusLabs.Needlr.AspNet Namespace","text":"Classes CreateWebApplicationOptions Represents options for creating a web application with logging configuration. CreateWebApplicationOptionsExtensions Provides extension methods for configuring CreateWebApplicationOptions. IWebApplicationFactoryExtensions Extension methods for IWebApplicationFactory providing convenient overloads for creating web applications. ServiceCollectionBuilderExtensions Extension methods for NexusLabs.Needlr.Injection.IServiceProviderBuilder to build service providers without explicit configuration. SyringeAspNetExtensions Extension methods for configuring NexusLabs.Needlr.Injection.ConfiguredSyringe instances with ASP.NET Core functionality. WebApplicationBuilderPluginOptions Options provided to IWebApplicationBuilderPlugin implementations during configuration. Contains the web application builder, discovered assemblies, logger, and plugin factory. WebApplicationFactory Default implementation of IWebApplicationFactory that creates and configures ASP.NET Core web applications. Handles service registration, plugin execution, and the complete application build lifecycle. WebApplicationPluginOptions Options provided to IWebApplicationPlugin implementations during configuration. Contains the built web application, discovered assemblies, and plugin factory. WebApplicationSyringe Provides a fluent API for configuring and building web applications using Needlr. Wraps a ConfiguredSyringe with additional web application functionality. WebApplicationSyringeExtensions Extension methods for configuring WebApplicationSyringe instances. Provides only web application specific configuration methods. Interfaces IWebApplicationBuilderPlugin Defines a plugin that configures the Microsoft.AspNetCore.Builder.WebApplicationBuilder before the application is built. Implement this interface to add services, configure logging, or modify the builder during application startup. IWebApplicationFactory Factory interface for creating configured Microsoft.AspNetCore.Builder.WebApplication instances. Handles the full application lifecycle including service registration, plugin execution, and configuration. IWebApplicationPlugin Defines a plugin that configures the Microsoft.AspNetCore.Builder.WebApplication after it has been built. Implement this interface to add middleware, configure endpoints, or perform other post-build configuration."},{"location":"api/dev/NexusLabs.Needlr.AspNet/ServiceCollectionBuilderExtensions/","title":"ServiceCollectionBuilderExtensions","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/ServiceCollectionBuilderExtensions/#nexuslabsneedlraspnet","title":"NexusLabs.Needlr.AspNet","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/ServiceCollectionBuilderExtensions/#servicecollectionbuilderextensions-class","title":"ServiceCollectionBuilderExtensions Class","text":"<p>Extension methods for NexusLabs.Needlr.Injection.IServiceProviderBuilder to build service providers without explicit configuration.</p> <pre><code>public static class ServiceCollectionBuilderExtensions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 ServiceCollectionBuilderExtensions</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/ServiceCollectionBuilderExtensions/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/ServiceCollectionBuilderExtensions/#servicecollectionbuilderextensionsbuildthis-iserviceproviderbuilder-method","title":"ServiceCollectionBuilderExtensions.Build(this IServiceProviderBuilder) Method","text":"<p>Builds a service provider using a default empty configuration.</p> <pre><code>public static System.IServiceProvider Build(this NexusLabs.Needlr.Injection.IServiceProviderBuilder builder);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/ServiceCollectionBuilderExtensions/#parameters","title":"Parameters","text":"<p><code>builder</code> NexusLabs.Needlr.Injection.IServiceProviderBuilder</p> <p>The service provider builder.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/ServiceCollectionBuilderExtensions/#returns","title":"Returns","text":"<p>System.IServiceProvider The built service provider.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/SyringeAspNetExtensions/","title":"SyringeAspNetExtensions","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/SyringeAspNetExtensions/#nexuslabsneedlraspnet","title":"NexusLabs.Needlr.AspNet","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/SyringeAspNetExtensions/#syringeaspnetextensions-class","title":"SyringeAspNetExtensions Class","text":"<p>Extension methods for configuring NexusLabs.Needlr.Injection.ConfiguredSyringe instances with ASP.NET Core functionality.</p> <pre><code>public static class SyringeAspNetExtensions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 SyringeAspNetExtensions</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/SyringeAspNetExtensions/#example","title":"Example","text":"<p>Source-gen first (recommended for AOT/trimming):</p> <pre><code>// With module initializer bootstrap (automatic):\nvar webApplication = new Syringe()\n    .UsingSourceGen()\n    .ForWebApplication()\n    .BuildWebApplication();\n\nawait webApplication.RunAsync();\n</code></pre> <p>Reflection-based (for dynamic scenarios):</p> <pre><code>var webApplication = new Syringe()\n    .UsingReflection()\n    .ForWebApplication()\n    .BuildWebApplication();\n\nawait webApplication.RunAsync();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/SyringeAspNetExtensions/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/SyringeAspNetExtensions/#syringeaspnetextensionsbuildwebapplicationthis-configuredsyringe-method","title":"SyringeAspNetExtensions.BuildWebApplication(this ConfiguredSyringe) Method","text":"<p>Builds a web application with the configured settings using the default WebApplicationFactory.</p> <pre><code>public static Microsoft.AspNetCore.Builder.WebApplication BuildWebApplication(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/SyringeAspNetExtensions/#parameters","title":"Parameters","text":"<p><code>syringe</code> NexusLabs.Needlr.Injection.ConfiguredSyringe</p> <p>The configured syringe to build from.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/SyringeAspNetExtensions/#returns","title":"Returns","text":"<p>Microsoft.AspNetCore.Builder.WebApplication The configured Microsoft.AspNetCore.Builder.WebApplication.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/SyringeAspNetExtensions/#example_1","title":"Example","text":"<pre><code>// Direct build without additional web configuration\nvar webApplication = new Syringe()\n    .UsingReflection()\n    .BuildWebApplication();\n\nawait webApplication.RunAsync();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/SyringeAspNetExtensions/#syringeaspnetextensionsforwebapplicationthis-configuredsyringe-method","title":"SyringeAspNetExtensions.ForWebApplication(this ConfiguredSyringe) Method","text":"<p>Transitions the configured syringe to web application mode, enabling web-specific configuration.</p> <pre><code>public static NexusLabs.Needlr.AspNet.WebApplicationSyringe ForWebApplication(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/SyringeAspNetExtensions/#parameters_1","title":"Parameters","text":"<p><code>syringe</code> NexusLabs.Needlr.Injection.ConfiguredSyringe</p> <p>The configured syringe to transition.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/SyringeAspNetExtensions/#returns_1","title":"Returns","text":"<p>WebApplicationSyringe A new web application syringe instance.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/SyringeAspNetExtensions/#example_2","title":"Example","text":"<pre><code>var webAppSyringe = new Syringe()\n    .UsingReflection()\n    .ForWebApplication(); // Transition to web application mode\n\n// Now you can use web-specific methods\nvar webApp = webAppSyringe\n    .UsingOptions(() =&gt; CreateWebApplicationOptions.Default.UsingCliArgs(args))\n    .BuildWebApplication();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationBuilderPluginOptions/","title":"WebApplicationBuilderPluginOptions","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationBuilderPluginOptions/#nexuslabsneedlraspnet","title":"NexusLabs.Needlr.AspNet","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationBuilderPluginOptions/#webapplicationbuilderpluginoptions-class","title":"WebApplicationBuilderPluginOptions Class","text":"<p>Options provided to IWebApplicationBuilderPlugin implementations during configuration. Contains the web application builder, discovered assemblies, logger, and plugin factory.</p> <pre><code>public sealed record WebApplicationBuilderPluginOptions : System.IEquatable&lt;NexusLabs.Needlr.AspNet.WebApplicationBuilderPluginOptions&gt;\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 WebApplicationBuilderPluginOptions</p> <p>Implements System.IEquatable&lt;WebApplicationBuilderPluginOptions&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationBuilderPluginOptions/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationBuilderPluginOptions/#webapplicationbuilderpluginoptionswebapplicationbuilder-ireadonlylistassembly-ilogger-ipluginfactory-constructor","title":"WebApplicationBuilderPluginOptions(WebApplicationBuilder, IReadOnlyList&lt;Assembly&gt;, ILogger, IPluginFactory) Constructor","text":"<p>Options provided to IWebApplicationBuilderPlugin implementations during configuration. Contains the web application builder, discovered assemblies, logger, and plugin factory.</p> <pre><code>public WebApplicationBuilderPluginOptions(Microsoft.AspNetCore.Builder.WebApplicationBuilder Builder, System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt; Assemblies, Microsoft.Extensions.Logging.ILogger Logger, NexusLabs.Needlr.IPluginFactory PluginFactory);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationBuilderPluginOptions/#parameters","title":"Parameters","text":"<p><code>Builder</code> Microsoft.AspNetCore.Builder.WebApplicationBuilder</p> <p>The web application builder being configured.</p> <p></p> <p><code>Assemblies</code> System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt;</p> <p>The list of assemblies discovered by Needlr.</p> <p></p> <p><code>Logger</code> Microsoft.Extensions.Logging.ILogger</p> <p>Logger for diagnostic output during plugin execution.</p> <p></p> <p><code>PluginFactory</code> NexusLabs.Needlr.IPluginFactory</p> <p>Factory for creating additional plugin instances.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationBuilderPluginOptions/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationBuilderPluginOptions/#webapplicationbuilderpluginoptionsassemblies-property","title":"WebApplicationBuilderPluginOptions.Assemblies Property","text":"<p>The list of assemblies discovered by Needlr.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt; Assemblies { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationBuilderPluginOptions/#property-value","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationBuilderPluginOptions/#webapplicationbuilderpluginoptionsbuilder-property","title":"WebApplicationBuilderPluginOptions.Builder Property","text":"<p>The web application builder being configured.</p> <pre><code>public Microsoft.AspNetCore.Builder.WebApplicationBuilder Builder { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationBuilderPluginOptions/#property-value_1","title":"Property Value","text":"<p>Microsoft.AspNetCore.Builder.WebApplicationBuilder</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationBuilderPluginOptions/#webapplicationbuilderpluginoptionslogger-property","title":"WebApplicationBuilderPluginOptions.Logger Property","text":"<p>Logger for diagnostic output during plugin execution.</p> <pre><code>public Microsoft.Extensions.Logging.ILogger Logger { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationBuilderPluginOptions/#property-value_2","title":"Property Value","text":"<p>Microsoft.Extensions.Logging.ILogger</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationBuilderPluginOptions/#webapplicationbuilderpluginoptionspluginfactory-property","title":"WebApplicationBuilderPluginOptions.PluginFactory Property","text":"<p>Factory for creating additional plugin instances.</p> <pre><code>public NexusLabs.Needlr.IPluginFactory PluginFactory { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationBuilderPluginOptions/#property-value_3","title":"Property Value","text":"<p>NexusLabs.Needlr.IPluginFactory</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationFactory/","title":"WebApplicationFactory","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationFactory/#nexuslabsneedlraspnet","title":"NexusLabs.Needlr.AspNet","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationFactory/#webapplicationfactory-class","title":"WebApplicationFactory Class","text":"<p>Default implementation of IWebApplicationFactory that creates and configures ASP.NET Core web applications. Handles service registration, plugin execution, and the complete application build lifecycle.</p> <pre><code>public sealed class WebApplicationFactory : NexusLabs.Needlr.AspNet.IWebApplicationFactory\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 WebApplicationFactory</p> <p>Implements IWebApplicationFactory</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationFactory/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationFactory/#webapplicationfactoryiserviceproviderbuilder-iservicecollectionpopulator-ipluginfactory-constructor","title":"WebApplicationFactory(IServiceProviderBuilder, IServiceCollectionPopulator, IPluginFactory) Constructor","text":"<p>Default implementation of IWebApplicationFactory that creates and configures ASP.NET Core web applications. Handles service registration, plugin execution, and the complete application build lifecycle.</p> <pre><code>public WebApplicationFactory(NexusLabs.Needlr.Injection.IServiceProviderBuilder _serviceProviderBuilder, NexusLabs.Needlr.Injection.IServiceCollectionPopulator _serviceCollectionPopulator, NexusLabs.Needlr.IPluginFactory _pluginFactory);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationFactory/#parameters","title":"Parameters","text":"<p><code>_serviceProviderBuilder</code> NexusLabs.Needlr.Injection.IServiceProviderBuilder</p> <p></p> <p><code>_serviceCollectionPopulator</code> NexusLabs.Needlr.Injection.IServiceCollectionPopulator</p> <p></p> <p><code>_pluginFactory</code> NexusLabs.Needlr.IPluginFactory</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationPluginOptions/","title":"WebApplicationPluginOptions","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationPluginOptions/#nexuslabsneedlraspnet","title":"NexusLabs.Needlr.AspNet","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationPluginOptions/#webapplicationpluginoptions-class","title":"WebApplicationPluginOptions Class","text":"<p>Options provided to IWebApplicationPlugin implementations during configuration. Contains the built web application, discovered assemblies, and plugin factory.</p> <pre><code>public sealed record WebApplicationPluginOptions : System.IEquatable&lt;NexusLabs.Needlr.AspNet.WebApplicationPluginOptions&gt;\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 WebApplicationPluginOptions</p> <p>Implements System.IEquatable&lt;WebApplicationPluginOptions&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationPluginOptions/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationPluginOptions/#webapplicationpluginoptionswebapplication-ireadonlylistassembly-ipluginfactory-constructor","title":"WebApplicationPluginOptions(WebApplication, IReadOnlyList&lt;Assembly&gt;, IPluginFactory) Constructor","text":"<p>Options provided to IWebApplicationPlugin implementations during configuration. Contains the built web application, discovered assemblies, and plugin factory.</p> <pre><code>public WebApplicationPluginOptions(Microsoft.AspNetCore.Builder.WebApplication WebApplication, System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt; Assemblies, NexusLabs.Needlr.IPluginFactory PluginFactory);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationPluginOptions/#parameters","title":"Parameters","text":"<p><code>WebApplication</code> Microsoft.AspNetCore.Builder.WebApplication</p> <p>The built web application to configure.</p> <p></p> <p><code>Assemblies</code> System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt;</p> <p>The list of assemblies discovered by Needlr.</p> <p></p> <p><code>PluginFactory</code> NexusLabs.Needlr.IPluginFactory</p> <p>Factory for creating additional plugin instances.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationPluginOptions/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationPluginOptions/#webapplicationpluginoptionsassemblies-property","title":"WebApplicationPluginOptions.Assemblies Property","text":"<p>The list of assemblies discovered by Needlr.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt; Assemblies { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationPluginOptions/#property-value","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationPluginOptions/#webapplicationpluginoptionspluginfactory-property","title":"WebApplicationPluginOptions.PluginFactory Property","text":"<p>Factory for creating additional plugin instances.</p> <pre><code>public NexusLabs.Needlr.IPluginFactory PluginFactory { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationPluginOptions/#property-value_1","title":"Property Value","text":"<p>NexusLabs.Needlr.IPluginFactory</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationPluginOptions/#webapplicationpluginoptionswebapplication-property","title":"WebApplicationPluginOptions.WebApplication Property","text":"<p>The built web application to configure.</p> <pre><code>public Microsoft.AspNetCore.Builder.WebApplication WebApplication { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationPluginOptions/#property-value_2","title":"Property Value","text":"<p>Microsoft.AspNetCore.Builder.WebApplication</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringe/","title":"WebApplicationSyringe","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringe/#nexuslabsneedlraspnet","title":"NexusLabs.Needlr.AspNet","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringe/#webapplicationsyringe-class","title":"WebApplicationSyringe Class","text":"<p>Provides a fluent API for configuring and building web applications using Needlr. Wraps a ConfiguredSyringe with additional web application functionality.</p> <pre><code>public sealed record WebApplicationSyringe : System.IEquatable&lt;NexusLabs.Needlr.AspNet.WebApplicationSyringe&gt;\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 WebApplicationSyringe</p> <p>Implements System.IEquatable&lt;WebApplicationSyringe&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringe/#example","title":"Example","text":"<p>Creating and configuring a WebApplicationSyringe:</p> <pre><code>// Method 1: Transition from ConfiguredSyringe\nvar webAppSyringe = new Syringe()\n    .UsingReflection()\n    .ForWebApplication();\n\n// Build and run the web application\nvar webApp = webAppSyringe\n    .UsingOptions(() =&gt; CreateWebApplicationOptions.Default.UsingCliArgs(args))\n    .UsingConfigurationCallback((builder, options) =&gt; \n    {\n        // Configure the WebApplicationBuilder\n        builder.Configuration.AddJsonFile(\"custom-settings.json\", optional: true);\n        builder.Services.AddSingleton&lt;IMyCustomService, MyCustomService&gt;();\n    })\n    .BuildWebApplication();\n\nawait webApp.RunAsync();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringe/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringe/#webapplicationsyringeconfiguredsyringe-constructor","title":"WebApplicationSyringe(ConfiguredSyringe) Constructor","text":"<p>Initializes a new instance of the WebApplicationSyringe class.</p> <pre><code>public WebApplicationSyringe(NexusLabs.Needlr.Injection.ConfiguredSyringe baseSyringe);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringe/#parameters","title":"Parameters","text":"<p><code>baseSyringe</code> NexusLabs.Needlr.Injection.ConfiguredSyringe</p> <p>The configured syringe to wrap.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringe/#example_1","title":"Example","text":"<pre><code>var configuredSyringe = new Syringe().UsingReflection();\n\nvar webAppSyringe = new WebApplicationSyringe(configuredSyringe);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringe/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringe/#webapplicationsyringebuildserviceprovidericonfiguration-method","title":"WebApplicationSyringe.BuildServiceProvider(IConfiguration) Method","text":"<p>Builds a service provider with the configured settings.</p> <pre><code>public System.IServiceProvider BuildServiceProvider(Microsoft.Extensions.Configuration.IConfiguration config);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringe/#parameters_1","title":"Parameters","text":"<p><code>config</code> Microsoft.Extensions.Configuration.IConfiguration</p> <p>The configuration to use for building the service provider.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringe/#returns","title":"Returns","text":"<p>System.IServiceProvider The configured System.IServiceProvider.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringe/#example_2","title":"Example","text":"<pre><code>var config = new ConfigurationBuilder()\n    .AddJsonFile(\"appsettings.json\")\n    .Build();\n\nvar serviceProvider = new Syringe()\n    .UsingReflection()\n    .UsingScrutorTypeRegistrar()\n    .ForWebApplication()\n    .BuildServiceProvider(config);\n\nvar myService = serviceProvider.GetRequiredService&lt;IMyService&gt;();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringe/#webapplicationsyringebuildwebapplication-method","title":"WebApplicationSyringe.BuildWebApplication() Method","text":"<p>Builds a web application with the configured settings.</p> <pre><code>public Microsoft.AspNetCore.Builder.WebApplication BuildWebApplication();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringe/#returns_1","title":"Returns","text":"<p>Microsoft.AspNetCore.Builder.WebApplication The configured Microsoft.AspNetCore.Builder.WebApplication.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringe/#example_3","title":"Example","text":"<pre><code>var webApplication = new Syringe()\n    .UsingReflection()\n    .UsingScrutorTypeRegistrar()\n    .ForWebApplication()\n    .UsingOptions(() =&gt; CreateWebApplicationOptions.Default\n        .UsingCliArgs(args)\n        .UsingApplicationName(\"My Web App\"))\n    .UsingConfigurationCallback((builder, options) =&gt;\n    {\n        // Add custom configuration sources\n        builder.Configuration.AddJsonFile(\"appsettings.local.json\", optional: true);\n\n        // Register additional services\n        builder.Services.AddSingleton&lt;ICustomService, CustomService&gt;();\n    })\n    .BuildWebApplication();\n\n// Configure middleware and endpoints\nwebApplication.MapGet(\"/\", () =&gt; \"Hello World!\");\n\nawait webApplication.RunAsync();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringeExtensions/","title":"WebApplicationSyringeExtensions","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringeExtensions/#nexuslabsneedlraspnet","title":"NexusLabs.Needlr.AspNet","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringeExtensions/#webapplicationsyringeextensions-class","title":"WebApplicationSyringeExtensions Class","text":"<p>Extension methods for configuring WebApplicationSyringe instances. Provides only web application specific configuration methods.</p> <pre><code>public static class WebApplicationSyringeExtensions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 WebApplicationSyringeExtensions</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringeExtensions/#example","title":"Example","text":"<p>Complete web application configuration:</p> <pre><code>var webApplication = new Syringe()\n    // Transition to web application mode\n    .ForWebApplication()\n    // Configure web-specific options\n    .UsingOptions(() =&gt; CreateWebApplicationOptions.Default\n        .UsingCliArgs(args)\n        .UsingApplicationName(\"My Web Application\")\n        .UsingStartupConsoleLogger())\n    .UsingConfigurationCallback((builder, options) =&gt;\n    {\n        // Configure the WebApplicationBuilder\n        builder.Configuration.AddJsonFile(\"custom-settings.json\", optional: true);\n        builder.Services.AddSingleton&lt;IMyCustomService, MyCustomService&gt;();\n    })\n    .BuildWebApplication();\n\nawait webApplication.RunAsync();\n</code></pre> <p>Minimal web application:</p> <pre><code>var webApp = new Syringe()\n    .ForWebApplication()\n    .BuildWebApplication();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringeExtensions/#remarks","title":"Remarks","text":"<p>Remember to use base NexusLabs.Needlr.Injection.Syringe extension methods BEFORE calling  \\&lt;seealso cref=\"M:NexusLabs.Needlr.AspNet.SyringeAspNetExtensions.ForWebApplication(NexusLabs.Needlr.Injection.ConfiguredSyringe)\" /&gt;.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringeExtensions/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringeExtensions/#webapplicationsyringeextensionsusingconfigurationcallbackthis-webapplicationsyringe-actionwebapplicationbuildercreatewebapplicationoptions-method","title":"WebApplicationSyringeExtensions.UsingConfigurationCallback(this WebApplicationSyringe, Action&lt;WebApplicationBuilder,CreateWebApplicationOptions&gt;) Method","text":"<p>Configures the WebApplicationSyringe to use a callback for configuring the Microsoft.AspNetCore.Builder.WebApplicationBuilder. This allows for custom configuration of the builder, such as modifying the Microsoft.Extensions.Configuration.ConfigurationBuilder or adding additional services before the web application is built.</p> <pre><code>public static NexusLabs.Needlr.AspNet.WebApplicationSyringe UsingConfigurationCallback(this NexusLabs.Needlr.AspNet.WebApplicationSyringe syringe, System.Action&lt;Microsoft.AspNetCore.Builder.WebApplicationBuilder,NexusLabs.Needlr.AspNet.CreateWebApplicationOptions&gt; configureCallback);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringeExtensions/#parameters","title":"Parameters","text":"<p><code>syringe</code> WebApplicationSyringe</p> <p>The WebApplicationSyringe to configure.</p> <p></p> <p><code>configureCallback</code> System.Action&lt;Microsoft.AspNetCore.Builder.WebApplicationBuilder,CreateWebApplicationOptions&gt;</p> <p>The callback to configure the Microsoft.AspNetCore.Builder.WebApplicationBuilder.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringeExtensions/#returns","title":"Returns","text":"<p>WebApplicationSyringe A new configured WebApplicationSyringe instance.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringeExtensions/#example_1","title":"Example","text":"<pre><code>var webAppSyringe = syringe\n    .ForWebApplication()\n    .UsingConfigurationCallback((builder, options) =&gt;\n    {\n        // Add custom configuration sources\n        builder.Configuration.AddJsonFile(\"appsettings.local.json\", optional: true);\n        builder.Configuration.AddEnvironmentVariables(\"MYAPP_\");\n\n        // Register additional services that need to be available before plugin registration\n        builder.Services.AddSingleton&lt;ICustomConfigurationService, CustomConfigurationService&gt;();\n\n        // Configure logging\n        builder.Services.AddLogging(logging =&gt;\n        {\n            logging.AddConsole();\n            logging.SetMinimumLevel(LogLevel.Debug);\n        });\n    });\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringeExtensions/#webapplicationsyringeextensionsusingoptionsthis-webapplicationsyringe-funccreatewebapplicationoptions-method","title":"WebApplicationSyringeExtensions.UsingOptions(this WebApplicationSyringe, Func&lt;CreateWebApplicationOptions&gt;) Method","text":"<p>Configures the WebApplicationSyringe to use the specified web application options factory.</p> <pre><code>public static NexusLabs.Needlr.AspNet.WebApplicationSyringe UsingOptions(this NexusLabs.Needlr.AspNet.WebApplicationSyringe syringe, System.Func&lt;NexusLabs.Needlr.AspNet.CreateWebApplicationOptions&gt; optionsFactory);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringeExtensions/#parameters_1","title":"Parameters","text":"<p><code>syringe</code> WebApplicationSyringe</p> <p>The WebApplicationSyringe to configure.</p> <p></p> <p><code>optionsFactory</code> System.Func&lt;CreateWebApplicationOptions&gt;</p> <p>The factory function for creating web application options.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringeExtensions/#returns_1","title":"Returns","text":"<p>WebApplicationSyringe A new configured WebApplicationSyringe instance.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringeExtensions/#example_2","title":"Example","text":"<pre><code>var webAppSyringe = syringe\n    .ForWebApplication()\n    .UsingOptions(() =&gt; CreateWebApplicationOptions.Default\n        .UsingCliArgs(args)\n        .UsingApplicationName(\"My App\")\n        .UsingStartupConsoleLogger());\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringeExtensions/#webapplicationsyringeextensionsusingwebapplicationfactorythis-webapplicationsyringe-funciserviceproviderbuilderiservicecollectionpopulatoriwebapplicationfactory-method","title":"WebApplicationSyringeExtensions.UsingWebApplicationFactory(this WebApplicationSyringe, Func&lt;IServiceProviderBuilder,IServiceCollectionPopulator,IWebApplicationFactory&gt;) Method","text":"<p>Configures the WebApplicationSyringe to use the specified web application factory.</p> <pre><code>public static NexusLabs.Needlr.AspNet.WebApplicationSyringe UsingWebApplicationFactory(this NexusLabs.Needlr.AspNet.WebApplicationSyringe syringe, System.Func&lt;NexusLabs.Needlr.Injection.IServiceProviderBuilder,NexusLabs.Needlr.Injection.IServiceCollectionPopulator,NexusLabs.Needlr.AspNet.IWebApplicationFactory&gt; factory);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringeExtensions/#parameters_2","title":"Parameters","text":"<p><code>syringe</code> WebApplicationSyringe</p> <p>The WebApplicationSyringe to configure.</p> <p></p> <p><code>factory</code> System.Func&lt;NexusLabs.Needlr.Injection.IServiceProviderBuilder,NexusLabs.Needlr.Injection.IServiceCollectionPopulator,IWebApplicationFactory&gt;</p> <p>The factory function for creating web application factories.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringeExtensions/#returns_2","title":"Returns","text":"<p>WebApplicationSyringe A new configured WebApplicationSyringe instance.</p>"},{"location":"api/dev/NexusLabs.Needlr.AspNet/WebApplicationSyringeExtensions/#example_3","title":"Example","text":"<pre><code>var webAppSyringe = syringe\n    .ForWebApplication()\n    .UsingWebApplicationFactory((serviceProviderBuilder, serviceCollectionPopulator) =&gt; \n    {\n        // Custom factory logic here\n        return new CustomWebApplicationFactory(serviceProviderBuilder, serviceCollectionPopulator);\n    });\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Carter/","title":"Index","text":""},{"location":"api/dev/NexusLabs.Needlr.Carter/#nexuslabsneedlrcarter","title":"NexusLabs.Needlr.Carter","text":""},{"location":"api/dev/NexusLabs.Needlr.Carter/#nexuslabsneedlrcarter-assembly","title":"NexusLabs.Needlr.Carter Assembly","text":"Namespaces NexusLabs.Needlr.Carter NexusLabs.Needlr.Carter.Generated"},{"location":"api/dev/NexusLabs.Needlr.Carter/CarterWebApplicationBuilderPlugin/","title":"CarterWebApplicationBuilderPlugin","text":""},{"location":"api/dev/NexusLabs.Needlr.Carter/CarterWebApplicationBuilderPlugin/#nexuslabsneedlrcarter","title":"NexusLabs.Needlr.Carter","text":""},{"location":"api/dev/NexusLabs.Needlr.Carter/CarterWebApplicationBuilderPlugin/#nexuslabsneedlrcarter_1","title":"NexusLabs.Needlr.Carter","text":""},{"location":"api/dev/NexusLabs.Needlr.Carter/CarterWebApplicationBuilderPlugin/#carterwebapplicationbuilderplugin-class","title":"CarterWebApplicationBuilderPlugin Class","text":"<p>Plugin that registers Carter services with the web application builder. Automatically adds Carter module support to the ASP.NET Core application.</p> <pre><code>public sealed class CarterWebApplicationBuilderPlugin : NexusLabs.Needlr.AspNet.IWebApplicationBuilderPlugin\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 CarterWebApplicationBuilderPlugin</p> <p>Implements NexusLabs.Needlr.AspNet.IWebApplicationBuilderPlugin</p>"},{"location":"api/dev/NexusLabs.Needlr.Carter/CarterWebApplicationPlugin/","title":"CarterWebApplicationPlugin","text":""},{"location":"api/dev/NexusLabs.Needlr.Carter/CarterWebApplicationPlugin/#nexuslabsneedlrcarter","title":"NexusLabs.Needlr.Carter","text":""},{"location":"api/dev/NexusLabs.Needlr.Carter/CarterWebApplicationPlugin/#nexuslabsneedlrcarter_1","title":"NexusLabs.Needlr.Carter","text":""},{"location":"api/dev/NexusLabs.Needlr.Carter/CarterWebApplicationPlugin/#carterwebapplicationplugin-class","title":"CarterWebApplicationPlugin Class","text":"<p>Plugin that configures Carter middleware on the web application. Maps Carter routes after the application has been built.</p> <pre><code>public sealed class CarterWebApplicationPlugin : NexusLabs.Needlr.AspNet.IWebApplicationPlugin\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 CarterWebApplicationPlugin</p> <p>Implements NexusLabs.Needlr.AspNet.IWebApplicationPlugin</p>"},{"location":"api/dev/NexusLabs.Needlr.Carter/NexusLabs.Needlr.Carter.Generated/","title":"NexusLabs.Needlr.Carter.Generated","text":""},{"location":"api/dev/NexusLabs.Needlr.Carter/NexusLabs.Needlr.Carter.Generated/#nexuslabsneedlrcarter","title":"NexusLabs.Needlr.Carter","text":""},{"location":"api/dev/NexusLabs.Needlr.Carter/NexusLabs.Needlr.Carter.Generated/#nexuslabsneedlrcartergenerated-namespace","title":"NexusLabs.Needlr.Carter.Generated Namespace","text":"Classes ServiceCatalog Compile-time service catalog containing all discovered registrations. TypeRegistry Compile-time generated registry of injectable types and plugins. This eliminates the need for runtime reflection-based type discovery."},{"location":"api/dev/NexusLabs.Needlr.Carter/NexusLabs.Needlr.Carter/","title":"NexusLabs.Needlr.Carter","text":""},{"location":"api/dev/NexusLabs.Needlr.Carter/NexusLabs.Needlr.Carter/#nexuslabsneedlrcarter","title":"NexusLabs.Needlr.Carter","text":""},{"location":"api/dev/NexusLabs.Needlr.Carter/NexusLabs.Needlr.Carter/#nexuslabsneedlrcarter-namespace","title":"NexusLabs.Needlr.Carter Namespace","text":"Classes CarterWebApplicationBuilderPlugin Plugin that registers Carter services with the web application builder. Automatically adds Carter module support to the ASP.NET Core application. CarterWebApplicationPlugin Plugin that configures Carter middleware on the web application. Maps Carter routes after the application has been built."},{"location":"api/dev/NexusLabs.Needlr.Carter/ServiceCatalog/","title":"ServiceCatalog","text":""},{"location":"api/dev/NexusLabs.Needlr.Carter/ServiceCatalog/#nexuslabsneedlrcarter","title":"NexusLabs.Needlr.Carter","text":""},{"location":"api/dev/NexusLabs.Needlr.Carter/ServiceCatalog/#nexuslabsneedlrcartergenerated","title":"NexusLabs.Needlr.Carter.Generated","text":""},{"location":"api/dev/NexusLabs.Needlr.Carter/ServiceCatalog/#servicecatalog-class","title":"ServiceCatalog Class","text":"<p>Compile-time service catalog containing all discovered registrations.</p> <pre><code>public sealed class ServiceCatalog : NexusLabs.Needlr.Catalog.IServiceCatalog\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 ServiceCatalog</p> <p>Implements NexusLabs.Needlr.Catalog.IServiceCatalog</p>"},{"location":"api/dev/NexusLabs.Needlr.Carter/ServiceCatalog/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.Carter/ServiceCatalog/#servicecatalogassemblyname-property","title":"ServiceCatalog.AssemblyName Property","text":"<p>Gets the assembly name this catalog was generated for.</p> <pre><code>public string AssemblyName { get; }\n</code></pre> <p>Implements AssemblyName</p>"},{"location":"api/dev/NexusLabs.Needlr.Carter/ServiceCatalog/#property-value","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Carter/ServiceCatalog/#servicecatalogdecorators-property","title":"ServiceCatalog.Decorators Property","text":"<p>Gets all discovered decorator registrations.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.DecoratorCatalogEntry&gt; Decorators { get; }\n</code></pre> <p>Implements Decorators</p>"},{"location":"api/dev/NexusLabs.Needlr.Carter/ServiceCatalog/#property-value_1","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.DecoratorCatalogEntry&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Carter/ServiceCatalog/#servicecataloggeneratedat-property","title":"ServiceCatalog.GeneratedAt Property","text":"<p>Gets the UTC timestamp when this catalog was generated.</p> <pre><code>public string GeneratedAt { get; }\n</code></pre> <p>Implements GeneratedAt</p>"},{"location":"api/dev/NexusLabs.Needlr.Carter/ServiceCatalog/#property-value_2","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Carter/ServiceCatalog/#servicecataloghostedservices-property","title":"ServiceCatalog.HostedServices Property","text":"<p>Gets all discovered hosted service registrations.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.HostedServiceCatalogEntry&gt; HostedServices { get; }\n</code></pre> <p>Implements HostedServices</p>"},{"location":"api/dev/NexusLabs.Needlr.Carter/ServiceCatalog/#property-value_3","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.HostedServiceCatalogEntry&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Carter/ServiceCatalog/#servicecataloginterceptedservices-property","title":"ServiceCatalog.InterceptedServices Property","text":"<p>Gets all discovered intercepted service registrations.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.InterceptedServiceCatalogEntry&gt; InterceptedServices { get; }\n</code></pre> <p>Implements InterceptedServices</p>"},{"location":"api/dev/NexusLabs.Needlr.Carter/ServiceCatalog/#property-value_4","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.InterceptedServiceCatalogEntry&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Carter/ServiceCatalog/#servicecatalogoptions-property","title":"ServiceCatalog.Options Property","text":"<p>Gets all discovered options/configuration bindings.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.OptionsCatalogEntry&gt; Options { get; }\n</code></pre> <p>Implements Options</p>"},{"location":"api/dev/NexusLabs.Needlr.Carter/ServiceCatalog/#property-value_5","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.OptionsCatalogEntry&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Carter/ServiceCatalog/#servicecatalogplugins-property","title":"ServiceCatalog.Plugins Property","text":"<p>Gets all discovered plugin registrations.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.PluginCatalogEntry&gt; Plugins { get; }\n</code></pre> <p>Implements Plugins</p>"},{"location":"api/dev/NexusLabs.Needlr.Carter/ServiceCatalog/#property-value_6","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.PluginCatalogEntry&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Carter/ServiceCatalog/#servicecatalogservices-property","title":"ServiceCatalog.Services Property","text":"<p>Gets all discovered service registrations.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.ServiceCatalogEntry&gt; Services { get; }\n</code></pre> <p>Implements Services</p>"},{"location":"api/dev/NexusLabs.Needlr.Carter/ServiceCatalog/#property-value_7","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.ServiceCatalogEntry&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.Carter/TypeRegistry/","title":"TypeRegistry","text":""},{"location":"api/dev/NexusLabs.Needlr.Carter/TypeRegistry/#nexuslabsneedlrcarter","title":"NexusLabs.Needlr.Carter","text":""},{"location":"api/dev/NexusLabs.Needlr.Carter/TypeRegistry/#nexuslabsneedlrcartergenerated","title":"NexusLabs.Needlr.Carter.Generated","text":""},{"location":"api/dev/NexusLabs.Needlr.Carter/TypeRegistry/#typeregistry-class","title":"TypeRegistry Class","text":"<p>Compile-time generated registry of injectable types and plugins. This eliminates the need for runtime reflection-based type discovery.</p> <pre><code>public static class TypeRegistry\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 TypeRegistry</p>"},{"location":"api/dev/NexusLabs.Needlr.Carter/TypeRegistry/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Carter/TypeRegistry/#typeregistryapplydecoratorsiservicecollection-method","title":"TypeRegistry.ApplyDecorators(IServiceCollection) Method","text":"<p>Applies all discovered decorators, interceptors, and hosted services to the service collection. Decorators are applied in order, with lower Order values applied first (closer to the original service).</p> <pre><code>public static void ApplyDecorators(Microsoft.Extensions.DependencyInjection.IServiceCollection services);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Carter/TypeRegistry/#parameters","title":"Parameters","text":"<p><code>services</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service collection to apply decorators to.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Carter/TypeRegistry/#typeregistrygetinjectabletypes-method","title":"TypeRegistry.GetInjectableTypes() Method","text":"<p>Gets all injectable types discovered at compile time.</p> <pre><code>public static System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.InjectableTypeInfo&gt; GetInjectableTypes();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Carter/TypeRegistry/#returns","title":"Returns","text":"<p>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.InjectableTypeInfo&gt; A read-only list of injectable type information.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Carter/TypeRegistry/#typeregistrygetplugintypes-method","title":"TypeRegistry.GetPluginTypes() Method","text":"<p>Gets all plugin types discovered at compile time.</p> <pre><code>public static System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.PluginTypeInfo&gt; GetPluginTypes();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Carter/TypeRegistry/#returns_1","title":"Returns","text":"<p>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.PluginTypeInfo&gt; A read-only list of plugin type information.</p>"},{"location":"api/dev/NexusLabs.Needlr.Extensions.Logging/","title":"Index","text":""},{"location":"api/dev/NexusLabs.Needlr.Extensions.Logging/#nexuslabsneedlrextensionslogging-namespace","title":"NexusLabs.Needlr.Extensions.Logging Namespace","text":"Classes PostBuildServiceCollectionPluginOptionsExtensions Extension methods for NexusLabs.Needlr.PostBuildServiceCollectionPluginOptions to simplify logger retrieval."},{"location":"api/dev/NexusLabs.Needlr.Extensions.Logging/NexusLabs.Needlr.Extensions.Logging/","title":"NexusLabs.Needlr.Extensions.Logging","text":""},{"location":"api/dev/NexusLabs.Needlr.Extensions.Logging/NexusLabs.Needlr.Extensions.Logging/#nexuslabsneedlrextensionslogging-namespace","title":"NexusLabs.Needlr.Extensions.Logging Namespace","text":"Classes PostBuildServiceCollectionPluginOptionsExtensions Extension methods for NexusLabs.Needlr.PostBuildServiceCollectionPluginOptions to simplify logger retrieval."},{"location":"api/dev/NexusLabs.Needlr.Extensions.Logging/PostBuildServiceCollectionPluginOptionsExtensions/","title":"PostBuildServiceCollectionPluginOptionsExtensions","text":""},{"location":"api/dev/NexusLabs.Needlr.Extensions.Logging/PostBuildServiceCollectionPluginOptionsExtensions/#nexuslabsneedlrextensionslogging","title":"NexusLabs.Needlr.Extensions.Logging","text":""},{"location":"api/dev/NexusLabs.Needlr.Extensions.Logging/PostBuildServiceCollectionPluginOptionsExtensions/#postbuildservicecollectionpluginoptionsextensions-class","title":"PostBuildServiceCollectionPluginOptionsExtensions Class","text":"<p>Extension methods for NexusLabs.Needlr.PostBuildServiceCollectionPluginOptions to simplify logger retrieval.</p> <pre><code>public static class PostBuildServiceCollectionPluginOptionsExtensions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 PostBuildServiceCollectionPluginOptionsExtensions</p>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/","title":"Index","text":""},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/#nexuslabsneedlrfluentvalidation-namespace","title":"NexusLabs.Needlr.FluentValidation Namespace","text":"Classes FluentOptionsValidator&lt;TOptions&gt; A convenience base class for creating Needlr-compatible validators from FluentValidation validators. FluentValidationOptionsAdapter&lt;TOptions&gt; Adapts a FluentValidation FluentValidation.IValidator&lt;&gt; to work as an Microsoft.Extensions.Options.IValidateOptions&lt;&gt; for Microsoft.Extensions.Options. FluentValidationServiceCollectionExtensions Extension methods for registering FluentValidation validators as options validators. FluentValidatorWrapper&lt;TOptions,TValidator&gt; Wraps a FluentValidation FluentValidation.IValidator&lt;&gt; to implement Needlr's NexusLabs.Needlr.Generators.IOptionsValidator&lt;&gt; interface. ValidationFailureConverter Converts FluentValidation FluentValidation.Results.ValidationFailure instances to Needlr NexusLabs.Needlr.Generators.ValidationError instances."},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentOptionsValidator_TOptions_/","title":"FluentOptionsValidator TOptions","text":""},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentOptionsValidator_TOptions_/#nexuslabsneedlrfluentvalidation","title":"NexusLabs.Needlr.FluentValidation","text":""},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentOptionsValidator_TOptions_/#fluentoptionsvalidatortoptions-class","title":"FluentOptionsValidator&lt;TOptions&gt; Class","text":"<p>A convenience base class for creating Needlr-compatible validators from FluentValidation validators.</p> <pre><code>public abstract class FluentOptionsValidator&lt;TOptions&gt; : FluentValidation.AbstractValidator&lt;TOptions&gt;, NexusLabs.Needlr.Generators.IOptionsValidator&lt;TOptions&gt;\n    where TOptions : class\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentOptionsValidator_TOptions_/#type-parameters","title":"Type parameters","text":"<p><code>TOptions</code></p> <p>The options type being validated.</p> <p>Inheritance System.Object \ud83e\udc52 FluentValidation.AbstractValidator&lt;TOptions&gt; \ud83e\udc52 FluentOptionsValidator\\&lt;TOptions&gt;</p> <p>Implements NexusLabs.Needlr.Generators.IOptionsValidator&lt;TOptions&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentOptionsValidator_TOptions_/#remarks","title":"Remarks","text":"<p>Inherit from this class and define your validation rules in the constructor. The resulting class can be used directly with <code>[Options(Validator = typeof(...))]</code>.</p> <p>Example:</p> <pre><code>[Options(ValidateOnStart = true, Validator = typeof(DatabaseOptionsValidator))]\npublic class DatabaseOptions\n{\n    public string ConnectionString { get; set; } = \"\";\n    public int MaxConnections { get; set; } = 100;\n}\n\npublic class DatabaseOptionsValidator : FluentOptionsValidator&lt;DatabaseOptions&gt;\n{\n    public DatabaseOptionsValidator()\n    {\n        RuleFor(x =&gt; x.ConnectionString)\n            .NotEmpty()\n            .WithMessage(\"Connection string is required\");\n\n        RuleFor(x =&gt; x.MaxConnections)\n            .InclusiveBetween(1, 1000)\n            .WithMessage(\"Max connections must be between 1 and 1000\");\n    }\n}\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentOptionsValidator_TOptions_/#explicit-interface-implementations","title":"Explicit Interface Implementations","text":""},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentOptionsValidator_TOptions_/#nexuslabsneedlrgeneratorsioptionsvalidatortoptionsvalidatetoptions-method","title":"NexusLabs.Needlr.Generators.IOptionsValidator&lt;TOptions&gt;.Validate(TOptions) Method","text":"<p>Validates the specified options instance.</p> <pre><code>System.Collections.Generic.IEnumerable&lt;NexusLabs.Needlr.Generators.ValidationError&gt; NexusLabs.Needlr.Generators.IOptionsValidator&lt;TOptions&gt;.Validate(TOptions options);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentOptionsValidator_TOptions_/#parameters","title":"Parameters","text":"<p><code>options</code> TOptions</p> <p>The options instance to validate.</p> <p>Implements Validate(TOptions)</p>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidationOptionsAdapter_TOptions_/","title":"FluentValidationOptionsAdapter TOptions","text":""},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidationOptionsAdapter_TOptions_/#nexuslabsneedlrfluentvalidation","title":"NexusLabs.Needlr.FluentValidation","text":""},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidationOptionsAdapter_TOptions_/#fluentvalidationoptionsadaptertoptions-class","title":"FluentValidationOptionsAdapter&lt;TOptions&gt; Class","text":"<p>Adapts a FluentValidation FluentValidation.IValidator&lt;&gt; to work as an Microsoft.Extensions.Options.IValidateOptions&lt;&gt; for Microsoft.Extensions.Options.</p> <pre><code>public sealed class FluentValidationOptionsAdapter&lt;TOptions&gt; : Microsoft.Extensions.Options.IValidateOptions&lt;TOptions&gt;\n    where TOptions : class\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidationOptionsAdapter_TOptions_/#type-parameters","title":"Type parameters","text":"<p><code>TOptions</code></p> <p>The options type being validated.</p> <p>Inheritance System.Object \ud83e\udc52 FluentValidationOptionsAdapter\\&lt;TOptions&gt;</p> <p>Implements Microsoft.Extensions.Options.IValidateOptions&lt;TOptions&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidationOptionsAdapter_TOptions_/#remarks","title":"Remarks","text":"<p>This adapter allows FluentValidation validators to be used seamlessly with Needlr's <code>[Options(ValidateOnStart = true)]</code> attribute. The adapter translates FluentValidation's FluentValidation.Results.ValidationResult into the Microsoft.Extensions.Options.ValidateOptionsResult expected by the options framework.</p> <p>Usage with Needlr source generation:</p> <pre><code>[Options(\"Database\", ValidateOnStart = true, Validator = typeof(DatabaseOptionsValidator))]\npublic class DatabaseOptions { ... }\n\npublic class DatabaseOptionsValidator : AbstractValidator&lt;DatabaseOptions&gt;\n{\n    public DatabaseOptionsValidator()\n    {\n        RuleFor(x =&gt; x.ConnectionString).NotEmpty();\n    }\n}\n</code></pre> <p>Register the adapter in your DI container:</p> <pre><code>services.AddFluentValidationOptionsAdapter&lt;DatabaseOptions, DatabaseOptionsValidator&gt;();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidationOptionsAdapter_TOptions_/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidationOptionsAdapter_TOptions_/#fluentvalidationoptionsadapterivalidatortoptions-string-constructor","title":"FluentValidationOptionsAdapter(IValidator&lt;TOptions&gt;, string) Constructor","text":"<p>Creates a new adapter for the specified FluentValidation validator.</p> <pre><code>public FluentValidationOptionsAdapter(FluentValidation.IValidator&lt;TOptions&gt; validator, string? name=null);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidationOptionsAdapter_TOptions_/#parameters","title":"Parameters","text":"<p><code>validator</code> FluentValidation.IValidator&lt;TOptions&gt;</p> <p>The FluentValidation validator to adapt.</p> <p></p> <p><code>name</code> System.String</p> <p>Optional name for named options validation.</p>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidationOptionsAdapter_TOptions_/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidationOptionsAdapter_TOptions_/#fluentvalidationoptionsadaptertoptionsvalidatestring-toptions-method","title":"FluentValidationOptionsAdapter&lt;TOptions&gt;.Validate(string, TOptions) Method","text":"<p>Validates the specified options instance.</p> <pre><code>public Microsoft.Extensions.Options.ValidateOptionsResult Validate(string? name, TOptions options);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidationOptionsAdapter_TOptions_/#parameters_1","title":"Parameters","text":"<p><code>name</code> System.String</p> <p>The name of the options instance being validated.</p> <p></p> <p><code>options</code> TOptions</p> <p>The options instance to validate.</p> <p>Implements Validate(string, TOptions)</p>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidationOptionsAdapter_TOptions_/#returns","title":"Returns","text":"<p>Microsoft.Extensions.Options.ValidateOptionsResult A Microsoft.Extensions.Options.ValidateOptionsResult indicating success or failure.</p>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidationServiceCollectionExtensions/","title":"FluentValidationServiceCollectionExtensions","text":""},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidationServiceCollectionExtensions/#nexuslabsneedlrfluentvalidation","title":"NexusLabs.Needlr.FluentValidation","text":""},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidationServiceCollectionExtensions/#fluentvalidationservicecollectionextensions-class","title":"FluentValidationServiceCollectionExtensions Class","text":"<p>Extension methods for registering FluentValidation validators as options validators.</p> <pre><code>public static class FluentValidationServiceCollectionExtensions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 FluentValidationServiceCollectionExtensions</p>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidationServiceCollectionExtensions/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidationServiceCollectionExtensions/#fluentvalidationservicecollectionextensionsaddfluentvalidationoptionsadaptertoptionstvalidatorthis-iservicecollection-method","title":"FluentValidationServiceCollectionExtensions.AddFluentValidationOptionsAdapter&lt;TOptions,TValidator&gt;(this IServiceCollection) Method","text":"<p>Adds a FluentValidation validator as an options validator for the specified options type.</p> <pre><code>public static Microsoft.Extensions.DependencyInjection.IServiceCollection AddFluentValidationOptionsAdapter&lt;TOptions,TValidator&gt;(this Microsoft.Extensions.DependencyInjection.IServiceCollection services)\n    where TOptions : class\n    where TValidator : class, FluentValidation.IValidator&lt;TOptions&gt;;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidationServiceCollectionExtensions/#type-parameters","title":"Type parameters","text":"<p><code>TOptions</code></p> <p>The options type to validate.</p> <p></p> <p><code>TValidator</code></p> <p>The FluentValidation validator type.</p>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidationServiceCollectionExtensions/#parameters","title":"Parameters","text":"<p><code>services</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service collection.</p>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidationServiceCollectionExtensions/#returns","title":"Returns","text":"<p>Microsoft.Extensions.DependencyInjection.IServiceCollection The service collection for chaining.</p>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidationServiceCollectionExtensions/#remarks","title":"Remarks","text":"<p>This method registers: - The validator as a singleton - An Microsoft.Extensions.Options.IValidateOptions&lt;&gt; adapter that uses the validator</p> <p>Example usage:</p> <pre><code>services.AddFluentValidationOptionsAdapter&lt;DatabaseOptions, DatabaseOptionsValidator&gt;();\n</code></pre> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidationServiceCollectionExtensions/#fluentvalidationservicecollectionextensionsaddfluentvalidationoptionsadaptertoptionstvalidatorthis-iservicecollection-string-method","title":"FluentValidationServiceCollectionExtensions.AddFluentValidationOptionsAdapter&lt;TOptions,TValidator&gt;(this IServiceCollection, string) Method","text":"<p>Adds a FluentValidation validator as an options validator for named options.</p> <pre><code>public static Microsoft.Extensions.DependencyInjection.IServiceCollection AddFluentValidationOptionsAdapter&lt;TOptions,TValidator&gt;(this Microsoft.Extensions.DependencyInjection.IServiceCollection services, string name)\n    where TOptions : class\n    where TValidator : class, FluentValidation.IValidator&lt;TOptions&gt;;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidationServiceCollectionExtensions/#type-parameters_1","title":"Type parameters","text":"<p><code>TOptions</code></p> <p>The options type to validate.</p> <p></p> <p><code>TValidator</code></p> <p>The FluentValidation validator type.</p>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidationServiceCollectionExtensions/#parameters_1","title":"Parameters","text":"<p><code>services</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service collection.</p> <p></p> <p><code>name</code> System.String</p> <p>The name of the options instance to validate.</p>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidationServiceCollectionExtensions/#returns_1","title":"Returns","text":"<p>Microsoft.Extensions.DependencyInjection.IServiceCollection The service collection for chaining.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidationServiceCollectionExtensions/#fluentvalidationservicecollectionextensionsaddfluentvalidationoptionsadaptertoptionsthis-iservicecollection-ivalidatortoptions-method","title":"FluentValidationServiceCollectionExtensions.AddFluentValidationOptionsAdapter&lt;TOptions&gt;(this IServiceCollection, IValidator&lt;TOptions&gt;) Method","text":"<p>Adds a FluentValidation validator instance as an options validator.</p> <pre><code>public static Microsoft.Extensions.DependencyInjection.IServiceCollection AddFluentValidationOptionsAdapter&lt;TOptions&gt;(this Microsoft.Extensions.DependencyInjection.IServiceCollection services, FluentValidation.IValidator&lt;TOptions&gt; validator)\n    where TOptions : class;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidationServiceCollectionExtensions/#type-parameters_2","title":"Type parameters","text":"<p><code>TOptions</code></p> <p>The options type to validate.</p>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidationServiceCollectionExtensions/#parameters_2","title":"Parameters","text":"<p><code>services</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service collection.</p> <p></p> <p><code>validator</code> FluentValidation.IValidator&lt;TOptions&gt;</p> <p>The validator instance.</p>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidationServiceCollectionExtensions/#returns_2","title":"Returns","text":"<p>Microsoft.Extensions.DependencyInjection.IServiceCollection The service collection for chaining.</p>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidatorWrapper_TOptions%2CTValidator_/","title":"FluentValidatorWrapper TOptions,TValidator","text":""},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidatorWrapper_TOptions%2CTValidator_/#nexuslabsneedlrfluentvalidation","title":"NexusLabs.Needlr.FluentValidation","text":""},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidatorWrapper_TOptions%2CTValidator_/#fluentvalidatorwrappertoptionstvalidator-class","title":"FluentValidatorWrapper&lt;TOptions,TValidator&gt; Class","text":"<p>Wraps a FluentValidation FluentValidation.IValidator&lt;&gt; to implement Needlr's NexusLabs.Needlr.Generators.IOptionsValidator&lt;&gt; interface.</p> <pre><code>public class FluentValidatorWrapper&lt;TOptions,TValidator&gt; : NexusLabs.Needlr.Generators.IOptionsValidator&lt;TOptions&gt;\n    where TOptions : class\n    where TValidator : FluentValidation.IValidator&lt;TOptions&gt;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidatorWrapper_TOptions%2CTValidator_/#type-parameters","title":"Type parameters","text":"<p><code>TOptions</code></p> <p>The options type being validated.</p> <p></p> <p><code>TValidator</code></p> <p>The FluentValidation validator type.</p> <p>Inheritance System.Object \ud83e\udc52 FluentValidatorWrapper\\&lt;TOptions,TValidator&gt;</p> <p>Implements NexusLabs.Needlr.Generators.IOptionsValidator&lt;TOptions&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidatorWrapper_TOptions%2CTValidator_/#remarks","title":"Remarks","text":"<p>This wrapper allows FluentValidation validators to be used with the <code>[Options(Validator = typeof(...))]</code> attribute by implementing the NexusLabs.Needlr.Generators.IOptionsValidator&lt;&gt; interface.</p> <p>Example usage:</p> <pre><code>// The FluentValidation validator\npublic class DatabaseOptionsValidator : AbstractValidator&lt;DatabaseOptions&gt;\n{\n    public DatabaseOptionsValidator()\n    {\n        RuleFor(x =&gt; x.ConnectionString).NotEmpty();\n    }\n}\n\n// Wrap it for use with Needlr\npublic class DatabaseOptionsNeedlrValidator \n    : FluentValidatorWrapper&lt;DatabaseOptions, DatabaseOptionsValidator&gt;\n{\n    public DatabaseOptionsNeedlrValidator() : base(new DatabaseOptionsValidator()) { }\n}\n\n// Use with [Options]\n[Options(ValidateOnStart = true, Validator = typeof(DatabaseOptionsNeedlrValidator))]\npublic class DatabaseOptions { ... }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidatorWrapper_TOptions%2CTValidator_/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidatorWrapper_TOptions%2CTValidator_/#fluentvalidatorwrappertvalidator-constructor","title":"FluentValidatorWrapper(TValidator) Constructor","text":"<p>Initializes a new instance wrapping the specified FluentValidation validator.</p> <pre><code>public FluentValidatorWrapper(TValidator validator);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidatorWrapper_TOptions%2CTValidator_/#parameters","title":"Parameters","text":"<p><code>validator</code> TValidator</p> <p>The FluentValidation validator to wrap.</p>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidatorWrapper_TOptions%2CTValidator_/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidatorWrapper_TOptions%2CTValidator_/#fluentvalidatorwrappertoptionstvalidatorvalidatetoptions-method","title":"FluentValidatorWrapper&lt;TOptions,TValidator&gt;.Validate(TOptions) Method","text":"<p>Validates the specified options instance using FluentValidation.</p> <pre><code>public System.Collections.Generic.IEnumerable&lt;NexusLabs.Needlr.Generators.ValidationError&gt; Validate(TOptions options);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidatorWrapper_TOptions%2CTValidator_/#parameters_1","title":"Parameters","text":"<p><code>options</code> TOptions</p> <p>The options instance to validate.</p> <p>Implements Validate(T)</p>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/FluentValidatorWrapper_TOptions%2CTValidator_/#returns","title":"Returns","text":"<p>System.Collections.Generic.IEnumerable&lt;NexusLabs.Needlr.Generators.ValidationError&gt; An enumerable of validation errors.</p>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/NexusLabs.Needlr.FluentValidation/","title":"NexusLabs.Needlr.FluentValidation","text":""},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/NexusLabs.Needlr.FluentValidation/#nexuslabsneedlrfluentvalidation-namespace","title":"NexusLabs.Needlr.FluentValidation Namespace","text":"Classes FluentOptionsValidator&lt;TOptions&gt; A convenience base class for creating Needlr-compatible validators from FluentValidation validators. FluentValidationOptionsAdapter&lt;TOptions&gt; Adapts a FluentValidation FluentValidation.IValidator&lt;&gt; to work as an Microsoft.Extensions.Options.IValidateOptions&lt;&gt; for Microsoft.Extensions.Options. FluentValidationServiceCollectionExtensions Extension methods for registering FluentValidation validators as options validators. FluentValidatorWrapper&lt;TOptions,TValidator&gt; Wraps a FluentValidation FluentValidation.IValidator&lt;&gt; to implement Needlr's NexusLabs.Needlr.Generators.IOptionsValidator&lt;&gt; interface. ValidationFailureConverter Converts FluentValidation FluentValidation.Results.ValidationFailure instances to Needlr NexusLabs.Needlr.Generators.ValidationError instances."},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/ValidationFailureConverter/","title":"ValidationFailureConverter","text":""},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/ValidationFailureConverter/#nexuslabsneedlrfluentvalidation","title":"NexusLabs.Needlr.FluentValidation","text":""},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/ValidationFailureConverter/#validationfailureconverter-class","title":"ValidationFailureConverter Class","text":"<p>Converts FluentValidation FluentValidation.Results.ValidationFailure instances to Needlr NexusLabs.Needlr.Generators.ValidationError instances.</p> <pre><code>public static class ValidationFailureConverter\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 ValidationFailureConverter</p>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/ValidationFailureConverter/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/ValidationFailureConverter/#validationfailureconvertertovalidationerrorthis-validationfailure-method","title":"ValidationFailureConverter.ToValidationError(this ValidationFailure) Method","text":"<p>Converts a FluentValidation FluentValidation.Results.ValidationFailure to a Needlr NexusLabs.Needlr.Generators.ValidationError.</p> <pre><code>public static NexusLabs.Needlr.Generators.ValidationError ToValidationError(this FluentValidation.Results.ValidationFailure failure);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/ValidationFailureConverter/#parameters","title":"Parameters","text":"<p><code>failure</code> FluentValidation.Results.ValidationFailure</p> <p>The FluentValidation failure to convert.</p>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/ValidationFailureConverter/#returns","title":"Returns","text":"<p>NexusLabs.Needlr.Generators.ValidationError A Needlr NexusLabs.Needlr.Generators.ValidationError with the same information.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/ValidationFailureConverter/#validationfailureconvertertovalidationerrorsthis-validationresult-method","title":"ValidationFailureConverter.ToValidationErrors(this ValidationResult) Method","text":"<p>Converts a FluentValidation FluentValidation.Results.ValidationResult to a collection of Needlr validation errors.</p> <pre><code>public static System.Collections.Generic.IEnumerable&lt;NexusLabs.Needlr.Generators.ValidationError&gt; ToValidationErrors(this FluentValidation.Results.ValidationResult result);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/ValidationFailureConverter/#parameters_1","title":"Parameters","text":"<p><code>result</code> FluentValidation.Results.ValidationResult</p> <p>The FluentValidation result to convert.</p>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/ValidationFailureConverter/#returns_1","title":"Returns","text":"<p>System.Collections.Generic.IEnumerable&lt;NexusLabs.Needlr.Generators.ValidationError&gt; An enumerable of Needlr NexusLabs.Needlr.Generators.ValidationError instances.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/ValidationFailureConverter/#validationfailureconvertertovalidationerrorsthis-ienumerablevalidationfailure-method","title":"ValidationFailureConverter.ToValidationErrors(this IEnumerable&lt;ValidationFailure&gt;) Method","text":"<p>Converts a collection of FluentValidation failures to Needlr validation errors.</p> <pre><code>public static System.Collections.Generic.IEnumerable&lt;NexusLabs.Needlr.Generators.ValidationError&gt; ToValidationErrors(this System.Collections.Generic.IEnumerable&lt;FluentValidation.Results.ValidationFailure&gt; failures);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/ValidationFailureConverter/#parameters_2","title":"Parameters","text":"<p><code>failures</code> System.Collections.Generic.IEnumerable&lt;FluentValidation.Results.ValidationFailure&gt;</p> <p>The FluentValidation failures to convert.</p>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation/ValidationFailureConverter/#returns_2","title":"Returns","text":"<p>System.Collections.Generic.IEnumerable&lt;NexusLabs.Needlr.Generators.ValidationError&gt; An enumerable of Needlr NexusLabs.Needlr.Generators.ValidationError instances.</p>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation.Generators/","title":"Index","text":""},{"location":"api/dev/NexusLabs.Needlr.FluentValidation.Generators/#nexuslabsneedlrfluentvalidationgenerators-namespace","title":"NexusLabs.Needlr.FluentValidation.Generators Namespace","text":"Classes FluentValidationAdapterGenerator Source generator that creates IValidateOptions adapters for FluentValidation validators and registers them via SourceGenRegistry.RegisterExtension."},{"location":"api/dev/NexusLabs.Needlr.FluentValidation.Generators/FluentValidationAdapterGenerator/","title":"FluentValidationAdapterGenerator","text":""},{"location":"api/dev/NexusLabs.Needlr.FluentValidation.Generators/FluentValidationAdapterGenerator/#nexuslabsneedlrfluentvalidationgenerators","title":"NexusLabs.Needlr.FluentValidation.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.FluentValidation.Generators/FluentValidationAdapterGenerator/#fluentvalidationadaptergenerator-class","title":"FluentValidationAdapterGenerator Class","text":"<p>Source generator that creates IValidateOptions adapters for FluentValidation validators and registers them via SourceGenRegistry.RegisterExtension.</p> <pre><code>public sealed class FluentValidationAdapterGenerator\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 Microsoft.CodeAnalysis.IIncrementalGenerator \ud83e\udc52 FluentValidationAdapterGenerator</p>"},{"location":"api/dev/NexusLabs.Needlr.FluentValidation.Generators/NexusLabs.Needlr.FluentValidation.Generators/","title":"NexusLabs.Needlr.FluentValidation.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.FluentValidation.Generators/NexusLabs.Needlr.FluentValidation.Generators/#nexuslabsneedlrfluentvalidationgenerators-namespace","title":"NexusLabs.Needlr.FluentValidation.Generators Namespace","text":"Classes FluentValidationAdapterGenerator Source generator that creates IValidateOptions adapters for FluentValidation validators and registers them via SourceGenRegistry.RegisterExtension."},{"location":"api/dev/NexusLabs.Needlr.Generators/","title":"Index","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/#nexuslabsneedlrgenerators","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/#nexuslabsneedlrgenerators-assembly","title":"NexusLabs.Needlr.Generators Assembly","text":"Namespaces NexusLabs.Needlr.Generators NexusLabs.Needlr.Generators.Helpers NexusLabs.Needlr.Roslyn.Shared"},{"location":"api/dev/NexusLabs.Needlr.Generators/GenerateFactoryAttributeAnalyzer/","title":"GenerateFactoryAttributeAnalyzer","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/GenerateFactoryAttributeAnalyzer/#nexuslabsneedlrgenerators","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/GenerateFactoryAttributeAnalyzer/#nexuslabsneedlrgenerators_1","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/GenerateFactoryAttributeAnalyzer/#generatefactoryattributeanalyzer-class","title":"GenerateFactoryAttributeAnalyzer Class","text":"<p>Analyzer that validates [GenerateFactory] and [GenerateFactory\\&lt;T&gt;] attribute usage: - NDLRGEN003: All constructor parameters are injectable (factory unnecessary) - NDLRGEN004: No constructor parameters are injectable (low value factory) - NDLRGEN005: Type argument T is not an interface implemented by the class</p> <pre><code>public sealed class GenerateFactoryAttributeAnalyzer\n</code></pre> <p>Inheritance Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer \ud83e\udc52 GenerateFactoryAttributeAnalyzer</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators/NexusLabs.Needlr.Generators.Helpers/","title":"NexusLabs.Needlr.Generators.Helpers","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/NexusLabs.Needlr.Generators.Helpers/#nexuslabsneedlrgenerators","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/NexusLabs.Needlr.Generators.Helpers/#nexuslabsneedlrgeneratorshelpers-namespace","title":"NexusLabs.Needlr.Generators.Helpers Namespace","text":"Classes OptionsNamingHelper Helper methods for inferring configuration section names from options class names."},{"location":"api/dev/NexusLabs.Needlr.Generators/NexusLabs.Needlr.Generators/","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/NexusLabs.Needlr.Generators/#nexuslabsneedlrgenerators","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/NexusLabs.Needlr.Generators/#nexuslabsneedlrgenerators-namespace","title":"NexusLabs.Needlr.Generators Namespace","text":"Classes GenerateFactoryAttributeAnalyzer Analyzer that validates [GenerateFactory] and [GenerateFactory\\&lt;T&gt;] attribute usage: - NDLRGEN003: All constructor parameters are injectable (factory unnecessary) - NDLRGEN004: No constructor parameters are injectable (low value factory) - NDLRGEN005: Type argument T is not an interface implemented by the class OpenDecoratorForAttributeAnalyzer Analyzer that validates [OpenDecoratorFor] attribute usage: - NDLRGEN006: Type argument must be an open generic interface - NDLRGEN007: Decorator class must be an open generic with matching arity - NDLRGEN008: Decorator class must implement the open generic interface OptionsAttributeAnalyzer Analyzer that validates [Options] attribute usage for validation configuration: - NDLRGEN014: Validator type has no validation method - NDLRGEN015: Validator type mismatch - NDLRGEN016: Validation method not found - NDLRGEN017: Validation method has wrong signature - NDLRGEN018: Validator won't run (ValidateOnStart = false) - NDLRGEN019: ValidateMethod won't run (ValidateOnStart = false) ProviderAttributeAnalyzer Analyzer that validates [Provider] attribute usage: - NDLRGEN031: [Provider] on class requires `partial` modifier - NDLRGEN032: [Provider] interface must only contain get-only properties - NDLRGEN033: Provider property type is a concrete class - NDLRGEN034: Circular provider dependency detected TypeRegistryGenerator Incremental source generator that produces a compile-time type registry for dependency injection, eliminating runtime reflection. UnsupportedDataAnnotationAnalyzer Analyzer that warns when [Options] classes use DataAnnotation validation attributes that cannot be source-generated.  NDLRGEN030: DataAnnotation attribute cannot be source-generated"},{"location":"api/dev/NexusLabs.Needlr.Generators/NexusLabs.Needlr.Roslyn.Shared/","title":"NexusLabs.Needlr.Roslyn.Shared","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/NexusLabs.Needlr.Roslyn.Shared/#nexuslabsneedlrgenerators","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/NexusLabs.Needlr.Roslyn.Shared/#nexuslabsneedlrroslynshared-namespace","title":"NexusLabs.Needlr.Roslyn.Shared Namespace","text":"Classes TypeDiscoveryHelper Shared helper utilities for discovering injectable types from Roslyn symbols. Used by both Generators and Analyzers to ensure consistent type discovery logic."},{"location":"api/dev/NexusLabs.Needlr.Generators/OpenDecoratorForAttributeAnalyzer/","title":"OpenDecoratorForAttributeAnalyzer","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/OpenDecoratorForAttributeAnalyzer/#nexuslabsneedlrgenerators","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/OpenDecoratorForAttributeAnalyzer/#nexuslabsneedlrgenerators_1","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/OpenDecoratorForAttributeAnalyzer/#opendecoratorforattributeanalyzer-class","title":"OpenDecoratorForAttributeAnalyzer Class","text":"<p>Analyzer that validates [OpenDecoratorFor] attribute usage: - NDLRGEN006: Type argument must be an open generic interface - NDLRGEN007: Decorator class must be an open generic with matching arity - NDLRGEN008: Decorator class must implement the open generic interface</p> <pre><code>public sealed class OpenDecoratorForAttributeAnalyzer\n</code></pre> <p>Inheritance Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer \ud83e\udc52 OpenDecoratorForAttributeAnalyzer</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators/OptionsAttributeAnalyzer/","title":"OptionsAttributeAnalyzer","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/OptionsAttributeAnalyzer/#nexuslabsneedlrgenerators","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/OptionsAttributeAnalyzer/#nexuslabsneedlrgenerators_1","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/OptionsAttributeAnalyzer/#optionsattributeanalyzer-class","title":"OptionsAttributeAnalyzer Class","text":"<p>Analyzer that validates [Options] attribute usage for validation configuration: - NDLRGEN014: Validator type has no validation method - NDLRGEN015: Validator type mismatch - NDLRGEN016: Validation method not found - NDLRGEN017: Validation method has wrong signature - NDLRGEN018: Validator won't run (ValidateOnStart = false) - NDLRGEN019: ValidateMethod won't run (ValidateOnStart = false)</p> <pre><code>public sealed class OptionsAttributeAnalyzer\n</code></pre> <p>Inheritance Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer \ud83e\udc52 OptionsAttributeAnalyzer</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators/OptionsNamingHelper/","title":"OptionsNamingHelper","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/OptionsNamingHelper/#nexuslabsneedlrgenerators","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/OptionsNamingHelper/#nexuslabsneedlrgeneratorshelpers","title":"NexusLabs.Needlr.Generators.Helpers","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/OptionsNamingHelper/#optionsnaminghelper-class","title":"OptionsNamingHelper Class","text":"<p>Helper methods for inferring configuration section names from options class names.</p> <pre><code>public static class OptionsNamingHelper\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 OptionsNamingHelper</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators/OptionsNamingHelper/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/OptionsNamingHelper/#optionsnaminghelpergetmatchedsuffixstring-method","title":"OptionsNamingHelper.GetMatchedSuffix(string) Method","text":"<p>Gets the suffix that was matched and would be stripped from the class name, if any.</p> <pre><code>public static string? GetMatchedSuffix(string className);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators/OptionsNamingHelper/#parameters","title":"Parameters","text":"<p><code>className</code> System.String</p> <p>The options class name.</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators/OptionsNamingHelper/#returns","title":"Returns","text":"<p>System.String The matched suffix, or null if no suffix matches.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators/OptionsNamingHelper/#optionsnaminghelperinfersectionnamestring-method","title":"OptionsNamingHelper.InferSectionName(string) Method","text":"<p>Infers the configuration section name from a class name. Strips common suffixes (Options, Settings, Config) if present and the result is non-empty.</p> <pre><code>public static string InferSectionName(string className);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators/OptionsNamingHelper/#parameters_1","title":"Parameters","text":"<p><code>className</code> System.String</p> <p>The options class name.</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators/OptionsNamingHelper/#returns_1","title":"Returns","text":"<p>System.String The inferred section name.</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators/OptionsNamingHelper/#example","title":"Example","text":"<pre><code>InferSectionName(\"DatabaseOptions\") // returns \"Database\"\nInferSectionName(\"CacheSettings\")   // returns \"Cache\"\nInferSectionName(\"RedisConfig\")     // returns \"Redis\"\nInferSectionName(\"FeatureFlags\")    // returns \"FeatureFlags\" (no suffix match)\nInferSectionName(\"Options\")         // returns \"Options\" (would be empty after stripping)\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators/ProviderAttributeAnalyzer/","title":"ProviderAttributeAnalyzer","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/ProviderAttributeAnalyzer/#nexuslabsneedlrgenerators","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/ProviderAttributeAnalyzer/#nexuslabsneedlrgenerators_1","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/ProviderAttributeAnalyzer/#providerattributeanalyzer-class","title":"ProviderAttributeAnalyzer Class","text":"<p>Analyzer that validates [Provider] attribute usage: - NDLRGEN031: [Provider] on class requires `partial` modifier - NDLRGEN032: [Provider] interface must only contain get-only properties - NDLRGEN033: Provider property type is a concrete class - NDLRGEN034: Circular provider dependency detected</p> <pre><code>public sealed class ProviderAttributeAnalyzer\n</code></pre> <p>Inheritance Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer \ud83e\udc52 ProviderAttributeAnalyzer</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators/TypeDiscoveryHelper/","title":"TypeDiscoveryHelper","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/TypeDiscoveryHelper/#nexuslabsneedlrgenerators","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/TypeDiscoveryHelper/#nexuslabsneedlrroslynshared","title":"NexusLabs.Needlr.Roslyn.Shared","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/TypeDiscoveryHelper/#typediscoveryhelper-class","title":"TypeDiscoveryHelper Class","text":"<p>Shared helper utilities for discovering injectable types from Roslyn symbols. Used by both Generators and Analyzers to ensure consistent type discovery logic.</p> <pre><code>public static class TypeDiscoveryHelper\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 TypeDiscoveryHelper</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators/TypeDiscoveryHelper/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/TypeDiscoveryHelper/#typediscoveryhelperhasdonotautoregisterattributeinamedtypesymbol-method","title":"TypeDiscoveryHelper.HasDoNotAutoRegisterAttribute(INamedTypeSymbol) Method","text":"<p>Checks if a type has the [DoNotAutoRegister] attribute (directly or on interfaces).</p> <pre><code>public static bool HasDoNotAutoRegisterAttribute(INamedTypeSymbol typeSymbol);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators/TypeDiscoveryHelper/#parameters","title":"Parameters","text":"<p><code>typeSymbol</code> Microsoft.CodeAnalysis.INamedTypeSymbol</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators/TypeDiscoveryHelper/#returns","title":"Returns","text":"<p>System.Boolean</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators/TypeDiscoveryHelper/#typediscoveryhelperhasdonotautoregisterattributedirectinamedtypesymbol-method","title":"TypeDiscoveryHelper.HasDoNotAutoRegisterAttributeDirect(INamedTypeSymbol) Method","text":"<p>Checks if a type has the [DoNotAutoRegister] or [DoNotInject] attribute directly applied.</p> <pre><code>public static bool HasDoNotAutoRegisterAttributeDirect(INamedTypeSymbol typeSymbol);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators/TypeDiscoveryHelper/#parameters_1","title":"Parameters","text":"<p><code>typeSymbol</code> Microsoft.CodeAnalysis.INamedTypeSymbol</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators/TypeDiscoveryHelper/#returns_1","title":"Returns","text":"<p>System.Boolean</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators/TypeDiscoveryHelper/#typediscoveryhelperhasunsatisfiedrequiredmembersinamedtypesymbol-method","title":"TypeDiscoveryHelper.HasUnsatisfiedRequiredMembers(INamedTypeSymbol) Method","text":"<p>Checks if a type has required members that aren't satisfied by any constructor with [SetsRequiredMembers] attribute.</p> <pre><code>public static bool HasUnsatisfiedRequiredMembers(INamedTypeSymbol typeSymbol);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators/TypeDiscoveryHelper/#parameters_2","title":"Parameters","text":"<p><code>typeSymbol</code> Microsoft.CodeAnalysis.INamedTypeSymbol</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators/TypeDiscoveryHelper/#returns_2","title":"Returns","text":"<p>System.Boolean</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators/TypeDiscoveryHelper/#typediscoveryhelperinheritsfrominamedtypesymbol-string-method","title":"TypeDiscoveryHelper.InheritsFrom(INamedTypeSymbol, string) Method","text":"<p>Checks if a type inherits from a base type by name.</p> <pre><code>public static bool InheritsFrom(INamedTypeSymbol typeSymbol, string baseTypeName);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators/TypeDiscoveryHelper/#parameters_3","title":"Parameters","text":"<p><code>typeSymbol</code> Microsoft.CodeAnalysis.INamedTypeSymbol</p> <p></p> <p><code>baseTypeName</code> System.String</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators/TypeDiscoveryHelper/#returns_3","title":"Returns","text":"<p>System.Boolean</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators/TypeDiscoveryHelper/#typediscoveryhelperisaccessiblefromgeneratedcodeinamedtypesymbol-bool-method","title":"TypeDiscoveryHelper.IsAccessibleFromGeneratedCode(INamedTypeSymbol, bool) Method","text":"<p>Checks if a type is accessible from generated code. For types in the current assembly, internal and public types are accessible. For types in referenced assemblies, only public types are accessible.</p> <pre><code>public static bool IsAccessibleFromGeneratedCode(INamedTypeSymbol typeSymbol, bool isCurrentAssembly);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators/TypeDiscoveryHelper/#parameters_4","title":"Parameters","text":"<p><code>typeSymbol</code> Microsoft.CodeAnalysis.INamedTypeSymbol</p> <p></p> <p><code>isCurrentAssembly</code> System.Boolean</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators/TypeDiscoveryHelper/#returns_4","title":"Returns","text":"<p>System.Boolean</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators/TypeDiscoveryHelper/#typediscoveryhelperiscompilergeneratedinamedtypesymbol-method","title":"TypeDiscoveryHelper.IsCompilerGenerated(INamedTypeSymbol) Method","text":"<p>Checks if a type is compiler-generated.</p> <pre><code>public static bool IsCompilerGenerated(INamedTypeSymbol typeSymbol);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators/TypeDiscoveryHelper/#parameters_5","title":"Parameters","text":"<p><code>typeSymbol</code> Microsoft.CodeAnalysis.INamedTypeSymbol</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators/TypeDiscoveryHelper/#returns_5","title":"Returns","text":"<p>System.Boolean</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators/TypeDiscoveryHelper/#typediscoveryhelperisinjectabletypeinamedtypesymbol-bool-method","title":"TypeDiscoveryHelper.IsInjectableType(INamedTypeSymbol, bool) Method","text":"<p>Determines whether a type symbol represents a concrete injectable type.</p> <pre><code>public static bool IsInjectableType(INamedTypeSymbol typeSymbol, bool isCurrentAssembly=false);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators/TypeDiscoveryHelper/#parameters_6","title":"Parameters","text":"<p><code>typeSymbol</code> Microsoft.CodeAnalysis.INamedTypeSymbol</p> <p>The type symbol to check.</p> <p></p> <p><code>isCurrentAssembly</code> System.Boolean</p> <p>True if the type is from the current compilation's assembly (allows internal types).</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators/TypeDiscoveryHelper/#returns_6","title":"Returns","text":"<p>System.Boolean True if the type is a valid injectable type; otherwise, false.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators/TypeDiscoveryHelper/#typediscoveryhelperissystemtypeinamedtypesymbol-method","title":"TypeDiscoveryHelper.IsSystemType(INamedTypeSymbol) Method","text":"<p>Checks if a type is from the System namespace or system assemblies.</p> <pre><code>public static bool IsSystemType(INamedTypeSymbol typeSymbol);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators/TypeDiscoveryHelper/#parameters_7","title":"Parameters","text":"<p><code>typeSymbol</code> Microsoft.CodeAnalysis.INamedTypeSymbol</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators/TypeDiscoveryHelper/#returns_7","title":"Returns","text":"<p>System.Boolean</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators/TypeRegistryGenerator/","title":"TypeRegistryGenerator","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/TypeRegistryGenerator/#nexuslabsneedlrgenerators","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/TypeRegistryGenerator/#nexuslabsneedlrgenerators_1","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/TypeRegistryGenerator/#typeregistrygenerator-class","title":"TypeRegistryGenerator Class","text":"<p>Incremental source generator that produces a compile-time type registry for dependency injection, eliminating runtime reflection.</p> <pre><code>public sealed class TypeRegistryGenerator\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 Microsoft.CodeAnalysis.IIncrementalGenerator \ud83e\udc52 TypeRegistryGenerator</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators/UnsupportedDataAnnotationAnalyzer/","title":"UnsupportedDataAnnotationAnalyzer","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/UnsupportedDataAnnotationAnalyzer/#nexuslabsneedlrgenerators","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/UnsupportedDataAnnotationAnalyzer/#nexuslabsneedlrgenerators_1","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators/UnsupportedDataAnnotationAnalyzer/#unsupporteddataannotationanalyzer-class","title":"UnsupportedDataAnnotationAnalyzer Class","text":"<p>Analyzer that warns when [Options] classes use DataAnnotation validation attributes that cannot be source-generated.</p> <p>NDLRGEN030: DataAnnotation attribute cannot be source-generated</p> <pre><code>public sealed class UnsupportedDataAnnotationAnalyzer\n</code></pre> <p>Inheritance Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer \ud83e\udc52 UnsupportedDataAnnotationAnalyzer</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/","title":"NexusLabs.Needlr.Generators.Attributes","text":"<ul> <li>FactoryGenerationMode</li> <li>GenerateFactoryAttribute</li> <li>GenerateFactoryAttribute_TInterface_</li> <li>GenerateTypeRegistryAttribute</li> <li>IOptionsValidator_T_</li> <li>InjectableLifetime</li> <li>InjectableTypeInfo</li> <li>NeedlrSourceGenBootstrap</li> <li>NexusLabs.Needlr.Generators</li> <li>OpenDecoratorForAttribute</li> <li>OptionsAttribute</li> <li>PluginTypeInfo</li> <li>ProviderAttribute</li> <li>ValidationError</li> <li>ValidationSeverity</li> <li>ValidatorProviderAttribute</li> </ul>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/FactoryGenerationMode/","title":"FactoryGenerationMode","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/FactoryGenerationMode/#nexuslabsneedlrgenerators","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/FactoryGenerationMode/#factorygenerationmode-enum","title":"FactoryGenerationMode Enum","text":"<p>Controls what factory artifacts are generated for types marked with GenerateFactoryAttribute.</p> <pre><code>public enum FactoryGenerationMode\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/FactoryGenerationMode/#fields","title":"Fields","text":"<p><code>Func</code> 1</p> <p>Generate Func\\&lt;TRuntime..., TService&gt; registrations.</p> <p></p> <p><code>Interface</code> 2</p> <p>Generate I{TypeName}Factory interface and implementation.</p> <p></p> <p><code>All</code> 3</p> <p>Generate both Func and Interface (default).</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/GenerateFactoryAttribute/","title":"GenerateFactoryAttribute","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/GenerateFactoryAttribute/#nexuslabsneedlrgenerators","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/GenerateFactoryAttribute/#generatefactoryattribute-class","title":"GenerateFactoryAttribute Class","text":"<p>Generates a factory for this type, allowing runtime parameters to be  specified while auto-injecting the rest from the service provider.</p> <pre><code>public sealed class GenerateFactoryAttribute : System.Attribute\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 System.Attribute \ud83e\udc52 GenerateFactoryAttribute</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/GenerateFactoryAttribute/#example","title":"Example","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n[GenerateFactory]\npublic class MyService : IMyService\n{\n    public MyService(IDependency dep, string connectionString) { }\n}\n\n// Generated: IMyServiceFactory with Create(string connectionString) returning MyService\n// Generated: Func&lt;string, MyService&gt;\n// Consumer can inject either and create instances with runtime params\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/GenerateFactoryAttribute/#remarks","title":"Remarks","text":"<p>This is a source-generation only feature. It requires the NexusLabs.Needlr.Generators package and has no effect when using reflection-based registration.</p> <p>When applied to a class with mixed injectable and non-injectable constructor parameters, the generator will create: - A <code>Func&lt;TRuntime..., TService&gt;</code> that takes only the non-injectable parameters - An <code>I{TypeName}Factory</code> interface with a <code>Create()</code> method</p> <p>The type itself is NOT registered in the container - only the factory is.</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/GenerateFactoryAttribute/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/GenerateFactoryAttribute/#generatefactoryattributemode-property","title":"GenerateFactoryAttribute.Mode Property","text":"<p>Controls what factory artifacts are generated. Default: All</p> <pre><code>public NexusLabs.Needlr.Generators.FactoryGenerationMode Mode { get; set; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/GenerateFactoryAttribute/#property-value","title":"Property Value","text":"<p>FactoryGenerationMode</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/GenerateFactoryAttribute_TInterface_/","title":"GenerateFactoryAttribute TInterface","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/GenerateFactoryAttribute_TInterface_/#nexuslabsneedlrgenerators","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/GenerateFactoryAttribute_TInterface_/#generatefactoryattributetinterface-class","title":"GenerateFactoryAttribute&lt;TInterface&gt; Class","text":"<p>Generates a factory for this type that returns the specified interface type, allowing runtime parameters to be specified while auto-injecting the rest from the service provider.</p> <pre><code>public sealed class GenerateFactoryAttribute&lt;TInterface&gt; : System.Attribute\n    where TInterface : class\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/GenerateFactoryAttribute_TInterface_/#type-parameters","title":"Type parameters","text":"<p><code>TInterface</code></p> <p>The interface type that the factory's <code>Create()</code> method will return. Must be an interface implemented by the decorated class.</p> <p>Inheritance System.Object \ud83e\udc52 System.Attribute \ud83e\udc52 GenerateFactoryAttribute\\&lt;TInterface&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/GenerateFactoryAttribute_TInterface_/#example","title":"Example","text":"<pre><code>using NexusLabs.Needlr.Generators;\n\n[GenerateFactory&lt;IMyService&gt;]\npublic class MyService : IMyService\n{\n    public MyService(IDependency dep, string connectionString) { }\n}\n\n// Generated: IMyServiceFactory with Create(string connectionString) returning IMyService\n// Generated: Func&lt;string, IMyService&gt;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/GenerateFactoryAttribute_TInterface_/#remarks","title":"Remarks","text":"<p>This is a source-generation only feature. It requires the NexusLabs.Needlr.Generators package and has no effect when using reflection-based registration.</p> <p>Use this generic variant when you need the factory to return an interface type for: - Mocking the factory's return value in tests - Abstracting the concrete implementation from consumers</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/GenerateFactoryAttribute_TInterface_/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/GenerateFactoryAttribute_TInterface_/#generatefactoryattributetinterfacemode-property","title":"GenerateFactoryAttribute&lt;TInterface&gt;.Mode Property","text":"<p>Controls what factory artifacts are generated. Default: All</p> <pre><code>public NexusLabs.Needlr.Generators.FactoryGenerationMode Mode { get; set; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/GenerateFactoryAttribute_TInterface_/#property-value","title":"Property Value","text":"<p>FactoryGenerationMode</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/GenerateTypeRegistryAttribute/","title":"GenerateTypeRegistryAttribute","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/GenerateTypeRegistryAttribute/#nexuslabsneedlrgenerators","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/GenerateTypeRegistryAttribute/#generatetyperegistryattribute-class","title":"GenerateTypeRegistryAttribute Class","text":"<p>Marks an assembly for compile-time type registry generation. The source generator will scan all referenced assemblies and generate a TypeRegistry class containing all injectable types.</p> <pre><code>public sealed class GenerateTypeRegistryAttribute : System.Attribute\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 System.Attribute \ud83e\udc52 GenerateTypeRegistryAttribute</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/GenerateTypeRegistryAttribute/#example","title":"Example","text":"<pre><code>// Include all types from NexusLabs and MyCompany namespaces\n[assembly: GenerateTypeRegistry(IncludeNamespacePrefixes = new[] { \"NexusLabs\", \"MyCompany\" })]\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/GenerateTypeRegistryAttribute/#remarks","title":"Remarks","text":"<p>This attribute triggers the source generator to analyze all types in referenced assemblies at compile time, eliminating the need for runtime reflection-based type discovery.</p> <p>Use IncludeNamespacePrefixes to filter which types are included in the generated registry. This is similar to the <code>MatchingAssemblies()</code> method in the reflection-based approach.</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/GenerateTypeRegistryAttribute/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/GenerateTypeRegistryAttribute/#generatetyperegistryattributeincludenamespaceprefixes-property","title":"GenerateTypeRegistryAttribute.IncludeNamespacePrefixes Property","text":"<p>Gets or sets namespace prefix filters. Only types in namespaces starting with these prefixes will be included in the generated registry.</p> <pre><code>public string[]? IncludeNamespacePrefixes { get; set; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/GenerateTypeRegistryAttribute/#property-value","title":"Property Value","text":"<p>System.String[]</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/GenerateTypeRegistryAttribute/#remarks_1","title":"Remarks","text":"<p>This is analogous to the <code>MatchingAssemblies()</code> configuration in the reflection-based approach. If null or empty, all namespaces are included.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/GenerateTypeRegistryAttribute/#generatetyperegistryattributeincludeself-property","title":"GenerateTypeRegistryAttribute.IncludeSelf Property","text":"<p>Gets or sets whether to include types from the current assembly in addition to referenced assemblies.</p> <pre><code>public bool IncludeSelf { get; set; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/GenerateTypeRegistryAttribute/#property-value_1","title":"Property Value","text":"<p>System.Boolean</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/GenerateTypeRegistryAttribute/#remarks_2","title":"Remarks","text":"<p>Defaults to <code>true</code>. Set to <code>false</code> to only include types from project references.</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/IOptionsValidator_T_/","title":"IOptionsValidator T","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/IOptionsValidator_T_/#nexuslabsneedlrgenerators","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/IOptionsValidator_T_/#ioptionsvalidatort-interface","title":"IOptionsValidator&lt;T&gt; Interface","text":"<p>Interface for validating options types.</p> <pre><code>public interface IOptionsValidator&lt;in T&gt;\n    where T : class\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/IOptionsValidator_T_/#type-parameters","title":"Type parameters","text":"<p><code>T</code></p> <p>The options type to validate.</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/IOptionsValidator_T_/#example","title":"Example","text":"<pre><code>[Options(ValidateOnStart = true, Validator = typeof(StripeOptionsValidator))]\npublic class StripeOptions\n{\n    public string ApiKey { get; set; } = \"\";\n}\n\npublic class StripeOptionsValidator : IOptionsValidator&lt;StripeOptions&gt;\n{\n    public IEnumerable&lt;ValidationError&gt; Validate(StripeOptions options)\n    {\n        if (!options.ApiKey.StartsWith(\"sk_\"))\n            yield return new ValidationError\n            {\n                Message = \"API key must start with 'sk_'\",\n                PropertyName = nameof(StripeOptions.ApiKey)\n            };\n    }\n}\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/IOptionsValidator_T_/#remarks","title":"Remarks","text":"<p>Implement this interface to create an external validator for an options type. The validator is specified using the <code>Validator</code> property on the OptionsAttribute.</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/IOptionsValidator_T_/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/IOptionsValidator_T_/#ioptionsvalidatortvalidatet-method","title":"IOptionsValidator&lt;T&gt;.Validate(T) Method","text":"<p>Validates the specified options instance.</p> <pre><code>System.Collections.Generic.IEnumerable&lt;NexusLabs.Needlr.Generators.ValidationError&gt; Validate(T options);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/IOptionsValidator_T_/#parameters","title":"Parameters","text":"<p><code>options</code> T</p> <p>The options instance to validate.</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/IOptionsValidator_T_/#returns","title":"Returns","text":"<p>System.Collections.Generic.IEnumerable&lt;ValidationError&gt; An enumerable of validation errors. Return an empty enumerable if validation succeeds.</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/InjectableLifetime/","title":"InjectableLifetime","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/InjectableLifetime/#nexuslabsneedlrgenerators","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/InjectableLifetime/#injectablelifetime-enum","title":"InjectableLifetime Enum","text":"<p>Specifies the lifetime of a service in the dependency injection container.</p> <pre><code>public enum InjectableLifetime\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/InjectableLifetime/#fields","title":"Fields","text":"<p><code>Singleton</code> 0</p> <p>A single instance is created and shared across all requests.</p> <p></p> <p><code>Scoped</code> 1</p> <p>A new instance is created for each scope (e.g., each HTTP request).</p> <p></p> <p><code>Transient</code> 2</p> <p>A new instance is created each time the service is requested.</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/InjectableLifetime/#remarks","title":"Remarks","text":"<p>This enum mirrors <code>Microsoft.Extensions.DependencyInjection.ServiceLifetime</code> to avoid adding a dependency on that package in the attributes assembly.</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/InjectableTypeInfo/","title":"InjectableTypeInfo","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/InjectableTypeInfo/#nexuslabsneedlrgenerators","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/InjectableTypeInfo/#injectabletypeinfo-struct","title":"InjectableTypeInfo Struct","text":"<p>Represents metadata about an injectable type discovered at compile time.</p> <pre><code>public readonly struct InjectableTypeInfo\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/InjectableTypeInfo/#remarks","title":"Remarks","text":"<p>This struct is used by the generated TypeRegistry to provide type information without requiring reflection at runtime.</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/InjectableTypeInfo/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/InjectableTypeInfo/#injectabletypeinfotype-ireadonlylisttype-constructor","title":"InjectableTypeInfo(Type, IReadOnlyList&lt;Type&gt;) Constructor","text":"<p>Initializes a new instance of InjectableTypeInfo.</p> <pre><code>public InjectableTypeInfo(System.Type type, System.Collections.Generic.IReadOnlyList&lt;System.Type&gt; interfaces);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/InjectableTypeInfo/#parameters","title":"Parameters","text":"<p><code>type</code> System.Type</p> <p>The concrete implementation type.</p> <p></p> <p><code>interfaces</code> System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;</p> <p>The interfaces implemented by the type that should be registered.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/InjectableTypeInfo/#injectabletypeinfotype-ireadonlylisttype-nullableinjectablelifetime-constructor","title":"InjectableTypeInfo(Type, IReadOnlyList&lt;Type&gt;, Nullable&lt;InjectableLifetime&gt;) Constructor","text":"<p>Initializes a new instance of InjectableTypeInfo.</p> <pre><code>public InjectableTypeInfo(System.Type type, System.Collections.Generic.IReadOnlyList&lt;System.Type&gt; interfaces, System.Nullable&lt;NexusLabs.Needlr.Generators.InjectableLifetime&gt; lifetime);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/InjectableTypeInfo/#parameters_1","title":"Parameters","text":"<p><code>type</code> System.Type</p> <p>The concrete implementation type.</p> <p></p> <p><code>interfaces</code> System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;</p> <p>The interfaces implemented by the type that should be registered.</p> <p></p> <p><code>lifetime</code> System.Nullable&lt;InjectableLifetime&gt;</p> <p>The pre-computed service lifetime, or null if not determined.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/InjectableTypeInfo/#injectabletypeinfotype-ireadonlylisttype-nullableinjectablelifetime-funciserviceproviderobject-constructor","title":"InjectableTypeInfo(Type, IReadOnlyList&lt;Type&gt;, Nullable&lt;InjectableLifetime&gt;, Func&lt;IServiceProvider,object&gt;) Constructor","text":"<p>Initializes a new instance of InjectableTypeInfo.</p> <pre><code>public InjectableTypeInfo(System.Type type, System.Collections.Generic.IReadOnlyList&lt;System.Type&gt; interfaces, System.Nullable&lt;NexusLabs.Needlr.Generators.InjectableLifetime&gt; lifetime, System.Func&lt;System.IServiceProvider,object&gt;? factory);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/InjectableTypeInfo/#parameters_2","title":"Parameters","text":"<p><code>type</code> System.Type</p> <p>The concrete implementation type.</p> <p></p> <p><code>interfaces</code> System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;</p> <p>The interfaces implemented by the type that should be registered.</p> <p></p> <p><code>lifetime</code> System.Nullable&lt;InjectableLifetime&gt;</p> <p>The pre-computed service lifetime, or null if not determined.</p> <p></p> <p><code>factory</code> System.Func&lt;System.IServiceProvider,System.Object&gt;</p> <p>A factory delegate that creates an instance of the type using the service provider. When provided, enables AOT-compatible instantiation without runtime reflection.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/InjectableTypeInfo/#injectabletypeinfotype-ireadonlylisttype-nullableinjectablelifetime-funciserviceproviderobject-ireadonlyliststring-constructor","title":"InjectableTypeInfo(Type, IReadOnlyList&lt;Type&gt;, Nullable&lt;InjectableLifetime&gt;, Func&lt;IServiceProvider,object&gt;, IReadOnlyList&lt;string&gt;) Constructor","text":"<p>Initializes a new instance of InjectableTypeInfo with keyed service support.</p> <pre><code>public InjectableTypeInfo(System.Type type, System.Collections.Generic.IReadOnlyList&lt;System.Type&gt; interfaces, System.Nullable&lt;NexusLabs.Needlr.Generators.InjectableLifetime&gt; lifetime, System.Func&lt;System.IServiceProvider,object&gt;? factory, System.Collections.Generic.IReadOnlyList&lt;string&gt; serviceKeys);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/InjectableTypeInfo/#parameters_3","title":"Parameters","text":"<p><code>type</code> System.Type</p> <p>The concrete implementation type.</p> <p></p> <p><code>interfaces</code> System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;</p> <p>The interfaces implemented by the type that should be registered.</p> <p></p> <p><code>lifetime</code> System.Nullable&lt;InjectableLifetime&gt;</p> <p>The pre-computed service lifetime, or null if not determined.</p> <p></p> <p><code>factory</code> System.Func&lt;System.IServiceProvider,System.Object&gt;</p> <p>A factory delegate that creates an instance of the type using the service provider. When provided, enables AOT-compatible instantiation without runtime reflection.</p> <p></p> <p><code>serviceKeys</code> System.Collections.Generic.IReadOnlyList&lt;System.String&gt;</p> <p>The service keys from [Keyed] attributes. When provided, the type will be registered as a keyed service in addition to its normal registration.</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/InjectableTypeInfo/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/InjectableTypeInfo/#injectabletypeinfofactory-property","title":"InjectableTypeInfo.Factory Property","text":"<p>Gets a factory delegate that creates an instance of the type using the service provider.</p> <pre><code>public System.Func&lt;System.IServiceProvider,object&gt;? Factory { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/InjectableTypeInfo/#property-value","title":"Property Value","text":"<p>System.Func&lt;System.IServiceProvider,System.Object&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/InjectableTypeInfo/#remarks_1","title":"Remarks","text":"<p>When this delegate is provided, the type registrar can use it to create instances without relying on <code>Activator.CreateInstance</code> or reflection-based constructor invocation. This is essential for NativeAOT scenarios where reflection may be disabled.</p> <p>The factory receives an System.IServiceProvider and should resolve all constructor dependencies from it before creating the instance.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/InjectableTypeInfo/#injectabletypeinfointerfaces-property","title":"InjectableTypeInfo.Interfaces Property","text":"<p>Gets the interfaces implemented by the type that should be registered.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;System.Type&gt; Interfaces { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/InjectableTypeInfo/#property-value_1","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/InjectableTypeInfo/#injectabletypeinfolifetime-property","title":"InjectableTypeInfo.Lifetime Property","text":"<p>Gets the pre-computed service lifetime for this type, or null if the lifetime should be determined at runtime by an <code>ITypeFilterer</code>.</p> <pre><code>public System.Nullable&lt;NexusLabs.Needlr.Generators.InjectableLifetime&gt; Lifetime { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/InjectableTypeInfo/#property-value_2","title":"Property Value","text":"<p>System.Nullable&lt;InjectableLifetime&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/InjectableTypeInfo/#remarks_2","title":"Remarks","text":"<p>When this value is set, the type registrar can skip runtime reflection for constructor analysis, improving startup performance and enabling AOT compilation scenarios.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/InjectableTypeInfo/#injectabletypeinfoservicekeys-property","title":"InjectableTypeInfo.ServiceKeys Property","text":"<p>Gets the service keys from [Keyed] attributes on this type.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;string&gt; ServiceKeys { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/InjectableTypeInfo/#property-value_3","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;System.String&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/InjectableTypeInfo/#remarks_3","title":"Remarks","text":"<p>When service keys are present, the type will be registered as a keyed service in addition to its normal registration. Consumers can then resolve the specific implementation using <code>[FromKeyedServices(\"key\")]</code> on constructor parameters.</p> <p>A type can have multiple keys, resulting in multiple keyed registrations for the same implementation.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/InjectableTypeInfo/#injectabletypeinfotype-property","title":"InjectableTypeInfo.Type Property","text":"<p>Gets the concrete implementation type.</p> <pre><code>public System.Type Type { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/InjectableTypeInfo/#property-value_4","title":"Property Value","text":"<p>System.Type</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/NeedlrSourceGenBootstrap/","title":"NeedlrSourceGenBootstrap","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/NeedlrSourceGenBootstrap/#nexuslabsneedlrgenerators","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/NeedlrSourceGenBootstrap/#needlrsourcegenbootstrap-class","title":"NeedlrSourceGenBootstrap Class","text":"<p>Runtime bootstrap registry for source-generated Needlr components.</p> <pre><code>public static class NeedlrSourceGenBootstrap\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 NeedlrSourceGenBootstrap</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/NeedlrSourceGenBootstrap/#remarks","title":"Remarks","text":"<p>The source generator emits a module initializer in the host assembly that calls one of the Register overloads with the generated TypeRegistry providers. Needlr runtime can then discover generated registries without any runtime reflection.</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/NeedlrSourceGenBootstrap/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/NeedlrSourceGenBootstrap/#needlrsourcegenbootstrapregisterfuncireadonlylistinjectabletypeinfo-funcireadonlylistplugintypeinfo-method","title":"NeedlrSourceGenBootstrap.Register(Func&lt;IReadOnlyList&lt;InjectableTypeInfo&gt;&gt;, Func&lt;IReadOnlyList&lt;PluginTypeInfo&gt;&gt;) Method","text":"<p>Registers the generated type and plugin providers for this application.</p> <pre><code>public static void Register(System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.InjectableTypeInfo&gt;&gt; injectableTypeProvider, System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.PluginTypeInfo&gt;&gt; pluginTypeProvider);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/NeedlrSourceGenBootstrap/#parameters","title":"Parameters","text":"<p><code>injectableTypeProvider</code> System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;InjectableTypeInfo&gt;&gt;</p> <p></p> <p><code>pluginTypeProvider</code> System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;PluginTypeInfo&gt;&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/NeedlrSourceGenBootstrap/#needlrsourcegenbootstrapregisterfuncireadonlylistinjectabletypeinfo-funcireadonlylistplugintypeinfo-actionobject-method","title":"NeedlrSourceGenBootstrap.Register(Func&lt;IReadOnlyList&lt;InjectableTypeInfo&gt;&gt;, Func&lt;IReadOnlyList&lt;PluginTypeInfo&gt;&gt;, Action&lt;object&gt;) Method","text":"<p>Registers the generated type, plugin, and decorator providers for this application.</p> <pre><code>public static void Register(System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.InjectableTypeInfo&gt;&gt; injectableTypeProvider, System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.PluginTypeInfo&gt;&gt; pluginTypeProvider, System.Action&lt;object&gt;? decoratorApplier);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/NeedlrSourceGenBootstrap/#parameters_1","title":"Parameters","text":"<p><code>injectableTypeProvider</code> System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;InjectableTypeInfo&gt;&gt;</p> <p>Provider for injectable types.</p> <p></p> <p><code>pluginTypeProvider</code> System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;PluginTypeInfo&gt;&gt;</p> <p>Provider for plugin types.</p> <p></p> <p><code>decoratorApplier</code> System.Action&lt;System.Object&gt;</p> <p>Action that applies decorators to the service collection.  The parameter is an IServiceCollection, but typed as object to avoid dependency on Microsoft.Extensions.DependencyInjection in this assembly.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/NeedlrSourceGenBootstrap/#needlrsourcegenbootstrapregisterfuncireadonlylistinjectabletypeinfo-funcireadonlylistplugintypeinfo-actionobject-actionobjectobject-method","title":"NeedlrSourceGenBootstrap.Register(Func&lt;IReadOnlyList&lt;InjectableTypeInfo&gt;&gt;, Func&lt;IReadOnlyList&lt;PluginTypeInfo&gt;&gt;, Action&lt;object&gt;, Action&lt;object,object&gt;) Method","text":"<p>Registers the generated type, plugin, decorator, and options providers for this application.</p> <pre><code>public static void Register(System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.InjectableTypeInfo&gt;&gt; injectableTypeProvider, System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.PluginTypeInfo&gt;&gt; pluginTypeProvider, System.Action&lt;object&gt;? decoratorApplier, System.Action&lt;object,object&gt;? optionsRegistrar);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/NeedlrSourceGenBootstrap/#parameters_2","title":"Parameters","text":"<p><code>injectableTypeProvider</code> System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;InjectableTypeInfo&gt;&gt;</p> <p>Provider for injectable types.</p> <p></p> <p><code>pluginTypeProvider</code> System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;PluginTypeInfo&gt;&gt;</p> <p>Provider for plugin types.</p> <p></p> <p><code>decoratorApplier</code> System.Action&lt;System.Object&gt;</p> <p>Action that applies decorators to the service collection.  The parameter is an IServiceCollection, but typed as object to avoid dependency on Microsoft.Extensions.DependencyInjection in this assembly.</p> <p></p> <p><code>optionsRegistrar</code> System.Action&lt;System.Object,System.Object&gt;</p> <p>Action that registers options with the service collection and configuration. Parameters are (IServiceCollection, IConfiguration), typed as object to avoid dependencies.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/NeedlrSourceGenBootstrap/#needlrsourcegenbootstrapregisterextensionactionobjectobject-method","title":"NeedlrSourceGenBootstrap.RegisterExtension(Action&lt;object,object&gt;) Method","text":"<p>Registers an extension that provides additional service registrations. Extensions are invoked after the main options registrar during BuildServiceProvider.</p> <pre><code>public static void RegisterExtension(System.Action&lt;object,object&gt; extensionRegistrar);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/NeedlrSourceGenBootstrap/#parameters_3","title":"Parameters","text":"<p><code>extensionRegistrar</code> System.Action&lt;System.Object,System.Object&gt;</p> <p>Action that registers extension services with the service collection and configuration. Parameters are (IServiceCollection, IConfiguration), typed as object to avoid dependencies.</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/NeedlrSourceGenBootstrap/#remarks_1","title":"Remarks","text":"<p>Use this method from extension package module initializers to register additional services. For example, FluentValidation can register its validators without modifying core Needlr.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/NeedlrSourceGenBootstrap/#needlrsourcegenbootstraptrygetdecoratorapplieractionobject-method","title":"NeedlrSourceGenBootstrap.TryGetDecoratorApplier(Action&lt;object&gt;) Method","text":"<p>Gets the decorator applier (if any).</p> <pre><code>public static bool TryGetDecoratorApplier(out System.Action&lt;object&gt;? decoratorApplier);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/NeedlrSourceGenBootstrap/#parameters_4","title":"Parameters","text":"<p><code>decoratorApplier</code> System.Action&lt;System.Object&gt;</p> <p>Action that applies decorators to the service collection. The parameter is an IServiceCollection, but typed as object to avoid dependency on Microsoft.Extensions.DependencyInjection in this assembly.</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/NeedlrSourceGenBootstrap/#returns","title":"Returns","text":"<p>System.Boolean True if a decorator applier is registered.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/NeedlrSourceGenBootstrap/#needlrsourcegenbootstraptrygetextensionregistraractionobjectobject-method","title":"NeedlrSourceGenBootstrap.TryGetExtensionRegistrar(Action&lt;object,object&gt;) Method","text":"<p>Gets the combined extension registrar (if any extensions are registered).</p> <pre><code>public static bool TryGetExtensionRegistrar(out System.Action&lt;object,object&gt;? extensionRegistrar);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/NeedlrSourceGenBootstrap/#parameters_5","title":"Parameters","text":"<p><code>extensionRegistrar</code> System.Action&lt;System.Object,System.Object&gt;</p> <p>Combined action that invokes all registered extensions. Parameters are (IServiceCollection, IConfiguration), typed as object to avoid dependencies.</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/NeedlrSourceGenBootstrap/#returns_1","title":"Returns","text":"<p>System.Boolean True if any extension registrars are registered.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/NeedlrSourceGenBootstrap/#needlrsourcegenbootstraptrygetoptionsregistraractionobjectobject-method","title":"NeedlrSourceGenBootstrap.TryGetOptionsRegistrar(Action&lt;object,object&gt;) Method","text":"<p>Gets the options registrar (if any).</p> <pre><code>public static bool TryGetOptionsRegistrar(out System.Action&lt;object,object&gt;? optionsRegistrar);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/NeedlrSourceGenBootstrap/#parameters_6","title":"Parameters","text":"<p><code>optionsRegistrar</code> System.Action&lt;System.Object,System.Object&gt;</p> <p>Action that registers options with the service collection and configuration. Parameters are (IServiceCollection, IConfiguration), typed as object to avoid dependencies.</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/NeedlrSourceGenBootstrap/#returns_2","title":"Returns","text":"<p>System.Boolean True if an options registrar is registered.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/NeedlrSourceGenBootstrap/#needlrsourcegenbootstraptrygetprovidersfuncireadonlylistinjectabletypeinfo-funcireadonlylistplugintypeinfo-method","title":"NeedlrSourceGenBootstrap.TryGetProviders(Func&lt;IReadOnlyList&lt;InjectableTypeInfo&gt;&gt;, Func&lt;IReadOnlyList&lt;PluginTypeInfo&gt;&gt;) Method","text":"<p>Gets the registered providers (if any).</p> <pre><code>public static bool TryGetProviders(out System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.InjectableTypeInfo&gt;&gt; injectableTypeProvider, out System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.PluginTypeInfo&gt;&gt; pluginTypeProvider);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/NeedlrSourceGenBootstrap/#parameters_7","title":"Parameters","text":"<p><code>injectableTypeProvider</code> System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;InjectableTypeInfo&gt;&gt;</p> <p></p> <p><code>pluginTypeProvider</code> System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;PluginTypeInfo&gt;&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/NeedlrSourceGenBootstrap/#returns_3","title":"Returns","text":"<p>System.Boolean</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/NexusLabs.Needlr.Generators/","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/NexusLabs.Needlr.Generators/#nexuslabsneedlrgenerators-namespace","title":"NexusLabs.Needlr.Generators Namespace","text":"Classes GenerateFactoryAttribute Generates a factory for this type, allowing runtime parameters to be  specified while auto-injecting the rest from the service provider. GenerateFactoryAttribute&lt;TInterface&gt; Generates a factory for this type that returns the specified interface type, allowing runtime parameters to be specified while auto-injecting the rest from the service provider. GenerateTypeRegistryAttribute Marks an assembly for compile-time type registry generation. The source generator will scan all referenced assemblies and generate a TypeRegistry class containing all injectable types. NeedlrSourceGenBootstrap Runtime bootstrap registry for source-generated Needlr components. OpenDecoratorForAttribute Marks a generic class as a decorator for all closed implementations of an open generic interface. This is a source-generation only feature - the generator discovers all closed implementations at compile time and emits decorator registrations for each. OptionsAttribute Marks a class as an options/configuration type that should be bound to a configuration section. The source generator will automatically generate the <code>services.Configure&lt;T&gt;()</code> call. ProviderAttribute Marks an interface or partial class as a Provider - a strongly-typed service locator. ValidationError Represents a validation error with optional structured information. ValidatorProviderAttribute Marks an assembly as providing a validator base type that the Needlr analyzer should recognize. When a type used with <code>[Options(Validator = typeof(...))]</code> inherits from the specified base type, the analyzer will not report NDLRGEN014 (validator missing interface). Structs InjectableTypeInfo Represents metadata about an injectable type discovered at compile time. PluginTypeInfo Represents metadata about a plugin type discovered at compile time. Interfaces IOptionsValidator&lt;T&gt; Interface for validating options types. Enums FactoryGenerationMode Controls what factory artifacts are generated for types marked with GenerateFactoryAttribute. InjectableLifetime Specifies the lifetime of a service in the dependency injection container. ValidationSeverity Specifies the severity of a validation error."},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OpenDecoratorForAttribute/","title":"OpenDecoratorForAttribute","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OpenDecoratorForAttribute/#nexuslabsneedlrgenerators","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OpenDecoratorForAttribute/#opendecoratorforattribute-class","title":"OpenDecoratorForAttribute Class","text":"<p>Marks a generic class as a decorator for all closed implementations of an open generic interface. This is a source-generation only feature - the generator discovers all closed implementations at compile time and emits decorator registrations for each.</p> <pre><code>public sealed class OpenDecoratorForAttribute : System.Attribute\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 System.Attribute \ud83e\udc52 OpenDecoratorForAttribute</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OpenDecoratorForAttribute/#example","title":"Example","text":"<pre><code>public interface IHandler&lt;T&gt;\n{\n    Task HandleAsync(T message);\n}\n\n// Concrete handlers\npublic class OrderHandler : IHandler&lt;Order&gt; { ... }\npublic class PaymentHandler : IHandler&lt;Payment&gt; { ... }\n\n// Open generic decorator - applies to ALL IHandler&lt;T&gt; implementations\n[OpenDecoratorFor(typeof(IHandler&lt;&gt;))]\npublic class LoggingDecorator&lt;T&gt; : IHandler&lt;T&gt;\n{\n    private readonly IHandler&lt;T&gt; _inner;\n    private readonly ILogger&lt;LoggingDecorator&lt;T&gt;&gt; _logger;\n\n    public LoggingDecorator(IHandler&lt;T&gt; inner, ILogger&lt;LoggingDecorator&lt;T&gt;&gt; logger)\n    {\n        _inner = inner;\n        _logger = logger;\n    }\n\n    public async Task HandleAsync(T message)\n    {\n        _logger.LogInformation(\"Handling {Type}\", typeof(T).Name);\n        await _inner.HandleAsync(message);\n        _logger.LogInformation(\"Handled {Type}\", typeof(T).Name);\n    }\n}\n\n// Generator emits:\n// services.AddDecorator&lt;IHandler&lt;Order&gt;, LoggingDecorator&lt;Order&gt;&gt;();\n// services.AddDecorator&lt;IHandler&lt;Payment&gt;, LoggingDecorator&lt;Payment&gt;&gt;();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OpenDecoratorForAttribute/#remarks","title":"Remarks","text":"<p>Use this attribute when you want to apply a single decorator implementation to ALL closed types of an open generic interface. For example, to add logging to every <code>IHandler&lt;T&gt;</code> implementation.</p> <p>The decorated class must: - Be an open generic class with matching type parameter arity - Implement the open generic interface specified - Accept the open generic interface as a constructor parameter (to wrap the inner service)</p> <p>At compile time, the source generator: 1. Discovers all closed implementations of the open generic interface 2. Emits <code>AddDecorator&lt;TService, TDecorator&gt;</code> for each closed type</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OpenDecoratorForAttribute/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OpenDecoratorForAttribute/#opendecoratorforattributetype-constructor","title":"OpenDecoratorForAttribute(Type) Constructor","text":"<p>Initializes a new instance of the OpenDecoratorForAttribute class.</p> <pre><code>public OpenDecoratorForAttribute(System.Type openGenericServiceType);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OpenDecoratorForAttribute/#parameters","title":"Parameters","text":"<p><code>openGenericServiceType</code> System.Type</p> <p>The open generic interface type to decorate (e.g., <code>typeof(IHandler&lt;&gt;)</code>). Must be an open generic interface.</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OpenDecoratorForAttribute/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OpenDecoratorForAttribute/#opendecoratorforattributeopengenericservicetype-property","title":"OpenDecoratorForAttribute.OpenGenericServiceType Property","text":"<p>Gets the open generic interface type that this decorator wraps.</p> <pre><code>public System.Type OpenGenericServiceType { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OpenDecoratorForAttribute/#property-value","title":"Property Value","text":"<p>System.Type</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OpenDecoratorForAttribute/#opendecoratorforattributeorder-property","title":"OpenDecoratorForAttribute.Order Property","text":"<p>Gets or sets the order in which this decorator is applied relative to other decorators for the same service. Lower values are applied first (closer to the original implementation). Default is 0.</p> <pre><code>public int Order { get; set; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OpenDecoratorForAttribute/#property-value_1","title":"Property Value","text":"<p>System.Int32</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OpenDecoratorForAttribute/#remarks_1","title":"Remarks","text":"<p>When multiple decorators exist for the same open generic interface, they are applied in order from lowest to highest Order value.</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OptionsAttribute/","title":"OptionsAttribute","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OptionsAttribute/#nexuslabsneedlrgenerators","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OptionsAttribute/#optionsattribute-class","title":"OptionsAttribute Class","text":"<p>Marks a class as an options/configuration type that should be bound to a configuration section. The source generator will automatically generate the <code>services.Configure&lt;T&gt;()</code> call.</p> <pre><code>public sealed class OptionsAttribute : System.Attribute\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 System.Attribute \ud83e\udc52 OptionsAttribute</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OptionsAttribute/#example","title":"Example","text":"<pre><code>// Section name inferred as \"Database\"\n[Options]\npublic class DatabaseOptions\n{\n    public string ConnectionString { get; set; } = \"\";\n    public int CommandTimeout { get; set; } = 30;\n}\n\n// Explicit section name\n[Options(\"MyApp:Database\")]\npublic class DbOptions\n{\n    public string ConnectionString { get; set; } = \"\";\n}\n\n// With validation at startup\n[Options(ValidateOnStart = true)]\npublic class StripeOptions\n{\n    [Required]\n    public string ApiKey { get; set; } = \"\";\n}\n\n// Named options for multiple instances\n[Options(\"Databases:Primary\", Name = \"Primary\")]\n[Options(\"Databases:Replica\", Name = \"Replica\")]\npublic class ConnectionOptions\n{\n    public string ConnectionString { get; set; } = \"\";\n    public bool ReadOnly { get; set; }\n}\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OptionsAttribute/#remarks","title":"Remarks","text":"<p>When applied to a class, the generator will emit code to bind the class to a configuration section. If no section name is specified, it is inferred from the class name by stripping common suffixes (Options, Settings, Config).</p> <p>All three options interfaces are registered automatically: - <code>IOptions&lt;T&gt;</code> - Singleton, no reload - <code>IOptionsSnapshot&lt;T&gt;</code> - Scoped, reloads per request - <code>IOptionsMonitor&lt;T&gt;</code> - Singleton with change notifications</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OptionsAttribute/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OptionsAttribute/#optionsattribute-constructor","title":"OptionsAttribute() Constructor","text":"<p>Initializes a new instance of the OptionsAttribute class with the section name inferred from the class name.</p> <pre><code>public OptionsAttribute();\n</code></pre> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OptionsAttribute/#optionsattributestring-constructor","title":"OptionsAttribute(string) Constructor","text":"<p>Initializes a new instance of the OptionsAttribute class with an explicit section name.</p> <pre><code>public OptionsAttribute(string sectionName);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OptionsAttribute/#parameters","title":"Parameters","text":"<p><code>sectionName</code> System.String</p> <p>The configuration section name to bind to (e.g., \"Database\" or \"MyApp:Database\").</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OptionsAttribute/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OptionsAttribute/#optionsattributename-property","title":"OptionsAttribute.Name Property","text":"<p>Gets or sets the name for named options. When set, registers as a named option that can be retrieved via <code>IOptionsSnapshot&lt;T&gt;.Get(name)</code> or <code>IOptionsMonitor&lt;T&gt;.Get(name)</code>.</p> <pre><code>public string? Name { get; set; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OptionsAttribute/#property-value","title":"Property Value","text":"<p>System.String</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OptionsAttribute/#remarks_1","title":"Remarks","text":"<p>Use this when you need multiple configurations of the same options type, such as primary and replica database connections.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OptionsAttribute/#optionsattributesectionname-property","title":"OptionsAttribute.SectionName Property","text":"<p>Gets the configuration section name to bind to. If null, the section name is inferred from the class name.</p> <pre><code>public string? SectionName { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OptionsAttribute/#property-value_1","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OptionsAttribute/#optionsattributevalidatemethod-property","title":"OptionsAttribute.ValidateMethod Property","text":"<p>Gets or sets the name of the validation method to use.</p> <pre><code>public string? ValidateMethod { get; set; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OptionsAttribute/#property-value_2","title":"Property Value","text":"<p>System.String</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OptionsAttribute/#example_1","title":"Example","text":"<pre><code>[Options(ValidateOnStart = true, ValidateMethod = nameof(CheckConfig))]\npublic class MyOptions\n{\n    public IEnumerable&lt;ValidationError&gt; CheckConfig()\n    {\n        if (string.IsNullOrEmpty(Value))\n            yield return \"Value is required\";\n    }\n}\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OptionsAttribute/#remarks_2","title":"Remarks","text":"<p>By default (when null), the generator looks for a method named <code>Validate</code>. Set this property to use a differently-named method.</p> <p>The method must return <code>IEnumerable&lt;ValidationError&gt;</code> (or <code>IEnumerable&lt;string&gt;</code> for backward compatibility) and take no parameters (for instance methods) or the options type as a parameter (for static methods).</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OptionsAttribute/#optionsattributevalidateonstart-property","title":"OptionsAttribute.ValidateOnStart Property","text":"<p>Gets or sets a value indicating whether to validate the options at application startup. When true, validation errors will prevent the application from starting.</p> <pre><code>public bool ValidateOnStart { get; set; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OptionsAttribute/#property-value_3","title":"Property Value","text":"<p>System.Boolean</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OptionsAttribute/#remarks_3","title":"Remarks","text":"<p>When enabled, the generator will emit: - <code>.ValidateDataAnnotations()</code> - Validates [Required], [Range], etc. - <code>.ValidateOnStart()</code> - Runs validation during startup</p> <p>For custom validation, implement a <code>Validate()</code> method returning <code>IEnumerable&lt;ValidationError&gt;</code>, or specify an external validator using the Validator property.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OptionsAttribute/#optionsattributevalidator-property","title":"OptionsAttribute.Validator Property","text":"<p>Gets or sets the external validator type to use.</p> <pre><code>public System.Type? Validator { get; set; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OptionsAttribute/#property-value_4","title":"Property Value","text":"<p>System.Type</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OptionsAttribute/#example_2","title":"Example","text":"<pre><code>[Options(ValidateOnStart = true, Validator = typeof(MyOptionsValidator))]\npublic class MyOptions { ... }\n\npublic class MyOptionsValidator : IOptionsValidator&lt;MyOptions&gt;\n{\n    public IEnumerable&lt;ValidationError&gt; Validate(MyOptions options) { ... }\n}\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/OptionsAttribute/#remarks_4","title":"Remarks","text":"<p>When set, validation is delegated to the specified type instead of a method on the options class. The validator type must implement <code>IOptionsValidator&lt;T&gt;</code> or FluentValidation's <code>AbstractValidator&lt;T&gt;</code> (if FluentValidation is referenced).</p> <p>Can be combined with ValidateMethod to specify a custom method name on the validator type (default is <code>Validate</code>).</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/PluginTypeInfo/","title":"PluginTypeInfo","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/PluginTypeInfo/#nexuslabsneedlrgenerators","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/PluginTypeInfo/#plugintypeinfo-struct","title":"PluginTypeInfo Struct","text":"<p>Represents metadata about a plugin type discovered at compile time.</p> <pre><code>public readonly struct PluginTypeInfo\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/PluginTypeInfo/#remarks","title":"Remarks","text":"<p>This struct is used by the generated TypeRegistry to provide plugin factory methods without requiring reflection or Activator.CreateInstance at runtime.</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/PluginTypeInfo/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/PluginTypeInfo/#plugintypeinfotype-ireadonlylisttype-funcobject-constructor","title":"PluginTypeInfo(Type, IReadOnlyList&lt;Type&gt;, Func&lt;object&gt;) Constructor","text":"<p>Initializes a new instance of PluginTypeInfo.</p> <pre><code>public PluginTypeInfo(System.Type pluginType, System.Collections.Generic.IReadOnlyList&lt;System.Type&gt; pluginInterfaces, System.Func&lt;object&gt; factory);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/PluginTypeInfo/#parameters","title":"Parameters","text":"<p><code>pluginType</code> System.Type</p> <p>The concrete plugin type.</p> <p></p> <p><code>pluginInterfaces</code> System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;</p> <p>The plugin interfaces implemented by the type.</p> <p></p> <p><code>factory</code> System.Func&lt;System.Object&gt;</p> <p>A factory delegate that creates an instance of the plugin.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/PluginTypeInfo/#plugintypeinfotype-ireadonlylisttype-funcobject-ireadonlylisttype-constructor","title":"PluginTypeInfo(Type, IReadOnlyList&lt;Type&gt;, Func&lt;object&gt;, IReadOnlyList&lt;Type&gt;) Constructor","text":"<p>Initializes a new instance of PluginTypeInfo.</p> <pre><code>public PluginTypeInfo(System.Type pluginType, System.Collections.Generic.IReadOnlyList&lt;System.Type&gt; pluginInterfaces, System.Func&lt;object&gt; factory, System.Collections.Generic.IReadOnlyList&lt;System.Type&gt; attributes);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/PluginTypeInfo/#parameters_1","title":"Parameters","text":"<p><code>pluginType</code> System.Type</p> <p>The concrete plugin type.</p> <p></p> <p><code>pluginInterfaces</code> System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;</p> <p>The plugin interfaces implemented by the type.</p> <p></p> <p><code>factory</code> System.Func&lt;System.Object&gt;</p> <p>A factory delegate that creates an instance of the plugin.</p> <p></p> <p><code>attributes</code> System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;</p> <p>The attribute types applied to the plugin type.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/PluginTypeInfo/#plugintypeinfotype-ireadonlylisttype-funcobject-ireadonlylisttype-int-constructor","title":"PluginTypeInfo(Type, IReadOnlyList&lt;Type&gt;, Func&lt;object&gt;, IReadOnlyList&lt;Type&gt;, int) Constructor","text":"<p>Initializes a new instance of PluginTypeInfo with execution order.</p> <pre><code>public PluginTypeInfo(System.Type pluginType, System.Collections.Generic.IReadOnlyList&lt;System.Type&gt; pluginInterfaces, System.Func&lt;object&gt; factory, System.Collections.Generic.IReadOnlyList&lt;System.Type&gt; attributes, int order);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/PluginTypeInfo/#parameters_2","title":"Parameters","text":"<p><code>pluginType</code> System.Type</p> <p>The concrete plugin type.</p> <p></p> <p><code>pluginInterfaces</code> System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;</p> <p>The plugin interfaces implemented by the type.</p> <p></p> <p><code>factory</code> System.Func&lt;System.Object&gt;</p> <p>A factory delegate that creates an instance of the plugin.</p> <p></p> <p><code>attributes</code> System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;</p> <p>The attribute types applied to the plugin type.</p> <p></p> <p><code>order</code> System.Int32</p> <p>The execution order. Lower values execute first.</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/PluginTypeInfo/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/PluginTypeInfo/#plugintypeinfoattributes-property","title":"PluginTypeInfo.Attributes Property","text":"<p>Gets the attribute types applied to the plugin type.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;System.Type&gt; Attributes { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/PluginTypeInfo/#property-value","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/PluginTypeInfo/#remarks_1","title":"Remarks","text":"<p>This enables attribute-based plugin filtering without requiring reflection via <code>GetCustomAttribute</code> at runtime.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/PluginTypeInfo/#plugintypeinfofactory-property","title":"PluginTypeInfo.Factory Property","text":"<p>Gets a factory delegate that creates an instance of the plugin without using Activator.CreateInstance.</p> <pre><code>public System.Func&lt;object&gt; Factory { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/PluginTypeInfo/#property-value_1","title":"Property Value","text":"<p>System.Func&lt;System.Object&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/PluginTypeInfo/#plugintypeinfoorder-property","title":"PluginTypeInfo.Order Property","text":"<p>Gets the execution order for this plugin. Lower values execute first.</p> <pre><code>public int Order { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/PluginTypeInfo/#property-value_2","title":"Property Value","text":"<p>System.Int32</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/PluginTypeInfo/#remarks_2","title":"Remarks","text":"<p>Plugins with lower order values are executed before those with higher values. The default order is 0. Use negative values for plugins that must run early (e.g., infrastructure setup) and positive values for plugins that must run late (e.g., validation, cleanup).</p> <p>When multiple plugins have the same order, they are sorted alphabetically by their fully qualified type name for deterministic execution.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/PluginTypeInfo/#plugintypeinfoplugininterfaces-property","title":"PluginTypeInfo.PluginInterfaces Property","text":"<p>Gets the plugin interfaces implemented by the type.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;System.Type&gt; PluginInterfaces { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/PluginTypeInfo/#property-value_3","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/PluginTypeInfo/#plugintypeinfoplugintype-property","title":"PluginTypeInfo.PluginType Property","text":"<p>Gets the concrete plugin type.</p> <pre><code>public System.Type PluginType { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/PluginTypeInfo/#property-value_4","title":"Property Value","text":"<p>System.Type</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/PluginTypeInfo/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/PluginTypeInfo/#plugintypeinfohasattributetype-method","title":"PluginTypeInfo.HasAttribute(Type) Method","text":"<p>Checks if the plugin has an attribute of the specified type.</p> <pre><code>public bool HasAttribute(System.Type attributeType);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/PluginTypeInfo/#parameters_3","title":"Parameters","text":"<p><code>attributeType</code> System.Type</p> <p>The attribute type to check for.</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/PluginTypeInfo/#returns","title":"Returns","text":"<p>System.Boolean True if the plugin has the attribute; otherwise, false.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/PluginTypeInfo/#plugintypeinfohasattributetattribute-method","title":"PluginTypeInfo.HasAttribute&lt;TAttribute&gt;() Method","text":"<p>Checks if the plugin has an attribute of the specified type.</p> <pre><code>public bool HasAttribute&lt;TAttribute&gt;()\n    where TAttribute : System.Attribute;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/PluginTypeInfo/#type-parameters","title":"Type parameters","text":"<p><code>TAttribute</code></p> <p>The attribute type to check for.</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/PluginTypeInfo/#returns_1","title":"Returns","text":"<p>System.Boolean True if the plugin has the attribute; otherwise, false.</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ProviderAttribute/","title":"ProviderAttribute","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ProviderAttribute/#nexuslabsneedlrgenerators","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ProviderAttribute/#providerattribute-class","title":"ProviderAttribute Class","text":"<p>Marks an interface or partial class as a Provider - a strongly-typed service locator.</p> <pre><code>public sealed class ProviderAttribute : System.Attribute\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 System.Attribute \ud83e\udc52 ProviderAttribute</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ProviderAttribute/#remarks","title":"Remarks","text":"<p>A Provider is a compile-time generated class that provides strongly-typed access to services registered in the dependency injection container. Unlike using <code>IServiceProvider.GetService&lt;T&gt;()</code> directly, Providers offer: - Compile-time verification that required services are registered - IntelliSense and IDE support for available services - Easy mocking in unit tests</p> <p>Providers are always registered as Singletons. All service properties are resolved             via constructor injection at Provider construction time (fail-fast). For creating new             instances on demand, use the Factories parameter to generate factory properties.</p> <p>Usage modes: 1. Interface definition: Apply to an interface with get-only properties.               The generator creates an implementing class.</p> <p><pre><code>[Provider]\npublic interface IOrderServicesProvider\n{\n    IOrderRepository Repository { get; }\n    IOrderValidator Validator { get; }\n}\n// Generates: OrderServicesProvider class\n</code></pre> 2. Shorthand class: Apply to a partial class with type parameters.               The generator creates both an interface and the implementation.</p> <pre><code>[Provider(typeof(IOrderRepository), typeof(IOrderValidator))]\npublic partial class OrderDependenciesProvider { }\n// Generates: IOrderDependenciesProvider interface + implementation\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ProviderAttribute/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ProviderAttribute/#providerattribute-constructor","title":"ProviderAttribute() Constructor","text":"<p>Creates a Provider attribute for an interface definition. Define service properties directly on the interface.</p> <pre><code>public ProviderAttribute();\n</code></pre> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ProviderAttribute/#providerattributetype-constructor","title":"ProviderAttribute(Type[]) Constructor","text":"<p>Creates a Provider with the specified required service types. Use on a partial class to auto-generate interface and implementation.</p> <pre><code>public ProviderAttribute(params System.Type[] requiredServices);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ProviderAttribute/#parameters","title":"Parameters","text":"<p><code>requiredServices</code> System.Type[]</p> <p>Service types that must be registered in the container. Property names are derived from type names (e.g., IOrderRepository \u2192 OrderRepository).</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ProviderAttribute/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ProviderAttribute/#providerattributecollections-property","title":"ProviderAttribute.Collections Property","text":"<p>Service types to resolve as <code>IEnumerable&lt;T&gt;</code>.</p> <pre><code>public System.Type[]? Collections { get; set; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ProviderAttribute/#property-value","title":"Property Value","text":"<p>System.Type[]</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ProviderAttribute/#remarks_1","title":"Remarks","text":"<p>Properties for these services use <code>GetServices&lt;T&gt;()</code> and return all registered implementations.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ProviderAttribute/#providerattributefactories-property","title":"ProviderAttribute.Factories Property","text":"<p>Types to generate factories for, enabling creation of new instances.</p> <pre><code>public System.Type[]? Factories { get; set; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ProviderAttribute/#property-value_1","title":"Property Value","text":"<p>System.Type[]</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ProviderAttribute/#remarks_2","title":"Remarks","text":"<p>For each type specified: - If the type has <code>[GenerateFactory]</code>, the existing factory is used. - Otherwise, a factory (<code>IXxxFactory</code>) is generated automatically.</p> <p>This allows the Provider to create new instances while remaining a Singleton.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ProviderAttribute/#providerattributeoptional-property","title":"ProviderAttribute.Optional Property","text":"<p>Service types that may not be registered. Properties are nullable.</p> <pre><code>public System.Type[]? Optional { get; set; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ProviderAttribute/#property-value_2","title":"Property Value","text":"<p>System.Type[]</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ProviderAttribute/#remarks_3","title":"Remarks","text":"<p>Properties for these services use <code>GetService&lt;T&gt;()</code> and return null if the service is not registered.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ProviderAttribute/#providerattributerequired-property","title":"ProviderAttribute.Required Property","text":"<p>Service types that must be registered. Resolution failure throws at startup.</p> <pre><code>public System.Type[]? Required { get; set; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ProviderAttribute/#property-value_3","title":"Property Value","text":"<p>System.Type[]</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ProviderAttribute/#remarks_4","title":"Remarks","text":"<p>Properties for these services use <code>GetRequiredService&lt;T&gt;()</code>. If any service is not registered, the application fails to start.</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidationError/","title":"ValidationError","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidationError/#nexuslabsneedlrgenerators","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidationError/#validationerror-class","title":"ValidationError Class","text":"<p>Represents a validation error with optional structured information.</p> <pre><code>public sealed class ValidationError\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 ValidationError</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidationError/#example","title":"Example","text":"<pre><code>// Simple: just yield a string (implicit conversion)\nyield return \"Name is required\";\n\n// Rich: provide structured information\nyield return new ValidationError(\"API key format is invalid\")\n{\n    PropertyName = nameof(ApiKey),\n    ErrorCode = \"API_KEY_FORMAT\",\n    Severity = ValidationSeverity.Error\n};\n\n// Warning (won't fail startup)\nyield return new ValidationError(\"Timeout is unusually high\")\n{\n    PropertyName = nameof(Timeout),\n    Severity = ValidationSeverity.Warning\n};\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidationError/#remarks","title":"Remarks","text":"<p>This class provides rich validation error information including the property name, error code, and severity level. For simple cases, strings can be implicitly converted to ValidationError via the implicit operator.</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidationError/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidationError/#validationerrorstring-constructor","title":"ValidationError(string) Constructor","text":"<p>Initializes a new instance of ValidationError with the specified message.</p> <pre><code>public ValidationError(string message);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidationError/#parameters","title":"Parameters","text":"<p><code>message</code> System.String</p> <p>The error message.</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidationError/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidationError/#validationerrorerrorcode-property","title":"ValidationError.ErrorCode Property","text":"<p>Gets or sets an error code for programmatic handling or localization.</p> <pre><code>public string? ErrorCode { get; set; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidationError/#property-value","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidationError/#validationerrormessage-property","title":"ValidationError.Message Property","text":"<p>Gets the error message.</p> <pre><code>public string Message { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidationError/#property-value_1","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidationError/#validationerrorpropertyname-property","title":"ValidationError.PropertyName Property","text":"<p>Gets or sets the name of the property that failed validation, if applicable.</p> <pre><code>public string? PropertyName { get; set; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidationError/#property-value_2","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidationError/#validationerrorseverity-property","title":"ValidationError.Severity Property","text":"<p>Gets or sets the severity of the validation error. Only Error will cause startup to fail.</p> <pre><code>public NexusLabs.Needlr.Generators.ValidationSeverity Severity { get; set; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidationError/#property-value_3","title":"Property Value","text":"<p>ValidationSeverity</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidationError/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidationError/#validationerrorequalsobject-method","title":"ValidationError.Equals(object) Method","text":"<p>Determines whether the specified object is equal to the current object.</p> <pre><code>public override bool Equals(object? obj);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidationError/#parameters_1","title":"Parameters","text":"<p><code>obj</code> System.Object</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidationError/#returns","title":"Returns","text":"<p>System.Boolean</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidationError/#validationerrorgethashcode-method","title":"ValidationError.GetHashCode() Method","text":"<p>Returns the hash code for this validation error.</p> <pre><code>public override int GetHashCode();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidationError/#returns_1","title":"Returns","text":"<p>System.Int32</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidationError/#validationerrortostring-method","title":"ValidationError.ToString() Method","text":"<p>Returns the error message, optionally prefixed with the property name.</p> <pre><code>public override string ToString();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidationError/#returns_2","title":"Returns","text":"<p>System.String</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidationError/#operators","title":"Operators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidationError/#validationerrorimplicit-operator-validationerrorstring-operator","title":"ValidationError.implicit operator ValidationError(string) Operator","text":"<p>Implicitly converts a string to a ValidationError.</p> <pre><code>public static NexusLabs.Needlr.Generators.ValidationError implicit operator NexusLabs.Needlr.Generators.ValidationError(string message);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidationError/#parameters_2","title":"Parameters","text":"<p><code>message</code> System.String</p> <p>The error message.</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidationError/#returns_3","title":"Returns","text":"<p>ValidationError A new ValidationError with the specified message.</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidationSeverity/","title":"ValidationSeverity","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidationSeverity/#nexuslabsneedlrgenerators","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidationSeverity/#validationseverity-enum","title":"ValidationSeverity Enum","text":"<p>Specifies the severity of a validation error.</p> <pre><code>public enum ValidationSeverity\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidationSeverity/#fields","title":"Fields","text":"<p><code>Error</code> 0</p> <p>An error that will cause validation to fail and prevent startup.</p> <p></p> <p><code>Warning</code> 1</p> <p>A warning that will be logged but won't prevent startup.</p> <p></p> <p><code>Info</code> 2</p> <p>An informational message that will be logged.</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidatorProviderAttribute/","title":"ValidatorProviderAttribute","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidatorProviderAttribute/#nexuslabsneedlrgenerators","title":"NexusLabs.Needlr.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidatorProviderAttribute/#validatorproviderattribute-class","title":"ValidatorProviderAttribute Class","text":"<p>Marks an assembly as providing a validator base type that the Needlr analyzer should recognize. When a type used with <code>[Options(Validator = typeof(...))]</code> inherits from the specified base type, the analyzer will not report NDLRGEN014 (validator missing interface).</p> <pre><code>public sealed class ValidatorProviderAttribute : System.Attribute\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 System.Attribute \ud83e\udc52 ValidatorProviderAttribute</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidatorProviderAttribute/#remarks","title":"Remarks","text":"<p>This enables integration packages (like FluentValidation adapters) to teach the core analyzer about their validator types without the core needing direct knowledge of those packages.</p> <p>Example usage in an extension package:</p> <pre><code>[assembly: ValidatorProvider(\"FluentValidation.AbstractValidator`1\")]\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidatorProviderAttribute/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidatorProviderAttribute/#validatorproviderattributestring-constructor","title":"ValidatorProviderAttribute(string) Constructor","text":"<p>Initializes a new instance of the ValidatorProviderAttribute class.</p> <pre><code>public ValidatorProviderAttribute(string baseTypeName);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidatorProviderAttribute/#parameters","title":"Parameters","text":"<p><code>baseTypeName</code> System.String</p> <p>The fully-qualified metadata name of the base validator type.</p>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidatorProviderAttribute/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidatorProviderAttribute/#validatorproviderattributebasetypename-property","title":"ValidatorProviderAttribute.BaseTypeName Property","text":"<p>The metadata name of the base validator type. Use backtick notation for generic types: \"FluentValidation.AbstractValidator`1\"</p> <pre><code>public string BaseTypeName { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Generators.Attributes/ValidatorProviderAttribute/#property-value","title":"Property Value","text":"<p>System.String</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/","title":"Index","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/#nexuslabsneedlrhosting-namespace","title":"NexusLabs.Needlr.Hosting Namespace","text":"Classes CreateHostOptions Represents options for creating a host application with logging configuration. CreateHostOptionsExtensions Provides extension methods for configuring CreateHostOptions. HostApplicationBuilderNeedlrExtensions Extension methods for integrating Needlr discovery into user-controlled Microsoft.Extensions.Hosting.HostApplicationBuilder instances. Use this when you want to maintain control over the host creation process while still benefiting from Needlr's automatic service discovery and plugin system. HostApplicationBuilderPluginOptions Options passed to NexusLabs.Needlr.Hosting.IHostApplicationBuilderPlugin.Configure(NexusLabs.Needlr.Hosting.HostApplicationBuilderPluginOptions). HostFactory Factory for creating Microsoft.Extensions.Hosting.IHost instances with Needlr configuration. HostPluginOptions Options passed to NexusLabs.Needlr.Hosting.IHostPlugin.Configure(NexusLabs.Needlr.Hosting.HostPluginOptions). HostSyringe Provides a fluent API for configuring and building host applications using Needlr. Wraps a ConfiguredSyringe with additional host functionality. HostSyringeExtensions Extension methods for configuring HostSyringe instances. Provides only host-specific configuration methods. IHostFactoryExtensions Extension methods for IHostFactory. SyringeHostingExtensions Extension methods for configuring NexusLabs.Needlr.Injection.ConfiguredSyringe instances with generic host functionality. Interfaces IHostApplicationBuilderPlugin Plugin that configures the Microsoft.Extensions.Hosting.HostApplicationBuilder  before the host is built. Analogous to <code>IWebApplicationBuilderPlugin</code> for web apps. IHostFactory Factory interface for creating Microsoft.Extensions.Hosting.IHost instances with Needlr configuration. IHostPlugin Plugin that configures the Microsoft.Extensions.Hosting.IHost after it's built  but before it runs. Analogous to <code>IWebApplicationPlugin</code> for web apps."},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/","title":"CreateHostOptions","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#nexuslabsneedlrhosting","title":"NexusLabs.Needlr.Hosting","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#createhostoptions-class","title":"CreateHostOptions Class","text":"<p>Represents options for creating a host application with logging configuration.</p> <pre><code>public sealed record CreateHostOptions : System.IEquatable&lt;NexusLabs.Needlr.Hosting.CreateHostOptions&gt;\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 CreateHostOptions</p> <p>Implements System.IEquatable&lt;CreateHostOptions&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#createhostoptionshostapplicationbuildersettings-constructor","title":"CreateHostOptions(HostApplicationBuilderSettings) Constructor","text":"<p>Initializes a new instance of the CreateHostOptions  record with a Microsoft.Extensions.Logging.Abstractions.NullLogger.</p> <pre><code>public CreateHostOptions(Microsoft.Extensions.Hosting.HostApplicationBuilderSettings? settings=null);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#parameters","title":"Parameters","text":"<p><code>settings</code> Microsoft.Extensions.Hosting.HostApplicationBuilderSettings</p> <p>The host application builder settings to use.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#createhostoptionshostapplicationbuildersettings-ilogger-constructor","title":"CreateHostOptions(HostApplicationBuilderSettings, ILogger) Constructor","text":"<p>Initializes a new instance with a logger.</p> <pre><code>public CreateHostOptions(Microsoft.Extensions.Hosting.HostApplicationBuilderSettings settings, Microsoft.Extensions.Logging.ILogger logger);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#parameters_1","title":"Parameters","text":"<p><code>settings</code> Microsoft.Extensions.Hosting.HostApplicationBuilderSettings</p> <p>The host application builder settings to use.</p> <p></p> <p><code>logger</code> Microsoft.Extensions.Logging.ILogger</p> <p>The logger instance to use for logging during host creation.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#exceptions","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when logger is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#createhostoptionshostapplicationbuildersettings-actioniservicecollection-constructor","title":"CreateHostOptions(HostApplicationBuilderSettings, Action&lt;IServiceCollection&gt;) Constructor","text":"<p>Initializes a new instance with a post-plugin registration callback.</p> <pre><code>public CreateHostOptions(Microsoft.Extensions.Hosting.HostApplicationBuilderSettings settings, System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt; postPluginRegistrationCallback);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#parameters_2","title":"Parameters","text":"<p><code>settings</code> Microsoft.Extensions.Hosting.HostApplicationBuilderSettings</p> <p>The host application builder settings to use.</p> <p></p> <p><code>postPluginRegistrationCallback</code> System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;</p> <p>The callback to execute after plugin registration, allowing for additional service configuration.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#exceptions_1","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when postPluginRegistrationCallback is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#createhostoptionshostapplicationbuildersettings-actioniservicecollection-ilogger-constructor","title":"CreateHostOptions(HostApplicationBuilderSettings, Action&lt;IServiceCollection&gt;, ILogger) Constructor","text":"<p>Initializes a new instance with a post-plugin registration callback and logger.</p> <pre><code>public CreateHostOptions(Microsoft.Extensions.Hosting.HostApplicationBuilderSettings settings, System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt; postPluginRegistrationCallback, Microsoft.Extensions.Logging.ILogger logger);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#parameters_3","title":"Parameters","text":"<p><code>settings</code> Microsoft.Extensions.Hosting.HostApplicationBuilderSettings</p> <p>The host application builder settings to use.</p> <p></p> <p><code>postPluginRegistrationCallback</code> System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;</p> <p>The callback to execute after plugin registration, allowing for additional service configuration.</p> <p></p> <p><code>logger</code> Microsoft.Extensions.Logging.ILogger</p> <p>The logger instance to use for logging during host creation.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#exceptions_2","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when postPluginRegistrationCallback or logger is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#createhostoptionshostapplicationbuildersettings-ienumerableactioniservicecollection-constructor","title":"CreateHostOptions(HostApplicationBuilderSettings, IEnumerable&lt;Action&lt;IServiceCollection&gt;&gt;) Constructor","text":"<p>Initializes a new instance with pre-plugin registration callbacks.</p> <pre><code>public CreateHostOptions(Microsoft.Extensions.Hosting.HostApplicationBuilderSettings settings, System.Collections.Generic.IEnumerable&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; prePluginRegistrationCallbacks);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#parameters_4","title":"Parameters","text":"<p><code>settings</code> Microsoft.Extensions.Hosting.HostApplicationBuilderSettings</p> <p>The host application builder settings to use.</p> <p></p> <p><code>prePluginRegistrationCallbacks</code> System.Collections.Generic.IEnumerable&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p>Callbacks to execute before plugin registration.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#exceptions_3","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when prePluginRegistrationCallbacks is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#createhostoptionshostapplicationbuildersettings-ienumerableactioniservicecollection-ilogger-constructor","title":"CreateHostOptions(HostApplicationBuilderSettings, IEnumerable&lt;Action&lt;IServiceCollection&gt;&gt;, ILogger) Constructor","text":"<p>Initializes a new instance with pre-plugin registration callbacks and logger.</p> <pre><code>public CreateHostOptions(Microsoft.Extensions.Hosting.HostApplicationBuilderSettings settings, System.Collections.Generic.IEnumerable&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; prePluginRegistrationCallbacks, Microsoft.Extensions.Logging.ILogger logger);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#parameters_5","title":"Parameters","text":"<p><code>settings</code> Microsoft.Extensions.Hosting.HostApplicationBuilderSettings</p> <p>The host application builder settings to use.</p> <p></p> <p><code>prePluginRegistrationCallbacks</code> System.Collections.Generic.IEnumerable&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p>Callbacks to execute before plugin registration.</p> <p></p> <p><code>logger</code> Microsoft.Extensions.Logging.ILogger</p> <p>The logger instance to use for logging during host creation.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#exceptions_4","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when a parameter is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#createhostoptionshostapplicationbuildersettings-ienumerableactioniservicecollection-ienumerableactioniservicecollection-constructor","title":"CreateHostOptions(HostApplicationBuilderSettings, IEnumerable&lt;Action&lt;IServiceCollection&gt;&gt;, IEnumerable&lt;Action&lt;IServiceCollection&gt;&gt;) Constructor","text":"<p>Initializes a new instance with pre- and post-plugin registration callbacks.</p> <pre><code>public CreateHostOptions(Microsoft.Extensions.Hosting.HostApplicationBuilderSettings settings, System.Collections.Generic.IEnumerable&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; prePluginRegistrationCallbacks, System.Collections.Generic.IEnumerable&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; postPluginRegistrationCallbacks);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#parameters_6","title":"Parameters","text":"<p><code>settings</code> Microsoft.Extensions.Hosting.HostApplicationBuilderSettings</p> <p>The host application builder settings to use.</p> <p></p> <p><code>prePluginRegistrationCallbacks</code> System.Collections.Generic.IEnumerable&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p>Callbacks to execute before plugin registration.</p> <p></p> <p><code>postPluginRegistrationCallbacks</code> System.Collections.Generic.IEnumerable&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p>Callbacks to execute after plugin registration.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#exceptions_5","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when a parameter is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#createhostoptionshostapplicationbuildersettings-ienumerableactioniservicecollection-ienumerableactioniservicecollection-ilogger-constructor","title":"CreateHostOptions(HostApplicationBuilderSettings, IEnumerable&lt;Action&lt;IServiceCollection&gt;&gt;, IEnumerable&lt;Action&lt;IServiceCollection&gt;&gt;, ILogger) Constructor","text":"<p>Initializes a new instance with pre- and post-plugin registration callbacks and logger.</p> <pre><code>public CreateHostOptions(Microsoft.Extensions.Hosting.HostApplicationBuilderSettings settings, System.Collections.Generic.IEnumerable&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; prePluginRegistrationCallbacks, System.Collections.Generic.IEnumerable&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; postPluginRegistrationCallbacks, Microsoft.Extensions.Logging.ILogger logger);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#parameters_7","title":"Parameters","text":"<p><code>settings</code> Microsoft.Extensions.Hosting.HostApplicationBuilderSettings</p> <p>The host application builder settings to use.</p> <p></p> <p><code>prePluginRegistrationCallbacks</code> System.Collections.Generic.IEnumerable&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p>Callbacks to execute before plugin registration.</p> <p></p> <p><code>postPluginRegistrationCallbacks</code> System.Collections.Generic.IEnumerable&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p>Callbacks to execute after plugin registration.</p> <p></p> <p><code>logger</code> Microsoft.Extensions.Logging.ILogger</p> <p>The logger instance to use for logging during host creation.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#exceptions_6","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when a parameter is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#createhostoptionshostapplicationbuildersettings-ireadonlylistactioniservicecollection-ilogger-constructor","title":"CreateHostOptions(HostApplicationBuilderSettings, IReadOnlyList&lt;Action&lt;IServiceCollection&gt;&gt;, ILogger) Constructor","text":"<p>Represents options for creating a host application with logging configuration.</p> <pre><code>public CreateHostOptions(Microsoft.Extensions.Hosting.HostApplicationBuilderSettings Settings, System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; PostPluginRegistrationCallbacks, Microsoft.Extensions.Logging.ILogger Logger);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#parameters_8","title":"Parameters","text":"<p><code>Settings</code> Microsoft.Extensions.Hosting.HostApplicationBuilderSettings</p> <p>The host application builder settings to use when creating the host.</p> <p></p> <p><code>PostPluginRegistrationCallbacks</code> System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p>The callbacks to execute after plugin registration, allowing for additional service configuration.</p> <p></p> <p><code>Logger</code> Microsoft.Extensions.Logging.ILogger</p> <p>The logger instance to use for logging during host creation.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#createhostoptionsdefault-property","title":"CreateHostOptions.Default Property","text":"<p>Gets the default instance of CreateHostOptions with empty  settings and a Microsoft.Extensions.Logging.Abstractions.NullLogger.</p> <pre><code>public static NexusLabs.Needlr.Hosting.CreateHostOptions Default { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#property-value","title":"Property Value","text":"<p>CreateHostOptions</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#createhostoptionslogger-property","title":"CreateHostOptions.Logger Property","text":"<p>The logger instance to use for logging during host creation.</p> <pre><code>public Microsoft.Extensions.Logging.ILogger Logger { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#property-value_1","title":"Property Value","text":"<p>Microsoft.Extensions.Logging.ILogger</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#createhostoptionspostpluginregistrationcallbacks-property","title":"CreateHostOptions.PostPluginRegistrationCallbacks Property","text":"<p>The callbacks to execute after plugin registration, allowing for additional service configuration.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; PostPluginRegistrationCallbacks { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#property-value_2","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#createhostoptionsprepluginregistrationcallbacks-property","title":"CreateHostOptions.PrePluginRegistrationCallbacks Property","text":"<p>Callbacks to execute before plugin registration to allow configuring the service collection.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; PrePluginRegistrationCallbacks { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#property-value_3","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#createhostoptionssettings-property","title":"CreateHostOptions.Settings Property","text":"<p>The host application builder settings to use when creating the host.</p> <pre><code>public Microsoft.Extensions.Hosting.HostApplicationBuilderSettings Settings { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptions/#property-value_4","title":"Property Value","text":"<p>Microsoft.Extensions.Hosting.HostApplicationBuilderSettings</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/","title":"CreateHostOptionsExtensions","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#nexuslabsneedlrhosting","title":"NexusLabs.Needlr.Hosting","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#createhostoptionsextensions-class","title":"CreateHostOptionsExtensions Class","text":"<p>Provides extension methods for configuring CreateHostOptions.</p> <pre><code>public static class CreateHostOptionsExtensions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 CreateHostOptionsExtensions</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#createhostoptionsextensionsusingapplicationnamethis-createhostoptions-string-method","title":"CreateHostOptionsExtensions.UsingApplicationName(this CreateHostOptions, string) Method","text":"<p>Configures the options to use the specified application name.</p> <pre><code>public static NexusLabs.Needlr.Hosting.CreateHostOptions UsingApplicationName(this NexusLabs.Needlr.Hosting.CreateHostOptions options, string applicationName);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#parameters","title":"Parameters","text":"<p><code>options</code> CreateHostOptions</p> <p>The options to configure.</p> <p></p> <p><code>applicationName</code> System.String</p> <p>The application name to use.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#returns","title":"Returns","text":"<p>CreateHostOptions A new instance of CreateHostOptions with the application name configured.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#exceptions","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when options or applicationName is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#createhostoptionsextensionsusingargsthis-createhostoptions-string-method","title":"CreateHostOptionsExtensions.UsingArgs(this CreateHostOptions, string[]) Method","text":"<p>Configures the options to use the specified command line arguments.</p> <pre><code>public static NexusLabs.Needlr.Hosting.CreateHostOptions UsingArgs(this NexusLabs.Needlr.Hosting.CreateHostOptions options, string[] args);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#parameters_1","title":"Parameters","text":"<p><code>options</code> CreateHostOptions</p> <p>The options to configure.</p> <p></p> <p><code>args</code> System.String[]</p> <p>The command line arguments to use.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#returns_1","title":"Returns","text":"<p>CreateHostOptions A new instance of CreateHostOptions with the command line arguments configured.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#exceptions_1","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when options or args is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#createhostoptionsextensionsusingcontentrootpaththis-createhostoptions-string-method","title":"CreateHostOptionsExtensions.UsingContentRootPath(this CreateHostOptions, string) Method","text":"<p>Configures the options to use the specified content root path.</p> <pre><code>public static NexusLabs.Needlr.Hosting.CreateHostOptions UsingContentRootPath(this NexusLabs.Needlr.Hosting.CreateHostOptions options, string contentRootPath);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#parameters_2","title":"Parameters","text":"<p><code>options</code> CreateHostOptions</p> <p>The options to configure.</p> <p></p> <p><code>contentRootPath</code> System.String</p> <p>The content root path to use.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#returns_2","title":"Returns","text":"<p>CreateHostOptions A new instance of CreateHostOptions with the content root path configured.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#exceptions_2","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when options or contentRootPath is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#createhostoptionsextensionsusingenvironmentnamethis-createhostoptions-string-method","title":"CreateHostOptionsExtensions.UsingEnvironmentName(this CreateHostOptions, string) Method","text":"<p>Configures the options to use the specified environment name.</p> <pre><code>public static NexusLabs.Needlr.Hosting.CreateHostOptions UsingEnvironmentName(this NexusLabs.Needlr.Hosting.CreateHostOptions options, string environmentName);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#parameters_3","title":"Parameters","text":"<p><code>options</code> CreateHostOptions</p> <p>The options to configure.</p> <p></p> <p><code>environmentName</code> System.String</p> <p>The environment name to use.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#returns_3","title":"Returns","text":"<p>CreateHostOptions A new instance of CreateHostOptions with the environment name configured.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#exceptions_3","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when options or environmentName is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#createhostoptionsextensionsusingpostpluginregistrationcallbackthis-createhostoptions-actioniservicecollection-method","title":"CreateHostOptionsExtensions.UsingPostPluginRegistrationCallback(this CreateHostOptions, Action&lt;IServiceCollection&gt;) Method","text":"<p>Adds a post-plugin registration callback to the options.</p> <pre><code>public static NexusLabs.Needlr.Hosting.CreateHostOptions UsingPostPluginRegistrationCallback(this NexusLabs.Needlr.Hosting.CreateHostOptions options, System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt; callback);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#parameters_4","title":"Parameters","text":"<p><code>options</code> CreateHostOptions</p> <p>The options to configure.</p> <p></p> <p><code>callback</code> System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;</p> <p>The callback to add for post-plugin registration.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#returns_4","title":"Returns","text":"<p>CreateHostOptions A new instance of CreateHostOptions with the callback added.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#exceptions_4","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when options or callback is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#createhostoptionsextensionsusingpostpluginregistrationcallbacksthis-createhostoptions-actioniservicecollection-method","title":"CreateHostOptionsExtensions.UsingPostPluginRegistrationCallbacks(this CreateHostOptions, Action&lt;IServiceCollection&gt;[]) Method","text":"<p>Adds multiple post-plugin registration callbacks to the options.</p> <pre><code>public static NexusLabs.Needlr.Hosting.CreateHostOptions UsingPostPluginRegistrationCallbacks(this NexusLabs.Needlr.Hosting.CreateHostOptions options, params System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;[] callbacks);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#parameters_5","title":"Parameters","text":"<p><code>options</code> CreateHostOptions</p> <p>The options to configure.</p> <p></p> <p><code>callbacks</code> System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;[]</p> <p>The callbacks to add for post-plugin registration.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#returns_5","title":"Returns","text":"<p>CreateHostOptions A new instance of CreateHostOptions with the callbacks added.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#exceptions_5","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when options or callbacks is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#createhostoptionsextensionsusingpostpluginregistrationcallbacksthis-createhostoptions-ienumerableactioniservicecollection-method","title":"CreateHostOptionsExtensions.UsingPostPluginRegistrationCallbacks(this CreateHostOptions, IEnumerable&lt;Action&lt;IServiceCollection&gt;&gt;) Method","text":"<p>Adds multiple post-plugin registration callbacks to the options.</p> <pre><code>public static NexusLabs.Needlr.Hosting.CreateHostOptions UsingPostPluginRegistrationCallbacks(this NexusLabs.Needlr.Hosting.CreateHostOptions options, System.Collections.Generic.IEnumerable&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; callbacks);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#parameters_6","title":"Parameters","text":"<p><code>options</code> CreateHostOptions</p> <p>The options to configure.</p> <p></p> <p><code>callbacks</code> System.Collections.Generic.IEnumerable&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p>The callbacks to add for post-plugin registration.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#returns_6","title":"Returns","text":"<p>CreateHostOptions A new instance of CreateHostOptions with the callbacks added.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#exceptions_6","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when options or callbacks is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#createhostoptionsextensionsusingprepluginregistrationcallbackthis-createhostoptions-actioniservicecollection-method","title":"CreateHostOptionsExtensions.UsingPrePluginRegistrationCallback(this CreateHostOptions, Action&lt;IServiceCollection&gt;) Method","text":"<p>Adds a pre-plugin registration callback to the options.</p> <pre><code>public static NexusLabs.Needlr.Hosting.CreateHostOptions UsingPrePluginRegistrationCallback(this NexusLabs.Needlr.Hosting.CreateHostOptions options, System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt; callback);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#parameters_7","title":"Parameters","text":"<p><code>options</code> CreateHostOptions</p> <p>The options to configure.</p> <p></p> <p><code>callback</code> System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;</p> <p>The callback to add for pre-plugin registration.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#returns_7","title":"Returns","text":"<p>CreateHostOptions A new instance of CreateHostOptions with the callback added.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#exceptions_7","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when options or callback is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#createhostoptionsextensionsusingprepluginregistrationcallbacksthis-createhostoptions-actioniservicecollection-method","title":"CreateHostOptionsExtensions.UsingPrePluginRegistrationCallbacks(this CreateHostOptions, Action&lt;IServiceCollection&gt;[]) Method","text":"<p>Adds multiple pre-plugin registration callbacks to the options.</p> <pre><code>public static NexusLabs.Needlr.Hosting.CreateHostOptions UsingPrePluginRegistrationCallbacks(this NexusLabs.Needlr.Hosting.CreateHostOptions options, params System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;[] callbacks);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#parameters_8","title":"Parameters","text":"<p><code>options</code> CreateHostOptions</p> <p>The options to configure.</p> <p></p> <p><code>callbacks</code> System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;[]</p> <p>The callbacks to add for pre-plugin registration.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#returns_8","title":"Returns","text":"<p>CreateHostOptions A new instance of CreateHostOptions with the callbacks added.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#exceptions_8","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when options or callbacks is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#createhostoptionsextensionsusingprepluginregistrationcallbacksthis-createhostoptions-ienumerableactioniservicecollection-method","title":"CreateHostOptionsExtensions.UsingPrePluginRegistrationCallbacks(this CreateHostOptions, IEnumerable&lt;Action&lt;IServiceCollection&gt;&gt;) Method","text":"<p>Adds multiple pre-plugin registration callbacks to the options.</p> <pre><code>public static NexusLabs.Needlr.Hosting.CreateHostOptions UsingPrePluginRegistrationCallbacks(this NexusLabs.Needlr.Hosting.CreateHostOptions options, System.Collections.Generic.IEnumerable&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; callbacks);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#parameters_9","title":"Parameters","text":"<p><code>options</code> CreateHostOptions</p> <p>The options to configure.</p> <p></p> <p><code>callbacks</code> System.Collections.Generic.IEnumerable&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p>The callbacks to add for pre-plugin registration.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#returns_9","title":"Returns","text":"<p>CreateHostOptions A new instance of CreateHostOptions with the callbacks added.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#exceptions_9","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when options or callbacks is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#createhostoptionsextensionsusingstartupconsoleloggerthis-createhostoptions-string-loglevel-method","title":"CreateHostOptionsExtensions.UsingStartupConsoleLogger(this CreateHostOptions, string, LogLevel) Method","text":"<p>Configures the options to use a console logger for startup logging.</p> <pre><code>public static NexusLabs.Needlr.Hosting.CreateHostOptions UsingStartupConsoleLogger(this NexusLabs.Needlr.Hosting.CreateHostOptions options, string name=\"Startup\", Microsoft.Extensions.Logging.LogLevel level=Microsoft.Extensions.Logging.LogLevel.Debug);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#parameters_10","title":"Parameters","text":"<p><code>options</code> CreateHostOptions</p> <p>The options to configure.</p> <p></p> <p><code>name</code> System.String</p> <p>The name of the logger. Defaults to \"Startup\".</p> <p></p> <p><code>level</code> Microsoft.Extensions.Logging.LogLevel</p> <p>The minimum log level. Defaults to Microsoft.Extensions.Logging.LogLevel.Debug.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#returns_10","title":"Returns","text":"<p>CreateHostOptions A new instance of CreateHostOptions with the console logger configured.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/CreateHostOptionsExtensions/#exceptions_10","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when options is null.</p> <p>System.ArgumentException Thrown when name is null or whitespace.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostApplicationBuilderNeedlrExtensions/","title":"HostApplicationBuilderNeedlrExtensions","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostApplicationBuilderNeedlrExtensions/#nexuslabsneedlrhosting","title":"NexusLabs.Needlr.Hosting","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostApplicationBuilderNeedlrExtensions/#hostapplicationbuilderneedlrextensions-class","title":"HostApplicationBuilderNeedlrExtensions Class","text":"<p>Extension methods for integrating Needlr discovery into user-controlled Microsoft.Extensions.Hosting.HostApplicationBuilder instances. Use this when you want to maintain control over the host creation process while still benefiting from Needlr's automatic service discovery and plugin system.</p> <pre><code>public static class HostApplicationBuilderNeedlrExtensions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 HostApplicationBuilderNeedlrExtensions</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostApplicationBuilderNeedlrExtensions/#example","title":"Example","text":"<p>Basic usage with user-controlled builder:</p> <pre><code>var builder = Host.CreateApplicationBuilder(args);\n\n// Your existing configuration\nbuilder.Services.AddMyCustomServices();\n\n// Add Needlr discovery - runs IHostApplicationBuilderPlugin and IServiceCollectionPlugin\nbuilder.UseNeedlrDiscovery();\n\n// More of your configuration\nbuilder.Services.AddOtherServices();\n\nvar host = builder.Build();\n\n// Optionally run IHostPlugin plugins\nhost.RunHostPlugins();\n\nawait host.RunAsync();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostApplicationBuilderNeedlrExtensions/#remarks","title":"Remarks","text":"<p>UseNeedlrDiscovery(this HostApplicationBuilder, ConfiguredSyringe, ILogger) provides a \"reverse integration\" approach where Needlr adapts to your builder             rather than you adapting to Needlr. This is useful when: - You have existing host configuration code you want to preserve - You need fine-grained control over the builder lifecycle - You're integrating Needlr into a larger framework</p> <p>Note: IHostPlugin plugins are NOT executed by UseNeedlrDiscovery(this HostApplicationBuilder, ConfiguredSyringe, ILogger) because the user controls when Microsoft.Extensions.Hosting.HostApplicationBuilder.Build is called. If you need IHostPlugin support, call RunHostPlugins(this IHost, ILogger) after building the host.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostApplicationBuilderNeedlrExtensions/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostApplicationBuilderNeedlrExtensions/#hostapplicationbuilderneedlrextensionsrunhostpluginsthis-ihost-ilogger-method","title":"HostApplicationBuilderNeedlrExtensions.RunHostPlugins(this IHost, ILogger) Method","text":"<p>Runs IHostPlugin plugins on the built host. Call this after Microsoft.Extensions.Hosting.HostApplicationBuilder.Build if you need IHostPlugin support.</p> <pre><code>public static Microsoft.Extensions.Hosting.IHost RunHostPlugins(this Microsoft.Extensions.Hosting.IHost host, Microsoft.Extensions.Logging.ILogger? logger=null);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostApplicationBuilderNeedlrExtensions/#parameters","title":"Parameters","text":"<p><code>host</code> Microsoft.Extensions.Hosting.IHost</p> <p>The built host to configure.</p> <p></p> <p><code>logger</code> Microsoft.Extensions.Logging.ILogger</p> <p>Optional logger for plugin execution logging.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostApplicationBuilderNeedlrExtensions/#returns","title":"Returns","text":"<p>Microsoft.Extensions.Hosting.IHost The same Microsoft.Extensions.Hosting.IHost for method chaining.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostApplicationBuilderNeedlrExtensions/#example_1","title":"Example","text":"<pre><code>var builder = Host.CreateApplicationBuilder(args);\nbuilder.UseNeedlrDiscovery();\n\nvar host = builder.Build();\nhost.RunHostPlugins(); // Run IHostPlugin plugins\n\nawait host.RunAsync();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostApplicationBuilderNeedlrExtensions/#remarks_1","title":"Remarks","text":"<p>This method retrieves the plugin factory and candidate assemblies that were stored during UseNeedlrDiscovery(this HostApplicationBuilder, ConfiguredSyringe, ILogger) and uses them to run IHostPlugin plugins.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostApplicationBuilderNeedlrExtensions/#hostapplicationbuilderneedlrextensionsuseneedlrdiscoverythis-hostapplicationbuilder-configuredsyringe-ilogger-method","title":"HostApplicationBuilderNeedlrExtensions.UseNeedlrDiscovery(this HostApplicationBuilder, ConfiguredSyringe, ILogger) Method","text":"<p>Integrates Needlr's automatic service discovery and plugin system into the Microsoft.Extensions.Hosting.HostApplicationBuilder.</p> <pre><code>public static Microsoft.Extensions.Hosting.HostApplicationBuilder UseNeedlrDiscovery(this Microsoft.Extensions.Hosting.HostApplicationBuilder builder, NexusLabs.Needlr.Injection.ConfiguredSyringe syringe, Microsoft.Extensions.Logging.ILogger? logger=null);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostApplicationBuilderNeedlrExtensions/#parameters_1","title":"Parameters","text":"<p><code>builder</code> Microsoft.Extensions.Hosting.HostApplicationBuilder</p> <p>The host application builder to configure.</p> <p></p> <p><code>syringe</code> NexusLabs.Needlr.Injection.ConfiguredSyringe</p> <p>Optional syringe instance to use for configuration. If not provided, a default syringe is created. Use this to provide a pre-configured syringe with specific type registrars or filterers.</p> <p></p> <p><code>logger</code> Microsoft.Extensions.Logging.ILogger</p> <p>Optional logger for discovery and plugin execution logging.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostApplicationBuilderNeedlrExtensions/#returns_1","title":"Returns","text":"<p>Microsoft.Extensions.Hosting.HostApplicationBuilder The same Microsoft.Extensions.Hosting.HostApplicationBuilder for method chaining.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostApplicationBuilderNeedlrExtensions/#example_2","title":"Example","text":"<p>With a pre-configured syringe:</p> <pre><code>var syringe = new Syringe()\n    .UsingReflection()\n    .UsingAdditionalAssemblies(typeof(MyPluginAssembly).Assembly);\n\nvar builder = Host.CreateApplicationBuilder(args);\nbuilder.UseNeedlrDiscovery(syringe);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostApplicationBuilderNeedlrExtensions/#remarks_2","title":"Remarks","text":"<p>This method performs the following in order: 1. Discovers assemblies using the syringe's assembly provider 2. Runs all NexusLabs.Needlr.Hosting.IHostApplicationBuilderPlugin.Configure(NexusLabs.Needlr.Hosting.HostApplicationBuilderPluginOptions) methods 3. Runs all NexusLabs.Needlr.IServiceCollectionPlugin.Configure(NexusLabs.Needlr.ServiceCollectionPluginOptions) methods 4. Registers discovered types to the service collection</p> <p>IHostPlugin plugins are NOT executed. If needed, call RunHostPlugins(this IHost, ILogger)             after Microsoft.Extensions.Hosting.HostApplicationBuilder.Build.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostApplicationBuilderPluginOptions/","title":"HostApplicationBuilderPluginOptions","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostApplicationBuilderPluginOptions/#nexuslabsneedlrhosting","title":"NexusLabs.Needlr.Hosting","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostApplicationBuilderPluginOptions/#hostapplicationbuilderpluginoptions-class","title":"HostApplicationBuilderPluginOptions Class","text":"<p>Options passed to NexusLabs.Needlr.Hosting.IHostApplicationBuilderPlugin.Configure(NexusLabs.Needlr.Hosting.HostApplicationBuilderPluginOptions).</p> <pre><code>public sealed record HostApplicationBuilderPluginOptions : System.IEquatable&lt;NexusLabs.Needlr.Hosting.HostApplicationBuilderPluginOptions&gt;\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 HostApplicationBuilderPluginOptions</p> <p>Implements System.IEquatable&lt;HostApplicationBuilderPluginOptions&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostApplicationBuilderPluginOptions/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostApplicationBuilderPluginOptions/#hostapplicationbuilderpluginoptionshostapplicationbuilder-ireadonlylistassembly-ilogger-ipluginfactory-constructor","title":"HostApplicationBuilderPluginOptions(HostApplicationBuilder, IReadOnlyList&lt;Assembly&gt;, ILogger, IPluginFactory) Constructor","text":"<p>Options passed to NexusLabs.Needlr.Hosting.IHostApplicationBuilderPlugin.Configure(NexusLabs.Needlr.Hosting.HostApplicationBuilderPluginOptions).</p> <pre><code>public HostApplicationBuilderPluginOptions(Microsoft.Extensions.Hosting.HostApplicationBuilder Builder, System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt; Assemblies, Microsoft.Extensions.Logging.ILogger Logger, NexusLabs.Needlr.IPluginFactory PluginFactory);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostApplicationBuilderPluginOptions/#parameters","title":"Parameters","text":"<p><code>Builder</code> Microsoft.Extensions.Hosting.HostApplicationBuilder</p> <p></p> <p><code>Assemblies</code> System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt;</p> <p></p> <p><code>Logger</code> Microsoft.Extensions.Logging.ILogger</p> <p></p> <p><code>PluginFactory</code> NexusLabs.Needlr.IPluginFactory</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostFactory/","title":"HostFactory","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostFactory/#nexuslabsneedlrhosting","title":"NexusLabs.Needlr.Hosting","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostFactory/#hostfactory-class","title":"HostFactory Class","text":"<p>Factory for creating Microsoft.Extensions.Hosting.IHost instances with Needlr configuration.</p> <pre><code>public sealed class HostFactory : NexusLabs.Needlr.Hosting.IHostFactory\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 HostFactory</p> <p>Implements IHostFactory</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostFactory/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostFactory/#hostfactoryiserviceproviderbuilder-iservicecollectionpopulator-ipluginfactory-constructor","title":"HostFactory(IServiceProviderBuilder, IServiceCollectionPopulator, IPluginFactory) Constructor","text":"<p>Factory for creating Microsoft.Extensions.Hosting.IHost instances with Needlr configuration.</p> <pre><code>public HostFactory(NexusLabs.Needlr.Injection.IServiceProviderBuilder _serviceProviderBuilder, NexusLabs.Needlr.Injection.IServiceCollectionPopulator _serviceCollectionPopulator, NexusLabs.Needlr.IPluginFactory _pluginFactory);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostFactory/#parameters","title":"Parameters","text":"<p><code>_serviceProviderBuilder</code> NexusLabs.Needlr.Injection.IServiceProviderBuilder</p> <p></p> <p><code>_serviceCollectionPopulator</code> NexusLabs.Needlr.Injection.IServiceCollectionPopulator</p> <p></p> <p><code>_pluginFactory</code> NexusLabs.Needlr.IPluginFactory</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostFactory/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostFactory/#hostfactorycreatecreatehostoptions-funchostapplicationbuilder-method","title":"HostFactory.Create(CreateHostOptions, Func&lt;HostApplicationBuilder&gt;) Method","text":"<p>Creates an Microsoft.Extensions.Hosting.IHost using the specified options and builder callback.</p> <pre><code>public Microsoft.Extensions.Hosting.IHost Create(NexusLabs.Needlr.Hosting.CreateHostOptions options, System.Func&lt;Microsoft.Extensions.Hosting.HostApplicationBuilder&gt; createHostApplicationBuilderCallback);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostFactory/#parameters_1","title":"Parameters","text":"<p><code>options</code> CreateHostOptions</p> <p>The options for creating the host.</p> <p></p> <p><code>createHostApplicationBuilderCallback</code> System.Func&lt;Microsoft.Extensions.Hosting.HostApplicationBuilder&gt;</p> <p>The callback that creates and configures the Microsoft.Extensions.Hosting.HostApplicationBuilder.</p> <p>Implements Create(CreateHostOptions, Func&lt;HostApplicationBuilder&gt;)</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostFactory/#returns","title":"Returns","text":"<p>Microsoft.Extensions.Hosting.IHost The configured Microsoft.Extensions.Hosting.IHost.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostPluginOptions/","title":"HostPluginOptions","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostPluginOptions/#nexuslabsneedlrhosting","title":"NexusLabs.Needlr.Hosting","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostPluginOptions/#hostpluginoptions-class","title":"HostPluginOptions Class","text":"<p>Options passed to NexusLabs.Needlr.Hosting.IHostPlugin.Configure(NexusLabs.Needlr.Hosting.HostPluginOptions).</p> <pre><code>public sealed record HostPluginOptions : System.IEquatable&lt;NexusLabs.Needlr.Hosting.HostPluginOptions&gt;\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 HostPluginOptions</p> <p>Implements System.IEquatable&lt;HostPluginOptions&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostPluginOptions/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostPluginOptions/#hostpluginoptionsihost-ireadonlylistassembly-ipluginfactory-constructor","title":"HostPluginOptions(IHost, IReadOnlyList&lt;Assembly&gt;, IPluginFactory) Constructor","text":"<p>Options passed to NexusLabs.Needlr.Hosting.IHostPlugin.Configure(NexusLabs.Needlr.Hosting.HostPluginOptions).</p> <pre><code>public HostPluginOptions(Microsoft.Extensions.Hosting.IHost Host, System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt; Assemblies, NexusLabs.Needlr.IPluginFactory PluginFactory);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostPluginOptions/#parameters","title":"Parameters","text":"<p><code>Host</code> Microsoft.Extensions.Hosting.IHost</p> <p></p> <p><code>Assemblies</code> System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt;</p> <p></p> <p><code>PluginFactory</code> NexusLabs.Needlr.IPluginFactory</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringe/","title":"HostSyringe","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringe/#nexuslabsneedlrhosting","title":"NexusLabs.Needlr.Hosting","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringe/#hostsyringe-class","title":"HostSyringe Class","text":"<p>Provides a fluent API for configuring and building host applications using Needlr. Wraps a ConfiguredSyringe with additional host functionality.</p> <pre><code>public sealed record HostSyringe : System.IEquatable&lt;NexusLabs.Needlr.Hosting.HostSyringe&gt;\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 HostSyringe</p> <p>Implements System.IEquatable&lt;HostSyringe&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringe/#example","title":"Example","text":"<p>Creating and configuring a HostSyringe:</p> <pre><code>// Transition from ConfiguredSyringe\nvar hostSyringe = new Syringe()\n    .UsingReflection()\n    .ForHost();\n\n// Build and run the host\nvar host = hostSyringe\n    .UsingOptions(() =&gt; CreateHostOptions.Default.UsingArgs(args))\n    .UsingConfigurationCallback((builder, options) =&gt; \n    {\n        // Configure the HostApplicationBuilder\n        builder.Configuration.AddJsonFile(\"custom-settings.json\", optional: true);\n        builder.Services.AddSingleton&lt;IMyCustomService, MyCustomService&gt;();\n    })\n    .BuildHost();\n\nawait host.RunAsync();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringe/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringe/#hostsyringeconfiguredsyringe-constructor","title":"HostSyringe(ConfiguredSyringe) Constructor","text":"<p>Initializes a new instance of the HostSyringe class.</p> <pre><code>public HostSyringe(NexusLabs.Needlr.Injection.ConfiguredSyringe baseSyringe);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringe/#parameters","title":"Parameters","text":"<p><code>baseSyringe</code> NexusLabs.Needlr.Injection.ConfiguredSyringe</p> <p>The configured syringe to wrap.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringe/#example_1","title":"Example","text":"<pre><code>var configuredSyringe = new Syringe().UsingReflection();\n\nvar hostSyringe = new HostSyringe(configuredSyringe);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringe/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringe/#hostsyringebuildhost-method","title":"HostSyringe.BuildHost() Method","text":"<p>Builds a host with the configured settings.</p> <pre><code>public Microsoft.Extensions.Hosting.IHost BuildHost();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringe/#returns","title":"Returns","text":"<p>Microsoft.Extensions.Hosting.IHost The configured Microsoft.Extensions.Hosting.IHost.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringe/#example_2","title":"Example","text":"<pre><code>var host = new Syringe()\n    .UsingReflection()\n    .UsingScrutorTypeRegistrar()\n    .ForHost()\n    .UsingOptions(() =&gt; CreateHostOptions.Default\n        .UsingArgs(args)\n        .UsingApplicationName(\"My Worker Service\"))\n    .UsingConfigurationCallback((builder, options) =&gt;\n    {\n        // Add custom configuration sources\n        builder.Configuration.AddJsonFile(\"appsettings.local.json\", optional: true);\n\n        // Register additional services\n        builder.Services.AddSingleton&lt;ICustomService, CustomService&gt;();\n    })\n    .BuildHost();\n\nawait host.RunAsync();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringe/#hostsyringebuildserviceprovidericonfiguration-method","title":"HostSyringe.BuildServiceProvider(IConfiguration) Method","text":"<p>Builds a service provider with the configured settings.</p> <pre><code>public System.IServiceProvider BuildServiceProvider(Microsoft.Extensions.Configuration.IConfiguration config);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringe/#parameters_1","title":"Parameters","text":"<p><code>config</code> Microsoft.Extensions.Configuration.IConfiguration</p> <p>The configuration to use for building the service provider.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringe/#returns_1","title":"Returns","text":"<p>System.IServiceProvider The configured System.IServiceProvider.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringe/#example_3","title":"Example","text":"<pre><code>var config = new ConfigurationBuilder()\n    .AddJsonFile(\"appsettings.json\")\n    .Build();\n\nvar serviceProvider = new Syringe()\n    .UsingReflection()\n    .UsingScrutorTypeRegistrar()\n    .ForHost()\n    .BuildServiceProvider(config);\n\nvar myService = serviceProvider.GetRequiredService&lt;IMyService&gt;();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringeExtensions/","title":"HostSyringeExtensions","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringeExtensions/#nexuslabsneedlrhosting","title":"NexusLabs.Needlr.Hosting","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringeExtensions/#hostsyringeextensions-class","title":"HostSyringeExtensions Class","text":"<p>Extension methods for configuring HostSyringe instances. Provides only host-specific configuration methods.</p> <pre><code>public static class HostSyringeExtensions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 HostSyringeExtensions</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringeExtensions/#example","title":"Example","text":"<p>Complete host configuration:</p> <pre><code>var host = new Syringe()\n    // Transition to host mode\n    .ForHost()\n    // Configure host-specific options\n    .UsingOptions(() =&gt; CreateHostOptions.Default\n        .UsingArgs(args)\n        .UsingApplicationName(\"My Worker Service\")\n        .UsingStartupConsoleLogger())\n    .UsingConfigurationCallback((builder, options) =&gt;\n    {\n        // Configure the HostApplicationBuilder\n        builder.Configuration.AddJsonFile(\"custom-settings.json\", optional: true);\n        builder.Services.AddSingleton&lt;IMyCustomService, MyCustomService&gt;();\n    })\n    .BuildHost();\n\nawait host.RunAsync();\n</code></pre> <p>Minimal host:</p> <pre><code>var host = new Syringe()\n    .ForHost()\n    .BuildHost();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringeExtensions/#remarks","title":"Remarks","text":"<p>Remember to use base NexusLabs.Needlr.Injection.Syringe extension methods BEFORE transitioning to host mode.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringeExtensions/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringeExtensions/#hostsyringeextensionsusingconfigurationcallbackthis-hostsyringe-actionhostapplicationbuildercreatehostoptions-method","title":"HostSyringeExtensions.UsingConfigurationCallback(this HostSyringe, Action&lt;HostApplicationBuilder,CreateHostOptions&gt;) Method","text":"<p>Configures the HostSyringe to use a callback for configuring the Microsoft.Extensions.Hosting.HostApplicationBuilder. This allows for custom configuration of the builder, such as modifying the Microsoft.Extensions.Configuration.ConfigurationBuilder or adding additional services before the host is built.</p> <pre><code>public static NexusLabs.Needlr.Hosting.HostSyringe UsingConfigurationCallback(this NexusLabs.Needlr.Hosting.HostSyringe syringe, System.Action&lt;Microsoft.Extensions.Hosting.HostApplicationBuilder,NexusLabs.Needlr.Hosting.CreateHostOptions&gt; configureCallback);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringeExtensions/#parameters","title":"Parameters","text":"<p><code>syringe</code> HostSyringe</p> <p>The HostSyringe to configure.</p> <p></p> <p><code>configureCallback</code> System.Action&lt;Microsoft.Extensions.Hosting.HostApplicationBuilder,CreateHostOptions&gt;</p> <p>The callback to configure the Microsoft.Extensions.Hosting.HostApplicationBuilder.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringeExtensions/#returns","title":"Returns","text":"<p>HostSyringe A new configured HostSyringe instance.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringeExtensions/#example_1","title":"Example","text":"<pre><code>var hostSyringe = syringe\n    .ForHost()\n    .UsingConfigurationCallback((builder, options) =&gt;\n    {\n        // Add custom configuration sources\n        builder.Configuration.AddJsonFile(\"appsettings.local.json\", optional: true);\n        builder.Configuration.AddEnvironmentVariables(\"MYAPP_\");\n\n        // Register additional services that need to be available before plugin registration\n        builder.Services.AddSingleton&lt;ICustomConfigurationService, CustomConfigurationService&gt;();\n\n        // Configure logging\n        builder.Services.AddLogging(logging =&gt;\n        {\n            logging.AddConsole();\n            logging.SetMinimumLevel(LogLevel.Debug);\n        });\n    });\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringeExtensions/#hostsyringeextensionsusinghostfactorythis-hostsyringe-funciserviceproviderbuilderiservicecollectionpopulatorihostfactory-method","title":"HostSyringeExtensions.UsingHostFactory(this HostSyringe, Func&lt;IServiceProviderBuilder,IServiceCollectionPopulator,IHostFactory&gt;) Method","text":"<p>Configures the HostSyringe to use the specified host factory.</p> <pre><code>public static NexusLabs.Needlr.Hosting.HostSyringe UsingHostFactory(this NexusLabs.Needlr.Hosting.HostSyringe syringe, System.Func&lt;NexusLabs.Needlr.Injection.IServiceProviderBuilder,NexusLabs.Needlr.Injection.IServiceCollectionPopulator,NexusLabs.Needlr.Hosting.IHostFactory&gt; factory);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringeExtensions/#parameters_1","title":"Parameters","text":"<p><code>syringe</code> HostSyringe</p> <p>The HostSyringe to configure.</p> <p></p> <p><code>factory</code> System.Func&lt;NexusLabs.Needlr.Injection.IServiceProviderBuilder,NexusLabs.Needlr.Injection.IServiceCollectionPopulator,IHostFactory&gt;</p> <p>The factory function for creating host factories.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringeExtensions/#returns_1","title":"Returns","text":"<p>HostSyringe A new configured HostSyringe instance.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringeExtensions/#example_2","title":"Example","text":"<pre><code>var hostSyringe = syringe\n    .ForHost()\n    .UsingHostFactory((serviceProviderBuilder, serviceCollectionPopulator) =&gt; \n    {\n        // Custom factory logic here\n        return new CustomHostFactory(serviceProviderBuilder, serviceCollectionPopulator);\n    });\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringeExtensions/#hostsyringeextensionsusingoptionsthis-hostsyringe-funccreatehostoptions-method","title":"HostSyringeExtensions.UsingOptions(this HostSyringe, Func&lt;CreateHostOptions&gt;) Method","text":"<p>Configures the HostSyringe to use the specified host options factory.</p> <pre><code>public static NexusLabs.Needlr.Hosting.HostSyringe UsingOptions(this NexusLabs.Needlr.Hosting.HostSyringe syringe, System.Func&lt;NexusLabs.Needlr.Hosting.CreateHostOptions&gt; optionsFactory);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringeExtensions/#parameters_2","title":"Parameters","text":"<p><code>syringe</code> HostSyringe</p> <p>The HostSyringe to configure.</p> <p></p> <p><code>optionsFactory</code> System.Func&lt;CreateHostOptions&gt;</p> <p>The factory function for creating host options.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringeExtensions/#returns_2","title":"Returns","text":"<p>HostSyringe A new configured HostSyringe instance.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/HostSyringeExtensions/#example_3","title":"Example","text":"<pre><code>var hostSyringe = syringe\n    .ForHost()\n    .UsingOptions(() =&gt; CreateHostOptions.Default\n        .UsingArgs(args)\n        .UsingApplicationName(\"My App\")\n        .UsingStartupConsoleLogger());\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/IHostApplicationBuilderPlugin/","title":"IHostApplicationBuilderPlugin","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/IHostApplicationBuilderPlugin/#nexuslabsneedlrhosting","title":"NexusLabs.Needlr.Hosting","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/IHostApplicationBuilderPlugin/#ihostapplicationbuilderplugin-interface","title":"IHostApplicationBuilderPlugin Interface","text":"<p>Plugin that configures the Microsoft.Extensions.Hosting.HostApplicationBuilder  before the host is built. Analogous to <code>IWebApplicationBuilderPlugin</code> for web apps.</p> <pre><code>public interface IHostApplicationBuilderPlugin\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/IHostFactory/","title":"IHostFactory","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/IHostFactory/#nexuslabsneedlrhosting","title":"NexusLabs.Needlr.Hosting","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/IHostFactory/#ihostfactory-interface","title":"IHostFactory Interface","text":"<p>Factory interface for creating Microsoft.Extensions.Hosting.IHost instances with Needlr configuration.</p> <pre><code>public interface IHostFactory\n</code></pre> <p>Derived \u21b3 HostFactory</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/IHostFactory/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/IHostFactory/#ihostfactorycreatecreatehostoptions-funchostapplicationbuilder-method","title":"IHostFactory.Create(CreateHostOptions, Func&lt;HostApplicationBuilder&gt;) Method","text":"<p>Creates an Microsoft.Extensions.Hosting.IHost using the specified options and builder callback.</p> <pre><code>Microsoft.Extensions.Hosting.IHost Create(NexusLabs.Needlr.Hosting.CreateHostOptions options, System.Func&lt;Microsoft.Extensions.Hosting.HostApplicationBuilder&gt; createHostApplicationBuilderCallback);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/IHostFactory/#parameters","title":"Parameters","text":"<p><code>options</code> CreateHostOptions</p> <p>The options for creating the host.</p> <p></p> <p><code>createHostApplicationBuilderCallback</code> System.Func&lt;Microsoft.Extensions.Hosting.HostApplicationBuilder&gt;</p> <p>The callback that creates and configures the Microsoft.Extensions.Hosting.HostApplicationBuilder.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/IHostFactory/#returns","title":"Returns","text":"<p>Microsoft.Extensions.Hosting.IHost The configured Microsoft.Extensions.Hosting.IHost.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/IHostFactoryExtensions/","title":"IHostFactoryExtensions","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/IHostFactoryExtensions/#nexuslabsneedlrhosting","title":"NexusLabs.Needlr.Hosting","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/IHostFactoryExtensions/#ihostfactoryextensions-class","title":"IHostFactoryExtensions Class","text":"<p>Extension methods for IHostFactory.</p> <pre><code>public static class IHostFactoryExtensions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 IHostFactoryExtensions</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/IHostFactoryExtensions/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/IHostFactoryExtensions/#ihostfactoryextensionscreatethis-ihostfactory-createhostoptions-method","title":"IHostFactoryExtensions.Create(this IHostFactory, CreateHostOptions) Method","text":"<p>Creates an Microsoft.Extensions.Hosting.IHost using the specified options.</p> <pre><code>public static Microsoft.Extensions.Hosting.IHost Create(this NexusLabs.Needlr.Hosting.IHostFactory factory, NexusLabs.Needlr.Hosting.CreateHostOptions options);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/IHostFactoryExtensions/#parameters","title":"Parameters","text":"<p><code>factory</code> IHostFactory</p> <p>The host factory.</p> <p></p> <p><code>options</code> CreateHostOptions</p> <p>The options for creating the host.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/IHostFactoryExtensions/#returns","title":"Returns","text":"<p>Microsoft.Extensions.Hosting.IHost The configured Microsoft.Extensions.Hosting.IHost.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/IHostFactoryExtensions/#exceptions","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when factory or options is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/IHostFactoryExtensions/#ihostfactoryextensionscreatethis-ihostfactory-createhostoptions-actionhostapplicationbuildercreatehostoptions-method","title":"IHostFactoryExtensions.Create(this IHostFactory, CreateHostOptions, Action&lt;HostApplicationBuilder,CreateHostOptions&gt;) Method","text":"<p>Creates an Microsoft.Extensions.Hosting.IHost using the specified options and configuration callback.</p> <pre><code>public static Microsoft.Extensions.Hosting.IHost Create(this NexusLabs.Needlr.Hosting.IHostFactory factory, NexusLabs.Needlr.Hosting.CreateHostOptions options, System.Action&lt;Microsoft.Extensions.Hosting.HostApplicationBuilder,NexusLabs.Needlr.Hosting.CreateHostOptions&gt;? configureCallback);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/IHostFactoryExtensions/#parameters_1","title":"Parameters","text":"<p><code>factory</code> IHostFactory</p> <p>The host factory.</p> <p></p> <p><code>options</code> CreateHostOptions</p> <p>The options for creating the host.</p> <p></p> <p><code>configureCallback</code> System.Action&lt;Microsoft.Extensions.Hosting.HostApplicationBuilder,CreateHostOptions&gt;</p> <p>Optional callback to configure the Microsoft.Extensions.Hosting.HostApplicationBuilder.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/IHostFactoryExtensions/#returns_1","title":"Returns","text":"<p>Microsoft.Extensions.Hosting.IHost The configured Microsoft.Extensions.Hosting.IHost.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/IHostFactoryExtensions/#exceptions_1","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when factory or options is null.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/IHostPlugin/","title":"IHostPlugin","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/IHostPlugin/#nexuslabsneedlrhosting","title":"NexusLabs.Needlr.Hosting","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/IHostPlugin/#ihostplugin-interface","title":"IHostPlugin Interface","text":"<p>Plugin that configures the Microsoft.Extensions.Hosting.IHost after it's built  but before it runs. Analogous to <code>IWebApplicationPlugin</code> for web apps.</p> <pre><code>public interface IHostPlugin\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/NexusLabs.Needlr.Hosting/","title":"NexusLabs.Needlr.Hosting","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/NexusLabs.Needlr.Hosting/#nexuslabsneedlrhosting-namespace","title":"NexusLabs.Needlr.Hosting Namespace","text":"Classes CreateHostOptions Represents options for creating a host application with logging configuration. CreateHostOptionsExtensions Provides extension methods for configuring CreateHostOptions. HostApplicationBuilderNeedlrExtensions Extension methods for integrating Needlr discovery into user-controlled Microsoft.Extensions.Hosting.HostApplicationBuilder instances. Use this when you want to maintain control over the host creation process while still benefiting from Needlr's automatic service discovery and plugin system. HostApplicationBuilderPluginOptions Options passed to NexusLabs.Needlr.Hosting.IHostApplicationBuilderPlugin.Configure(NexusLabs.Needlr.Hosting.HostApplicationBuilderPluginOptions). HostFactory Factory for creating Microsoft.Extensions.Hosting.IHost instances with Needlr configuration. HostPluginOptions Options passed to NexusLabs.Needlr.Hosting.IHostPlugin.Configure(NexusLabs.Needlr.Hosting.HostPluginOptions). HostSyringe Provides a fluent API for configuring and building host applications using Needlr. Wraps a ConfiguredSyringe with additional host functionality. HostSyringeExtensions Extension methods for configuring HostSyringe instances. Provides only host-specific configuration methods. IHostFactoryExtensions Extension methods for IHostFactory. SyringeHostingExtensions Extension methods for configuring NexusLabs.Needlr.Injection.ConfiguredSyringe instances with generic host functionality. Interfaces IHostApplicationBuilderPlugin Plugin that configures the Microsoft.Extensions.Hosting.HostApplicationBuilder  before the host is built. Analogous to <code>IWebApplicationBuilderPlugin</code> for web apps. IHostFactory Factory interface for creating Microsoft.Extensions.Hosting.IHost instances with Needlr configuration. IHostPlugin Plugin that configures the Microsoft.Extensions.Hosting.IHost after it's built  but before it runs. Analogous to <code>IWebApplicationPlugin</code> for web apps."},{"location":"api/dev/NexusLabs.Needlr.Hosting/SyringeHostingExtensions/","title":"SyringeHostingExtensions","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/SyringeHostingExtensions/#nexuslabsneedlrhosting","title":"NexusLabs.Needlr.Hosting","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/SyringeHostingExtensions/#syringehostingextensions-class","title":"SyringeHostingExtensions Class","text":"<p>Extension methods for configuring NexusLabs.Needlr.Injection.ConfiguredSyringe instances with generic host functionality.</p> <pre><code>public static class SyringeHostingExtensions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 SyringeHostingExtensions</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/SyringeHostingExtensions/#example","title":"Example","text":"<p>Source-gen first (recommended for AOT/trimming):</p> <pre><code>// With module initializer bootstrap (automatic):\nvar host = new Syringe()\n    .UsingSourceGen()\n    .ForHost()\n    .BuildHost();\n\nawait host.RunAsync();\n</code></pre> <p>Reflection-based (for dynamic scenarios):</p> <pre><code>var host = new Syringe()\n    .UsingReflection()\n    .ForHost()\n    .BuildHost();\n\nawait host.RunAsync();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/SyringeHostingExtensions/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Hosting/SyringeHostingExtensions/#syringehostingextensionsbuildhostthis-configuredsyringe-method","title":"SyringeHostingExtensions.BuildHost(this ConfiguredSyringe) Method","text":"<p>Builds a host with the configured settings using the default HostFactory.</p> <pre><code>public static Microsoft.Extensions.Hosting.IHost BuildHost(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/SyringeHostingExtensions/#parameters","title":"Parameters","text":"<p><code>syringe</code> NexusLabs.Needlr.Injection.ConfiguredSyringe</p> <p>The configured syringe to build from.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/SyringeHostingExtensions/#returns","title":"Returns","text":"<p>Microsoft.Extensions.Hosting.IHost The configured Microsoft.Extensions.Hosting.IHost.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/SyringeHostingExtensions/#example_1","title":"Example","text":"<pre><code>// Direct build without additional host configuration\nvar host = new Syringe()\n    .UsingReflection()\n    .BuildHost();\n\nawait host.RunAsync();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/SyringeHostingExtensions/#syringehostingextensionsforhostthis-configuredsyringe-method","title":"SyringeHostingExtensions.ForHost(this ConfiguredSyringe) Method","text":"<p>Transitions the configured syringe to host mode, enabling host-specific configuration.</p> <pre><code>public static NexusLabs.Needlr.Hosting.HostSyringe ForHost(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/SyringeHostingExtensions/#parameters_1","title":"Parameters","text":"<p><code>syringe</code> NexusLabs.Needlr.Injection.ConfiguredSyringe</p> <p>The configured syringe to transition.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/SyringeHostingExtensions/#returns_1","title":"Returns","text":"<p>HostSyringe A new host syringe instance.</p>"},{"location":"api/dev/NexusLabs.Needlr.Hosting/SyringeHostingExtensions/#example_2","title":"Example","text":"<pre><code>var hostSyringe = new Syringe()\n    .UsingReflection()\n    .ForHost(); // Transition to host mode\n\n// Now you can use host-specific methods\nvar host = hostSyringe\n    .UsingOptions(() =&gt; CreateHostOptions.Default.UsingArgs(args))\n    .BuildHost();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/","title":"Index","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/#nexuslabsneedlrinjection","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/#nexuslabsneedlrinjection-assembly","title":"NexusLabs.Needlr.Injection Assembly","text":"Namespaces NexusLabs.Needlr.Injection NexusLabs.Needlr.Injection.AssemblyOrdering NexusLabs.Needlr.Injection.TypeFilterers"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyInfo/","title":"AssemblyInfo","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyInfo/#nexuslabsneedlrinjection","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyInfo/#nexuslabsneedlrinjectionassemblyordering","title":"NexusLabs.Needlr.Injection.AssemblyOrdering","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyInfo/#assemblyinfo-class","title":"AssemblyInfo Class","text":"<p>Provides a simplified view of assembly information for ordering expressions. This abstraction works for both reflection (runtime Assembly) and source-gen (compile-time info).</p> <pre><code>public sealed class AssemblyInfo\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 AssemblyInfo</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyInfo/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyInfo/#assemblyinfolocation-property","title":"AssemblyInfo.Location Property","text":"<p>The full file path/location of the assembly (if available).</p> <pre><code>public string Location { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyInfo/#property-value","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyInfo/#assemblyinfoname-property","title":"AssemblyInfo.Name Property","text":"<p>The assembly name (without extension).</p> <pre><code>public string Name { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyInfo/#property-value_1","title":"Property Value","text":"<p>System.String</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyInfo/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyInfo/#assemblyinfofromassemblyassembly-method","title":"AssemblyInfo.FromAssembly(Assembly) Method","text":"<p>Creates an AssemblyInfo from a runtime Assembly.</p> <pre><code>public static NexusLabs.Needlr.Injection.AssemblyOrdering.AssemblyInfo FromAssembly(System.Reflection.Assembly assembly);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyInfo/#parameters","title":"Parameters","text":"<p><code>assembly</code> System.Reflection.Assembly</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyInfo/#returns","title":"Returns","text":"<p>AssemblyInfo</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyInfo/#remarks","title":"Remarks","text":"<p>Note: In single-file published apps, Assembly.Location returns an empty string. This is expected behavior and the Location property will be empty in those scenarios.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyInfo/#assemblyinfofromstringsstring-string-method","title":"AssemblyInfo.FromStrings(string, string) Method","text":"<p>Creates an AssemblyInfo from string values (for source-gen scenarios).</p> <pre><code>public static NexusLabs.Needlr.Injection.AssemblyOrdering.AssemblyInfo FromStrings(string name, string location=\"\");\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyInfo/#parameters_1","title":"Parameters","text":"<p><code>name</code> System.String</p> <p></p> <p><code>location</code> System.String</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyInfo/#returns_1","title":"Returns","text":"<p>AssemblyInfo</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrder/","title":"AssemblyOrder","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrder/#nexuslabsneedlrinjection","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrder/#nexuslabsneedlrinjectionassemblyordering","title":"NexusLabs.Needlr.Injection.AssemblyOrdering","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrder/#assemblyorder-class","title":"AssemblyOrder Class","text":"<p>Factory for creating assembly ordering configurations.</p> <pre><code>public static class AssemblyOrder\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 AssemblyOrder</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrder/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrder/#assemblyorderalphabetical-method","title":"AssemblyOrder.Alphabetical() Method","text":"<p>Creates a preset ordering: alphabetical by name.</p> <pre><code>public static NexusLabs.Needlr.Injection.AssemblyOrdering.AssemblyOrderBuilder Alphabetical();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrder/#returns","title":"Returns","text":"<p>AssemblyOrderBuilder A builder configured with alphabetical ordering.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrder/#assemblyordercreate-method","title":"AssemblyOrder.Create() Method","text":"<p>Creates a new assembly order builder.</p> <pre><code>public static NexusLabs.Needlr.Injection.AssemblyOrdering.AssemblyOrderBuilder Create();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrder/#returns_1","title":"Returns","text":"<p>AssemblyOrderBuilder A new builder instance.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrder/#assemblyordercreateactionassemblyorderbuilder-method","title":"AssemblyOrder.Create(Action&lt;AssemblyOrderBuilder&gt;) Method","text":"<p>Creates an ordering configuration from a builder action.</p> <pre><code>public static NexusLabs.Needlr.Injection.AssemblyOrdering.AssemblyOrderBuilder Create(System.Action&lt;NexusLabs.Needlr.Injection.AssemblyOrdering.AssemblyOrderBuilder&gt; configure);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrder/#parameters","title":"Parameters","text":"<p><code>configure</code> System.Action&lt;AssemblyOrderBuilder&gt;</p> <p>Action to configure the ordering rules.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrder/#returns_2","title":"Returns","text":"<p>AssemblyOrderBuilder The configured builder.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrder/#assemblyorderlibtestentry-method","title":"AssemblyOrder.LibTestEntry() Method","text":"<p>Creates a preset ordering: libraries first, then executables, tests last. Uses file location to distinguish DLLs from EXEs.</p> <pre><code>public static NexusLabs.Needlr.Injection.AssemblyOrdering.AssemblyOrderBuilder LibTestEntry();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrder/#returns_3","title":"Returns","text":"<p>AssemblyOrderBuilder A builder configured with lib-test-entry ordering.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrder/#assemblyordertestslast-method","title":"AssemblyOrder.TestsLast() Method","text":"<p>Creates a preset ordering: non-test assemblies first, tests last. Use this for source-gen scenarios where only assembly names are available.</p> <pre><code>public static NexusLabs.Needlr.Injection.AssemblyOrdering.AssemblyOrderBuilder TestsLast();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrder/#returns_4","title":"Returns","text":"<p>AssemblyOrderBuilder A builder configured with tests-last ordering by name.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrderBuilder/","title":"AssemblyOrderBuilder","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrderBuilder/#nexuslabsneedlrinjection","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrderBuilder/#nexuslabsneedlrinjectionassemblyordering","title":"NexusLabs.Needlr.Injection.AssemblyOrdering","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrderBuilder/#assemblyorderbuilder-class","title":"AssemblyOrderBuilder Class","text":"<p>Fluent builder for specifying assembly ordering rules. Assemblies are sorted into tiers based on the first matching rule. Unmatched assemblies are placed last.</p> <pre><code>public sealed class AssemblyOrderBuilder\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 AssemblyOrderBuilder</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrderBuilder/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrderBuilder/#assemblyorderbuilderrules-property","title":"AssemblyOrderBuilder.Rules Property","text":"<p>Gets the ordering rules that have been configured.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Injection.AssemblyOrdering.AssemblyOrderRule&gt; Rules { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrderBuilder/#property-value","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;AssemblyOrderRule&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrderBuilder/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrderBuilder/#assemblyorderbuilderbyexpressionfuncassemblyinfobool-method","title":"AssemblyOrderBuilder.By(Expression&lt;Func&lt;AssemblyInfo,bool&gt;&gt;) Method","text":"<p>Adds the first ordering rule. Assemblies matching this expression go first.</p> <pre><code>public NexusLabs.Needlr.Injection.AssemblyOrdering.AssemblyOrderBuilder By(System.Linq.Expressions.Expression&lt;System.Func&lt;NexusLabs.Needlr.Injection.AssemblyOrdering.AssemblyInfo,bool&gt;&gt; predicate);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrderBuilder/#parameters","title":"Parameters","text":"<p><code>predicate</code> System.Linq.Expressions.Expression&lt;System.Func&lt;AssemblyInfo,System.Boolean&gt;&gt;</p> <p>Expression that determines if an assembly matches this tier.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrderBuilder/#returns","title":"Returns","text":"<p>AssemblyOrderBuilder The builder for chaining.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrderBuilder/#assemblyorderbuildersortienumerableassembly-method","title":"AssemblyOrderBuilder.Sort(IEnumerable&lt;Assembly&gt;) Method","text":"<p>Sorts assemblies according to the configured rules. Each assembly is placed in the first tier it matches. Unmatched assemblies are placed last.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt; Sort(System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt; assemblies);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrderBuilder/#parameters_1","title":"Parameters","text":"<p><code>assemblies</code> System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt;</p> <p>The assemblies to sort.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrderBuilder/#returns_1","title":"Returns","text":"<p>System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt; The sorted assemblies.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrderBuilder/#assemblyorderbuildersortnamesienumerablestring-method","title":"AssemblyOrderBuilder.SortNames(IEnumerable&lt;string&gt;) Method","text":"<p>Sorts assembly names according to the configured rules. Used for source-gen scenarios where only names are available.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;string&gt; SortNames(System.Collections.Generic.IEnumerable&lt;string&gt; assemblyNames);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrderBuilder/#parameters_2","title":"Parameters","text":"<p><code>assemblyNames</code> System.Collections.Generic.IEnumerable&lt;System.String&gt;</p> <p>The assembly names to sort.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrderBuilder/#returns_2","title":"Returns","text":"<p>System.Collections.Generic.IReadOnlyList&lt;System.String&gt; The sorted assembly names.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrderBuilder/#assemblyorderbuilderthenbyexpressionfuncassemblyinfobool-method","title":"AssemblyOrderBuilder.ThenBy(Expression&lt;Func&lt;AssemblyInfo,bool&gt;&gt;) Method","text":"<p>Adds a subsequent ordering rule. Assemblies matching this expression  (and not matching any previous rules) go in the next tier.</p> <pre><code>public NexusLabs.Needlr.Injection.AssemblyOrdering.AssemblyOrderBuilder ThenBy(System.Linq.Expressions.Expression&lt;System.Func&lt;NexusLabs.Needlr.Injection.AssemblyOrdering.AssemblyInfo,bool&gt;&gt; predicate);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrderBuilder/#parameters_3","title":"Parameters","text":"<p><code>predicate</code> System.Linq.Expressions.Expression&lt;System.Func&lt;AssemblyInfo,System.Boolean&gt;&gt;</p> <p>Expression that determines if an assembly matches this tier.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrderBuilder/#returns_3","title":"Returns","text":"<p>AssemblyOrderBuilder The builder for chaining.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrderRule/","title":"AssemblyOrderRule","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrderRule/#nexuslabsneedlrinjection","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrderRule/#nexuslabsneedlrinjectionassemblyordering","title":"NexusLabs.Needlr.Injection.AssemblyOrdering","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrderRule/#assemblyorderrule-class","title":"AssemblyOrderRule Class","text":"<p>Represents a single ordering rule that matches assemblies to a tier.</p> <pre><code>public sealed class AssemblyOrderRule\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 AssemblyOrderRule</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrderRule/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrderRule/#assemblyorderrulecompiledpredicate-property","title":"AssemblyOrderRule.CompiledPredicate Property","text":"<p>The compiled predicate for runtime execution.</p> <pre><code>public System.Func&lt;NexusLabs.Needlr.Injection.AssemblyOrdering.AssemblyInfo,bool&gt; CompiledPredicate { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrderRule/#property-value","title":"Property Value","text":"<p>System.Func&lt;AssemblyInfo,System.Boolean&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrderRule/#assemblyorderruleexpression-property","title":"AssemblyOrderRule.Expression Property","text":"<p>The expression that determines if an assembly matches this rule.</p> <pre><code>public System.Linq.Expressions.Expression&lt;System.Func&lt;NexusLabs.Needlr.Injection.AssemblyOrdering.AssemblyInfo,bool&gt;&gt; Expression { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrderRule/#property-value_1","title":"Property Value","text":"<p>System.Linq.Expressions.Expression&lt;System.Func&lt;AssemblyInfo,System.Boolean&gt;&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrderRule/#assemblyorderruletier-property","title":"AssemblyOrderRule.Tier Property","text":"<p>The tier index (lower = earlier in sort order).</p> <pre><code>public int Tier { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/AssemblyOrderRule/#property-value_2","title":"Property Value","text":"<p>System.Int32</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ConfiguredSyringe/","title":"ConfiguredSyringe","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/ConfiguredSyringe/#nexuslabsneedlrinjection","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/ConfiguredSyringe/#nexuslabsneedlrinjection_1","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/ConfiguredSyringe/#configuredsyringe-class","title":"ConfiguredSyringe Class","text":"<p>Represents a Syringe that has been configured with a strategy (UsingReflection, UsingSourceGen, or UsingAutoConfiguration). This type has access to all configuration extension methods and can build a service provider.</p> <pre><code>public sealed record ConfiguredSyringe : System.IEquatable&lt;NexusLabs.Needlr.Injection.ConfiguredSyringe&gt;\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 ConfiguredSyringe</p> <p>Implements System.IEquatable&lt;ConfiguredSyringe&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ConfiguredSyringe/#remarks","title":"Remarks","text":"<p>ConfiguredSyringe is created by calling one of the strategy methods on Syringe: - <code>new Syringe().UsingReflection()</code> - uses reflection-based type discovery - <code>new Syringe().UsingSourceGen()</code> - uses source-generated type discovery - <code>new Syringe().UsingAutoConfiguration()</code> - automatically selects best available strategy</p> <p>Once configured, use extension methods to further customize the container, then call  BuildServiceProvider(IConfiguration) to create the service provider.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ConfiguredSyringe/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/ConfiguredSyringe/#configuredsyringebuildserviceprovidericonfiguration-method","title":"ConfiguredSyringe.BuildServiceProvider(IConfiguration) Method","text":"<p>Builds a service provider with the configured settings. Automatically runs container verification based on NexusLabs.Needlr.Injection.ConfiguredSyringe.VerificationOptions.</p> <pre><code>public System.IServiceProvider BuildServiceProvider(Microsoft.Extensions.Configuration.IConfiguration config);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ConfiguredSyringe/#parameters","title":"Parameters","text":"<p><code>config</code> Microsoft.Extensions.Configuration.IConfiguration</p> <p>The configuration to use for building the service provider.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ConfiguredSyringe/#returns","title":"Returns","text":"<p>System.IServiceProvider The configured System.IServiceProvider.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ConfiguredSyringe/#exceptions","title":"Exceptions","text":"<p>System.InvalidOperationException Thrown if required components (TypeRegistrar, TypeFilterer, PluginFactory, AssemblyProvider) are not configured.</p> <p>NexusLabs.Needlr.ContainerVerificationException Thrown if verification issues are detected and the configured behavior is NexusLabs.Needlr.VerificationBehavior.Throw.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ConfiguredSyringe/#configuredsyringegetadditionalassemblies-method","title":"ConfiguredSyringe.GetAdditionalAssemblies() Method","text":"<p>Gets the configured additional assemblies.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt; GetAdditionalAssemblies();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ConfiguredSyringe/#returns_1","title":"Returns","text":"<p>System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ConfiguredSyringe/#configuredsyringegetorcreateassemblyprovider-method","title":"ConfiguredSyringe.GetOrCreateAssemblyProvider() Method","text":"<p>Gets the configured assembly provider, with ordering applied if configured.</p> <pre><code>public NexusLabs.Needlr.Injection.IAssemblyProvider GetOrCreateAssemblyProvider();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ConfiguredSyringe/#returns_2","title":"Returns","text":"<p>IAssemblyProvider</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ConfiguredSyringe/#exceptions_1","title":"Exceptions","text":"<p>System.InvalidOperationException Thrown if no assembly provider is configured. This should not happen if the syringe was created via UsingReflection(), UsingSourceGen(), or UsingAutoConfiguration().</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ConfiguredSyringe/#configuredsyringegetorcreatepluginfactory-method","title":"ConfiguredSyringe.GetOrCreatePluginFactory() Method","text":"<p>Gets the configured plugin factory.</p> <pre><code>public NexusLabs.Needlr.IPluginFactory GetOrCreatePluginFactory();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ConfiguredSyringe/#returns_3","title":"Returns","text":"<p>NexusLabs.Needlr.IPluginFactory</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ConfiguredSyringe/#exceptions_2","title":"Exceptions","text":"<p>System.InvalidOperationException Thrown if no plugin factory is configured. This should not happen if the syringe was created via UsingReflection(), UsingSourceGen(), or UsingAutoConfiguration().</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ConfiguredSyringe/#configuredsyringegetorcreateservicecollectionpopulatorityperegistrar-itypefilterer-ipluginfactory-method","title":"ConfiguredSyringe.GetOrCreateServiceCollectionPopulator(ITypeRegistrar, ITypeFilterer, IPluginFactory) Method","text":"<p>Gets the configured service collection populator or creates a default one.</p> <pre><code>public NexusLabs.Needlr.Injection.IServiceCollectionPopulator GetOrCreateServiceCollectionPopulator(NexusLabs.Needlr.Injection.ITypeRegistrar typeRegistrar, NexusLabs.Needlr.Injection.ITypeFilterer typeFilterer, NexusLabs.Needlr.IPluginFactory pluginFactory);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ConfiguredSyringe/#parameters_1","title":"Parameters","text":"<p><code>typeRegistrar</code> ITypeRegistrar</p> <p></p> <p><code>typeFilterer</code> ITypeFilterer</p> <p></p> <p><code>pluginFactory</code> NexusLabs.Needlr.IPluginFactory</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ConfiguredSyringe/#returns_4","title":"Returns","text":"<p>IServiceCollectionPopulator</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ConfiguredSyringe/#configuredsyringegetorcreateserviceproviderbuilderiservicecollectionpopulator-iassemblyprovider-ireadonlylistassembly-method","title":"ConfiguredSyringe.GetOrCreateServiceProviderBuilder(IServiceCollectionPopulator, IAssemblyProvider, IReadOnlyList&lt;Assembly&gt;) Method","text":"<p>Gets the configured service provider builder or throws if not configured.</p> <pre><code>public NexusLabs.Needlr.Injection.IServiceProviderBuilder GetOrCreateServiceProviderBuilder(NexusLabs.Needlr.Injection.IServiceCollectionPopulator serviceCollectionPopulator, NexusLabs.Needlr.Injection.IAssemblyProvider assemblyProvider, System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt; additionalAssemblies);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ConfiguredSyringe/#parameters_2","title":"Parameters","text":"<p><code>serviceCollectionPopulator</code> IServiceCollectionPopulator</p> <p></p> <p><code>assemblyProvider</code> IAssemblyProvider</p> <p></p> <p><code>additionalAssemblies</code> System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ConfiguredSyringe/#returns_5","title":"Returns","text":"<p>IServiceProviderBuilder</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ConfiguredSyringe/#exceptions_3","title":"Exceptions","text":"<p>System.InvalidOperationException Thrown if no service provider builder factory is configured. This should not happen if the syringe was created via UsingReflection(), UsingSourceGen(), or UsingAutoConfiguration().</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ConfiguredSyringe/#configuredsyringegetorcreatetypefilterer-method","title":"ConfiguredSyringe.GetOrCreateTypeFilterer() Method","text":"<p>Gets the configured type filterer or creates an empty one.</p> <pre><code>public NexusLabs.Needlr.Injection.ITypeFilterer GetOrCreateTypeFilterer();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ConfiguredSyringe/#returns_6","title":"Returns","text":"<p>ITypeFilterer</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ConfiguredSyringe/#configuredsyringegetorcreatetyperegistrar-method","title":"ConfiguredSyringe.GetOrCreateTypeRegistrar() Method","text":"<p>Gets the configured type registrar.</p> <pre><code>public NexusLabs.Needlr.Injection.ITypeRegistrar GetOrCreateTypeRegistrar();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ConfiguredSyringe/#returns_7","title":"Returns","text":"<p>ITypeRegistrar</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ConfiguredSyringe/#exceptions_4","title":"Exceptions","text":"<p>System.InvalidOperationException Thrown if no type registrar is configured. This should not happen if the syringe was created via UsingReflection(), UsingSourceGen(), or UsingAutoConfiguration().</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ConfiguredSyringe/#configuredsyringegetpostpluginregistrationcallbacks-method","title":"ConfiguredSyringe.GetPostPluginRegistrationCallbacks() Method","text":"<p>Gets the configured post-plugin registration callbacks.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; GetPostPluginRegistrationCallbacks();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ConfiguredSyringe/#returns_8","title":"Returns","text":"<p>System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/EmptyTypeFilterer/","title":"EmptyTypeFilterer","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/EmptyTypeFilterer/#nexuslabsneedlrinjection","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/EmptyTypeFilterer/#nexuslabsneedlrinjectiontypefilterers","title":"NexusLabs.Needlr.Injection.TypeFilterers","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/EmptyTypeFilterer/#emptytypefilterer-class","title":"EmptyTypeFilterer Class","text":"<p>A type filterer that rejects all types. Use as a base when building custom filters.</p> <pre><code>public sealed class EmptyTypeFilterer : NexusLabs.Needlr.Injection.ITypeFilterer\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 EmptyTypeFilterer</p> <p>Implements ITypeFilterer</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/EmptyTypeFilterer/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/EmptyTypeFilterer/#emptytypefiltererinstance-property","title":"EmptyTypeFilterer.Instance Property","text":"<p>Gets the singleton instance of the empty type filterer.</p> <pre><code>public static NexusLabs.Needlr.Injection.TypeFilterers.EmptyTypeFilterer Instance { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/EmptyTypeFilterer/#property-value","title":"Property Value","text":"<p>EmptyTypeFilterer</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/IAssemblyLoader/","title":"IAssemblyLoader","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/IAssemblyLoader/#nexuslabsneedlrinjection","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/IAssemblyLoader/#nexuslabsneedlrinjection_1","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/IAssemblyLoader/#iassemblyloader-interface","title":"IAssemblyLoader Interface","text":"<p>Defines a loader that loads assemblies for dependency injection scanning. Implement this interface to customize how assemblies are discovered and loaded.</p> <pre><code>public interface IAssemblyLoader\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/IAssemblyProvider/","title":"IAssemblyProvider","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/IAssemblyProvider/#nexuslabsneedlrinjection","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/IAssemblyProvider/#nexuslabsneedlrinjection_1","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/IAssemblyProvider/#iassemblyprovider-interface","title":"IAssemblyProvider Interface","text":"<p>Defines a provider that supplies the list of candidate assemblies for dependency injection. Implement this interface to customize which assemblies are scanned for types.</p> <pre><code>public interface IAssemblyProvider\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/IServiceCollectionPopulator/","title":"IServiceCollectionPopulator","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/IServiceCollectionPopulator/#nexuslabsneedlrinjection","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/IServiceCollectionPopulator/#nexuslabsneedlrinjection_1","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/IServiceCollectionPopulator/#iservicecollectionpopulator-interface","title":"IServiceCollectionPopulator Interface","text":"<p>Defines a populator that registers discovered types into a service collection. Handles type scanning, filtering, and registration with appropriate service lifetimes.</p> <pre><code>public interface IServiceCollectionPopulator\n</code></pre> <p>Derived \u21b3 ServiceCollectionPopulator</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/IServiceProviderBuilder/","title":"IServiceProviderBuilder","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/IServiceProviderBuilder/#nexuslabsneedlrinjection","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/IServiceProviderBuilder/#nexuslabsneedlrinjection_1","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/IServiceProviderBuilder/#iserviceproviderbuilder-interface","title":"IServiceProviderBuilder Interface","text":"<p>Defines a builder for constructing service providers with Needlr's auto-discovery capabilities. Coordinates assembly loading, type registration, and plugin execution.</p> <pre><code>public interface IServiceProviderBuilder\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/IServiceProviderBuilder/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/IServiceProviderBuilder/#iserviceproviderbuilderbuildiconfiguration-method","title":"IServiceProviderBuilder.Build(IConfiguration) Method","text":"<p>Builds a new System.IServiceProvider using the discovered assemblies and a custom registration callback.</p> <pre><code>System.IServiceProvider Build(Microsoft.Extensions.Configuration.IConfiguration config);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/IServiceProviderBuilder/#parameters","title":"Parameters","text":"<p><code>config</code> Microsoft.Extensions.Configuration.IConfiguration</p> <p>The configuration to use for settings.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/IServiceProviderBuilder/#returns","title":"Returns","text":"<p>System.IServiceProvider The built System.IServiceProvider.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/IServiceProviderBuilder/#iserviceproviderbuilderbuildiservicecollection-iconfiguration-method","title":"IServiceProviderBuilder.Build(IServiceCollection, IConfiguration) Method","text":"<p>Builds a new System.IServiceProvider using the discovered assemblies and a custom registration callback.</p> <pre><code>System.IServiceProvider Build(Microsoft.Extensions.DependencyInjection.IServiceCollection services, Microsoft.Extensions.Configuration.IConfiguration config);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/IServiceProviderBuilder/#parameters_1","title":"Parameters","text":"<p><code>services</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service collection to configure.</p> <p></p> <p><code>config</code> Microsoft.Extensions.Configuration.IConfiguration</p> <p>The configuration to use for settings.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/IServiceProviderBuilder/#returns_1","title":"Returns","text":"<p>System.IServiceProvider The built System.IServiceProvider.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/IServiceProviderBuilder/#iserviceproviderbuilderbuildiservicecollection-iconfiguration-ireadonlylistactioniservicecollection-method","title":"IServiceProviderBuilder.Build(IServiceCollection, IConfiguration, IReadOnlyList&lt;Action&lt;IServiceCollection&gt;&gt;) Method","text":"<p>Builds a new System.IServiceProvider using the provided Microsoft.Extensions.DependencyInjection.IServiceCollection and a custom registration callback.</p> <pre><code>System.IServiceProvider Build(Microsoft.Extensions.DependencyInjection.IServiceCollection services, Microsoft.Extensions.Configuration.IConfiguration config, System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; postPluginRegistrationCallbacks);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/IServiceProviderBuilder/#parameters_2","title":"Parameters","text":"<p><code>services</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service collection to configure.</p> <p></p> <p><code>config</code> Microsoft.Extensions.Configuration.IConfiguration</p> <p>The configuration to use for settings.</p> <p></p> <p><code>postPluginRegistrationCallbacks</code> System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p>The set of callbacks for additional registration logic</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/IServiceProviderBuilder/#returns_2","title":"Returns","text":"<p>System.IServiceProvider The built System.IServiceProvider.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/IServiceProviderBuilder/#iserviceproviderbuilderbuildiservicecollection-iconfiguration-ireadonlylistactioniservicecollection-ireadonlylistactioniservicecollection-method","title":"IServiceProviderBuilder.Build(IServiceCollection, IConfiguration, IReadOnlyList&lt;Action&lt;IServiceCollection&gt;&gt;, IReadOnlyList&lt;Action&lt;IServiceCollection&gt;&gt;) Method","text":"<p>Builds a new System.IServiceProvider with both pre and post registration callbacks.</p> <pre><code>System.IServiceProvider Build(Microsoft.Extensions.DependencyInjection.IServiceCollection services, Microsoft.Extensions.Configuration.IConfiguration config, System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; preRegistrationCallbacks, System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; postPluginRegistrationCallbacks);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/IServiceProviderBuilder/#parameters_3","title":"Parameters","text":"<p><code>services</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service collection to configure.</p> <p></p> <p><code>config</code> Microsoft.Extensions.Configuration.IConfiguration</p> <p>The configuration to use for settings.</p> <p></p> <p><code>preRegistrationCallbacks</code> System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p>Callbacks executed before auto-discovery registration (e.g., for open generics).</p> <p></p> <p><code>postPluginRegistrationCallbacks</code> System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p>Callbacks executed after plugin registration.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/IServiceProviderBuilder/#returns_3","title":"Returns","text":"<p>System.IServiceProvider The built System.IServiceProvider.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/IServiceProviderBuilder/#iserviceproviderbuilderconfigurepostbuildservicecollectionpluginsiserviceprovider-iconfiguration-method","title":"IServiceProviderBuilder.ConfigurePostBuildServiceCollectionPlugins(IServiceProvider, IConfiguration) Method","text":"<p>Configures plugins that require post-build service collection configuration using the built service provider.</p> <pre><code>void ConfigurePostBuildServiceCollectionPlugins(System.IServiceProvider provider, Microsoft.Extensions.Configuration.IConfiguration config);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/IServiceProviderBuilder/#parameters_4","title":"Parameters","text":"<p><code>provider</code> System.IServiceProvider</p> <p>The built service provider to use for plugin configuration.</p> <p></p> <p><code>config</code> Microsoft.Extensions.Configuration.IConfiguration</p> <p>The configuration to use for settings.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/IServiceProviderBuilder/#iserviceproviderbuildergetcandidateassemblies-method","title":"IServiceProviderBuilder.GetCandidateAssemblies() Method","text":"<p>Gets the list of candidate assemblies that will be scanned for service registrations and plugins.</p> <pre><code>System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt; GetCandidateAssemblies();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/IServiceProviderBuilder/#returns_4","title":"Returns","text":"<p>System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt; A read-only list of assemblies to be processed for dependency injection.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ITypeFilterer/","title":"ITypeFilterer","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/ITypeFilterer/#nexuslabsneedlrinjection","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/ITypeFilterer/#nexuslabsneedlrinjection_1","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/ITypeFilterer/#itypefilterer-interface","title":"ITypeFilterer Interface","text":"<p>Defines a filterer that determines the service lifetime for discovered types. Implement this interface to customize how types are categorized as scoped, transient, or singleton.</p> <pre><code>public interface ITypeFilterer\n</code></pre> <p>Derived \u21b3 EmptyTypeFilterer \u21b3 TypeFilterDecorator</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ITypeFilterer/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/ITypeFilterer/#itypefilterergeteffectivelifetimetype-typefiltererlifetime-method","title":"ITypeFilterer.GetEffectiveLifetime(Type, TypeFiltererLifetime) Method","text":"<p>Gets the effective lifetime for a type, considering any overrides applied via UsingOnlyAsTransient, UsingOnlyAsSingleton, or UsingOnlyAsScoped decorators.</p> <pre><code>NexusLabs.Needlr.Injection.TypeFiltererLifetime GetEffectiveLifetime(System.Type type, NexusLabs.Needlr.Injection.TypeFiltererLifetime defaultLifetime);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ITypeFilterer/#parameters","title":"Parameters","text":"<p><code>type</code> System.Type</p> <p>The type to check.</p> <p></p> <p><code>defaultLifetime</code> TypeFiltererLifetime</p> <p>The default lifetime if no override applies.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ITypeFilterer/#returns","title":"Returns","text":"<p>TypeFiltererLifetime The effective lifetime for the type.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ITypeFilterer/#itypefiltereristypeexcludedtype-method","title":"ITypeFilterer.IsTypeExcluded(Type) Method","text":"<p>Determines whether a type should be excluded from registration. Used by source-gen registrars where lifetimes are pre-computed.</p> <pre><code>bool IsTypeExcluded(System.Type type);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ITypeFilterer/#parameters_1","title":"Parameters","text":"<p><code>type</code> System.Type</p> <p>The type to check.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ITypeFilterer/#returns_1","title":"Returns","text":"<p>System.Boolean True if the type should be excluded; otherwise false.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ITypeFiltererExtensionMethods/","title":"ITypeFiltererExtensionMethods","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/ITypeFiltererExtensionMethods/#nexuslabsneedlrinjection","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/ITypeFiltererExtensionMethods/#nexuslabsneedlrinjection_1","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/ITypeFiltererExtensionMethods/#itypefiltererextensionmethods-class","title":"ITypeFiltererExtensionMethods Class","text":"<p>Extension methods for ITypeFilterer providing fluent configuration of type lifetime rules.</p> <pre><code>public static class ITypeFiltererExtensionMethods\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 ITypeFiltererExtensionMethods</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ITypeRegistrar/","title":"ITypeRegistrar","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/ITypeRegistrar/#nexuslabsneedlrinjection","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/ITypeRegistrar/#nexuslabsneedlrinjection_1","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/ITypeRegistrar/#ityperegistrar-interface","title":"ITypeRegistrar Interface","text":"<p>Provides functionality for registering types in a dependency injection container.</p> <pre><code>public interface ITypeRegistrar\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ITypeRegistrar/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/ITypeRegistrar/#ityperegistrarregistertypesfromassembliesiservicecollection-itypefilterer-ireadonlylistassembly-method","title":"ITypeRegistrar.RegisterTypesFromAssemblies(IServiceCollection, ITypeFilterer, IReadOnlyList&lt;Assembly&gt;) Method","text":"<p>Registers types from the specified assemblies into the service collection.</p> <pre><code>void RegisterTypesFromAssemblies(Microsoft.Extensions.DependencyInjection.IServiceCollection services, NexusLabs.Needlr.Injection.ITypeFilterer typeFilterer, System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt; assemblies);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ITypeRegistrar/#parameters","title":"Parameters","text":"<p><code>services</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service collection to register types into.</p> <p></p> <p><code>typeFilterer</code> ITypeFilterer</p> <p>The type filterer used to determine which types should be registered and their lifetimes.</p> <p></p> <p><code>assemblies</code> System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt;</p> <p>The assemblies to scan for types to register.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/NexusLabs.Needlr.Injection.AssemblyOrdering/","title":"NexusLabs.Needlr.Injection.AssemblyOrdering","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/NexusLabs.Needlr.Injection.AssemblyOrdering/#nexuslabsneedlrinjection","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/NexusLabs.Needlr.Injection.AssemblyOrdering/#nexuslabsneedlrinjectionassemblyordering-namespace","title":"NexusLabs.Needlr.Injection.AssemblyOrdering Namespace","text":"Classes AssemblyInfo Provides a simplified view of assembly information for ordering expressions. This abstraction works for both reflection (runtime Assembly) and source-gen (compile-time info). AssemblyOrder Factory for creating assembly ordering configurations. AssemblyOrderBuilder Fluent builder for specifying assembly ordering rules. Assemblies are sorted into tiers based on the first matching rule. Unmatched assemblies are placed last. AssemblyOrderRule Represents a single ordering rule that matches assemblies to a tier."},{"location":"api/dev/NexusLabs.Needlr.Injection/NexusLabs.Needlr.Injection.TypeFilterers/","title":"NexusLabs.Needlr.Injection.TypeFilterers","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/NexusLabs.Needlr.Injection.TypeFilterers/#nexuslabsneedlrinjection","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/NexusLabs.Needlr.Injection.TypeFilterers/#nexuslabsneedlrinjectiontypefilterers-namespace","title":"NexusLabs.Needlr.Injection.TypeFilterers Namespace","text":"Classes EmptyTypeFilterer A type filterer that rejects all types. Use as a base when building custom filters. TypeFilterDecorator A decorator that wraps an ITypeFilterer and modifies its filtering behavior. Allows customization of lifetime categorization without replacing the entire filterer."},{"location":"api/dev/NexusLabs.Needlr.Injection/NexusLabs.Needlr.Injection/","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/NexusLabs.Needlr.Injection/#nexuslabsneedlrinjection","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/NexusLabs.Needlr.Injection/#nexuslabsneedlrinjection-namespace","title":"NexusLabs.Needlr.Injection Namespace","text":"Classes ConfiguredSyringe Represents a Syringe that has been configured with a strategy (UsingReflection, UsingSourceGen, or UsingAutoConfiguration). This type has access to all configuration extension methods and can build a service provider. ITypeFiltererExtensionMethods Extension methods for ITypeFilterer providing fluent configuration of type lifetime rules. ServiceCollectionPopulator Default implementation of IServiceCollectionPopulator that registers discovered types into a service collection. Handles type registration, plugin execution, and built-in service factory registration. Syringe The base container for configuring Needlr service discovery. SyringeExtensions Core extension methods for configuring ConfiguredSyringe instances. TypeFiltering Provides helper methods for filtering types during dependency injection scanning. Interfaces IAssemblyLoader Defines a loader that loads assemblies for dependency injection scanning. Implement this interface to customize how assemblies are discovered and loaded. IAssemblyProvider Defines a provider that supplies the list of candidate assemblies for dependency injection. Implement this interface to customize which assemblies are scanned for types. IServiceCollectionPopulator Defines a populator that registers discovered types into a service collection. Handles type scanning, filtering, and registration with appropriate service lifetimes. IServiceProviderBuilder Defines a builder for constructing service providers with Needlr's auto-discovery capabilities. Coordinates assembly loading, type registration, and plugin execution. ITypeFilterer Defines a filterer that determines the service lifetime for discovered types. Implement this interface to customize how types are categorized as scoped, transient, or singleton. ITypeRegistrar Provides functionality for registering types in a dependency injection container. Enums TypeFiltererLifetime Represents a service lifetime for type filtering purposes."},{"location":"api/dev/NexusLabs.Needlr.Injection/ServiceCollectionPopulator/","title":"ServiceCollectionPopulator","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/ServiceCollectionPopulator/#nexuslabsneedlrinjection","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/ServiceCollectionPopulator/#nexuslabsneedlrinjection_1","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/ServiceCollectionPopulator/#servicecollectionpopulator-class","title":"ServiceCollectionPopulator Class","text":"<p>Default implementation of IServiceCollectionPopulator that registers discovered types into a service collection. Handles type registration, plugin execution, and built-in service factory registration.</p> <pre><code>public sealed class ServiceCollectionPopulator : NexusLabs.Needlr.Injection.IServiceCollectionPopulator\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 ServiceCollectionPopulator</p> <p>Implements IServiceCollectionPopulator</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ServiceCollectionPopulator/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/ServiceCollectionPopulator/#servicecollectionpopulatorityperegistrar-itypefilterer-ipluginfactory-constructor","title":"ServiceCollectionPopulator(ITypeRegistrar, ITypeFilterer, IPluginFactory) Constructor","text":"<p>Initializes a new instance of the ServiceCollectionPopulator class.</p> <pre><code>public ServiceCollectionPopulator(NexusLabs.Needlr.Injection.ITypeRegistrar typeRegistrar, NexusLabs.Needlr.Injection.ITypeFilterer typeFilterer, NexusLabs.Needlr.IPluginFactory pluginFactory);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/ServiceCollectionPopulator/#parameters","title":"Parameters","text":"<p><code>typeRegistrar</code> ITypeRegistrar</p> <p>The type registrar to use for service registration.</p> <p></p> <p><code>typeFilterer</code> ITypeFilterer</p> <p>The type filterer to determine service lifetimes.</p> <p></p> <p><code>pluginFactory</code> NexusLabs.Needlr.IPluginFactory</p> <p>The plugin factory to use for plugin discovery and instantiation.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/Syringe/","title":"Syringe","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/Syringe/#nexuslabsneedlrinjection","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/Syringe/#nexuslabsneedlrinjection_1","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/Syringe/#syringe-class","title":"Syringe Class","text":"<p>The base container for configuring Needlr service discovery.</p> <pre><code>public sealed record Syringe : System.IEquatable&lt;NexusLabs.Needlr.Injection.Syringe&gt;\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 Syringe</p> <p>Implements System.IEquatable&lt;Syringe&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/Syringe/#example","title":"Example","text":"<pre><code>// Using reflection\nvar provider = new Syringe()\n    .UsingReflection()\n    .BuildServiceProvider();\n\n// Using source generation (AOT-compatible)\nvar provider = new Syringe()\n    .UsingSourceGen()\n    .BuildServiceProvider();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/Syringe/#remarks","title":"Remarks","text":"<p>Syringe is a starting point that must be configured with a strategy before building.             Use one of these approaches to get a ConfiguredSyringe that can build a service provider: - Reference <code>NexusLabs.Needlr.Injection.SourceGen</code> and call <code>.UsingSourceGen()</code> - Reference <code>NexusLabs.Needlr.Injection.Reflection</code> and call <code>.UsingReflection()</code> - Reference <code>NexusLabs.Needlr.Injection.Bundle</code> and call <code>.UsingAutoConfiguration()</code></p> <p>The strategy methods return a ConfiguredSyringe which has the <code>BuildServiceProvider()</code> method.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/","title":"SyringeExtensions","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#nexuslabsneedlrinjection","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#nexuslabsneedlrinjection_1","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#syringeextensions-class","title":"SyringeExtensions Class","text":"<p>Core extension methods for configuring ConfiguredSyringe instances.</p> <pre><code>public static class SyringeExtensions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 SyringeExtensions</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#remarks","title":"Remarks","text":"<p>This class contains the core configuration methods that work with any implementation. All methods operate on ConfiguredSyringe, which is created by calling one of the strategy methods on Syringe: - <code>new Syringe().UsingSourceGen()</code> - for AOT-compatible source-generated components - <code>new Syringe().UsingReflection()</code> - for runtime reflection-based components - <code>new Syringe().UsingAutoConfiguration()</code> - for automatic fallback</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#syringeextensionsadddecoratortservicetdecoratorthis-configuredsyringe-method","title":"SyringeExtensions.AddDecorator&lt;TService,TDecorator&gt;(this ConfiguredSyringe) Method","text":"<p>Configures the syringe to add a decorator for the specified service type. This is a convenience method that adds a post-plugin registration callback to decorate the service. The decorator will preserve the original service's lifetime. Works with both interfaces and class types.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe AddDecorator&lt;TService,TDecorator&gt;(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe)\n    where TDecorator : class, TService;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#type-parameters","title":"Type parameters","text":"<p><code>TService</code></p> <p>The service type (interface or class) to decorate.</p> <p></p> <p><code>TDecorator</code></p> <p>The decorator type that implements TService.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#parameters","title":"Parameters","text":"<p><code>syringe</code> ConfiguredSyringe</p> <p>The configured syringe to update.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#returns","title":"Returns","text":"<p>ConfiguredSyringe A new configured syringe instance.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#syringeextensionsbuildserviceproviderthis-configuredsyringe-method","title":"SyringeExtensions.BuildServiceProvider(this ConfiguredSyringe) Method","text":"<p>Builds a service provider with default configuration.</p> <pre><code>public static System.IServiceProvider BuildServiceProvider(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#parameters_1","title":"Parameters","text":"<p><code>syringe</code> ConfiguredSyringe</p> <p>The configured syringe to build from.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#returns_1","title":"Returns","text":"<p>System.IServiceProvider The configured System.IServiceProvider.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#syringeextensionsorderassembliesthis-configuredsyringe-assemblyorderbuilder-method","title":"SyringeExtensions.OrderAssemblies(this ConfiguredSyringe, AssemblyOrderBuilder) Method","text":"<p>Configures assembly ordering using a pre-built order builder.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe OrderAssemblies(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe, NexusLabs.Needlr.Injection.AssemblyOrdering.AssemblyOrderBuilder orderBuilder);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#parameters_2","title":"Parameters","text":"<p><code>syringe</code> ConfiguredSyringe</p> <p>The configured syringe to update.</p> <p></p> <p><code>orderBuilder</code> AssemblyOrderBuilder</p> <p>The pre-configured order builder.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#returns_2","title":"Returns","text":"<p>ConfiguredSyringe A new configured syringe instance.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#example","title":"Example","text":"<pre><code>new Syringe()\n    .UsingSourceGen()\n    .OrderAssemblies(AssemblyOrder.LibTestEntry())\n    .BuildServiceProvider();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#syringeextensionsorderassembliesthis-configuredsyringe-actionassemblyorderbuilder-method","title":"SyringeExtensions.OrderAssemblies(this ConfiguredSyringe, Action&lt;AssemblyOrderBuilder&gt;) Method","text":"<p>Configures assembly ordering using expression-based rules. Assemblies are sorted into tiers based on the first matching rule. Unmatched assemblies are placed last.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe OrderAssemblies(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe, System.Action&lt;NexusLabs.Needlr.Injection.AssemblyOrdering.AssemblyOrderBuilder&gt; configure);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#parameters_3","title":"Parameters","text":"<p><code>syringe</code> ConfiguredSyringe</p> <p>The configured syringe to update.</p> <p></p> <p><code>configure</code> System.Action&lt;AssemblyOrderBuilder&gt;</p> <p>Action to configure the ordering rules.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#returns_3","title":"Returns","text":"<p>ConfiguredSyringe A new configured syringe instance.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#example_1","title":"Example","text":"<pre><code>new Syringe()\n    .UsingReflection()  // or .UsingSourceGen()\n    .OrderAssemblies(order =&gt; order\n        .By(a =&gt; a.Name.EndsWith(\".Core\"))\n        .ThenBy(a =&gt; a.Name.Contains(\"Services\"))\n        .ThenBy(a =&gt; a.Name.Contains(\"Tests\")))\n    .BuildServiceProvider();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#syringeextensionsuselibtestentryorderingthis-configuredsyringe-method","title":"SyringeExtensions.UseLibTestEntryOrdering(this ConfiguredSyringe) Method","text":"<p>Configures assembly ordering: libraries first, then executables, tests last.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UseLibTestEntryOrdering(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#parameters_4","title":"Parameters","text":"<p><code>syringe</code> ConfiguredSyringe</p> <p>The configured syringe to update.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#returns_4","title":"Returns","text":"<p>ConfiguredSyringe A new configured syringe instance.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#syringeextensionsusetestslastorderingthis-configuredsyringe-method","title":"SyringeExtensions.UseTestsLastOrdering(this ConfiguredSyringe) Method","text":"<p>Configures assembly ordering: non-test assemblies first, tests last.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UseTestsLastOrdering(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#parameters_5","title":"Parameters","text":"<p><code>syringe</code> ConfiguredSyringe</p> <p>The configured syringe to update.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#returns_5","title":"Returns","text":"<p>ConfiguredSyringe A new configured syringe instance.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#syringeextensionsusingadditionalassembliesthis-configuredsyringe-ireadonlylistassembly-method","title":"SyringeExtensions.UsingAdditionalAssemblies(this ConfiguredSyringe, IReadOnlyList&lt;Assembly&gt;) Method","text":"<p>Configures the syringe to use additional assemblies.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UsingAdditionalAssemblies(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe, System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt; additionalAssemblies);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#parameters_6","title":"Parameters","text":"<p><code>syringe</code> ConfiguredSyringe</p> <p>The configured syringe to update.</p> <p></p> <p><code>additionalAssemblies</code> System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt;</p> <p>The additional assemblies to include.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#returns_6","title":"Returns","text":"<p>ConfiguredSyringe A new configured syringe instance.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#syringeextensionsusingassemblyproviderthis-configuredsyringe-iassemblyprovider-method","title":"SyringeExtensions.UsingAssemblyProvider(this ConfiguredSyringe, IAssemblyProvider) Method","text":"<p>Configures the syringe to use the specified assembly provider.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UsingAssemblyProvider(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe, NexusLabs.Needlr.Injection.IAssemblyProvider assemblyProvider);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#parameters_7","title":"Parameters","text":"<p><code>syringe</code> ConfiguredSyringe</p> <p>The configured syringe to update.</p> <p></p> <p><code>assemblyProvider</code> IAssemblyProvider</p> <p>The assembly provider to use.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#returns_7","title":"Returns","text":"<p>ConfiguredSyringe A new configured syringe instance.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#syringeextensionsusingpluginfactorythis-configuredsyringe-ipluginfactory-method","title":"SyringeExtensions.UsingPluginFactory(this ConfiguredSyringe, IPluginFactory) Method","text":"<p>Configures the syringe to use the specified plugin factory.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UsingPluginFactory(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe, NexusLabs.Needlr.IPluginFactory pluginFactory);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#parameters_8","title":"Parameters","text":"<p><code>syringe</code> ConfiguredSyringe</p> <p>The configured syringe to update.</p> <p></p> <p><code>pluginFactory</code> NexusLabs.Needlr.IPluginFactory</p> <p>The plugin factory to use.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#returns_8","title":"Returns","text":"<p>ConfiguredSyringe A new configured syringe instance.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#syringeextensionsusingpostpluginregistrationcallbackthis-configuredsyringe-actioniservicecollection-method","title":"SyringeExtensions.UsingPostPluginRegistrationCallback(this ConfiguredSyringe, Action&lt;IServiceCollection&gt;) Method","text":"<p>Configures the syringe to add a single post-plugin registration callback. This callback is executed after plugin registration but before the service provider is finalized.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UsingPostPluginRegistrationCallback(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe, System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt; callback);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#parameters_9","title":"Parameters","text":"<p><code>syringe</code> ConfiguredSyringe</p> <p>The configured syringe to update.</p> <p></p> <p><code>callback</code> System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;</p> <p>The callback to execute during service provider building.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#returns_9","title":"Returns","text":"<p>ConfiguredSyringe A new configured syringe instance.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#syringeextensionsusingpostpluginregistrationcallbacksthis-configuredsyringe-ireadonlylistactioniservicecollection-method","title":"SyringeExtensions.UsingPostPluginRegistrationCallbacks(this ConfiguredSyringe, IReadOnlyList&lt;Action&lt;IServiceCollection&gt;&gt;) Method","text":"<p>Configures the syringe to use post-plugin registration callbacks. These callbacks are executed after plugin registration but before the service provider is finalized.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UsingPostPluginRegistrationCallbacks(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe, System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; callbacks);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#parameters_10","title":"Parameters","text":"<p><code>syringe</code> ConfiguredSyringe</p> <p>The configured syringe to update.</p> <p></p> <p><code>callbacks</code> System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p>The callbacks to execute during service provider building.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#returns_10","title":"Returns","text":"<p>ConfiguredSyringe A new configured syringe instance.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#syringeextensionsusingpreregistrationcallbackthis-configuredsyringe-actioniservicecollection-method","title":"SyringeExtensions.UsingPreRegistrationCallback(this ConfiguredSyringe, Action&lt;IServiceCollection&gt;) Method","text":"<p>Configures the syringe to add a single pre-registration callback. This callback is executed before auto-discovery registration, useful for open generics or base registrations.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UsingPreRegistrationCallback(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe, System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt; callback);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#parameters_11","title":"Parameters","text":"<p><code>syringe</code> ConfiguredSyringe</p> <p>The configured syringe to update.</p> <p></p> <p><code>callback</code> System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;</p> <p>The callback to execute before auto-discovery.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#returns_11","title":"Returns","text":"<p>ConfiguredSyringe A new configured syringe instance.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#syringeextensionsusingpreregistrationcallbacksthis-configuredsyringe-ireadonlylistactioniservicecollection-method","title":"SyringeExtensions.UsingPreRegistrationCallbacks(this ConfiguredSyringe, IReadOnlyList&lt;Action&lt;IServiceCollection&gt;&gt;) Method","text":"<p>Configures the syringe to use pre-registration callbacks. These callbacks are executed before auto-discovery registration, useful for open generics or base registrations.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UsingPreRegistrationCallbacks(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe, System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; callbacks);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#parameters_12","title":"Parameters","text":"<p><code>syringe</code> ConfiguredSyringe</p> <p>The configured syringe to update.</p> <p></p> <p><code>callbacks</code> System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p>The callbacks to execute before auto-discovery.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#returns_12","title":"Returns","text":"<p>ConfiguredSyringe A new configured syringe instance.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#syringeextensionsusingservicecollectionpopulatorthis-configuredsyringe-funcityperegistraritypefiltereripluginfactoryiservicecollectionpopulator-method","title":"SyringeExtensions.UsingServiceCollectionPopulator(this ConfiguredSyringe, Func&lt;ITypeRegistrar,ITypeFilterer,IPluginFactory,IServiceCollectionPopulator&gt;) Method","text":"<p>Configures the syringe to use the specified service collection populator factory.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UsingServiceCollectionPopulator(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe, System.Func&lt;NexusLabs.Needlr.Injection.ITypeRegistrar,NexusLabs.Needlr.Injection.ITypeFilterer,NexusLabs.Needlr.IPluginFactory,NexusLabs.Needlr.Injection.IServiceCollectionPopulator&gt; factory);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#parameters_13","title":"Parameters","text":"<p><code>syringe</code> ConfiguredSyringe</p> <p>The configured syringe to update.</p> <p></p> <p><code>factory</code> System.Func&lt;ITypeRegistrar,ITypeFilterer,NexusLabs.Needlr.IPluginFactory,IServiceCollectionPopulator&gt;</p> <p>The factory function for creating service collection populators.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#returns_13","title":"Returns","text":"<p>ConfiguredSyringe A new configured syringe instance.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#syringeextensionsusingserviceproviderbuilderfactorythis-configuredsyringe-funciservicecollectionpopulatoriassemblyproviderireadonlylistassemblyiserviceproviderbuilder-method","title":"SyringeExtensions.UsingServiceProviderBuilderFactory(this ConfiguredSyringe, Func&lt;IServiceCollectionPopulator,IAssemblyProvider,IReadOnlyList&lt;Assembly&gt;,IServiceProviderBuilder&gt;) Method","text":"<p>Configures the syringe to use the specified service provider builder factory.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UsingServiceProviderBuilderFactory(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe, System.Func&lt;NexusLabs.Needlr.Injection.IServiceCollectionPopulator,NexusLabs.Needlr.Injection.IAssemblyProvider,System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt;,NexusLabs.Needlr.Injection.IServiceProviderBuilder&gt; factory);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#parameters_14","title":"Parameters","text":"<p><code>syringe</code> ConfiguredSyringe</p> <p>The configured syringe to update.</p> <p></p> <p><code>factory</code> System.Func&lt;IServiceCollectionPopulator,IAssemblyProvider,System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt;,IServiceProviderBuilder&gt;</p> <p>The factory function for creating service provider builders.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#returns_14","title":"Returns","text":"<p>ConfiguredSyringe A new configured syringe instance.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#syringeextensionsusingtypefiltererthis-configuredsyringe-itypefilterer-method","title":"SyringeExtensions.UsingTypeFilterer(this ConfiguredSyringe, ITypeFilterer) Method","text":"<p>Configures the syringe to use the specified type filterer.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UsingTypeFilterer(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe, NexusLabs.Needlr.Injection.ITypeFilterer typeFilterer);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#parameters_15","title":"Parameters","text":"<p><code>syringe</code> ConfiguredSyringe</p> <p>The configured syringe to update.</p> <p></p> <p><code>typeFilterer</code> ITypeFilterer</p> <p>The type filterer to use.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#returns_15","title":"Returns","text":"<p>ConfiguredSyringe A new configured syringe instance.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#syringeextensionsusingtyperegistrarthis-configuredsyringe-ityperegistrar-method","title":"SyringeExtensions.UsingTypeRegistrar(this ConfiguredSyringe, ITypeRegistrar) Method","text":"<p>Configures the syringe to use the specified type registrar.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UsingTypeRegistrar(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe, NexusLabs.Needlr.Injection.ITypeRegistrar typeRegistrar);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#parameters_16","title":"Parameters","text":"<p><code>syringe</code> ConfiguredSyringe</p> <p>The configured syringe to update.</p> <p></p> <p><code>typeRegistrar</code> ITypeRegistrar</p> <p>The type registrar to use.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#returns_16","title":"Returns","text":"<p>ConfiguredSyringe A new configured syringe instance.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#syringeextensionswithverificationthis-configuredsyringe-verificationoptions-method","title":"SyringeExtensions.WithVerification(this ConfiguredSyringe, VerificationOptions) Method","text":"<p>Configures verification options for the syringe. Verification runs automatically during BuildServiceProvider(IConfiguration).</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe WithVerification(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe, NexusLabs.Needlr.VerificationOptions options);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#parameters_17","title":"Parameters","text":"<p><code>syringe</code> ConfiguredSyringe</p> <p>The configured syringe to update.</p> <p></p> <p><code>options</code> NexusLabs.Needlr.VerificationOptions</p> <p>The verification options to use.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#returns_17","title":"Returns","text":"<p>ConfiguredSyringe A new configured syringe instance.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#example_2","title":"Example","text":"<pre><code>// Strict mode - throw on any issue\nnew Syringe()\n    .UsingSourceGen()\n    .WithVerification(VerificationOptions.Strict)\n    .BuildServiceProvider();\n\n// Disable verification\nnew Syringe()\n    .UsingSourceGen()\n    .WithVerification(VerificationOptions.Disabled)\n    .BuildServiceProvider();\n\n// Custom configuration\nnew Syringe()\n    .UsingSourceGen()\n    .WithVerification(new VerificationOptions\n    {\n        LifetimeMismatchBehavior = VerificationBehavior.Throw,\n        IssueReporter = issue =&gt; logger.LogWarning(issue.Message)\n    })\n    .BuildServiceProvider();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#syringeextensionswithverificationthis-configuredsyringe-actionverificationoptionsbuilder-method","title":"SyringeExtensions.WithVerification(this ConfiguredSyringe, Action&lt;VerificationOptionsBuilder&gt;) Method","text":"<p>Configures verification options using a builder action.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe WithVerification(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe, System.Action&lt;NexusLabs.Needlr.VerificationOptionsBuilder&gt; configure);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#parameters_18","title":"Parameters","text":"<p><code>syringe</code> ConfiguredSyringe</p> <p>The configured syringe to update.</p> <p></p> <p><code>configure</code> System.Action&lt;NexusLabs.Needlr.VerificationOptionsBuilder&gt;</p> <p>An action to configure the verification options.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/SyringeExtensions/#returns_18","title":"Returns","text":"<p>ConfiguredSyringe A new configured syringe instance.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/TypeFilterDecorator/","title":"TypeFilterDecorator","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/TypeFilterDecorator/#nexuslabsneedlrinjection","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/TypeFilterDecorator/#nexuslabsneedlrinjectiontypefilterers","title":"NexusLabs.Needlr.Injection.TypeFilterers","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/TypeFilterDecorator/#typefilterdecorator-class","title":"TypeFilterDecorator Class","text":"<p>A decorator that wraps an ITypeFilterer and modifies its filtering behavior. Allows customization of lifetime categorization without replacing the entire filterer.</p> <pre><code>public sealed class TypeFilterDecorator : NexusLabs.Needlr.Injection.ITypeFilterer\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 TypeFilterDecorator</p> <p>Implements ITypeFilterer</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/TypeFilterDecorator/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/TypeFilterDecorator/#typefilterdecoratoristypeexcludedtype-method","title":"TypeFilterDecorator.IsTypeExcluded(Type) Method","text":"<p>Determines whether a type should be excluded from registration. Used by source-gen registrars where lifetimes are pre-computed.</p> <pre><code>public bool IsTypeExcluded(System.Type type);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/TypeFilterDecorator/#parameters","title":"Parameters","text":"<p><code>type</code> System.Type</p> <p>The type to check.</p> <p>Implements IsTypeExcluded(Type)</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/TypeFilterDecorator/#returns","title":"Returns","text":"<p>System.Boolean True if the type should be excluded; otherwise false.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/TypeFiltererLifetime/","title":"TypeFiltererLifetime","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/TypeFiltererLifetime/#nexuslabsneedlrinjection","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/TypeFiltererLifetime/#nexuslabsneedlrinjection_1","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/TypeFiltererLifetime/#typefiltererlifetime-enum","title":"TypeFiltererLifetime Enum","text":"<p>Represents a service lifetime for type filtering purposes.</p> <pre><code>public enum TypeFiltererLifetime\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/TypeFiltering/","title":"TypeFiltering","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/TypeFiltering/#nexuslabsneedlrinjection","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/TypeFiltering/#nexuslabsneedlrinjection_1","title":"NexusLabs.Needlr.Injection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/TypeFiltering/#typefiltering-class","title":"TypeFiltering Class","text":"<p>Provides helper methods for filtering types during dependency injection scanning.</p> <pre><code>public static class TypeFiltering\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 TypeFiltering</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/TypeFiltering/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection/TypeFiltering/#typefilteringisconcretetypetype-method","title":"TypeFiltering.IsConcreteType(Type) Method","text":"<p>Determines if a type is a concrete type suitable for registration. This filters out abstract classes, interfaces, nested types, delegates, exceptions, attributes, etc.</p> <pre><code>public static bool IsConcreteType(System.Type type);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/TypeFiltering/#parameters","title":"Parameters","text":"<p><code>type</code> System.Type</p> <p>The type to check.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/TypeFiltering/#returns","title":"Returns","text":"<p>System.Boolean True if the type is a concrete type that can be instantiated.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/TypeFiltering/#typefilteringisrecordtype-method","title":"TypeFiltering.IsRecord(Type) Method","text":"<p>Determines if a type is a record type.</p> <pre><code>public static bool IsRecord(System.Type type);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection/TypeFiltering/#parameters_1","title":"Parameters","text":"<p><code>type</code> System.Type</p> <p>The type to check.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection/TypeFiltering/#returns_1","title":"Returns","text":"<p>System.Boolean True if the type is a record.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/","title":"Index","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/#nexuslabsneedlrinjectionbundle-namespace","title":"NexusLabs.Needlr.Injection.Bundle Namespace","text":"Classes ServiceProviderBuilder Builds and configures an Microsoft.Extensions.DependencyInjection.IServiceCollection, scanning assemblies for injectable types and plugins. SyringeBundleExtensions Extension methods that provide automatic fallback between source-generated and reflection-based components."},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/NexusLabs.Needlr.Injection.Bundle/","title":"NexusLabs.Needlr.Injection.Bundle","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/NexusLabs.Needlr.Injection.Bundle/#nexuslabsneedlrinjectionbundle-namespace","title":"NexusLabs.Needlr.Injection.Bundle Namespace","text":"Classes ServiceProviderBuilder Builds and configures an Microsoft.Extensions.DependencyInjection.IServiceCollection, scanning assemblies for injectable types and plugins. SyringeBundleExtensions Extension methods that provide automatic fallback between source-generated and reflection-based components."},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/ServiceProviderBuilder/","title":"ServiceProviderBuilder","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/ServiceProviderBuilder/#nexuslabsneedlrinjectionbundle","title":"NexusLabs.Needlr.Injection.Bundle","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/ServiceProviderBuilder/#serviceproviderbuilder-class","title":"ServiceProviderBuilder Class","text":"<p>Builds and configures an Microsoft.Extensions.DependencyInjection.IServiceCollection, scanning assemblies for injectable types and plugins.</p> <pre><code>public sealed class ServiceProviderBuilder : NexusLabs.Needlr.Injection.IServiceProviderBuilder\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 ServiceProviderBuilder</p> <p>Implements NexusLabs.Needlr.Injection.IServiceProviderBuilder</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/ServiceProviderBuilder/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/ServiceProviderBuilder/#serviceproviderbuilderbuildiconfiguration-method","title":"ServiceProviderBuilder.Build(IConfiguration) Method","text":"<p>Builds a new System.IServiceProvider using the discovered assemblies and a custom registration callback.</p> <pre><code>public System.IServiceProvider Build(Microsoft.Extensions.Configuration.IConfiguration config);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/ServiceProviderBuilder/#parameters","title":"Parameters","text":"<p><code>config</code> Microsoft.Extensions.Configuration.IConfiguration</p> <p>The configuration to use for settings.</p> <p>Implements Build(IConfiguration)</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/ServiceProviderBuilder/#returns","title":"Returns","text":"<p>System.IServiceProvider The built System.IServiceProvider.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/ServiceProviderBuilder/#serviceproviderbuilderbuildiservicecollection-iconfiguration-method","title":"ServiceProviderBuilder.Build(IServiceCollection, IConfiguration) Method","text":"<p>Builds a new System.IServiceProvider using the discovered assemblies and a custom registration callback.</p> <pre><code>public System.IServiceProvider Build(Microsoft.Extensions.DependencyInjection.IServiceCollection services, Microsoft.Extensions.Configuration.IConfiguration config);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/ServiceProviderBuilder/#parameters_1","title":"Parameters","text":"<p><code>services</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service collection to configure.</p> <p></p> <p><code>config</code> Microsoft.Extensions.Configuration.IConfiguration</p> <p>The configuration to use for settings.</p> <p>Implements Build(IServiceCollection, IConfiguration)</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/ServiceProviderBuilder/#returns_1","title":"Returns","text":"<p>System.IServiceProvider The built System.IServiceProvider.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/ServiceProviderBuilder/#serviceproviderbuilderbuildiservicecollection-iconfiguration-ireadonlylistactioniservicecollection-method","title":"ServiceProviderBuilder.Build(IServiceCollection, IConfiguration, IReadOnlyList&lt;Action&lt;IServiceCollection&gt;&gt;) Method","text":"<p>Builds a new System.IServiceProvider using the provided Microsoft.Extensions.DependencyInjection.IServiceCollection and a custom registration callback.</p> <pre><code>public System.IServiceProvider Build(Microsoft.Extensions.DependencyInjection.IServiceCollection services, Microsoft.Extensions.Configuration.IConfiguration config, System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; postPluginRegistrationCallbacks);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/ServiceProviderBuilder/#parameters_2","title":"Parameters","text":"<p><code>services</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service collection to configure.</p> <p></p> <p><code>config</code> Microsoft.Extensions.Configuration.IConfiguration</p> <p>The configuration to use for settings.</p> <p></p> <p><code>postPluginRegistrationCallbacks</code> System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p>The set of callbacks for additional registration logic</p> <p>Implements Build(IServiceCollection, IConfiguration, IReadOnlyList&lt;Action&lt;IServiceCollection&gt;&gt;)</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/ServiceProviderBuilder/#returns_2","title":"Returns","text":"<p>System.IServiceProvider The built System.IServiceProvider.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/ServiceProviderBuilder/#serviceproviderbuilderbuildiservicecollection-iconfiguration-ireadonlylistactioniservicecollection-ireadonlylistactioniservicecollection-method","title":"ServiceProviderBuilder.Build(IServiceCollection, IConfiguration, IReadOnlyList&lt;Action&lt;IServiceCollection&gt;&gt;, IReadOnlyList&lt;Action&lt;IServiceCollection&gt;&gt;) Method","text":"<p>Builds a new System.IServiceProvider with both pre and post registration callbacks.</p> <pre><code>public System.IServiceProvider Build(Microsoft.Extensions.DependencyInjection.IServiceCollection services, Microsoft.Extensions.Configuration.IConfiguration config, System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; preRegistrationCallbacks, System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; postPluginRegistrationCallbacks);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/ServiceProviderBuilder/#parameters_3","title":"Parameters","text":"<p><code>services</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service collection to configure.</p> <p></p> <p><code>config</code> Microsoft.Extensions.Configuration.IConfiguration</p> <p>The configuration to use for settings.</p> <p></p> <p><code>preRegistrationCallbacks</code> System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p>Callbacks executed before auto-discovery registration (e.g., for open generics).</p> <p></p> <p><code>postPluginRegistrationCallbacks</code> System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p>Callbacks executed after plugin registration.</p> <p>Implements Build(IServiceCollection, IConfiguration, IReadOnlyList&lt;Action&lt;IServiceCollection&gt;&gt;, IReadOnlyList&lt;Action&lt;IServiceCollection&gt;&gt;)</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/ServiceProviderBuilder/#returns_3","title":"Returns","text":"<p>System.IServiceProvider The built System.IServiceProvider.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/ServiceProviderBuilder/#serviceproviderbuilderconfigurepostbuildservicecollectionpluginsiserviceprovider-iconfiguration-method","title":"ServiceProviderBuilder.ConfigurePostBuildServiceCollectionPlugins(IServiceProvider, IConfiguration) Method","text":"<p>Configures plugins that require post-build service collection configuration using the built service provider.</p> <pre><code>public void ConfigurePostBuildServiceCollectionPlugins(System.IServiceProvider provider, Microsoft.Extensions.Configuration.IConfiguration config);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/ServiceProviderBuilder/#parameters_4","title":"Parameters","text":"<p><code>provider</code> System.IServiceProvider</p> <p>The built service provider to use for plugin configuration.</p> <p></p> <p><code>config</code> Microsoft.Extensions.Configuration.IConfiguration</p> <p>The configuration to use for settings.</p> <p>Implements ConfigurePostBuildServiceCollectionPlugins(IServiceProvider, IConfiguration)</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/ServiceProviderBuilder/#serviceproviderbuildergetcandidateassemblies-method","title":"ServiceProviderBuilder.GetCandidateAssemblies() Method","text":"<p>Gets the list of candidate assemblies that will be scanned for service registrations and plugins.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt; GetCandidateAssemblies();\n</code></pre> <p>Implements GetCandidateAssemblies()</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/ServiceProviderBuilder/#returns_4","title":"Returns","text":"<p>System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt; A read-only list of assemblies to be processed for dependency injection.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/SyringeBundleExtensions/","title":"SyringeBundleExtensions","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/SyringeBundleExtensions/#nexuslabsneedlrinjectionbundle","title":"NexusLabs.Needlr.Injection.Bundle","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/SyringeBundleExtensions/#syringebundleextensions-class","title":"SyringeBundleExtensions Class","text":"<p>Extension methods that provide automatic fallback between source-generated and reflection-based components.</p> <pre><code>public static class SyringeBundleExtensions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 SyringeBundleExtensions</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/SyringeBundleExtensions/#remarks","title":"Remarks","text":"<p>When using the Bundle package, Needlr will automatically: 1. Try to use source-generated components if available (via NeedlrSourceGenBootstrap) 2. Fall back to reflection-based components if source generation is not configured</p> <p>Use WithFallbackBehavior(this Syringe, Action&lt;ReflectionFallbackContext&gt;) to configure the fallback behavior, or WithFastFailOnReflection(this Syringe) to throw if reflection is used.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/SyringeBundleExtensions/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/SyringeBundleExtensions/#syringebundleextensionsusingautoconfigurationthis-syringe-method","title":"SyringeBundleExtensions.UsingAutoConfiguration(this Syringe) Method","text":"<p>Configures the syringe with automatic fallback from source-gen to reflection.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UsingAutoConfiguration(this NexusLabs.Needlr.Injection.Syringe syringe);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/SyringeBundleExtensions/#parameters","title":"Parameters","text":"<p><code>syringe</code> NexusLabs.Needlr.Injection.Syringe</p> <p>The syringe to configure.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/SyringeBundleExtensions/#returns","title":"Returns","text":"<p>NexusLabs.Needlr.Injection.ConfiguredSyringe A configured syringe ready for further configuration and building.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/SyringeBundleExtensions/#remarks_1","title":"Remarks","text":"<p>This method automatically detects whether source generation is available and configures the appropriate components. If source-generated providers are registered via NeedlrSourceGenBootstrap, they will be used. Otherwise, reflection-based components are used as fallback.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/SyringeBundleExtensions/#syringebundleextensionswithfallbackbehaviorthis-syringe-actionreflectionfallbackcontext-method","title":"SyringeBundleExtensions.WithFallbackBehavior(this Syringe, Action&lt;ReflectionFallbackContext&gt;) Method","text":"<p>Configures the syringe with automatic fallback and a custom fallback handler.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe WithFallbackBehavior(this NexusLabs.Needlr.Injection.Syringe syringe, System.Action&lt;NexusLabs.Needlr.Injection.Reflection.ReflectionFallbackContext&gt;? onFallback);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/SyringeBundleExtensions/#parameters_1","title":"Parameters","text":"<p><code>syringe</code> NexusLabs.Needlr.Injection.Syringe</p> <p>The syringe to configure.</p> <p></p> <p><code>onFallback</code> System.Action&lt;NexusLabs.Needlr.Injection.Reflection.ReflectionFallbackContext&gt;</p> <p>Called when reflection fallback occurs. Can be used for logging or to throw.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/SyringeBundleExtensions/#returns_1","title":"Returns","text":"<p>NexusLabs.Needlr.Injection.ConfiguredSyringe A configured syringe ready for further configuration and building.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/SyringeBundleExtensions/#syringebundleextensionswithfallbackloggingthis-syringe-method","title":"SyringeBundleExtensions.WithFallbackLogging(this Syringe) Method","text":"<p>Configures the syringe to log warnings when reflection fallback occurs.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe WithFallbackLogging(this NexusLabs.Needlr.Injection.Syringe syringe);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/SyringeBundleExtensions/#parameters_2","title":"Parameters","text":"<p><code>syringe</code> NexusLabs.Needlr.Injection.Syringe</p> <p>The syringe to configure.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/SyringeBundleExtensions/#returns_2","title":"Returns","text":"<p>NexusLabs.Needlr.Injection.ConfiguredSyringe A configured syringe ready for further configuration and building.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/SyringeBundleExtensions/#syringebundleextensionswithfastfailonreflectionthis-syringe-method","title":"SyringeBundleExtensions.WithFastFailOnReflection(this Syringe) Method","text":"<p>Configures the syringe to throw an exception if reflection fallback would occur.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe WithFastFailOnReflection(this NexusLabs.Needlr.Injection.Syringe syringe);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/SyringeBundleExtensions/#parameters_3","title":"Parameters","text":"<p><code>syringe</code> NexusLabs.Needlr.Injection.Syringe</p> <p>The syringe to configure.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/SyringeBundleExtensions/#returns_3","title":"Returns","text":"<p>NexusLabs.Needlr.Injection.ConfiguredSyringe A configured syringe ready for further configuration and building.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Bundle/SyringeBundleExtensions/#remarks_2","title":"Remarks","text":"<p>Use this in AOT/trimming scenarios to ensure that source-generated components are always used. If no source-generated providers are registered, an System.InvalidOperationException is thrown.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/","title":"Index","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/#nexuslabsneedlrinjectionreflection","title":"NexusLabs.Needlr.Injection.Reflection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/#nexuslabsneedlrinjectionreflection-assembly","title":"NexusLabs.Needlr.Injection.Reflection Assembly","text":"Namespaces NexusLabs.Needlr.Injection.Reflection NexusLabs.Needlr.Injection.Reflection.Loaders NexusLabs.Needlr.Injection.Reflection.PluginFactories NexusLabs.Needlr.Injection.Reflection.TypeFilterers NexusLabs.Needlr.Injection.Reflection.TypeRegistrars"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/AllAssembliesLoader/","title":"AllAssembliesLoader","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/AllAssembliesLoader/#nexuslabsneedlrinjectionreflection","title":"NexusLabs.Needlr.Injection.Reflection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/AllAssembliesLoader/#nexuslabsneedlrinjectionreflectionloaders","title":"NexusLabs.Needlr.Injection.Reflection.Loaders","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/AllAssembliesLoader/#allassembliesloader-class","title":"AllAssembliesLoader Class","text":"<p>An assembly loader that loads all assemblies (.dll and .exe) from the application's base directory.</p> <pre><code>public sealed class AllAssembliesLoader : NexusLabs.Needlr.Injection.IAssemblyLoader\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 AllAssembliesLoader</p> <p>Implements NexusLabs.Needlr.Injection.IAssemblyLoader</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/AssemblyProviderBuilder/","title":"AssemblyProviderBuilder","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/AssemblyProviderBuilder/#nexuslabsneedlrinjectionreflection","title":"NexusLabs.Needlr.Injection.Reflection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/AssemblyProviderBuilder/#nexuslabsneedlrinjectionreflection_1","title":"NexusLabs.Needlr.Injection.Reflection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/AssemblyProviderBuilder/#assemblyproviderbuilder-class","title":"AssemblyProviderBuilder Class","text":"<p>Builder for creating assembly providers using reflection-based loaders.</p> <pre><code>public sealed class AssemblyProviderBuilder : NexusLabs.Needlr.Injection.Reflection.IAssemblyProviderBuilder\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 AssemblyProviderBuilder</p> <p>Implements IAssemblyProviderBuilder</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/AssemblyProviderBuilder/#remarks","title":"Remarks","text":"<p>This builder uses reflection-based assembly loading and is not compatible with NativeAOT or trimming. For AOT scenarios, use GeneratedAssemblyProvider from NexusLabs.Needlr.Injection.SourceGen instead.</p> <p>For assembly ordering, use <code>SyringeExtensions.OrderAssemblies</code> after configuring the Syringe.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/FileMatchAssemblyLoader/","title":"FileMatchAssemblyLoader","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/FileMatchAssemblyLoader/#nexuslabsneedlrinjectionreflection","title":"NexusLabs.Needlr.Injection.Reflection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/FileMatchAssemblyLoader/#nexuslabsneedlrinjectionreflectionloaders","title":"NexusLabs.Needlr.Injection.Reflection.Loaders","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/FileMatchAssemblyLoader/#filematchassemblyloader-class","title":"FileMatchAssemblyLoader Class","text":"<p>Assembly loader that loads assemblies from disk based on file name matching.</p> <pre><code>public sealed class FileMatchAssemblyLoader : NexusLabs.Needlr.Injection.IAssemblyLoader\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 FileMatchAssemblyLoader</p> <p>Implements NexusLabs.Needlr.Injection.IAssemblyLoader</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/FileMatchAssemblyLoader/#remarks","title":"Remarks","text":"<p>This loader is not compatible with NativeAOT or trimming. For AOT scenarios, use GeneratedAssemblyProvider from NexusLabs.Needlr.Injection.SourceGen instead.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilder/","title":"IAssemblyProviderBuilder","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilder/#nexuslabsneedlrinjectionreflection","title":"NexusLabs.Needlr.Injection.Reflection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilder/#nexuslabsneedlrinjectionreflection_1","title":"NexusLabs.Needlr.Injection.Reflection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilder/#iassemblyproviderbuilder-interface","title":"IAssemblyProviderBuilder Interface","text":"<p>Defines a builder for constructing NexusLabs.Needlr.Injection.IAssemblyProvider instances with custom loaders. Use this to configure how assemblies are discovered for dependency injection. For assembly ordering, use <code>SyringeExtensions.OrderAssemblies</code> instead.</p> <pre><code>public interface IAssemblyProviderBuilder\n</code></pre> <p>Derived \u21b3 AssemblyProviderBuilder</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilderExtensions/","title":"IAssemblyProviderBuilderExtensions","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilderExtensions/#nexuslabsneedlrinjectionreflection","title":"NexusLabs.Needlr.Injection.Reflection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilderExtensions/#nexuslabsneedlrinjectionreflection_1","title":"NexusLabs.Needlr.Injection.Reflection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilderExtensions/#iassemblyproviderbuilderextensions-class","title":"IAssemblyProviderBuilderExtensions Class","text":"<p>Extension methods for IAssemblyProviderBuilder providing fluent configuration of assembly loading. For assembly ordering, use <code>SyringeExtensions.OrderAssemblies</code> instead.</p> <pre><code>public static class IAssemblyProviderBuilderExtensions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 IAssemblyProviderBuilderExtensions</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilderExtensions/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilderExtensions/#iassemblyproviderbuilderextensionsmatchingassembliesthis-iassemblyproviderbuilder-string-predicatestring-method","title":"IAssemblyProviderBuilderExtensions.MatchingAssemblies(this IAssemblyProviderBuilder, string, Predicate&lt;string&gt;) Method","text":"<p>Configures the builder to load assemblies from the specified directory that match the filter criteria. Only files with .dll or .exe extensions will be considered.</p> <pre><code>public static NexusLabs.Needlr.Injection.Reflection.IAssemblyProviderBuilder MatchingAssemblies(this NexusLabs.Needlr.Injection.Reflection.IAssemblyProviderBuilder builder, string directory, System.Predicate&lt;string&gt; fileFilter);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilderExtensions/#parameters","title":"Parameters","text":"<p><code>builder</code> IAssemblyProviderBuilder</p> <p>The assembly provider builder to configure.</p> <p></p> <p><code>directory</code> System.String</p> <p>The directory path to scan for assembly files.</p> <p></p> <p><code>fileFilter</code> System.Predicate&lt;System.String&gt;</p> <p>A predicate that determines which assembly files to include based on their file path.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilderExtensions/#returns","title":"Returns","text":"<p>IAssemblyProviderBuilder The configured assembly provider builder.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilderExtensions/#exceptions","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when builder, directory, or fileFilter is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilderExtensions/#iassemblyproviderbuilderextensionsmatchingassembliesthis-iassemblyproviderbuilder-ireadonlyliststring-predicatestring-method","title":"IAssemblyProviderBuilderExtensions.MatchingAssemblies(this IAssemblyProviderBuilder, IReadOnlyList&lt;string&gt;, Predicate&lt;string&gt;) Method","text":"<p>Configures the builder to load assemblies from the specified directories that match the filter criteria. Only files with .dll or .exe extensions will be considered.</p> <pre><code>public static NexusLabs.Needlr.Injection.Reflection.IAssemblyProviderBuilder MatchingAssemblies(this NexusLabs.Needlr.Injection.Reflection.IAssemblyProviderBuilder builder, System.Collections.Generic.IReadOnlyList&lt;string&gt; directories, System.Predicate&lt;string&gt; fileFilter);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilderExtensions/#parameters_1","title":"Parameters","text":"<p><code>builder</code> IAssemblyProviderBuilder</p> <p>The assembly provider builder to configure.</p> <p></p> <p><code>directories</code> System.Collections.Generic.IReadOnlyList&lt;System.String&gt;</p> <p>The collection of directory paths to scan for assembly files.</p> <p></p> <p><code>fileFilter</code> System.Predicate&lt;System.String&gt;</p> <p>A predicate that determines which assembly files to include based on their file path.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilderExtensions/#returns_1","title":"Returns","text":"<p>IAssemblyProviderBuilder The configured assembly provider builder.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilderExtensions/#exceptions_1","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when builder, directories, or fileFilter is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilderExtensions/#iassemblyproviderbuilderextensionsmatchingassembliesthis-iassemblyproviderbuilder-predicatestring-method","title":"IAssemblyProviderBuilderExtensions.MatchingAssemblies(this IAssemblyProviderBuilder, Predicate&lt;string&gt;) Method","text":"<p>Configures the builder to load assemblies from the application's base directory that match the specified filter criteria. Only files with .dll or .exe extensions will be considered.</p> <pre><code>public static NexusLabs.Needlr.Injection.Reflection.IAssemblyProviderBuilder MatchingAssemblies(this NexusLabs.Needlr.Injection.Reflection.IAssemblyProviderBuilder builder, System.Predicate&lt;string&gt; fileFilter);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilderExtensions/#parameters_2","title":"Parameters","text":"<p><code>builder</code> IAssemblyProviderBuilder</p> <p>The assembly provider builder to configure.</p> <p></p> <p><code>fileFilter</code> System.Predicate&lt;System.String&gt;</p> <p>A predicate that determines which assembly files to include based on their file path.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilderExtensions/#returns_2","title":"Returns","text":"<p>IAssemblyProviderBuilder The configured assembly provider builder.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilderExtensions/#exceptions_2","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when builder or fileFilter is null.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilderExtensions/#example","title":"Example","text":"<pre><code>builder.MatchingAssemblies(path =&gt; path.Contains(\"MyProject\"));\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilderExtensions/#iassemblyproviderbuilderextensionsmatchingfilesthis-iassemblyproviderbuilder-string-predicatestring-method","title":"IAssemblyProviderBuilderExtensions.MatchingFiles(this IAssemblyProviderBuilder, string, Predicate&lt;string&gt;) Method","text":"<p>Configures the builder to load files from the specified directory that match the filter criteria.</p> <pre><code>public static NexusLabs.Needlr.Injection.Reflection.IAssemblyProviderBuilder MatchingFiles(this NexusLabs.Needlr.Injection.Reflection.IAssemblyProviderBuilder builder, string directory, System.Predicate&lt;string&gt; fileFilter);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilderExtensions/#parameters_3","title":"Parameters","text":"<p><code>builder</code> IAssemblyProviderBuilder</p> <p>The assembly provider builder to configure.</p> <p></p> <p><code>directory</code> System.String</p> <p>The directory path to scan for files.</p> <p></p> <p><code>fileFilter</code> System.Predicate&lt;System.String&gt;</p> <p>A predicate that determines which files to include based on their file path.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilderExtensions/#returns_3","title":"Returns","text":"<p>IAssemblyProviderBuilder The configured assembly provider builder.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilderExtensions/#exceptions_3","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when builder, directory, or fileFilter is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilderExtensions/#iassemblyproviderbuilderextensionsmatchingfilesthis-iassemblyproviderbuilder-ireadonlyliststring-predicatestring-method","title":"IAssemblyProviderBuilderExtensions.MatchingFiles(this IAssemblyProviderBuilder, IReadOnlyList&lt;string&gt;, Predicate&lt;string&gt;) Method","text":"<p>Configures the builder to load files from the specified directories that match the filter criteria. This is the core method that sets up the FileMatchAssemblyLoader.</p> <pre><code>public static NexusLabs.Needlr.Injection.Reflection.IAssemblyProviderBuilder MatchingFiles(this NexusLabs.Needlr.Injection.Reflection.IAssemblyProviderBuilder builder, System.Collections.Generic.IReadOnlyList&lt;string&gt; directories, System.Predicate&lt;string&gt; fileFilter);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilderExtensions/#parameters_4","title":"Parameters","text":"<p><code>builder</code> IAssemblyProviderBuilder</p> <p>The assembly provider builder to configure.</p> <p></p> <p><code>directories</code> System.Collections.Generic.IReadOnlyList&lt;System.String&gt;</p> <p>The collection of directory paths to scan for files.</p> <p></p> <p><code>fileFilter</code> System.Predicate&lt;System.String&gt;</p> <p>A predicate that determines which files to include based on their file path.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilderExtensions/#returns_4","title":"Returns","text":"<p>IAssemblyProviderBuilder The configured assembly provider builder.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilderExtensions/#exceptions_4","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when builder, directories, or fileFilter is null.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilderExtensions/#iassemblyproviderbuilderextensionsmatchingfilesthis-iassemblyproviderbuilder-predicatestring-method","title":"IAssemblyProviderBuilderExtensions.MatchingFiles(this IAssemblyProviderBuilder, Predicate&lt;string&gt;) Method","text":"<p>Configures the builder to load files from the application's base directory that match the specified filter criteria.</p> <pre><code>public static NexusLabs.Needlr.Injection.Reflection.IAssemblyProviderBuilder MatchingFiles(this NexusLabs.Needlr.Injection.Reflection.IAssemblyProviderBuilder builder, System.Predicate&lt;string&gt; fileFilter);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilderExtensions/#parameters_5","title":"Parameters","text":"<p><code>builder</code> IAssemblyProviderBuilder</p> <p>The assembly provider builder to configure.</p> <p></p> <p><code>fileFilter</code> System.Predicate&lt;System.String&gt;</p> <p>A predicate that determines which files to include based on their file path.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilderExtensions/#returns_5","title":"Returns","text":"<p>IAssemblyProviderBuilder The configured assembly provider builder.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/IAssemblyProviderBuilderExtensions/#exceptions_5","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when builder or fileFilter is null.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/NexusLabs.Needlr.Injection.Reflection.Loaders/","title":"NexusLabs.Needlr.Injection.Reflection.Loaders","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/NexusLabs.Needlr.Injection.Reflection.Loaders/#nexuslabsneedlrinjectionreflection","title":"NexusLabs.Needlr.Injection.Reflection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/NexusLabs.Needlr.Injection.Reflection.Loaders/#nexuslabsneedlrinjectionreflectionloaders-namespace","title":"NexusLabs.Needlr.Injection.Reflection.Loaders Namespace","text":"Classes AllAssembliesLoader An assembly loader that loads all assemblies (.dll and .exe) from the application's base directory. FileMatchAssemblyLoader Assembly loader that loads assemblies from disk based on file name matching. ReflectionAssemblyLoader Assembly loader that uses reflection to discover the entry assembly."},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/NexusLabs.Needlr.Injection.Reflection.PluginFactories/","title":"NexusLabs.Needlr.Injection.Reflection.PluginFactories","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/NexusLabs.Needlr.Injection.Reflection.PluginFactories/#nexuslabsneedlrinjectionreflection","title":"NexusLabs.Needlr.Injection.Reflection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/NexusLabs.Needlr.Injection.Reflection.PluginFactories/#nexuslabsneedlrinjectionreflectionpluginfactories-namespace","title":"NexusLabs.Needlr.Injection.Reflection.PluginFactories Namespace","text":"Classes ReflectionPluginFactory Plugin factory that uses runtime reflection to scan assemblies for types that implement specified interfaces, are decorated with particular attributes, or meet both criteria. All discovered types are instantiated using their parameterless constructors."},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/NexusLabs.Needlr.Injection.Reflection.TypeFilterers/","title":"NexusLabs.Needlr.Injection.Reflection.TypeFilterers","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/NexusLabs.Needlr.Injection.Reflection.TypeFilterers/#nexuslabsneedlrinjectionreflection","title":"NexusLabs.Needlr.Injection.Reflection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/NexusLabs.Needlr.Injection.Reflection.TypeFilterers/#nexuslabsneedlrinjectionreflectiontypefilterers-namespace","title":"NexusLabs.Needlr.Injection.Reflection.TypeFilterers Namespace","text":"Classes ReflectionTypeFilterer Type filterer that uses runtime reflection to analyze constructors."},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/NexusLabs.Needlr.Injection.Reflection.TypeRegistrars/","title":"NexusLabs.Needlr.Injection.Reflection.TypeRegistrars","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/NexusLabs.Needlr.Injection.Reflection.TypeRegistrars/#nexuslabsneedlrinjectionreflection","title":"NexusLabs.Needlr.Injection.Reflection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/NexusLabs.Needlr.Injection.Reflection.TypeRegistrars/#nexuslabsneedlrinjectionreflectiontyperegistrars-namespace","title":"NexusLabs.Needlr.Injection.Reflection.TypeRegistrars Namespace","text":"Classes ReflectionTypeRegistrar Type registrar that uses runtime reflection to discover and register types."},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/NexusLabs.Needlr.Injection.Reflection/","title":"NexusLabs.Needlr.Injection.Reflection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/NexusLabs.Needlr.Injection.Reflection/#nexuslabsneedlrinjectionreflection","title":"NexusLabs.Needlr.Injection.Reflection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/NexusLabs.Needlr.Injection.Reflection/#nexuslabsneedlrinjectionreflection-namespace","title":"NexusLabs.Needlr.Injection.Reflection Namespace","text":"Classes AssemblyProviderBuilder Builder for creating assembly providers using reflection-based loaders. IAssemblyProviderBuilderExtensions Extension methods for IAssemblyProviderBuilder providing fluent configuration of assembly loading. For assembly ordering, use <code>SyringeExtensions.OrderAssemblies</code> instead. ReflectionFallbackContext Provides context information when a reflection-based component is used as a fallback because no source-generated component is available. ReflectionFallbackHandlers Provides built-in handlers for reflection fallback scenarios. Use these with WithReflectionFallbackHandler(this ConfiguredSyringe, Action&lt;ReflectionFallbackContext&gt;) to control what happens when source-generated components are not available. ReflectionServiceProviderBuilder Builds and configures an Microsoft.Extensions.DependencyInjection.IServiceCollection using reflection-based plugin discovery. SyringeReflectionExtensions Extension methods for configuring NexusLabs.Needlr.Injection.Syringe with reflection-based components. Interfaces IAssemblyProviderBuilder Defines a builder for constructing NexusLabs.Needlr.Injection.IAssemblyProvider instances with custom loaders. Use this to configure how assemblies are discovered for dependency injection. For assembly ordering, use <code>SyringeExtensions.OrderAssemblies</code> instead."},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionAssemblyLoader/","title":"ReflectionAssemblyLoader","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionAssemblyLoader/#nexuslabsneedlrinjectionreflection","title":"NexusLabs.Needlr.Injection.Reflection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionAssemblyLoader/#nexuslabsneedlrinjectionreflectionloaders","title":"NexusLabs.Needlr.Injection.Reflection.Loaders","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionAssemblyLoader/#reflectionassemblyloader-class","title":"ReflectionAssemblyLoader Class","text":"<p>Assembly loader that uses reflection to discover the entry assembly.</p> <pre><code>public sealed class ReflectionAssemblyLoader : NexusLabs.Needlr.Injection.IAssemblyLoader\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 ReflectionAssemblyLoader</p> <p>Implements NexusLabs.Needlr.Injection.IAssemblyLoader</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionAssemblyLoader/#remarks","title":"Remarks","text":"<p>This loader is not compatible with NativeAOT or trimming. For AOT scenarios, use GeneratedAssemblyProvider from NexusLabs.Needlr.Injection.SourceGen with the Needlr source generator instead.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackContext/","title":"ReflectionFallbackContext","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackContext/#nexuslabsneedlrinjectionreflection","title":"NexusLabs.Needlr.Injection.Reflection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackContext/#nexuslabsneedlrinjectionreflection_1","title":"NexusLabs.Needlr.Injection.Reflection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackContext/#reflectionfallbackcontext-class","title":"ReflectionFallbackContext Class","text":"<p>Provides context information when a reflection-based component is used as a fallback because no source-generated component is available.</p> <pre><code>public sealed class ReflectionFallbackContext\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 ReflectionFallbackContext</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackContext/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackContext/#reflectionfallbackcontextcomponentname-property","title":"ReflectionFallbackContext.ComponentName Property","text":"<p>Gets the name of the component that triggered the reflection fallback.</p> <pre><code>public string ComponentName { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackContext/#property-value","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackContext/#reflectionfallbackcontextgeneratedcomponenttype-property","title":"ReflectionFallbackContext.GeneratedComponentType Property","text":"<p>Gets the type of the source-generated component that would have been used if available. May be null if the reflection package doesn't have visibility to source-gen types.</p> <pre><code>public System.Type? GeneratedComponentType { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackContext/#property-value_1","title":"Property Value","text":"<p>System.Type</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackContext/#reflectionfallbackcontextreason-property","title":"ReflectionFallbackContext.Reason Property","text":"<p>Gets a description of why the fallback occurred.</p> <pre><code>public string Reason { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackContext/#property-value_2","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackContext/#reflectionfallbackcontextreflectioncomponenttype-property","title":"ReflectionFallbackContext.ReflectionComponentType Property","text":"<p>Gets the type of the reflection-based component being used.</p> <pre><code>public System.Type ReflectionComponentType { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackContext/#property-value_3","title":"Property Value","text":"<p>System.Type</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackHandlers/","title":"ReflectionFallbackHandlers","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackHandlers/#nexuslabsneedlrinjectionreflection","title":"NexusLabs.Needlr.Injection.Reflection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackHandlers/#nexuslabsneedlrinjectionreflection_1","title":"NexusLabs.Needlr.Injection.Reflection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackHandlers/#reflectionfallbackhandlers-class","title":"ReflectionFallbackHandlers Class","text":"<p>Provides built-in handlers for reflection fallback scenarios. Use these with WithReflectionFallbackHandler(this ConfiguredSyringe, Action&lt;ReflectionFallbackContext&gt;) to control what happens when source-generated components are not available.</p> <pre><code>public static class ReflectionFallbackHandlers\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 ReflectionFallbackHandlers</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackHandlers/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackHandlers/#reflectionfallbackhandlerscreateassemblyprovidercontext-method","title":"ReflectionFallbackHandlers.CreateAssemblyProviderContext() Method","text":"<p>Creates context for AssemblyProvider fallback.</p> <pre><code>public static NexusLabs.Needlr.Injection.Reflection.ReflectionFallbackContext CreateAssemblyProviderContext();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackHandlers/#returns","title":"Returns","text":"<p>ReflectionFallbackContext</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackHandlers/#reflectionfallbackhandlerscreatepluginfactorycontext-method","title":"ReflectionFallbackHandlers.CreatePluginFactoryContext() Method","text":"<p>Creates context for PluginFactory fallback.</p> <pre><code>public static NexusLabs.Needlr.Injection.Reflection.ReflectionFallbackContext CreatePluginFactoryContext();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackHandlers/#returns_1","title":"Returns","text":"<p>ReflectionFallbackContext</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackHandlers/#reflectionfallbackhandlerscreatetypefilterercontext-method","title":"ReflectionFallbackHandlers.CreateTypeFiltererContext() Method","text":"<p>Creates context for TypeFilterer fallback.</p> <pre><code>public static NexusLabs.Needlr.Injection.Reflection.ReflectionFallbackContext CreateTypeFiltererContext();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackHandlers/#returns_2","title":"Returns","text":"<p>ReflectionFallbackContext</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackHandlers/#reflectionfallbackhandlerscreatetyperegistrarcontext-method","title":"ReflectionFallbackHandlers.CreateTypeRegistrarContext() Method","text":"<p>Creates context for TypeRegistrar fallback.</p> <pre><code>public static NexusLabs.Needlr.Injection.Reflection.ReflectionFallbackContext CreateTypeRegistrarContext();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackHandlers/#returns_3","title":"Returns","text":"<p>ReflectionFallbackContext</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackHandlers/#reflectionfallbackhandlerslogwarningreflectionfallbackcontext-method","title":"ReflectionFallbackHandlers.LogWarning(ReflectionFallbackContext) Method","text":"<p>A handler that writes a warning to System.Console.Error when reflection fallback occurs. Useful for development/debugging to identify missing source generation.</p> <pre><code>public static void LogWarning(NexusLabs.Needlr.Injection.Reflection.ReflectionFallbackContext context);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackHandlers/#parameters","title":"Parameters","text":"<p><code>context</code> ReflectionFallbackContext</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackHandlers/#example","title":"Example","text":"<pre><code>var syringe = new Syringe()\n    .WithReflectionFallbackHandler(ReflectionFallbackHandlers.LogWarning);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackHandlers/#reflectionfallbackhandlerssilentreflectionfallbackcontext-method","title":"ReflectionFallbackHandlers.Silent(ReflectionFallbackContext) Method","text":"<p>A handler that does nothing when reflection fallback occurs. This is the default behavior - silent fallback to reflection.</p> <pre><code>public static void Silent(NexusLabs.Needlr.Injection.Reflection.ReflectionFallbackContext context);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackHandlers/#parameters_1","title":"Parameters","text":"<p><code>context</code> ReflectionFallbackContext</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackHandlers/#reflectionfallbackhandlersthrowexceptionreflectionfallbackcontext-method","title":"ReflectionFallbackHandlers.ThrowException(ReflectionFallbackContext) Method","text":"<p>A handler that throws an System.InvalidOperationException when reflection fallback occurs. Use this to enforce source-generation in AOT/trimmed applications.</p> <pre><code>public static void ThrowException(NexusLabs.Needlr.Injection.Reflection.ReflectionFallbackContext context);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackHandlers/#parameters_2","title":"Parameters","text":"<p><code>context</code> ReflectionFallbackContext</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionFallbackHandlers/#example_1","title":"Example","text":"<pre><code>var syringe = new Syringe()\n    .WithReflectionFallbackHandler(ReflectionFallbackHandlers.ThrowException);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionPluginFactory/","title":"ReflectionPluginFactory","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionPluginFactory/#nexuslabsneedlrinjectionreflection","title":"NexusLabs.Needlr.Injection.Reflection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionPluginFactory/#nexuslabsneedlrinjectionreflectionpluginfactories","title":"NexusLabs.Needlr.Injection.Reflection.PluginFactories","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionPluginFactory/#reflectionpluginfactory-class","title":"ReflectionPluginFactory Class","text":"<p>Plugin factory that uses runtime reflection to scan assemblies for types that implement specified interfaces, are decorated with particular attributes, or meet both criteria. All discovered types are instantiated using their parameterless constructors.</p> <pre><code>public sealed class ReflectionPluginFactory : NexusLabs.Needlr.IPluginFactory\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 ReflectionPluginFactory</p> <p>Implements NexusLabs.Needlr.IPluginFactory</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionPluginFactory/#remarks","title":"Remarks","text":"<p>This factory uses runtime reflection and is not compatible with NativeAOT or trimming. For AOT scenarios, use the GeneratedPluginFactory from NexusLabs.Needlr.Injection.SourceGen instead.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionPluginFactory/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionPluginFactory/#reflectionpluginfactorycreatepluginsfromassembliestplugintattributeienumerableassembly-method","title":"ReflectionPluginFactory.CreatePluginsFromAssemblies&lt;TPlugin,TAttribute&gt;(IEnumerable&lt;Assembly&gt;) Method","text":"<p>Creates instances of plugins of type TPlugin from the provided assemblies  that are also decorated with the specified attribute.</p> <pre><code>public System.Collections.Generic.IEnumerable&lt;TPlugin&gt; CreatePluginsFromAssemblies&lt;TPlugin,TAttribute&gt;(System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt; assemblies)\n    where TPlugin : class\n    where TAttribute : System.Attribute;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionPluginFactory/#type-parameters","title":"Type parameters","text":"<p><code>TPlugin</code></p> <p>The plugin interface or base type to search for.</p> <p></p> <p><code>TAttribute</code></p> <p>The attribute type to search for in the type hierarchy.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionPluginFactory/#parameters","title":"Parameters","text":"<p><code>assemblies</code> System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt;</p> <p>A collection of assemblies to scan for plugin types.</p> <p>Implements CreatePluginsFromAssemblies&lt;TPlugin,TAttribute&gt;(IEnumerable&lt;Assembly&gt;)</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionPluginFactory/#returns","title":"Returns","text":"<p>System.Collections.Generic.IEnumerable&lt;TPlugin&gt; An enumerable of instantiated plugins implementing TPlugin and  decorated with TAttribute.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionPluginFactory/#reflectionpluginfactorycreatepluginsfromassembliestpluginienumerableassembly-method","title":"ReflectionPluginFactory.CreatePluginsFromAssemblies&lt;TPlugin&gt;(IEnumerable&lt;Assembly&gt;) Method","text":"<p>Creates instances of plugins of type TPlugin from the provided assemblies.</p> <pre><code>public System.Collections.Generic.IEnumerable&lt;TPlugin&gt; CreatePluginsFromAssemblies&lt;TPlugin&gt;(System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt; assemblies)\n    where TPlugin : class;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionPluginFactory/#type-parameters_1","title":"Type parameters","text":"<p><code>TPlugin</code></p> <p>The plugin interface or base type to search for.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionPluginFactory/#parameters_1","title":"Parameters","text":"<p><code>assemblies</code> System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt;</p> <p>A collection of assemblies to scan for plugin types.</p> <p>Implements CreatePluginsFromAssemblies&lt;TPlugin&gt;(IEnumerable&lt;Assembly&gt;)</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionPluginFactory/#returns_1","title":"Returns","text":"<p>System.Collections.Generic.IEnumerable&lt;TPlugin&gt; An enumerable of instantiated plugins implementing TPlugin.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionPluginFactory/#reflectionpluginfactorycreatepluginswithattributefromassembliestattributeienumerableassembly-method","title":"ReflectionPluginFactory.CreatePluginsWithAttributeFromAssemblies&lt;TAttribute&gt;(IEnumerable&lt;Assembly&gt;) Method","text":"<p>Creates instances of plugins from the provided assemblies that are decorated with the specified attribute.</p> <pre><code>public System.Collections.Generic.IEnumerable&lt;object&gt; CreatePluginsWithAttributeFromAssemblies&lt;TAttribute&gt;(System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt; assemblies)\n    where TAttribute : System.Attribute;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionPluginFactory/#type-parameters_2","title":"Type parameters","text":"<p><code>TAttribute</code></p> <p>The attribute type to search for in the type hierarchy.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionPluginFactory/#parameters_2","title":"Parameters","text":"<p><code>assemblies</code> System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt;</p> <p>A collection of assemblies to scan for plugin types.</p> <p>Implements CreatePluginsWithAttributeFromAssemblies&lt;TAttribute&gt;(IEnumerable&lt;Assembly&gt;)</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionPluginFactory/#returns_2","title":"Returns","text":"<p>System.Collections.Generic.IEnumerable&lt;System.Object&gt; An enumerable of instantiated plugins decorated with TAttribute.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionServiceProviderBuilder/","title":"ReflectionServiceProviderBuilder","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionServiceProviderBuilder/#nexuslabsneedlrinjectionreflection","title":"NexusLabs.Needlr.Injection.Reflection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionServiceProviderBuilder/#nexuslabsneedlrinjectionreflection_1","title":"NexusLabs.Needlr.Injection.Reflection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionServiceProviderBuilder/#reflectionserviceproviderbuilder-class","title":"ReflectionServiceProviderBuilder Class","text":"<p>Builds and configures an Microsoft.Extensions.DependencyInjection.IServiceCollection using reflection-based plugin discovery.</p> <pre><code>public sealed class ReflectionServiceProviderBuilder : NexusLabs.Needlr.Injection.IServiceProviderBuilder\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 ReflectionServiceProviderBuilder</p> <p>Implements NexusLabs.Needlr.Injection.IServiceProviderBuilder</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionServiceProviderBuilder/#remarks","title":"Remarks","text":"<p>This builder uses ReflectionPluginFactory for plugin discovery and is not AOT compatible.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionServiceProviderBuilder/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionServiceProviderBuilder/#reflectionserviceproviderbuilderbuildiconfiguration-method","title":"ReflectionServiceProviderBuilder.Build(IConfiguration) Method","text":"<p>Builds a new System.IServiceProvider using the discovered assemblies and a custom registration callback.</p> <pre><code>public System.IServiceProvider Build(Microsoft.Extensions.Configuration.IConfiguration config);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionServiceProviderBuilder/#parameters","title":"Parameters","text":"<p><code>config</code> Microsoft.Extensions.Configuration.IConfiguration</p> <p>The configuration to use for settings.</p> <p>Implements Build(IConfiguration)</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionServiceProviderBuilder/#returns","title":"Returns","text":"<p>System.IServiceProvider The built System.IServiceProvider.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionServiceProviderBuilder/#reflectionserviceproviderbuilderbuildiservicecollection-iconfiguration-method","title":"ReflectionServiceProviderBuilder.Build(IServiceCollection, IConfiguration) Method","text":"<p>Builds a new System.IServiceProvider using the discovered assemblies and a custom registration callback.</p> <pre><code>public System.IServiceProvider Build(Microsoft.Extensions.DependencyInjection.IServiceCollection services, Microsoft.Extensions.Configuration.IConfiguration config);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionServiceProviderBuilder/#parameters_1","title":"Parameters","text":"<p><code>services</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service collection to configure.</p> <p></p> <p><code>config</code> Microsoft.Extensions.Configuration.IConfiguration</p> <p>The configuration to use for settings.</p> <p>Implements Build(IServiceCollection, IConfiguration)</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionServiceProviderBuilder/#returns_1","title":"Returns","text":"<p>System.IServiceProvider The built System.IServiceProvider.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionServiceProviderBuilder/#reflectionserviceproviderbuilderbuildiservicecollection-iconfiguration-ireadonlylistactioniservicecollection-method","title":"ReflectionServiceProviderBuilder.Build(IServiceCollection, IConfiguration, IReadOnlyList&lt;Action&lt;IServiceCollection&gt;&gt;) Method","text":"<p>Builds a new System.IServiceProvider using the provided Microsoft.Extensions.DependencyInjection.IServiceCollection and a custom registration callback.</p> <pre><code>public System.IServiceProvider Build(Microsoft.Extensions.DependencyInjection.IServiceCollection services, Microsoft.Extensions.Configuration.IConfiguration config, System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; postPluginRegistrationCallbacks);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionServiceProviderBuilder/#parameters_2","title":"Parameters","text":"<p><code>services</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service collection to configure.</p> <p></p> <p><code>config</code> Microsoft.Extensions.Configuration.IConfiguration</p> <p>The configuration to use for settings.</p> <p></p> <p><code>postPluginRegistrationCallbacks</code> System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p>The set of callbacks for additional registration logic</p> <p>Implements Build(IServiceCollection, IConfiguration, IReadOnlyList&lt;Action&lt;IServiceCollection&gt;&gt;)</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionServiceProviderBuilder/#returns_2","title":"Returns","text":"<p>System.IServiceProvider The built System.IServiceProvider.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionServiceProviderBuilder/#reflectionserviceproviderbuilderbuildiservicecollection-iconfiguration-ireadonlylistactioniservicecollection-ireadonlylistactioniservicecollection-method","title":"ReflectionServiceProviderBuilder.Build(IServiceCollection, IConfiguration, IReadOnlyList&lt;Action&lt;IServiceCollection&gt;&gt;, IReadOnlyList&lt;Action&lt;IServiceCollection&gt;&gt;) Method","text":"<p>Builds a new System.IServiceProvider with both pre and post registration callbacks.</p> <pre><code>public System.IServiceProvider Build(Microsoft.Extensions.DependencyInjection.IServiceCollection services, Microsoft.Extensions.Configuration.IConfiguration config, System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; preRegistrationCallbacks, System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; postPluginRegistrationCallbacks);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionServiceProviderBuilder/#parameters_3","title":"Parameters","text":"<p><code>services</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service collection to configure.</p> <p></p> <p><code>config</code> Microsoft.Extensions.Configuration.IConfiguration</p> <p>The configuration to use for settings.</p> <p></p> <p><code>preRegistrationCallbacks</code> System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p>Callbacks executed before auto-discovery registration (e.g., for open generics).</p> <p></p> <p><code>postPluginRegistrationCallbacks</code> System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p>Callbacks executed after plugin registration.</p> <p>Implements Build(IServiceCollection, IConfiguration, IReadOnlyList&lt;Action&lt;IServiceCollection&gt;&gt;, IReadOnlyList&lt;Action&lt;IServiceCollection&gt;&gt;)</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionServiceProviderBuilder/#returns_3","title":"Returns","text":"<p>System.IServiceProvider The built System.IServiceProvider.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionServiceProviderBuilder/#reflectionserviceproviderbuilderconfigurepostbuildservicecollectionpluginsiserviceprovider-iconfiguration-method","title":"ReflectionServiceProviderBuilder.ConfigurePostBuildServiceCollectionPlugins(IServiceProvider, IConfiguration) Method","text":"<p>Configures plugins that require post-build service collection configuration using the built service provider.</p> <pre><code>public void ConfigurePostBuildServiceCollectionPlugins(System.IServiceProvider provider, Microsoft.Extensions.Configuration.IConfiguration config);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionServiceProviderBuilder/#parameters_4","title":"Parameters","text":"<p><code>provider</code> System.IServiceProvider</p> <p>The built service provider to use for plugin configuration.</p> <p></p> <p><code>config</code> Microsoft.Extensions.Configuration.IConfiguration</p> <p>The configuration to use for settings.</p> <p>Implements ConfigurePostBuildServiceCollectionPlugins(IServiceProvider, IConfiguration)</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionServiceProviderBuilder/#reflectionserviceproviderbuildergetcandidateassemblies-method","title":"ReflectionServiceProviderBuilder.GetCandidateAssemblies() Method","text":"<p>Gets the list of candidate assemblies that will be scanned for service registrations and plugins.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt; GetCandidateAssemblies();\n</code></pre> <p>Implements GetCandidateAssemblies()</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionServiceProviderBuilder/#returns_4","title":"Returns","text":"<p>System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt; A read-only list of assemblies to be processed for dependency injection.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionTypeFilterer/","title":"ReflectionTypeFilterer","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionTypeFilterer/#nexuslabsneedlrinjectionreflection","title":"NexusLabs.Needlr.Injection.Reflection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionTypeFilterer/#nexuslabsneedlrinjectionreflectiontypefilterers","title":"NexusLabs.Needlr.Injection.Reflection.TypeFilterers","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionTypeFilterer/#reflectiontypefilterer-class","title":"ReflectionTypeFilterer Class","text":"<p>Type filterer that uses runtime reflection to analyze constructors.</p> <pre><code>public sealed class ReflectionTypeFilterer : NexusLabs.Needlr.Injection.ITypeFilterer\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 ReflectionTypeFilterer</p> <p>Implements NexusLabs.Needlr.Injection.ITypeFilterer</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionTypeFilterer/#remarks","title":"Remarks","text":"<p>This filterer is not compatible with NativeAOT or trimming. For AOT scenarios, use GeneratedTypeFilterer from NexusLabs.Needlr.Injection.SourceGen with the Needlr source generator instead.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionTypeRegistrar/","title":"ReflectionTypeRegistrar","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionTypeRegistrar/#nexuslabsneedlrinjectionreflection","title":"NexusLabs.Needlr.Injection.Reflection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionTypeRegistrar/#nexuslabsneedlrinjectionreflectiontyperegistrars","title":"NexusLabs.Needlr.Injection.Reflection.TypeRegistrars","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionTypeRegistrar/#reflectiontyperegistrar-class","title":"ReflectionTypeRegistrar Class","text":"<p>Type registrar that uses runtime reflection to discover and register types.</p> <pre><code>public sealed class ReflectionTypeRegistrar : NexusLabs.Needlr.Injection.ITypeRegistrar\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 ReflectionTypeRegistrar</p> <p>Implements NexusLabs.Needlr.Injection.ITypeRegistrar</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionTypeRegistrar/#remarks","title":"Remarks","text":"<p>This registrar is not compatible with NativeAOT or trimming. For AOT scenarios, use GeneratedTypeRegistrar from NexusLabs.Needlr.Injection.SourceGen with the Needlr source generator instead.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionTypeRegistrar/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionTypeRegistrar/#reflectiontyperegistrarregistertypesfromassembliesiservicecollection-itypefilterer-ireadonlylistassembly-method","title":"ReflectionTypeRegistrar.RegisterTypesFromAssemblies(IServiceCollection, ITypeFilterer, IReadOnlyList&lt;Assembly&gt;) Method","text":"<p>Registers types from the specified assemblies into the service collection.</p> <pre><code>public void RegisterTypesFromAssemblies(Microsoft.Extensions.DependencyInjection.IServiceCollection services, NexusLabs.Needlr.Injection.ITypeFilterer typeFilterer, System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt; assemblies);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/ReflectionTypeRegistrar/#parameters","title":"Parameters","text":"<p><code>services</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service collection to register types into.</p> <p></p> <p><code>typeFilterer</code> NexusLabs.Needlr.Injection.ITypeFilterer</p> <p>The type filterer used to determine which types should be registered and their lifetimes.</p> <p></p> <p><code>assemblies</code> System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt;</p> <p>The assemblies to scan for types to register.</p> <p>Implements RegisterTypesFromAssemblies(IServiceCollection, ITypeFilterer, IReadOnlyList&lt;Assembly&gt;)</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/SyringeReflectionExtensions/","title":"SyringeReflectionExtensions","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/SyringeReflectionExtensions/#nexuslabsneedlrinjectionreflection","title":"NexusLabs.Needlr.Injection.Reflection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/SyringeReflectionExtensions/#nexuslabsneedlrinjectionreflection_1","title":"NexusLabs.Needlr.Injection.Reflection","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/SyringeReflectionExtensions/#syringereflectionextensions-class","title":"SyringeReflectionExtensions Class","text":"<p>Extension methods for configuring NexusLabs.Needlr.Injection.Syringe with reflection-based components.</p> <pre><code>public static class SyringeReflectionExtensions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 SyringeReflectionExtensions</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/SyringeReflectionExtensions/#remarks","title":"Remarks","text":"<p>These extensions enable runtime reflection-based type discovery and registration. Use these when you need dynamic assembly loading or when source generation is not available.</p> <p>For AOT/trimming compatibility, use <code>NexusLabs.Needlr.Injection.SourceGen</code> instead.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/SyringeReflectionExtensions/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/SyringeReflectionExtensions/#syringereflectionextensionsusingassemblyproviderthis-configuredsyringe-funciassemblyproviderbuilderiassemblyprovider-method","title":"SyringeReflectionExtensions.UsingAssemblyProvider(this ConfiguredSyringe, Func&lt;IAssemblyProviderBuilder,IAssemblyProvider&gt;) Method","text":"<p>Configures the syringe to use a custom assembly provider built with the builder pattern.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UsingAssemblyProvider(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe, System.Func&lt;NexusLabs.Needlr.Injection.Reflection.IAssemblyProviderBuilder,NexusLabs.Needlr.Injection.IAssemblyProvider&gt; configure);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/SyringeReflectionExtensions/#parameters","title":"Parameters","text":"<p><code>syringe</code> NexusLabs.Needlr.Injection.ConfiguredSyringe</p> <p>The configured syringe to update.</p> <p></p> <p><code>configure</code> System.Func&lt;IAssemblyProviderBuilder,NexusLabs.Needlr.Injection.IAssemblyProvider&gt;</p> <p>A function to configure the assembly provider builder.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/SyringeReflectionExtensions/#returns","title":"Returns","text":"<p>NexusLabs.Needlr.Injection.ConfiguredSyringe A new configured syringe instance.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/SyringeReflectionExtensions/#syringereflectionextensionsusingreflectionthis-syringe-method","title":"SyringeReflectionExtensions.UsingReflection(this Syringe) Method","text":"<p>Configures the syringe to use all reflection-based components.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UsingReflection(this NexusLabs.Needlr.Injection.Syringe syringe);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/SyringeReflectionExtensions/#parameters_1","title":"Parameters","text":"<p><code>syringe</code> NexusLabs.Needlr.Injection.Syringe</p> <p>The syringe to configure.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/SyringeReflectionExtensions/#returns_1","title":"Returns","text":"<p>NexusLabs.Needlr.Injection.ConfiguredSyringe A configured syringe ready for further configuration and building.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/SyringeReflectionExtensions/#remarks_1","title":"Remarks","text":"<p>This sets the type registrar, type filterer, plugin factory, and assembly provider to their reflection-based implementations. Not compatible with AOT/trimming.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/SyringeReflectionExtensions/#syringereflectionextensionsusingreflectionassemblyproviderthis-configuredsyringe-method","title":"SyringeReflectionExtensions.UsingReflectionAssemblyProvider(this ConfiguredSyringe) Method","text":"<p>Configures the syringe to use the reflection-based assembly provider.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UsingReflectionAssemblyProvider(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/SyringeReflectionExtensions/#parameters_2","title":"Parameters","text":"<p><code>syringe</code> NexusLabs.Needlr.Injection.ConfiguredSyringe</p> <p>The configured syringe to update.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/SyringeReflectionExtensions/#returns_2","title":"Returns","text":"<p>NexusLabs.Needlr.Injection.ConfiguredSyringe A new configured syringe instance.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/SyringeReflectionExtensions/#syringereflectionextensionsusingreflectionpluginfactorythis-configuredsyringe-method","title":"SyringeReflectionExtensions.UsingReflectionPluginFactory(this ConfiguredSyringe) Method","text":"<p>Configures the syringe to use the reflection-based plugin factory.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UsingReflectionPluginFactory(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/SyringeReflectionExtensions/#parameters_3","title":"Parameters","text":"<p><code>syringe</code> NexusLabs.Needlr.Injection.ConfiguredSyringe</p> <p>The configured syringe to update.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/SyringeReflectionExtensions/#returns_3","title":"Returns","text":"<p>NexusLabs.Needlr.Injection.ConfiguredSyringe A new configured syringe instance.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/SyringeReflectionExtensions/#syringereflectionextensionsusingreflectiontypefiltererthis-configuredsyringe-method","title":"SyringeReflectionExtensions.UsingReflectionTypeFilterer(this ConfiguredSyringe) Method","text":"<p>Configures the syringe to use the reflection-based type filterer.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UsingReflectionTypeFilterer(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/SyringeReflectionExtensions/#parameters_4","title":"Parameters","text":"<p><code>syringe</code> NexusLabs.Needlr.Injection.ConfiguredSyringe</p> <p>The configured syringe to update.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/SyringeReflectionExtensions/#returns_4","title":"Returns","text":"<p>NexusLabs.Needlr.Injection.ConfiguredSyringe A new configured syringe instance.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/SyringeReflectionExtensions/#syringereflectionextensionsusingreflectiontyperegistrarthis-configuredsyringe-method","title":"SyringeReflectionExtensions.UsingReflectionTypeRegistrar(this ConfiguredSyringe) Method","text":"<p>Configures the syringe to use the reflection-based type registrar.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UsingReflectionTypeRegistrar(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/SyringeReflectionExtensions/#parameters_5","title":"Parameters","text":"<p><code>syringe</code> NexusLabs.Needlr.Injection.ConfiguredSyringe</p> <p>The configured syringe to update.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/SyringeReflectionExtensions/#returns_5","title":"Returns","text":"<p>NexusLabs.Needlr.Injection.ConfiguredSyringe A new configured syringe instance.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/SyringeReflectionExtensions/#syringereflectionextensionswithreflectionfallbackhandlerthis-configuredsyringe-actionreflectionfallbackcontext-method","title":"SyringeReflectionExtensions.WithReflectionFallbackHandler(this ConfiguredSyringe, Action&lt;ReflectionFallbackContext&gt;) Method","text":"<p>Configures a handler to be invoked when reflection-based components are used as fallback.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe WithReflectionFallbackHandler(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe, System.Action&lt;NexusLabs.Needlr.Injection.Reflection.ReflectionFallbackContext&gt; handler);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/SyringeReflectionExtensions/#parameters_6","title":"Parameters","text":"<p><code>syringe</code> NexusLabs.Needlr.Injection.ConfiguredSyringe</p> <p>The configured syringe to update.</p> <p></p> <p><code>handler</code> System.Action&lt;ReflectionFallbackContext&gt;</p> <p>The handler to invoke when reflection fallback occurs.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Reflection/SyringeReflectionExtensions/#returns_6","title":"Returns","text":"<p>NexusLabs.Needlr.Injection.ConfiguredSyringe A new configured syringe instance.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Scrutor/","title":"Index","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Scrutor/#nexuslabsneedlrinjectionscrutor-namespace","title":"NexusLabs.Needlr.Injection.Scrutor Namespace","text":"Classes ScrutorTypeRegistrar Registers types from assemblies using Scrutor. SyringeScrutorExtensions Extension methods for configuring NexusLabs.Needlr.Injection.ConfiguredSyringe instances with Scrutor-specific functionality."},{"location":"api/dev/NexusLabs.Needlr.Injection.Scrutor/NexusLabs.Needlr.Injection.Scrutor/","title":"NexusLabs.Needlr.Injection.Scrutor","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Scrutor/NexusLabs.Needlr.Injection.Scrutor/#nexuslabsneedlrinjectionscrutor-namespace","title":"NexusLabs.Needlr.Injection.Scrutor Namespace","text":"Classes ScrutorTypeRegistrar Registers types from assemblies using Scrutor. SyringeScrutorExtensions Extension methods for configuring NexusLabs.Needlr.Injection.ConfiguredSyringe instances with Scrutor-specific functionality."},{"location":"api/dev/NexusLabs.Needlr.Injection.Scrutor/ScrutorTypeRegistrar/","title":"ScrutorTypeRegistrar","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Scrutor/ScrutorTypeRegistrar/#nexuslabsneedlrinjectionscrutor","title":"NexusLabs.Needlr.Injection.Scrutor","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Scrutor/ScrutorTypeRegistrar/#scrutortyperegistrar-class","title":"ScrutorTypeRegistrar Class","text":"<p>Registers types from assemblies using Scrutor.</p> <pre><code>public sealed class ScrutorTypeRegistrar : NexusLabs.Needlr.Injection.ITypeRegistrar\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 ScrutorTypeRegistrar</p> <p>Implements NexusLabs.Needlr.Injection.ITypeRegistrar</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Scrutor/ScrutorTypeRegistrar/#remarks","title":"Remarks","text":"<p>Scrutor does not traverse up the inheritance hierarchy of interfaces to look for the NexusLabs.Needlr.DoNotAutoRegisterAttribute. As a result, types that implement an interface with this attribute will still be  registered unless the attribute is applied directly to the type itself.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Scrutor/ScrutorTypeRegistrar/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Scrutor/ScrutorTypeRegistrar/#scrutortyperegistrarregistertypesfromassembliesiservicecollection-itypefilterer-ireadonlylistassembly-method","title":"ScrutorTypeRegistrar.RegisterTypesFromAssemblies(IServiceCollection, ITypeFilterer, IReadOnlyList&lt;Assembly&gt;) Method","text":"<p>Registers types from the specified assemblies into the service collection.</p> <pre><code>public void RegisterTypesFromAssemblies(Microsoft.Extensions.DependencyInjection.IServiceCollection services, NexusLabs.Needlr.Injection.ITypeFilterer typeFilterer, System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt; assemblies);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Scrutor/ScrutorTypeRegistrar/#parameters","title":"Parameters","text":"<p><code>services</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service collection to register types into.</p> <p></p> <p><code>typeFilterer</code> NexusLabs.Needlr.Injection.ITypeFilterer</p> <p>The type filterer used to determine which types should be registered and their lifetimes.</p> <p></p> <p><code>assemblies</code> System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt;</p> <p>The assemblies to scan for types to register.</p> <p>Implements RegisterTypesFromAssemblies(IServiceCollection, ITypeFilterer, IReadOnlyList&lt;Assembly&gt;)</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Scrutor/SyringeScrutorExtensions/","title":"SyringeScrutorExtensions","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Scrutor/SyringeScrutorExtensions/#nexuslabsneedlrinjectionscrutor","title":"NexusLabs.Needlr.Injection.Scrutor","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Scrutor/SyringeScrutorExtensions/#syringescrutorextensions-class","title":"SyringeScrutorExtensions Class","text":"<p>Extension methods for configuring NexusLabs.Needlr.Injection.ConfiguredSyringe instances with Scrutor-specific functionality.</p> <pre><code>public static class SyringeScrutorExtensions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 SyringeScrutorExtensions</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Scrutor/SyringeScrutorExtensions/#example","title":"Example","text":"<p>Reflection-based usage with Scrutor:</p> <pre><code>var serviceProvider = new Syringe()\n    .UsingReflection()\n    .UsingScrutorTypeRegistrar()\n    .BuildServiceProvider();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Scrutor/SyringeScrutorExtensions/#remarks","title":"Remarks","text":"<p>Scrutor uses runtime reflection for assembly scanning.  For AOT/trimming compatibility, use source-generated components instead.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Scrutor/SyringeScrutorExtensions/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.Scrutor/SyringeScrutorExtensions/#syringescrutorextensionsusingscrutortyperegistrarthis-configuredsyringe-method","title":"SyringeScrutorExtensions.UsingScrutorTypeRegistrar(this ConfiguredSyringe) Method","text":"<p>Configures the syringe to use the Scrutor type registrar. This enables automatic service registration using the Scrutor library for assembly scanning.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UsingScrutorTypeRegistrar(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Scrutor/SyringeScrutorExtensions/#parameters","title":"Parameters","text":"<p><code>syringe</code> NexusLabs.Needlr.Injection.ConfiguredSyringe</p> <p>The configured syringe to update.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Scrutor/SyringeScrutorExtensions/#returns","title":"Returns","text":"<p>NexusLabs.Needlr.Injection.ConfiguredSyringe A new configured syringe instance.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.Scrutor/SyringeScrutorExtensions/#example_1","title":"Example","text":"<pre><code>var syringe = new Syringe()\n    .UsingReflection()\n    .UsingScrutorTypeRegistrar();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/","title":"Index","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/#nexuslabsneedlrinjectionsourcegen","title":"NexusLabs.Needlr.Injection.SourceGen","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/#nexuslabsneedlrinjectionsourcegen-assembly","title":"NexusLabs.Needlr.Injection.SourceGen Assembly","text":"Namespaces NexusLabs.Needlr.Injection.SourceGen NexusLabs.Needlr.Injection.SourceGen.Loaders NexusLabs.Needlr.Injection.SourceGen.PluginFactories NexusLabs.Needlr.Injection.SourceGen.TypeFilterers NexusLabs.Needlr.Injection.SourceGen.TypeRegistrars"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedAssemblyProvider/","title":"GeneratedAssemblyProvider","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedAssemblyProvider/#nexuslabsneedlrinjectionsourcegen","title":"NexusLabs.Needlr.Injection.SourceGen","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedAssemblyProvider/#nexuslabsneedlrinjectionsourcegenloaders","title":"NexusLabs.Needlr.Injection.SourceGen.Loaders","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedAssemblyProvider/#generatedassemblyprovider-class","title":"GeneratedAssemblyProvider Class","text":"<p>An assembly provider that derives assemblies from the generated TypeRegistry.</p> <pre><code>public sealed class GeneratedAssemblyProvider : NexusLabs.Needlr.Injection.IAssemblyProvider\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 GeneratedAssemblyProvider</p> <p>Implements NexusLabs.Needlr.Injection.IAssemblyProvider</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedAssemblyProvider/#remarks","title":"Remarks","text":"<p>When using source generation, the TypeRegistry contains all injectable types and plugins discovered at compile time. This provider extracts the unique assemblies from those types, enabling cross-assembly plugin discovery without runtime assembly scanning.</p> <p>This provider should be used with GeneratedPluginFactory to ensure that all assemblies containing generated types are included in plugin discovery.</p> <p>For assembly ordering, use <code>SyringeExtensions.OrderAssemblies</code> after configuring the Syringe.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedAssemblyProvider/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedAssemblyProvider/#generatedassemblyproviderfuncireadonlylistinjectabletypeinfo-funcireadonlylistplugintypeinfo-constructor","title":"GeneratedAssemblyProvider(Func&lt;IReadOnlyList&lt;InjectableTypeInfo&gt;&gt;, Func&lt;IReadOnlyList&lt;PluginTypeInfo&gt;&gt;) Constructor","text":"<p>Initializes a new instance of the GeneratedAssemblyProvider class.</p> <pre><code>public GeneratedAssemblyProvider(System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.InjectableTypeInfo&gt;&gt; injectableTypesProvider, System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.PluginTypeInfo&gt;&gt; pluginTypesProvider);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedAssemblyProvider/#parameters","title":"Parameters","text":"<p><code>injectableTypesProvider</code> System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.InjectableTypeInfo&gt;&gt;</p> <p>A function that returns the injectable types.</p> <p></p> <p><code>pluginTypesProvider</code> System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.PluginTypeInfo&gt;&gt;</p> <p>A function that returns the plugin types.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedPluginFactory/","title":"GeneratedPluginFactory","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedPluginFactory/#nexuslabsneedlrinjectionsourcegen","title":"NexusLabs.Needlr.Injection.SourceGen","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedPluginFactory/#nexuslabsneedlrinjectionsourcegenpluginfactories","title":"NexusLabs.Needlr.Injection.SourceGen.PluginFactories","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedPluginFactory/#generatedpluginfactory-class","title":"GeneratedPluginFactory Class","text":"<p>A plugin factory that uses compile-time generated type information instead of runtime reflection for plugin discovery and instantiation.</p> <pre><code>public sealed class GeneratedPluginFactory : NexusLabs.Needlr.IPluginFactory\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 GeneratedPluginFactory</p> <p>Implements NexusLabs.Needlr.IPluginFactory</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedPluginFactory/#remarks","title":"Remarks","text":"<p>This factory provides better performance and AOT compatibility by using pre-computed plugin information and factory delegates generated at compile time.</p> <p>To use this factory, your assembly must have: - A reference to <code>NexusLabs.Needlr.Generators</code> - The <code>[assembly: GenerateTypeRegistry(...)]</code> attribute</p> <p>Plugins are sorted by their NexusLabs.Needlr.Generators.PluginTypeInfo.Order value (lower first), then alphabetically by fully qualified type name for deterministic execution order. Sorting is performed once during initialization.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedPluginFactory/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedPluginFactory/#generatedpluginfactoryfuncireadonlylistplugintypeinfo-bool-constructor","title":"GeneratedPluginFactory(Func&lt;IReadOnlyList&lt;PluginTypeInfo&gt;&gt;, bool) Constructor","text":"<p>Initializes a new instance of the GeneratedPluginFactory class with a custom plugin provider.</p> <pre><code>public GeneratedPluginFactory(System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.PluginTypeInfo&gt;&gt; pluginProvider, bool allowAllWhenAssembliesEmpty=false);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedPluginFactory/#parameters","title":"Parameters","text":"<p><code>pluginProvider</code> System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.PluginTypeInfo&gt;&gt;</p> <p>A function that returns the plugin types.</p> <p></p> <p><code>allowAllWhenAssembliesEmpty</code> System.Boolean</p> <p>When true, passing an empty assemblies collection to the factory methods will not filter plugins. This is useful for NativeAOT scenarios where producing an System.Reflection.Assembly list without reflection is not possible.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedPluginFactory/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedPluginFactory/#generatedpluginfactorycreatepluginstplugintattribute-method","title":"GeneratedPluginFactory.CreatePlugins&lt;TPlugin,TAttribute&gt;() Method","text":"<p>Creates instances of plugins of type TPlugin that are  decorated with the specified attribute.</p> <pre><code>public System.Collections.Generic.IEnumerable&lt;TPlugin&gt; CreatePlugins&lt;TPlugin,TAttribute&gt;()\n    where TPlugin : class\n    where TAttribute : System.Attribute;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedPluginFactory/#type-parameters","title":"Type parameters","text":"<p><code>TPlugin</code></p> <p>The plugin interface or base type to search for.</p> <p></p> <p><code>TAttribute</code></p> <p>The attribute type to search for in the type hierarchy.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedPluginFactory/#returns","title":"Returns","text":"<p>System.Collections.Generic.IEnumerable&lt;TPlugin&gt; An enumerable of instantiated plugins implementing TPlugin and  decorated with TAttribute.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedPluginFactory/#remarks_1","title":"Remarks","text":"<p>Plugins are returned in order by their NexusLabs.Needlr.Generators.PluginTypeInfo.Order value (lower first), then alphabetically by fully qualified type name for deterministic execution order.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedPluginFactory/#generatedpluginfactorycreatepluginstplugin-method","title":"GeneratedPluginFactory.CreatePlugins&lt;TPlugin&gt;() Method","text":"<p>Creates instances of plugins of type TPlugin.</p> <pre><code>public System.Collections.Generic.IEnumerable&lt;TPlugin&gt; CreatePlugins&lt;TPlugin&gt;()\n    where TPlugin : class;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedPluginFactory/#type-parameters_1","title":"Type parameters","text":"<p><code>TPlugin</code></p> <p>The plugin interface or base type to search for.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedPluginFactory/#returns_1","title":"Returns","text":"<p>System.Collections.Generic.IEnumerable&lt;TPlugin&gt; An enumerable of instantiated plugins implementing TPlugin.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedPluginFactory/#remarks_2","title":"Remarks","text":"<p>Plugins are returned in order by their NexusLabs.Needlr.Generators.PluginTypeInfo.Order value (lower first), then alphabetically by fully qualified type name for deterministic execution order.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedPluginFactory/#generatedpluginfactorycreatepluginsfromassembliestplugintattributeienumerableassembly-method","title":"GeneratedPluginFactory.CreatePluginsFromAssemblies&lt;TPlugin,TAttribute&gt;(IEnumerable&lt;Assembly&gt;) Method","text":"<p>Creates instances of plugins of type TPlugin from the provided assemblies  that are also decorated with the specified attribute.</p> <pre><code>public System.Collections.Generic.IEnumerable&lt;TPlugin&gt; CreatePluginsFromAssemblies&lt;TPlugin,TAttribute&gt;(System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt; assemblies)\n    where TPlugin : class\n    where TAttribute : System.Attribute;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedPluginFactory/#type-parameters_2","title":"Type parameters","text":"<p><code>TPlugin</code></p> <p>The plugin interface or base type to search for.</p> <p></p> <p><code>TAttribute</code></p> <p>The attribute type to search for in the type hierarchy.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedPluginFactory/#parameters_1","title":"Parameters","text":"<p><code>assemblies</code> System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt;</p> <p>A collection of assemblies to scan for plugin types.</p> <p>Implements CreatePluginsFromAssemblies&lt;TPlugin,TAttribute&gt;(IEnumerable&lt;Assembly&gt;)</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedPluginFactory/#returns_2","title":"Returns","text":"<p>System.Collections.Generic.IEnumerable&lt;TPlugin&gt; An enumerable of instantiated plugins implementing TPlugin and  decorated with TAttribute.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedPluginFactory/#generatedpluginfactorycreatepluginsfromassembliestpluginienumerableassembly-method","title":"GeneratedPluginFactory.CreatePluginsFromAssemblies&lt;TPlugin&gt;(IEnumerable&lt;Assembly&gt;) Method","text":"<p>Creates instances of plugins of type TPlugin from the provided assemblies.</p> <pre><code>public System.Collections.Generic.IEnumerable&lt;TPlugin&gt; CreatePluginsFromAssemblies&lt;TPlugin&gt;(System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt; assemblies)\n    where TPlugin : class;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedPluginFactory/#type-parameters_3","title":"Type parameters","text":"<p><code>TPlugin</code></p> <p>The plugin interface or base type to search for.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedPluginFactory/#parameters_2","title":"Parameters","text":"<p><code>assemblies</code> System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt;</p> <p>A collection of assemblies to scan for plugin types.</p> <p>Implements CreatePluginsFromAssemblies&lt;TPlugin&gt;(IEnumerable&lt;Assembly&gt;)</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedPluginFactory/#returns_3","title":"Returns","text":"<p>System.Collections.Generic.IEnumerable&lt;TPlugin&gt; An enumerable of instantiated plugins implementing TPlugin.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedPluginFactory/#generatedpluginfactorycreatepluginswithattributetattribute-method","title":"GeneratedPluginFactory.CreatePluginsWithAttribute&lt;TAttribute&gt;() Method","text":"<p>Creates instances of plugins that are decorated with the specified attribute.</p> <pre><code>public System.Collections.Generic.IEnumerable&lt;object&gt; CreatePluginsWithAttribute&lt;TAttribute&gt;()\n    where TAttribute : System.Attribute;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedPluginFactory/#type-parameters_4","title":"Type parameters","text":"<p><code>TAttribute</code></p> <p>The attribute type to search for in the type hierarchy.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedPluginFactory/#returns_4","title":"Returns","text":"<p>System.Collections.Generic.IEnumerable&lt;System.Object&gt; An enumerable of instantiated plugins decorated with TAttribute.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedPluginFactory/#remarks_3","title":"Remarks","text":"<p>Plugins are returned in order by their NexusLabs.Needlr.Generators.PluginTypeInfo.Order value (lower first), then alphabetically by fully qualified type name for deterministic execution order.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedPluginFactory/#generatedpluginfactorycreatepluginswithattributefromassembliestattributeienumerableassembly-method","title":"GeneratedPluginFactory.CreatePluginsWithAttributeFromAssemblies&lt;TAttribute&gt;(IEnumerable&lt;Assembly&gt;) Method","text":"<p>Creates instances of plugins from the provided assemblies that are decorated with the specified attribute.</p> <pre><code>public System.Collections.Generic.IEnumerable&lt;object&gt; CreatePluginsWithAttributeFromAssemblies&lt;TAttribute&gt;(System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt; assemblies)\n    where TAttribute : System.Attribute;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedPluginFactory/#type-parameters_5","title":"Type parameters","text":"<p><code>TAttribute</code></p> <p>The attribute type to search for in the type hierarchy.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedPluginFactory/#parameters_3","title":"Parameters","text":"<p><code>assemblies</code> System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt;</p> <p>A collection of assemblies to scan for plugin types.</p> <p>Implements CreatePluginsWithAttributeFromAssemblies&lt;TAttribute&gt;(IEnumerable&lt;Assembly&gt;)</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedPluginFactory/#returns_5","title":"Returns","text":"<p>System.Collections.Generic.IEnumerable&lt;System.Object&gt; An enumerable of instantiated plugins decorated with TAttribute.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedServiceProviderBuilder/","title":"GeneratedServiceProviderBuilder","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedServiceProviderBuilder/#nexuslabsneedlrinjectionsourcegen","title":"NexusLabs.Needlr.Injection.SourceGen","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedServiceProviderBuilder/#nexuslabsneedlrinjectionsourcegen_1","title":"NexusLabs.Needlr.Injection.SourceGen","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedServiceProviderBuilder/#generatedserviceproviderbuilder-class","title":"GeneratedServiceProviderBuilder Class","text":"<p>Builds and configures an Microsoft.Extensions.DependencyInjection.IServiceCollection using source-generated plugin discovery.</p> <pre><code>public sealed class GeneratedServiceProviderBuilder : NexusLabs.Needlr.Injection.IServiceProviderBuilder\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 GeneratedServiceProviderBuilder</p> <p>Implements NexusLabs.Needlr.Injection.IServiceProviderBuilder</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedServiceProviderBuilder/#remarks","title":"Remarks","text":"<p>This builder uses GeneratedPluginFactory for plugin discovery and is AOT compatible.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedServiceProviderBuilder/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedServiceProviderBuilder/#generatedserviceproviderbuilderbuildiconfiguration-method","title":"GeneratedServiceProviderBuilder.Build(IConfiguration) Method","text":"<p>Builds a new System.IServiceProvider using the discovered assemblies and a custom registration callback.</p> <pre><code>public System.IServiceProvider Build(Microsoft.Extensions.Configuration.IConfiguration config);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedServiceProviderBuilder/#parameters","title":"Parameters","text":"<p><code>config</code> Microsoft.Extensions.Configuration.IConfiguration</p> <p>The configuration to use for settings.</p> <p>Implements Build(IConfiguration)</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedServiceProviderBuilder/#returns","title":"Returns","text":"<p>System.IServiceProvider The built System.IServiceProvider.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedServiceProviderBuilder/#generatedserviceproviderbuilderbuildiservicecollection-iconfiguration-method","title":"GeneratedServiceProviderBuilder.Build(IServiceCollection, IConfiguration) Method","text":"<p>Builds a new System.IServiceProvider using the discovered assemblies and a custom registration callback.</p> <pre><code>public System.IServiceProvider Build(Microsoft.Extensions.DependencyInjection.IServiceCollection services, Microsoft.Extensions.Configuration.IConfiguration config);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedServiceProviderBuilder/#parameters_1","title":"Parameters","text":"<p><code>services</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service collection to configure.</p> <p></p> <p><code>config</code> Microsoft.Extensions.Configuration.IConfiguration</p> <p>The configuration to use for settings.</p> <p>Implements Build(IServiceCollection, IConfiguration)</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedServiceProviderBuilder/#returns_1","title":"Returns","text":"<p>System.IServiceProvider The built System.IServiceProvider.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedServiceProviderBuilder/#generatedserviceproviderbuilderbuildiservicecollection-iconfiguration-ireadonlylistactioniservicecollection-method","title":"GeneratedServiceProviderBuilder.Build(IServiceCollection, IConfiguration, IReadOnlyList&lt;Action&lt;IServiceCollection&gt;&gt;) Method","text":"<p>Builds a new System.IServiceProvider using the provided Microsoft.Extensions.DependencyInjection.IServiceCollection and a custom registration callback.</p> <pre><code>public System.IServiceProvider Build(Microsoft.Extensions.DependencyInjection.IServiceCollection services, Microsoft.Extensions.Configuration.IConfiguration config, System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; postPluginRegistrationCallbacks);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedServiceProviderBuilder/#parameters_2","title":"Parameters","text":"<p><code>services</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service collection to configure.</p> <p></p> <p><code>config</code> Microsoft.Extensions.Configuration.IConfiguration</p> <p>The configuration to use for settings.</p> <p></p> <p><code>postPluginRegistrationCallbacks</code> System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p>The set of callbacks for additional registration logic</p> <p>Implements Build(IServiceCollection, IConfiguration, IReadOnlyList&lt;Action&lt;IServiceCollection&gt;&gt;)</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedServiceProviderBuilder/#returns_2","title":"Returns","text":"<p>System.IServiceProvider The built System.IServiceProvider.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedServiceProviderBuilder/#generatedserviceproviderbuilderbuildiservicecollection-iconfiguration-ireadonlylistactioniservicecollection-ireadonlylistactioniservicecollection-method","title":"GeneratedServiceProviderBuilder.Build(IServiceCollection, IConfiguration, IReadOnlyList&lt;Action&lt;IServiceCollection&gt;&gt;, IReadOnlyList&lt;Action&lt;IServiceCollection&gt;&gt;) Method","text":"<p>Builds a new System.IServiceProvider with both pre and post registration callbacks.</p> <pre><code>public System.IServiceProvider Build(Microsoft.Extensions.DependencyInjection.IServiceCollection services, Microsoft.Extensions.Configuration.IConfiguration config, System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; preRegistrationCallbacks, System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt; postPluginRegistrationCallbacks);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedServiceProviderBuilder/#parameters_3","title":"Parameters","text":"<p><code>services</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service collection to configure.</p> <p></p> <p><code>config</code> Microsoft.Extensions.Configuration.IConfiguration</p> <p>The configuration to use for settings.</p> <p></p> <p><code>preRegistrationCallbacks</code> System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p>Callbacks executed before auto-discovery registration (e.g., for open generics).</p> <p></p> <p><code>postPluginRegistrationCallbacks</code> System.Collections.Generic.IReadOnlyList&lt;System.Action&lt;Microsoft.Extensions.DependencyInjection.IServiceCollection&gt;&gt;</p> <p>Callbacks executed after plugin registration.</p> <p>Implements Build(IServiceCollection, IConfiguration, IReadOnlyList&lt;Action&lt;IServiceCollection&gt;&gt;, IReadOnlyList&lt;Action&lt;IServiceCollection&gt;&gt;)</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedServiceProviderBuilder/#returns_3","title":"Returns","text":"<p>System.IServiceProvider The built System.IServiceProvider.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedServiceProviderBuilder/#generatedserviceproviderbuilderconfigurepostbuildservicecollectionpluginsiserviceprovider-iconfiguration-method","title":"GeneratedServiceProviderBuilder.ConfigurePostBuildServiceCollectionPlugins(IServiceProvider, IConfiguration) Method","text":"<p>Configures plugins that require post-build service collection configuration using the built service provider.</p> <pre><code>public void ConfigurePostBuildServiceCollectionPlugins(System.IServiceProvider provider, Microsoft.Extensions.Configuration.IConfiguration config);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedServiceProviderBuilder/#parameters_4","title":"Parameters","text":"<p><code>provider</code> System.IServiceProvider</p> <p>The built service provider to use for plugin configuration.</p> <p></p> <p><code>config</code> Microsoft.Extensions.Configuration.IConfiguration</p> <p>The configuration to use for settings.</p> <p>Implements ConfigurePostBuildServiceCollectionPlugins(IServiceProvider, IConfiguration)</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedServiceProviderBuilder/#generatedserviceproviderbuildergetcandidateassemblies-method","title":"GeneratedServiceProviderBuilder.GetCandidateAssemblies() Method","text":"<p>Gets the list of candidate assemblies that will be scanned for service registrations and plugins.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt; GetCandidateAssemblies();\n</code></pre> <p>Implements GetCandidateAssemblies()</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedServiceProviderBuilder/#returns_4","title":"Returns","text":"<p>System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt; A read-only list of assemblies to be processed for dependency injection.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedTypeFilterer/","title":"GeneratedTypeFilterer","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedTypeFilterer/#nexuslabsneedlrinjectionsourcegen","title":"NexusLabs.Needlr.Injection.SourceGen","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedTypeFilterer/#nexuslabsneedlrinjectionsourcegentypefilterers","title":"NexusLabs.Needlr.Injection.SourceGen.TypeFilterers","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedTypeFilterer/#generatedtypefilterer-class","title":"GeneratedTypeFilterer Class","text":"<p>A type filterer that uses compile-time generated lifetime information instead of runtime reflection for constructor analysis.</p> <pre><code>public sealed class GeneratedTypeFilterer : NexusLabs.Needlr.Injection.ITypeFilterer\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 GeneratedTypeFilterer</p> <p>Implements NexusLabs.Needlr.Injection.ITypeFilterer</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedTypeFilterer/#example","title":"Example","text":"<pre><code>// Zero-reflection configuration:\nvar syringe = new Syringe()\n    .UsingGeneratedTypeRegistrar(TypeRegistry.GetInjectableTypes)\n    .UsingGeneratedTypeFilterer()\n    .UsingGeneratedPluginFactory(TypeRegistry.GetPluginTypes);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedTypeFilterer/#remarks","title":"Remarks","text":"<p>When using the generated type registrar with pre-computed lifetimes, this filterer is effectively a no-op since all lifetime decisions are made at compile time. It exists for API compatibility and as a safety fallback that returns false for all checks.</p> <p>For zero-reflection scenarios, use this filterer together with GeneratedTypeRegistrar and explicitly provide the type provider function.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedTypeFilterer/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedTypeFilterer/#generatedtypefilterer-constructor","title":"GeneratedTypeFilterer() Constructor","text":"<p>Initializes a new instance that returns false for all type checks.</p> <pre><code>public GeneratedTypeFilterer();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedTypeFilterer/#remarks_1","title":"Remarks","text":"<p>Use this when all lifetime information is pre-computed by the source generator. The GeneratedTypeRegistrar will use pre-computed lifetimes directly and will not need to call this filterer.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedTypeFilterer/#generatedtypefiltererfuncireadonlylistinjectabletypeinfo-constructor","title":"GeneratedTypeFilterer(Func&lt;IReadOnlyList&lt;InjectableTypeInfo&gt;&gt;) Constructor","text":"<p>Initializes a new instance with pre-computed lifetime information.</p> <pre><code>public GeneratedTypeFilterer(System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.InjectableTypeInfo&gt;&gt; typeProvider);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedTypeFilterer/#parameters","title":"Parameters","text":"<p><code>typeProvider</code> System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.InjectableTypeInfo&gt;&gt;</p> <p>A function that returns the injectable types with pre-computed lifetimes.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedTypeFilterer/#remarks_2","title":"Remarks","text":"<p>This constructor builds a lookup table from the provided type information, enabling reflection-free lifetime checks.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedTypeRegistrar/","title":"GeneratedTypeRegistrar","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedTypeRegistrar/#nexuslabsneedlrinjectionsourcegen","title":"NexusLabs.Needlr.Injection.SourceGen","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedTypeRegistrar/#nexuslabsneedlrinjectionsourcegentyperegistrars","title":"NexusLabs.Needlr.Injection.SourceGen.TypeRegistrars","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedTypeRegistrar/#generatedtyperegistrar-class","title":"GeneratedTypeRegistrar Class","text":"<p>A type registrar that uses compile-time generated type registry instead of runtime reflection for type discovery.</p> <pre><code>public sealed class GeneratedTypeRegistrar : NexusLabs.Needlr.Injection.ITypeRegistrar\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 GeneratedTypeRegistrar</p> <p>Implements NexusLabs.Needlr.Injection.ITypeRegistrar</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedTypeRegistrar/#example","title":"Example","text":"<pre><code>// In your assembly (typically Program.cs or a dedicated file):\n[assembly: GenerateTypeRegistry(IncludeNamespacePrefixes = new[] { \"MyCompany\", \"NexusLabs\" })]\n\n// When building the service provider:\nvar serviceProvider = new Syringe()\n    .UsingGeneratedTypeRegistrar()\n    .BuildServiceProvider(config);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedTypeRegistrar/#remarks","title":"Remarks","text":"<p>This registrar is designed to work with the source generator from <code>NexusLabs.Needlr.Generators</code>. To use it: 1. Add the <code>NexusLabs.Needlr.Generators</code> package to your project 2. Add <code>[assembly: GenerateTypeRegistry(...)]</code> attribute 3. Use <code>.UsingGeneratedTypeRegistrar()</code> when building the service provider</p> <p>The assemblies parameter is ignored when a type provider is supplied, as all type discovery happens at compile time.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedTypeRegistrar/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedTypeRegistrar/#generatedtyperegistrar-constructor","title":"GeneratedTypeRegistrar() Constructor","text":"<p>Initializes a new instance using the default generated TypeRegistry.</p> <pre><code>public GeneratedTypeRegistrar();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedTypeRegistrar/#remarks_1","title":"Remarks","text":"<p>This constructor uses reflection to locate the generated TypeRegistry class. The generated class must be present in the calling assembly.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedTypeRegistrar/#generatedtyperegistrarfuncireadonlylistinjectabletypeinfo-constructor","title":"GeneratedTypeRegistrar(Func&lt;IReadOnlyList&lt;InjectableTypeInfo&gt;&gt;) Constructor","text":"<p>Initializes a new instance with a custom type provider.</p> <pre><code>public GeneratedTypeRegistrar(System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.InjectableTypeInfo&gt;&gt;? typeProvider);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedTypeRegistrar/#parameters","title":"Parameters","text":"<p><code>typeProvider</code> System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.InjectableTypeInfo&gt;&gt;</p> <p>A function that returns the injectable types. If null, the registrar will attempt to locate the generated TypeRegistry at runtime.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedTypeRegistrar/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedTypeRegistrar/#generatedtyperegistrarregistertypesfromassembliesiservicecollection-itypefilterer-ireadonlylistassembly-method","title":"GeneratedTypeRegistrar.RegisterTypesFromAssemblies(IServiceCollection, ITypeFilterer, IReadOnlyList&lt;Assembly&gt;) Method","text":"<p>Registers types from the specified assemblies into the service collection.</p> <pre><code>public void RegisterTypesFromAssemblies(Microsoft.Extensions.DependencyInjection.IServiceCollection services, NexusLabs.Needlr.Injection.ITypeFilterer typeFilterer, System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt; assemblies);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/GeneratedTypeRegistrar/#parameters_1","title":"Parameters","text":"<p><code>services</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service collection to register types into.</p> <p></p> <p><code>typeFilterer</code> NexusLabs.Needlr.Injection.ITypeFilterer</p> <p>The type filterer used to determine which types should be registered and their lifetimes.</p> <p></p> <p><code>assemblies</code> System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt;</p> <p>The assemblies to scan for types to register.</p> <p>Implements RegisterTypesFromAssemblies(IServiceCollection, ITypeFilterer, IReadOnlyList&lt;Assembly&gt;)</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/NexusLabs.Needlr.Injection.SourceGen.Loaders/","title":"NexusLabs.Needlr.Injection.SourceGen.Loaders","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/NexusLabs.Needlr.Injection.SourceGen.Loaders/#nexuslabsneedlrinjectionsourcegen","title":"NexusLabs.Needlr.Injection.SourceGen","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/NexusLabs.Needlr.Injection.SourceGen.Loaders/#nexuslabsneedlrinjectionsourcegenloaders-namespace","title":"NexusLabs.Needlr.Injection.SourceGen.Loaders Namespace","text":"Classes GeneratedAssemblyProvider An assembly provider that derives assemblies from the generated TypeRegistry."},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/NexusLabs.Needlr.Injection.SourceGen.PluginFactories/","title":"NexusLabs.Needlr.Injection.SourceGen.PluginFactories","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/NexusLabs.Needlr.Injection.SourceGen.PluginFactories/#nexuslabsneedlrinjectionsourcegen","title":"NexusLabs.Needlr.Injection.SourceGen","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/NexusLabs.Needlr.Injection.SourceGen.PluginFactories/#nexuslabsneedlrinjectionsourcegenpluginfactories-namespace","title":"NexusLabs.Needlr.Injection.SourceGen.PluginFactories Namespace","text":"Classes GeneratedPluginFactory A plugin factory that uses compile-time generated type information instead of runtime reflection for plugin discovery and instantiation."},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/NexusLabs.Needlr.Injection.SourceGen.TypeFilterers/","title":"NexusLabs.Needlr.Injection.SourceGen.TypeFilterers","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/NexusLabs.Needlr.Injection.SourceGen.TypeFilterers/#nexuslabsneedlrinjectionsourcegen","title":"NexusLabs.Needlr.Injection.SourceGen","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/NexusLabs.Needlr.Injection.SourceGen.TypeFilterers/#nexuslabsneedlrinjectionsourcegentypefilterers-namespace","title":"NexusLabs.Needlr.Injection.SourceGen.TypeFilterers Namespace","text":"Classes GeneratedTypeFilterer A type filterer that uses compile-time generated lifetime information instead of runtime reflection for constructor analysis."},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/NexusLabs.Needlr.Injection.SourceGen.TypeRegistrars/","title":"NexusLabs.Needlr.Injection.SourceGen.TypeRegistrars","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/NexusLabs.Needlr.Injection.SourceGen.TypeRegistrars/#nexuslabsneedlrinjectionsourcegen","title":"NexusLabs.Needlr.Injection.SourceGen","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/NexusLabs.Needlr.Injection.SourceGen.TypeRegistrars/#nexuslabsneedlrinjectionsourcegentyperegistrars-namespace","title":"NexusLabs.Needlr.Injection.SourceGen.TypeRegistrars Namespace","text":"Classes GeneratedTypeRegistrar A type registrar that uses compile-time generated type registry instead of runtime reflection for type discovery."},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/NexusLabs.Needlr.Injection.SourceGen/","title":"NexusLabs.Needlr.Injection.SourceGen","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/NexusLabs.Needlr.Injection.SourceGen/#nexuslabsneedlrinjectionsourcegen","title":"NexusLabs.Needlr.Injection.SourceGen","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/NexusLabs.Needlr.Injection.SourceGen/#nexuslabsneedlrinjectionsourcegen-namespace","title":"NexusLabs.Needlr.Injection.SourceGen Namespace","text":"Classes GeneratedServiceProviderBuilder Builds and configures an Microsoft.Extensions.DependencyInjection.IServiceCollection using source-generated plugin discovery. SyringeSourceGenExtensions Extension methods for configuring NexusLabs.Needlr.Injection.Syringe with source-generated components."},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/SyringeSourceGenExtensions/","title":"SyringeSourceGenExtensions","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/SyringeSourceGenExtensions/#nexuslabsneedlrinjectionsourcegen","title":"NexusLabs.Needlr.Injection.SourceGen","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/SyringeSourceGenExtensions/#nexuslabsneedlrinjectionsourcegen_1","title":"NexusLabs.Needlr.Injection.SourceGen","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/SyringeSourceGenExtensions/#syringesourcegenextensions-class","title":"SyringeSourceGenExtensions Class","text":"<p>Extension methods for configuring NexusLabs.Needlr.Injection.Syringe with source-generated components.</p> <pre><code>public static class SyringeSourceGenExtensions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 SyringeSourceGenExtensions</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/SyringeSourceGenExtensions/#remarks","title":"Remarks","text":"<p>These extensions enable AOT-compatible, zero-reflection type discovery and registration using compile-time generated type registries.</p> <p>To use these extensions, your assembly must have: - A reference to <code>NexusLabs.Needlr.Generators</code> - The <code>[assembly: GenerateTypeRegistry(...)]</code> attribute</p> <p>For assembly ordering, use <code>SyringeExtensions.OrderAssemblies</code> after calling <code>UsingSourceGen()</code>.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/SyringeSourceGenExtensions/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/SyringeSourceGenExtensions/#syringesourcegenextensionsusinggeneratedassemblyproviderthis-configuredsyringe-funcireadonlylistinjectabletypeinfo-funcireadonlylistplugintypeinfo-method","title":"SyringeSourceGenExtensions.UsingGeneratedAssemblyProvider(this ConfiguredSyringe, Func&lt;IReadOnlyList&lt;InjectableTypeInfo&gt;&gt;, Func&lt;IReadOnlyList&lt;PluginTypeInfo&gt;&gt;) Method","text":"<p>Configures the syringe to use the generated assembly provider.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UsingGeneratedAssemblyProvider(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe, System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.InjectableTypeInfo&gt;&gt; injectableTypeProvider, System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.PluginTypeInfo&gt;&gt; pluginTypeProvider);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/SyringeSourceGenExtensions/#parameters","title":"Parameters","text":"<p><code>syringe</code> NexusLabs.Needlr.Injection.ConfiguredSyringe</p> <p>The configured syringe to update.</p> <p></p> <p><code>injectableTypeProvider</code> System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.InjectableTypeInfo&gt;&gt;</p> <p>A function that returns the injectable types.</p> <p></p> <p><code>pluginTypeProvider</code> System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.PluginTypeInfo&gt;&gt;</p> <p>A function that returns the plugin types.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/SyringeSourceGenExtensions/#returns","title":"Returns","text":"<p>NexusLabs.Needlr.Injection.ConfiguredSyringe A new configured syringe instance.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/SyringeSourceGenExtensions/#syringesourcegenextensionsusinggeneratedcomponentsthis-configuredsyringe-funcireadonlylistinjectabletypeinfo-funcireadonlylistplugintypeinfo-method","title":"SyringeSourceGenExtensions.UsingGeneratedComponents(this ConfiguredSyringe, Func&lt;IReadOnlyList&lt;InjectableTypeInfo&gt;&gt;, Func&lt;IReadOnlyList&lt;PluginTypeInfo&gt;&gt;) Method","text":"<p>Configures the syringe with all generated components for zero-reflection operation.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UsingGeneratedComponents(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe, System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.InjectableTypeInfo&gt;&gt; injectableTypeProvider, System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.PluginTypeInfo&gt;&gt; pluginTypeProvider);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/SyringeSourceGenExtensions/#parameters_1","title":"Parameters","text":"<p><code>syringe</code> NexusLabs.Needlr.Injection.ConfiguredSyringe</p> <p>The configured syringe to update.</p> <p></p> <p><code>injectableTypeProvider</code> System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.InjectableTypeInfo&gt;&gt;</p> <p>A function that returns the injectable types.</p> <p></p> <p><code>pluginTypeProvider</code> System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.PluginTypeInfo&gt;&gt;</p> <p>A function that returns the plugin types.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/SyringeSourceGenExtensions/#returns_1","title":"Returns","text":"<p>NexusLabs.Needlr.Injection.ConfiguredSyringe A configured syringe with all source-generated components.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/SyringeSourceGenExtensions/#syringesourcegenextensionsusinggeneratedcomponentsthis-syringe-funcireadonlylistinjectabletypeinfo-funcireadonlylistplugintypeinfo-method","title":"SyringeSourceGenExtensions.UsingGeneratedComponents(this Syringe, Func&lt;IReadOnlyList&lt;InjectableTypeInfo&gt;&gt;, Func&lt;IReadOnlyList&lt;PluginTypeInfo&gt;&gt;) Method","text":"<p>Configures the syringe with all generated components for zero-reflection operation.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UsingGeneratedComponents(this NexusLabs.Needlr.Injection.Syringe syringe, System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.InjectableTypeInfo&gt;&gt; injectableTypeProvider, System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.PluginTypeInfo&gt;&gt; pluginTypeProvider);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/SyringeSourceGenExtensions/#parameters_2","title":"Parameters","text":"<p><code>syringe</code> NexusLabs.Needlr.Injection.Syringe</p> <p>The base syringe to configure.</p> <p></p> <p><code>injectableTypeProvider</code> System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.InjectableTypeInfo&gt;&gt;</p> <p>A function that returns the injectable types.</p> <p></p> <p><code>pluginTypeProvider</code> System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.PluginTypeInfo&gt;&gt;</p> <p>A function that returns the plugin types.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/SyringeSourceGenExtensions/#returns_2","title":"Returns","text":"<p>NexusLabs.Needlr.Injection.ConfiguredSyringe A configured syringe with all source-generated components.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/SyringeSourceGenExtensions/#remarks_1","title":"Remarks","text":"<p>This is a strategy method that creates a ConfiguredSyringe. Use this when you have explicit type providers (e.g., from generated code) rather than using the bootstrap.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/SyringeSourceGenExtensions/#syringesourcegenextensionsusinggeneratedpluginfactorythis-configuredsyringe-funcireadonlylistplugintypeinfo-method","title":"SyringeSourceGenExtensions.UsingGeneratedPluginFactory(this ConfiguredSyringe, Func&lt;IReadOnlyList&lt;PluginTypeInfo&gt;&gt;) Method","text":"<p>Configures the syringe to use the generated plugin factory.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UsingGeneratedPluginFactory(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe, System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.PluginTypeInfo&gt;&gt; pluginProvider);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/SyringeSourceGenExtensions/#parameters_3","title":"Parameters","text":"<p><code>syringe</code> NexusLabs.Needlr.Injection.ConfiguredSyringe</p> <p>The configured syringe to update.</p> <p></p> <p><code>pluginProvider</code> System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.PluginTypeInfo&gt;&gt;</p> <p>A function that returns the plugin types.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/SyringeSourceGenExtensions/#returns_3","title":"Returns","text":"<p>NexusLabs.Needlr.Injection.ConfiguredSyringe A new configured syringe instance.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/SyringeSourceGenExtensions/#syringesourcegenextensionsusinggeneratedtypefiltererthis-configuredsyringe-funcireadonlylistinjectabletypeinfo-method","title":"SyringeSourceGenExtensions.UsingGeneratedTypeFilterer(this ConfiguredSyringe, Func&lt;IReadOnlyList&lt;InjectableTypeInfo&gt;&gt;) Method","text":"<p>Configures the syringe to use the generated type filterer.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UsingGeneratedTypeFilterer(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe, System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.InjectableTypeInfo&gt;&gt; typeProvider);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/SyringeSourceGenExtensions/#parameters_4","title":"Parameters","text":"<p><code>syringe</code> NexusLabs.Needlr.Injection.ConfiguredSyringe</p> <p>The configured syringe to update.</p> <p></p> <p><code>typeProvider</code> System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.InjectableTypeInfo&gt;&gt;</p> <p>A function that returns the injectable types.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/SyringeSourceGenExtensions/#returns_4","title":"Returns","text":"<p>NexusLabs.Needlr.Injection.ConfiguredSyringe A new configured syringe instance.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/SyringeSourceGenExtensions/#syringesourcegenextensionsusinggeneratedtyperegistrarthis-configuredsyringe-funcireadonlylistinjectabletypeinfo-method","title":"SyringeSourceGenExtensions.UsingGeneratedTypeRegistrar(this ConfiguredSyringe, Func&lt;IReadOnlyList&lt;InjectableTypeInfo&gt;&gt;) Method","text":"<p>Configures the syringe to use the generated type registrar.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UsingGeneratedTypeRegistrar(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe, System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.InjectableTypeInfo&gt;&gt; typeProvider);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/SyringeSourceGenExtensions/#parameters_5","title":"Parameters","text":"<p><code>syringe</code> NexusLabs.Needlr.Injection.ConfiguredSyringe</p> <p>The configured syringe to update.</p> <p></p> <p><code>typeProvider</code> System.Func&lt;System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.InjectableTypeInfo&gt;&gt;</p> <p>A function that returns the injectable types.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/SyringeSourceGenExtensions/#returns_5","title":"Returns","text":"<p>NexusLabs.Needlr.Injection.ConfiguredSyringe A new configured syringe instance.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/SyringeSourceGenExtensions/#syringesourcegenextensionsusingsourcegenthis-syringe-method","title":"SyringeSourceGenExtensions.UsingSourceGen(this Syringe) Method","text":"<p>Configures the syringe to use source-generated components from the module initializer bootstrap.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UsingSourceGen(this NexusLabs.Needlr.Injection.Syringe syringe);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/SyringeSourceGenExtensions/#parameters_6","title":"Parameters","text":"<p><code>syringe</code> NexusLabs.Needlr.Injection.Syringe</p> <p>The syringe to configure.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/SyringeSourceGenExtensions/#returns_6","title":"Returns","text":"<p>NexusLabs.Needlr.Injection.ConfiguredSyringe A configured syringe ready for further configuration and building.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/SyringeSourceGenExtensions/#exceptions","title":"Exceptions","text":"<p>System.InvalidOperationException Thrown if no source-generated type providers are registered via NeedlrSourceGenBootstrap.</p>"},{"location":"api/dev/NexusLabs.Needlr.Injection.SourceGen/SyringeSourceGenExtensions/#remarks_2","title":"Remarks","text":"<p>This method uses the type providers registered via NexusLabs.Needlr.Generators.NeedlrSourceGenBootstrap. The bootstrap is automatically registered by the generated module initializer when you use <code>[assembly: GenerateTypeRegistry(...)]</code>.</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/","title":"Index","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/#nexuslabsneedlrsemantickernel","title":"NexusLabs.Needlr.SemanticKernel","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/#nexuslabsneedlrsemantickernel-assembly","title":"NexusLabs.Needlr.SemanticKernel Assembly","text":"Namespaces NexusLabs.Needlr.SemanticKernel NexusLabs.Needlr.SemanticKernel.Generated NexusLabs.Needlr.SemanticKernel.PluginScanners"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/GeneratedSemanticKernelPluginScanner/","title":"GeneratedSemanticKernelPluginScanner","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/GeneratedSemanticKernelPluginScanner/#nexuslabsneedlrsemantickernel","title":"NexusLabs.Needlr.SemanticKernel","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/GeneratedSemanticKernelPluginScanner/#nexuslabsneedlrsemantickernelpluginscanners","title":"NexusLabs.Needlr.SemanticKernel.PluginScanners","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/GeneratedSemanticKernelPluginScanner/#generatedsemantickernelpluginscanner-class","title":"GeneratedSemanticKernelPluginScanner Class","text":"<p>Source-generation-friendly SemanticKernel plugin scanner that uses compile-time generated plugin type lists.</p> <pre><code>public sealed class GeneratedSemanticKernelPluginScanner : NexusLabs.Needlr.SemanticKernel.ISemanticKernelPluginScanner\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 GeneratedSemanticKernelPluginScanner</p> <p>Implements ISemanticKernelPluginScanner</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/GeneratedSemanticKernelPluginScanner/#remarks","title":"Remarks","text":"<p>When using source generation, the generator emits a  <code>NexusLabs.Needlr.Generated.SemanticKernelPlugins</code> class containing: - <code>StaticPluginTypes</code>: Types with static [KernelFunction] methods - <code>InstancePluginTypes</code>: Types with instance [KernelFunction] methods - <code>AllPluginTypes</code>: Combined list of all plugin types</p> <p>This scanner provides a reflection-free way to access these generated lists. For AOT/trimmed applications, use this scanner instead of  NexusLabs.Needlr.SemanticKernel.PluginScanners.AssemblySemanticKernelPluginScanner or  NexusLabs.Needlr.SemanticKernel.PluginScanners.ServiceProviderSemanticKernelPluginScanner which use reflection.</p> <p>Usage:</p> <pre><code>// The generated types are available in NexusLabs.Needlr.Generated namespace\nvar pluginTypes = NexusLabs.Needlr.Generated.SemanticKernelPlugins.AllPluginTypes;\n\n// Or use this scanner wrapper\nvar scanner = new GeneratedSemanticKernelPluginScanner();\nvar types = scanner.ScanForPluginTypes();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/GeneratedSemanticKernelPluginScanner/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/GeneratedSemanticKernelPluginScanner/#generatedsemantickernelpluginscannerireadonlylisttype-constructor","title":"GeneratedSemanticKernelPluginScanner(IReadOnlyList&lt;Type&gt;) Constructor","text":"<p>Creates a new instance using the specified plugin types.</p> <pre><code>public GeneratedSemanticKernelPluginScanner(System.Collections.Generic.IReadOnlyList&lt;System.Type&gt; pluginTypes);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/GeneratedSemanticKernelPluginScanner/#parameters","title":"Parameters","text":"<p><code>pluginTypes</code> System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;</p> <p>The pre-discovered plugin types (typically from generated code).</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/IKernelBuilderPlugin/","title":"IKernelBuilderPlugin","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/IKernelBuilderPlugin/#nexuslabsneedlrsemantickernel","title":"NexusLabs.Needlr.SemanticKernel","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/IKernelBuilderPlugin/#nexuslabsneedlrsemantickernel_1","title":"NexusLabs.Needlr.SemanticKernel","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/IKernelBuilderPlugin/#ikernelbuilderplugin-interface","title":"IKernelBuilderPlugin Interface","text":"<p>Defines a plugin that configures the Semantic Kernel builder before the kernel is built. Implement this interface to add AI services, configure logging, or modify the kernel builder.</p> <pre><code>public interface IKernelBuilderPlugin\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/IKernelFactory/","title":"IKernelFactory","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/IKernelFactory/#nexuslabsneedlrsemantickernel","title":"NexusLabs.Needlr.SemanticKernel","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/IKernelFactory/#nexuslabsneedlrsemantickernel_1","title":"NexusLabs.Needlr.SemanticKernel","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/IKernelFactory/#ikernelfactory-interface","title":"IKernelFactory Interface","text":"<p>Factory interface for creating configured Microsoft.SemanticKernel.Kernel instances with Needlr's auto-discovery capabilities.</p> <pre><code>public interface IKernelFactory\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/ISemanticKernelPluginScanner/","title":"ISemanticKernelPluginScanner","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/ISemanticKernelPluginScanner/#nexuslabsneedlrsemantickernel","title":"NexusLabs.Needlr.SemanticKernel","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/ISemanticKernelPluginScanner/#nexuslabsneedlrsemantickernel_1","title":"NexusLabs.Needlr.SemanticKernel","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/ISemanticKernelPluginScanner/#isemantickernelpluginscanner-interface","title":"ISemanticKernelPluginScanner Interface","text":"<p>Defines a scanner that discovers Semantic Kernel plugin types for registration. Implement this interface to customize how plugins are discovered.</p> <pre><code>public interface ISemanticKernelPluginScanner\n</code></pre> <p>Derived \u21b3 GeneratedSemanticKernelPluginScanner</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/KernelBuilderPluginOptions/","title":"KernelBuilderPluginOptions","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/KernelBuilderPluginOptions/#nexuslabsneedlrsemantickernel","title":"NexusLabs.Needlr.SemanticKernel","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/KernelBuilderPluginOptions/#nexuslabsneedlrsemantickernel_1","title":"NexusLabs.Needlr.SemanticKernel","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/KernelBuilderPluginOptions/#kernelbuilderpluginoptions-class","title":"KernelBuilderPluginOptions Class","text":"<p>Options provided to IKernelBuilderPlugin implementations during configuration.</p> <pre><code>public sealed record KernelBuilderPluginOptions : System.IEquatable&lt;NexusLabs.Needlr.SemanticKernel.KernelBuilderPluginOptions&gt;\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 KernelBuilderPluginOptions</p> <p>Implements System.IEquatable&lt;KernelBuilderPluginOptions&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/KernelBuilderPluginOptions/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/KernelBuilderPluginOptions/#kernelbuilderpluginoptionsikernelbuilder-constructor","title":"KernelBuilderPluginOptions(IKernelBuilder) Constructor","text":"<p>Options provided to IKernelBuilderPlugin implementations during configuration.</p> <pre><code>public KernelBuilderPluginOptions(Microsoft.SemanticKernel.IKernelBuilder KernelBuilder);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/KernelBuilderPluginOptions/#parameters","title":"Parameters","text":"<p><code>KernelBuilder</code> Microsoft.SemanticKernel.IKernelBuilder</p> <p>The kernel builder being configured.</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/KernelBuilderPluginOptions/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/KernelBuilderPluginOptions/#kernelbuilderpluginoptionskernelbuilder-property","title":"KernelBuilderPluginOptions.KernelBuilder Property","text":"<p>The kernel builder being configured.</p> <pre><code>public Microsoft.SemanticKernel.IKernelBuilder KernelBuilder { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/KernelBuilderPluginOptions/#property-value","title":"Property Value","text":"<p>Microsoft.SemanticKernel.IKernelBuilder</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/KernelFactoryOptions/","title":"KernelFactoryOptions","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/KernelFactoryOptions/#nexuslabsneedlrsemantickernel","title":"NexusLabs.Needlr.SemanticKernel","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/KernelFactoryOptions/#nexuslabsneedlrsemantickernel_1","title":"NexusLabs.Needlr.SemanticKernel","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/KernelFactoryOptions/#kernelfactoryoptions-class","title":"KernelFactoryOptions Class","text":"<p>Options provided to kernel factory configuration callbacks.</p> <pre><code>public sealed record KernelFactoryOptions : System.IEquatable&lt;NexusLabs.Needlr.SemanticKernel.KernelFactoryOptions&gt;\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 KernelFactoryOptions</p> <p>Implements System.IEquatable&lt;KernelFactoryOptions&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/KernelFactoryOptions/#constructors","title":"Constructors","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/KernelFactoryOptions/#kernelfactoryoptionsiserviceprovider-ikernelbuilder-constructor","title":"KernelFactoryOptions(IServiceProvider, IKernelBuilder) Constructor","text":"<p>Options provided to kernel factory configuration callbacks.</p> <pre><code>public KernelFactoryOptions(System.IServiceProvider ServiceProvider, Microsoft.SemanticKernel.IKernelBuilder KernelBuilder);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/KernelFactoryOptions/#parameters","title":"Parameters","text":"<p><code>ServiceProvider</code> System.IServiceProvider</p> <p>The service provider for resolving dependencies.</p> <p></p> <p><code>KernelBuilder</code> Microsoft.SemanticKernel.IKernelBuilder</p> <p>The kernel builder being configured.</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/KernelFactoryOptions/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/KernelFactoryOptions/#kernelfactoryoptionskernelbuilder-property","title":"KernelFactoryOptions.KernelBuilder Property","text":"<p>The kernel builder being configured.</p> <pre><code>public Microsoft.SemanticKernel.IKernelBuilder KernelBuilder { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/KernelFactoryOptions/#property-value","title":"Property Value","text":"<p>Microsoft.SemanticKernel.IKernelBuilder</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/KernelFactoryOptions/#kernelfactoryoptionsserviceprovider-property","title":"KernelFactoryOptions.ServiceProvider Property","text":"<p>The service provider for resolving dependencies.</p> <pre><code>public System.IServiceProvider ServiceProvider { get; init; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/KernelFactoryOptions/#property-value_1","title":"Property Value","text":"<p>System.IServiceProvider</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/NexusLabs.Needlr.SemanticKernel.Generated/","title":"NexusLabs.Needlr.SemanticKernel.Generated","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/NexusLabs.Needlr.SemanticKernel.Generated/#nexuslabsneedlrsemantickernel","title":"NexusLabs.Needlr.SemanticKernel","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/NexusLabs.Needlr.SemanticKernel.Generated/#nexuslabsneedlrsemantickernelgenerated-namespace","title":"NexusLabs.Needlr.SemanticKernel.Generated Namespace","text":"Classes ServiceCatalog Compile-time service catalog containing all discovered registrations. TypeRegistry Compile-time generated registry of injectable types and plugins. This eliminates the need for runtime reflection-based type discovery."},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/NexusLabs.Needlr.SemanticKernel.PluginScanners/","title":"NexusLabs.Needlr.SemanticKernel.PluginScanners","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/NexusLabs.Needlr.SemanticKernel.PluginScanners/#nexuslabsneedlrsemantickernel","title":"NexusLabs.Needlr.SemanticKernel","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/NexusLabs.Needlr.SemanticKernel.PluginScanners/#nexuslabsneedlrsemantickernelpluginscanners-namespace","title":"NexusLabs.Needlr.SemanticKernel.PluginScanners Namespace","text":"Classes GeneratedSemanticKernelPluginScanner Source-generation-friendly SemanticKernel plugin scanner that uses compile-time generated plugin type lists."},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/NexusLabs.Needlr.SemanticKernel/","title":"NexusLabs.Needlr.SemanticKernel","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/NexusLabs.Needlr.SemanticKernel/#nexuslabsneedlrsemantickernel","title":"NexusLabs.Needlr.SemanticKernel","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/NexusLabs.Needlr.SemanticKernel/#nexuslabsneedlrsemantickernel-namespace","title":"NexusLabs.Needlr.SemanticKernel Namespace","text":"Classes KernelBuilderPluginOptions Options provided to IKernelBuilderPlugin implementations during configuration. KernelFactoryOptions Options provided to kernel factory configuration callbacks. SemanticKernelSyringe Fluent builder for configuring Semantic Kernel with Needlr plugin discovery. SemanticKernelSyringeExtensions Extension methods for SemanticKernelSyringe providing fluent configuration of Semantic Kernel integration. SyringeExtensionsForSemanticKernel Extension methods for NexusLabs.Needlr.Injection.ConfiguredSyringe that enable registering Semantic Kernel infrastructure (namely IKernelFactory) as part of the Needlr build pipeline. Interfaces IKernelBuilderPlugin Defines a plugin that configures the Semantic Kernel builder before the kernel is built. Implement this interface to add AI services, configure logging, or modify the kernel builder. IKernelFactory Factory interface for creating configured Microsoft.SemanticKernel.Kernel instances with Needlr's auto-discovery capabilities. ISemanticKernelPluginScanner Defines a scanner that discovers Semantic Kernel plugin types for registration. Implement this interface to customize how plugins are discovered."},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringe/","title":"SemanticKernelSyringe","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringe/#nexuslabsneedlrsemantickernel","title":"NexusLabs.Needlr.SemanticKernel","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringe/#nexuslabsneedlrsemantickernel_1","title":"NexusLabs.Needlr.SemanticKernel","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringe/#semantickernelsyringe-class","title":"SemanticKernelSyringe Class","text":"<p>Fluent builder for configuring Semantic Kernel with Needlr plugin discovery.</p> <pre><code>public sealed record SemanticKernelSyringe : System.IEquatable&lt;NexusLabs.Needlr.SemanticKernel.SemanticKernelSyringe&gt;\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 SemanticKernelSyringe</p> <p>Implements System.IEquatable&lt;SemanticKernelSyringe&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringe/#example","title":"Example","text":"<pre><code>// Obtained from SyringeExtensionsForSemanticKernel.UsingSemanticKernel()\nSemanticKernelSyringe syringe = app.Services.UsingSemanticKernel();\n\n// Register plugins and build the kernel factory\nIKernelFactory kernelFactory = syringe\n    .AddSemanticKernelPluginsFromGenerated(GeneratedSemanticKernelPlugins.AllPluginTypes)\n    .BuildKernelFactory();\n\n// Create a Kernel instance from the factory\nKernel kernel = kernelFactory.CreateKernel();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringe/#remarks","title":"Remarks","text":"<p>This class uses reflection to discover methods with Microsoft.SemanticKernel.KernelFunctionAttribute. For AOT/trimmed applications, consider registering kernel functions explicitly.</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/","title":"SemanticKernelSyringeExtensions","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/#nexuslabsneedlrsemantickernel","title":"NexusLabs.Needlr.SemanticKernel","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/#nexuslabsneedlrsemantickernel_1","title":"NexusLabs.Needlr.SemanticKernel","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/#semantickernelsyringeextensions-class","title":"SemanticKernelSyringeExtensions Class","text":"<p>Extension methods for SemanticKernelSyringe providing fluent configuration of Semantic Kernel integration.</p> <pre><code>public static class SemanticKernelSyringeExtensions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 SemanticKernelSyringeExtensions</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/#semantickernelsyringeextensionsaddsemantickernelplugintthis-semantickernelsyringe-method","title":"SemanticKernelSyringeExtensions.AddSemanticKernelPlugin&lt;T&gt;(this SemanticKernelSyringe) Method","text":"<p>Adds a single SemanticKernel plugin type to the syringe.</p> <pre><code>public static NexusLabs.Needlr.SemanticKernel.SemanticKernelSyringe AddSemanticKernelPlugin&lt;T&gt;(this NexusLabs.Needlr.SemanticKernel.SemanticKernelSyringe syringe);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/#type-parameters","title":"Type parameters","text":"<p><code>T</code></p> <p>The plugin type that contains Microsoft.SemanticKernel.KernelFunctionAttribute-marked methods.</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/#parameters","title":"Parameters","text":"<p><code>syringe</code> SemanticKernelSyringe</p> <p>The Semantic Kernel syringe to configure.</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/#returns","title":"Returns","text":"<p>SemanticKernelSyringe The configured syringe.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/#semantickernelsyringeextensionsaddsemantickernelpluginsthis-semantickernelsyringe-isemantickernelpluginscanner-bool-bool-method","title":"SemanticKernelSyringeExtensions.AddSemanticKernelPlugins(this SemanticKernelSyringe, ISemanticKernelPluginScanner, bool, bool) Method","text":"<p>Adds SemanticKernel plugins by scanning with a custom ISemanticKernelPluginScanner.</p> <pre><code>public static NexusLabs.Needlr.SemanticKernel.SemanticKernelSyringe AddSemanticKernelPlugins(this NexusLabs.Needlr.SemanticKernel.SemanticKernelSyringe syringe, NexusLabs.Needlr.SemanticKernel.ISemanticKernelPluginScanner scanner, bool includeInstancePlugins=true, bool includeStaticPlugins=true);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/#parameters_1","title":"Parameters","text":"<p><code>syringe</code> SemanticKernelSyringe</p> <p>The Semantic Kernel syringe to configure.</p> <p></p> <p><code>scanner</code> ISemanticKernelPluginScanner</p> <p>The scanner that produces plugin types.</p> <p></p> <p><code>includeInstancePlugins</code> System.Boolean</p> <p>Whether to include instance-based plugins.</p> <p></p> <p><code>includeStaticPlugins</code> System.Boolean</p> <p>Whether to include static class plugins.</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/#returns_1","title":"Returns","text":"<p>SemanticKernelSyringe The configured syringe.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/#semantickernelsyringeextensionsaddsemantickernelpluginsthis-semantickernelsyringe-ireadonlylisttype-bool-bool-method","title":"SemanticKernelSyringeExtensions.AddSemanticKernelPlugins(this SemanticKernelSyringe, IReadOnlyList&lt;Type&gt;, bool, bool) Method","text":"<p>Adds SemanticKernel plugins from an explicit list of plugin types.</p> <pre><code>public static NexusLabs.Needlr.SemanticKernel.SemanticKernelSyringe AddSemanticKernelPlugins(this NexusLabs.Needlr.SemanticKernel.SemanticKernelSyringe syringe, System.Collections.Generic.IReadOnlyList&lt;System.Type&gt; pluginTypes, bool includeInstancePlugins=true, bool includeStaticPlugins=true);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/#parameters_2","title":"Parameters","text":"<p><code>syringe</code> SemanticKernelSyringe</p> <p>The Semantic Kernel syringe to configure.</p> <p></p> <p><code>pluginTypes</code> System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;</p> <p>The plugin types to register.</p> <p></p> <p><code>includeInstancePlugins</code> System.Boolean</p> <p>Whether to include instance-based plugins.</p> <p></p> <p><code>includeStaticPlugins</code> System.Boolean</p> <p>Whether to include static class plugins.</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/#returns_2","title":"Returns","text":"<p>SemanticKernelSyringe The configured syringe.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/#semantickernelsyringeextensionsaddsemantickernelpluginsfromassembliesthis-semantickernelsyringe-bool-bool-method","title":"SemanticKernelSyringeExtensions.AddSemanticKernelPluginsFromAssemblies(this SemanticKernelSyringe, bool, bool) Method","text":"<p>Adds SemanticKernel plugins discovered from all registered assemblies in the service provider.</p> <pre><code>public static NexusLabs.Needlr.SemanticKernel.SemanticKernelSyringe AddSemanticKernelPluginsFromAssemblies(this NexusLabs.Needlr.SemanticKernel.SemanticKernelSyringe syringe, bool includeInstancePlugins=true, bool includeStaticPlugins=true);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/#parameters_3","title":"Parameters","text":"<p><code>syringe</code> SemanticKernelSyringe</p> <p>The Semantic Kernel syringe to configure.</p> <p></p> <p><code>includeInstancePlugins</code> System.Boolean</p> <p>Whether to include instance-based plugins.</p> <p></p> <p><code>includeStaticPlugins</code> System.Boolean</p> <p>Whether to include static class plugins.</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/#returns_3","title":"Returns","text":"<p>SemanticKernelSyringe The configured syringe.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/#semantickernelsyringeextensionsaddsemantickernelpluginsfromassembliesthis-semantickernelsyringe-ireadonlylistassembly-bool-bool-method","title":"SemanticKernelSyringeExtensions.AddSemanticKernelPluginsFromAssemblies(this SemanticKernelSyringe, IReadOnlyList&lt;Assembly&gt;, bool, bool) Method","text":"<p>Adds SemanticKernel plugins discovered from a specific list of assemblies.</p> <pre><code>public static NexusLabs.Needlr.SemanticKernel.SemanticKernelSyringe AddSemanticKernelPluginsFromAssemblies(this NexusLabs.Needlr.SemanticKernel.SemanticKernelSyringe syringe, System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt; asssemblies, bool includeInstancePlugins=true, bool includeStaticPlugins=true);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/#parameters_4","title":"Parameters","text":"<p><code>syringe</code> SemanticKernelSyringe</p> <p>The Semantic Kernel syringe to configure.</p> <p></p> <p><code>asssemblies</code> System.Collections.Generic.IReadOnlyList&lt;System.Reflection.Assembly&gt;</p> <p>The assemblies to scan for plugin types.</p> <p></p> <p><code>includeInstancePlugins</code> System.Boolean</p> <p>Whether to include instance-based plugins.</p> <p></p> <p><code>includeStaticPlugins</code> System.Boolean</p> <p>Whether to include static class plugins.</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/#returns_4","title":"Returns","text":"<p>SemanticKernelSyringe The configured syringe.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/#semantickernelsyringeextensionsaddsemantickernelpluginsfromgeneratedthis-semantickernelsyringe-ireadonlylisttype-method","title":"SemanticKernelSyringeExtensions.AddSemanticKernelPluginsFromGenerated(this SemanticKernelSyringe, IReadOnlyList&lt;Type&gt;) Method","text":"<p>Adds SemanticKernel plugins from a pre-discovered list of types. This is the recommended approach for AOT/trimmed applications.</p> <pre><code>public static NexusLabs.Needlr.SemanticKernel.SemanticKernelSyringe AddSemanticKernelPluginsFromGenerated(this NexusLabs.Needlr.SemanticKernel.SemanticKernelSyringe syringe, System.Collections.Generic.IReadOnlyList&lt;System.Type&gt; pluginTypes);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/#parameters_5","title":"Parameters","text":"<p><code>syringe</code> SemanticKernelSyringe</p> <p>The SemanticKernel syringe to configure.</p> <p></p> <p><code>pluginTypes</code> System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;</p> <p>Pre-discovered plugin types, typically from the generated  <code>NexusLabs.Needlr.Generated.SemanticKernelPlugins.AllPluginTypes</code>.</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/#returns_5","title":"Returns","text":"<p>SemanticKernelSyringe The configured syringe.</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/#remarks","title":"Remarks","text":"<p>Example usage with source-generated types:</p> <pre><code>syringe.AddSemanticKernelPluginsFromGenerated(\n    NexusLabs.Needlr.Generated.SemanticKernelPlugins.AllPluginTypes);\n</code></pre> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/#semantickernelsyringeextensionsaddsemantickernelpluginsfromproviderthis-semantickernelsyringe-method","title":"SemanticKernelSyringeExtensions.AddSemanticKernelPluginsFromProvider(this SemanticKernelSyringe) Method","text":"<p>Adds SemanticKernel plugins discovered by scanning all services registered in the service provider.</p> <pre><code>public static NexusLabs.Needlr.SemanticKernel.SemanticKernelSyringe AddSemanticKernelPluginsFromProvider(this NexusLabs.Needlr.SemanticKernel.SemanticKernelSyringe syringe);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/#parameters_6","title":"Parameters","text":"<p><code>syringe</code> SemanticKernelSyringe</p> <p>The Semantic Kernel syringe to configure.</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/#returns_6","title":"Returns","text":"<p>SemanticKernelSyringe The configured syringe.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/#semantickernelsyringeextensionsaddsemantickernelpluginsfromscannerthis-semantickernelsyringe-isemantickernelpluginscanner-bool-bool-method","title":"SemanticKernelSyringeExtensions.AddSemanticKernelPluginsFromScanner(this SemanticKernelSyringe, ISemanticKernelPluginScanner, bool, bool) Method","text":"<p>Adds SemanticKernel plugins from a custom scanner.</p> <pre><code>public static NexusLabs.Needlr.SemanticKernel.SemanticKernelSyringe AddSemanticKernelPluginsFromScanner(this NexusLabs.Needlr.SemanticKernel.SemanticKernelSyringe syringe, NexusLabs.Needlr.SemanticKernel.ISemanticKernelPluginScanner scanner, bool includeInstancePlugins=true, bool includeStaticPlugins=true);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/#parameters_7","title":"Parameters","text":"<p><code>syringe</code> SemanticKernelSyringe</p> <p>The SemanticKernel syringe to configure.</p> <p></p> <p><code>scanner</code> ISemanticKernelPluginScanner</p> <p>The scanner to use for plugin discovery.</p> <p></p> <p><code>includeInstancePlugins</code> System.Boolean</p> <p>Whether to include instance plugins.</p> <p></p> <p><code>includeStaticPlugins</code> System.Boolean</p> <p>Whether to include static plugins.</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/#returns_7","title":"Returns","text":"<p>SemanticKernelSyringe The configured syringe.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/#semantickernelsyringeextensionsconfigurethis-semantickernelsyringe-actionkernelfactoryoptions-method","title":"SemanticKernelSyringeExtensions.Configure(this SemanticKernelSyringe, Action&lt;KernelFactoryOptions&gt;) Method","text":"<p>Registers a callback to further configure KernelFactoryOptions when the kernel factory is built.</p> <pre><code>public static NexusLabs.Needlr.SemanticKernel.SemanticKernelSyringe Configure(this NexusLabs.Needlr.SemanticKernel.SemanticKernelSyringe syringe, System.Action&lt;NexusLabs.Needlr.SemanticKernel.KernelFactoryOptions&gt; configure);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/#parameters_8","title":"Parameters","text":"<p><code>syringe</code> SemanticKernelSyringe</p> <p>The Semantic Kernel syringe to configure.</p> <p></p> <p><code>configure</code> System.Action&lt;KernelFactoryOptions&gt;</p> <p>The configuration callback to apply.</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SemanticKernelSyringeExtensions/#returns_8","title":"Returns","text":"<p>SemanticKernelSyringe The configured syringe.</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/ServiceCatalog/","title":"ServiceCatalog","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/ServiceCatalog/#nexuslabsneedlrsemantickernel","title":"NexusLabs.Needlr.SemanticKernel","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/ServiceCatalog/#nexuslabsneedlrsemantickernelgenerated","title":"NexusLabs.Needlr.SemanticKernel.Generated","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/ServiceCatalog/#servicecatalog-class","title":"ServiceCatalog Class","text":"<p>Compile-time service catalog containing all discovered registrations.</p> <pre><code>public sealed class ServiceCatalog : NexusLabs.Needlr.Catalog.IServiceCatalog\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 ServiceCatalog</p> <p>Implements NexusLabs.Needlr.Catalog.IServiceCatalog</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/ServiceCatalog/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/ServiceCatalog/#servicecatalogassemblyname-property","title":"ServiceCatalog.AssemblyName Property","text":"<p>Gets the assembly name this catalog was generated for.</p> <pre><code>public string AssemblyName { get; }\n</code></pre> <p>Implements AssemblyName</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/ServiceCatalog/#property-value","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/ServiceCatalog/#servicecatalogdecorators-property","title":"ServiceCatalog.Decorators Property","text":"<p>Gets all discovered decorator registrations.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.DecoratorCatalogEntry&gt; Decorators { get; }\n</code></pre> <p>Implements Decorators</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/ServiceCatalog/#property-value_1","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.DecoratorCatalogEntry&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/ServiceCatalog/#servicecataloggeneratedat-property","title":"ServiceCatalog.GeneratedAt Property","text":"<p>Gets the UTC timestamp when this catalog was generated.</p> <pre><code>public string GeneratedAt { get; }\n</code></pre> <p>Implements GeneratedAt</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/ServiceCatalog/#property-value_2","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/ServiceCatalog/#servicecataloghostedservices-property","title":"ServiceCatalog.HostedServices Property","text":"<p>Gets all discovered hosted service registrations.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.HostedServiceCatalogEntry&gt; HostedServices { get; }\n</code></pre> <p>Implements HostedServices</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/ServiceCatalog/#property-value_3","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.HostedServiceCatalogEntry&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/ServiceCatalog/#servicecataloginterceptedservices-property","title":"ServiceCatalog.InterceptedServices Property","text":"<p>Gets all discovered intercepted service registrations.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.InterceptedServiceCatalogEntry&gt; InterceptedServices { get; }\n</code></pre> <p>Implements InterceptedServices</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/ServiceCatalog/#property-value_4","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.InterceptedServiceCatalogEntry&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/ServiceCatalog/#servicecatalogoptions-property","title":"ServiceCatalog.Options Property","text":"<p>Gets all discovered options/configuration bindings.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.OptionsCatalogEntry&gt; Options { get; }\n</code></pre> <p>Implements Options</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/ServiceCatalog/#property-value_5","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.OptionsCatalogEntry&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/ServiceCatalog/#servicecatalogplugins-property","title":"ServiceCatalog.Plugins Property","text":"<p>Gets all discovered plugin registrations.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.PluginCatalogEntry&gt; Plugins { get; }\n</code></pre> <p>Implements Plugins</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/ServiceCatalog/#property-value_6","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.PluginCatalogEntry&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/ServiceCatalog/#servicecatalogservices-property","title":"ServiceCatalog.Services Property","text":"<p>Gets all discovered service registrations.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.ServiceCatalogEntry&gt; Services { get; }\n</code></pre> <p>Implements Services</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/ServiceCatalog/#property-value_7","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.ServiceCatalogEntry&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SyringeExtensionsForSemanticKernel/","title":"SyringeExtensionsForSemanticKernel","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SyringeExtensionsForSemanticKernel/#nexuslabsneedlrsemantickernel","title":"NexusLabs.Needlr.SemanticKernel","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SyringeExtensionsForSemanticKernel/#nexuslabsneedlrsemantickernel_1","title":"NexusLabs.Needlr.SemanticKernel","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SyringeExtensionsForSemanticKernel/#syringeextensionsforsemantickernel-class","title":"SyringeExtensionsForSemanticKernel Class","text":"<p>Extension methods for NexusLabs.Needlr.Injection.ConfiguredSyringe that enable registering Semantic Kernel infrastructure (namely IKernelFactory) as part of the Needlr build pipeline.</p> <pre><code>public static class SyringeExtensionsForSemanticKernel\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 SyringeExtensionsForSemanticKernel</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SyringeExtensionsForSemanticKernel/#remarks","title":"Remarks","text":"<p>These helpers defer service registration using the Syringe post-plugin registration callback so that plugin discovery and registration are completed before the Semantic Kernel factory is added.</p> <p>Note: Microsoft.SemanticKernel internally uses reflection to discover             <code>[KernelFunction]</code> methods and create plugins. This integration therefore requires             reflection and is not fully AOT-compatible. For AOT scenarios, consider registering             kernel functions explicitly.</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SyringeExtensionsForSemanticKernel/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SyringeExtensionsForSemanticKernel/#syringeextensionsforsemantickernelusingsemantickernelthis-configuredsyringe-method","title":"SyringeExtensionsForSemanticKernel.UsingSemanticKernel(this ConfiguredSyringe) Method","text":"<p>Registers an IKernelFactory built via a SemanticKernelSyringe instance.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UsingSemanticKernel(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SyringeExtensionsForSemanticKernel/#parameters","title":"Parameters","text":"<p><code>syringe</code> NexusLabs.Needlr.Injection.ConfiguredSyringe</p> <p>The NexusLabs.Needlr.Injection.ConfiguredSyringe to augment with the registration.</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SyringeExtensionsForSemanticKernel/#returns","title":"Returns","text":"<p>NexusLabs.Needlr.Injection.ConfiguredSyringe A new NexusLabs.Needlr.Injection.ConfiguredSyringe instance containing the registration.</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SyringeExtensionsForSemanticKernel/#exceptions","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when syringe is null.</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SyringeExtensionsForSemanticKernel/#example","title":"Example","text":"<pre><code>var syringe = new Syringe().UsingReflection().UsingSemanticKernel();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SyringeExtensionsForSemanticKernel/#remarks_1","title":"Remarks","text":"<p>Use this overload when you do not need to configure Semantic Kernel.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SyringeExtensionsForSemanticKernel/#syringeextensionsforsemantickernelusingsemantickernelthis-configuredsyringe-funcsemantickernelsyringesemantickernelsyringe-method","title":"SyringeExtensionsForSemanticKernel.UsingSemanticKernel(this ConfiguredSyringe, Func&lt;SemanticKernelSyringe,SemanticKernelSyringe&gt;) Method","text":"<p>Registers an IKernelFactory built via a configurable SemanticKernelSyringe instance.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UsingSemanticKernel(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe, System.Func&lt;NexusLabs.Needlr.SemanticKernel.SemanticKernelSyringe,NexusLabs.Needlr.SemanticKernel.SemanticKernelSyringe&gt; configure);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SyringeExtensionsForSemanticKernel/#parameters_1","title":"Parameters","text":"<p><code>syringe</code> NexusLabs.Needlr.Injection.ConfiguredSyringe</p> <p>The NexusLabs.Needlr.Injection.ConfiguredSyringe to augment with the registration.</p> <p></p> <p><code>configure</code> System.Func&lt;SemanticKernelSyringe,SemanticKernelSyringe&gt;</p> <p>A delegate that receives a pre-initialized SemanticKernelSyringe (with its NexusLabs.Needlr.SemanticKernel.SemanticKernelSyringe.ServiceProvider set) and returns the configured instance used to build the kernel factory.</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SyringeExtensionsForSemanticKernel/#returns_1","title":"Returns","text":"<p>NexusLabs.Needlr.Injection.ConfiguredSyringe A new NexusLabs.Needlr.Injection.ConfiguredSyringe instance containing the registration.</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SyringeExtensionsForSemanticKernel/#exceptions_1","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when syringe or configure is null.</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SyringeExtensionsForSemanticKernel/#example_1","title":"Example","text":"<pre><code>var syringe = new Syringe()\n    .UsingReflection()\n    .UsingSemanticKernel(sk =&gt; sk with\n    {\n        // e.g., add plugins or configure options requiring the provider\n        PluginTypes = new() { typeof(MyPlugin) },\n    });\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SyringeExtensionsForSemanticKernel/#remarks_2","title":"Remarks","text":"<p>Use this overload when your Semantic Kernel configuration needs access to services from the container during configuration.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SyringeExtensionsForSemanticKernel/#syringeextensionsforsemantickernelusingsemantickernelthis-configuredsyringe-funcsemantickernelsyringe-method","title":"SyringeExtensionsForSemanticKernel.UsingSemanticKernel(this ConfiguredSyringe, Func&lt;SemanticKernelSyringe&gt;) Method","text":"<p>Registers an IKernelFactory built via a SemanticKernelSyringe created by the supplied delegate.</p> <pre><code>public static NexusLabs.Needlr.Injection.ConfiguredSyringe UsingSemanticKernel(this NexusLabs.Needlr.Injection.ConfiguredSyringe syringe, System.Func&lt;NexusLabs.Needlr.SemanticKernel.SemanticKernelSyringe&gt; configure);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SyringeExtensionsForSemanticKernel/#parameters_2","title":"Parameters","text":"<p><code>syringe</code> NexusLabs.Needlr.Injection.ConfiguredSyringe</p> <p>The NexusLabs.Needlr.Injection.ConfiguredSyringe to augment with the registration.</p> <p></p> <p><code>configure</code> System.Func&lt;SemanticKernelSyringe&gt;</p> <p>A factory that creates a fully-configured SemanticKernelSyringe used to build the kernel factory. This is useful when configuration does not need the service provider.</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SyringeExtensionsForSemanticKernel/#returns_2","title":"Returns","text":"<p>NexusLabs.Needlr.Injection.ConfiguredSyringe A new NexusLabs.Needlr.Injection.ConfiguredSyringe instance containing the registration.</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SyringeExtensionsForSemanticKernel/#exceptions_2","title":"Exceptions","text":"<p>System.ArgumentNullException Thrown when syringe or configure is null.</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/SyringeExtensionsForSemanticKernel/#example_2","title":"Example","text":"<pre><code>var syringe = new Syringe()\n    .UsingReflection()\n    .UsingSemanticKernel(() =&gt; new SemanticKernelSyringe\n    {\n        // Initialize without requiring the service provider\n        PluginTypes = new() { typeof(MyPlugin) },\n    });\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/TypeRegistry/","title":"TypeRegistry","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/TypeRegistry/#nexuslabsneedlrsemantickernel","title":"NexusLabs.Needlr.SemanticKernel","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/TypeRegistry/#nexuslabsneedlrsemantickernelgenerated","title":"NexusLabs.Needlr.SemanticKernel.Generated","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/TypeRegistry/#typeregistry-class","title":"TypeRegistry Class","text":"<p>Compile-time generated registry of injectable types and plugins. This eliminates the need for runtime reflection-based type discovery.</p> <pre><code>public static class TypeRegistry\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 TypeRegistry</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/TypeRegistry/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/TypeRegistry/#typeregistryapplydecoratorsiservicecollection-method","title":"TypeRegistry.ApplyDecorators(IServiceCollection) Method","text":"<p>Applies all discovered decorators, interceptors, and hosted services to the service collection. Decorators are applied in order, with lower Order values applied first (closer to the original service).</p> <pre><code>public static void ApplyDecorators(Microsoft.Extensions.DependencyInjection.IServiceCollection services);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/TypeRegistry/#parameters","title":"Parameters","text":"<p><code>services</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service collection to apply decorators to.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/TypeRegistry/#typeregistrygetinjectabletypes-method","title":"TypeRegistry.GetInjectableTypes() Method","text":"<p>Gets all injectable types discovered at compile time.</p> <pre><code>public static System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.InjectableTypeInfo&gt; GetInjectableTypes();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/TypeRegistry/#returns","title":"Returns","text":"<p>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.InjectableTypeInfo&gt; A read-only list of injectable type information.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/TypeRegistry/#typeregistrygetplugintypes-method","title":"TypeRegistry.GetPluginTypes() Method","text":"<p>Gets all plugin types discovered at compile time.</p> <pre><code>public static System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.PluginTypeInfo&gt; GetPluginTypes();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel/TypeRegistry/#returns_1","title":"Returns","text":"<p>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.PluginTypeInfo&gt; A read-only list of plugin type information.</p>"},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel.Generators/","title":"Index","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel.Generators/#nexuslabsneedlrsemantickernelgenerators-namespace","title":"NexusLabs.Needlr.SemanticKernel.Generators Namespace","text":"Classes SemanticKernelPluginRegistryGenerator Source generator for Semantic Kernel plugins. Discovers classes with [KernelFunction] methods and generates registration code."},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel.Generators/NexusLabs.Needlr.SemanticKernel.Generators/","title":"NexusLabs.Needlr.SemanticKernel.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel.Generators/NexusLabs.Needlr.SemanticKernel.Generators/#nexuslabsneedlrsemantickernelgenerators-namespace","title":"NexusLabs.Needlr.SemanticKernel.Generators Namespace","text":"Classes SemanticKernelPluginRegistryGenerator Source generator for Semantic Kernel plugins. Discovers classes with [KernelFunction] methods and generates registration code."},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel.Generators/SemanticKernelPluginRegistryGenerator/","title":"SemanticKernelPluginRegistryGenerator","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel.Generators/SemanticKernelPluginRegistryGenerator/#nexuslabsneedlrsemantickernelgenerators","title":"NexusLabs.Needlr.SemanticKernel.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.SemanticKernel.Generators/SemanticKernelPluginRegistryGenerator/#semantickernelpluginregistrygenerator-class","title":"SemanticKernelPluginRegistryGenerator Class","text":"<p>Source generator for Semantic Kernel plugins. Discovers classes with [KernelFunction] methods and generates registration code.</p> <pre><code>public class SemanticKernelPluginRegistryGenerator\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 Microsoft.CodeAnalysis.IIncrementalGenerator \ud83e\udc52 SemanticKernelPluginRegistryGenerator</p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/","title":"Index","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR/#nexuslabsneedlrsignalr","title":"NexusLabs.Needlr.SignalR","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR/#nexuslabsneedlrsignalr-assembly","title":"NexusLabs.Needlr.SignalR Assembly","text":"Namespaces NexusLabs.Needlr.SignalR NexusLabs.Needlr.SignalR.Generated"},{"location":"api/dev/NexusLabs.Needlr.SignalR/GeneratedSignalRHubRegistration/","title":"GeneratedSignalRHubRegistration","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR/GeneratedSignalRHubRegistration/#nexuslabsneedlrsignalr","title":"NexusLabs.Needlr.SignalR","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR/GeneratedSignalRHubRegistration/#nexuslabsneedlrsignalr_1","title":"NexusLabs.Needlr.SignalR","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR/GeneratedSignalRHubRegistration/#generatedsignalrhubregistration-class","title":"GeneratedSignalRHubRegistration Class","text":"<p>Marker interface for source-generated SignalR hub registration.</p> <pre><code>public static class GeneratedSignalRHubRegistration\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 GeneratedSignalRHubRegistration</p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/GeneratedSignalRHubRegistration/#remarks","title":"Remarks","text":"<p>When using source generation, the generator emits a  <code>SignalRHubRegistrations.MapGeneratedHubs(WebApplication)</code> extension method that can be called directly in your Program.cs:</p> <pre><code>var app = builder.Build();\napp.MapGeneratedHubs(); // Generated at compile-time\n</code></pre> <p>This approach is preferred for AOT/trimmed applications because it avoids all runtime reflection. The SignalRHubRegistrationPlugin uses reflection and is marked with appropriate AOT warnings.</p> <p>To enable hub registration generation, implement IHubRegistrationPlugin with compile-time constant property values:</p> <pre><code>public class ChatHubPlugin : IHubRegistrationPlugin\n{\n    public string HubPath =&gt; \"/chat\";\n    public Type HubType =&gt; typeof(ChatHub);\n}\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/GeneratedSignalRHubRegistration/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR/GeneratedSignalRHubRegistration/#generatedsignalrhubregistrationdocumentationplaceholder-method","title":"GeneratedSignalRHubRegistration.DocumentationPlaceholder() Method","text":"<p>Extension method placeholder that provides documentation for source-generated hub registration. The actual implementation is generated by NexusLabs.Needlr.Generators when  IHubRegistrationPlugin implementations are discovered.</p> <pre><code>public static void DocumentationPlaceholder();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/GeneratedSignalRHubRegistration/#remarks_1","title":"Remarks","text":"<p>This method exists to provide IntelliSense documentation. The generated <code>NexusLabs.Needlr.Generated.SignalRHubRegistrations.MapGeneratedHubs()</code> extension method should be called instead.</p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/IHubRegistrationPlugin/","title":"IHubRegistrationPlugin","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR/IHubRegistrationPlugin/#nexuslabsneedlrsignalr","title":"NexusLabs.Needlr.SignalR","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR/IHubRegistrationPlugin/#nexuslabsneedlrsignalr_1","title":"NexusLabs.Needlr.SignalR","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR/IHubRegistrationPlugin/#ihubregistrationplugin-interface","title":"IHubRegistrationPlugin Interface","text":"<p>Defines a plugin for registering SignalR hubs with the application. Implement this interface to provide hub routing information for automatic endpoint mapping.</p> <pre><code>public interface IHubRegistrationPlugin\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/IHubRegistrationPlugin/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR/IHubRegistrationPlugin/#ihubregistrationpluginhubpath-property","title":"IHubRegistrationPlugin.HubPath Property","text":"<p>Gets the path used to identify the hub.</p> <pre><code>string HubPath { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/IHubRegistrationPlugin/#property-value","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/IHubRegistrationPlugin/#ihubregistrationpluginhubtype-property","title":"IHubRegistrationPlugin.HubType Property","text":"<p>Gets the System.Type of the hub being registered.</p> <pre><code>System.Type HubType { get; }\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/IHubRegistrationPlugin/#property-value_1","title":"Property Value","text":"<p>System.Type</p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/NexusLabs.Needlr.SignalR.Generated/","title":"NexusLabs.Needlr.SignalR.Generated","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR/NexusLabs.Needlr.SignalR.Generated/#nexuslabsneedlrsignalr","title":"NexusLabs.Needlr.SignalR","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR/NexusLabs.Needlr.SignalR.Generated/#nexuslabsneedlrsignalrgenerated-namespace","title":"NexusLabs.Needlr.SignalR.Generated Namespace","text":"Classes ServiceCatalog Compile-time service catalog containing all discovered registrations. TypeRegistry Compile-time generated registry of injectable types and plugins. This eliminates the need for runtime reflection-based type discovery."},{"location":"api/dev/NexusLabs.Needlr.SignalR/NexusLabs.Needlr.SignalR/","title":"NexusLabs.Needlr.SignalR","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR/NexusLabs.Needlr.SignalR/#nexuslabsneedlrsignalr","title":"NexusLabs.Needlr.SignalR","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR/NexusLabs.Needlr.SignalR/#nexuslabsneedlrsignalr-namespace","title":"NexusLabs.Needlr.SignalR Namespace","text":"Classes GeneratedSignalRHubRegistration Marker interface for source-generated SignalR hub registration. SignalRExtensions Extension methods for configuring SignalR hub registration via Needlr. SignalRHubRegistrationPlugin Plugin that registers SignalR hubs discovered via IHubRegistrationPlugin implementations. SignalRWebApplicationBuilderPlugin Plugin that registers SignalR services with the web application builder. Automatically adds SignalR support to the ASP.NET Core application. Interfaces IHubRegistrationPlugin Defines a plugin for registering SignalR hubs with the application. Implement this interface to provide hub routing information for automatic endpoint mapping."},{"location":"api/dev/NexusLabs.Needlr.SignalR/ServiceCatalog/","title":"ServiceCatalog","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR/ServiceCatalog/#nexuslabsneedlrsignalr","title":"NexusLabs.Needlr.SignalR","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR/ServiceCatalog/#nexuslabsneedlrsignalrgenerated","title":"NexusLabs.Needlr.SignalR.Generated","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR/ServiceCatalog/#servicecatalog-class","title":"ServiceCatalog Class","text":"<p>Compile-time service catalog containing all discovered registrations.</p> <pre><code>public sealed class ServiceCatalog : NexusLabs.Needlr.Catalog.IServiceCatalog\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 ServiceCatalog</p> <p>Implements NexusLabs.Needlr.Catalog.IServiceCatalog</p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/ServiceCatalog/#properties","title":"Properties","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR/ServiceCatalog/#servicecatalogassemblyname-property","title":"ServiceCatalog.AssemblyName Property","text":"<p>Gets the assembly name this catalog was generated for.</p> <pre><code>public string AssemblyName { get; }\n</code></pre> <p>Implements AssemblyName</p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/ServiceCatalog/#property-value","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/ServiceCatalog/#servicecatalogdecorators-property","title":"ServiceCatalog.Decorators Property","text":"<p>Gets all discovered decorator registrations.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.DecoratorCatalogEntry&gt; Decorators { get; }\n</code></pre> <p>Implements Decorators</p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/ServiceCatalog/#property-value_1","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.DecoratorCatalogEntry&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/ServiceCatalog/#servicecataloggeneratedat-property","title":"ServiceCatalog.GeneratedAt Property","text":"<p>Gets the UTC timestamp when this catalog was generated.</p> <pre><code>public string GeneratedAt { get; }\n</code></pre> <p>Implements GeneratedAt</p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/ServiceCatalog/#property-value_2","title":"Property Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/ServiceCatalog/#servicecataloghostedservices-property","title":"ServiceCatalog.HostedServices Property","text":"<p>Gets all discovered hosted service registrations.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.HostedServiceCatalogEntry&gt; HostedServices { get; }\n</code></pre> <p>Implements HostedServices</p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/ServiceCatalog/#property-value_3","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.HostedServiceCatalogEntry&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/ServiceCatalog/#servicecataloginterceptedservices-property","title":"ServiceCatalog.InterceptedServices Property","text":"<p>Gets all discovered intercepted service registrations.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.InterceptedServiceCatalogEntry&gt; InterceptedServices { get; }\n</code></pre> <p>Implements InterceptedServices</p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/ServiceCatalog/#property-value_4","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.InterceptedServiceCatalogEntry&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/ServiceCatalog/#servicecatalogoptions-property","title":"ServiceCatalog.Options Property","text":"<p>Gets all discovered options/configuration bindings.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.OptionsCatalogEntry&gt; Options { get; }\n</code></pre> <p>Implements Options</p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/ServiceCatalog/#property-value_5","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.OptionsCatalogEntry&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/ServiceCatalog/#servicecatalogplugins-property","title":"ServiceCatalog.Plugins Property","text":"<p>Gets all discovered plugin registrations.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.PluginCatalogEntry&gt; Plugins { get; }\n</code></pre> <p>Implements Plugins</p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/ServiceCatalog/#property-value_6","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.PluginCatalogEntry&gt;</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/ServiceCatalog/#servicecatalogservices-property","title":"ServiceCatalog.Services Property","text":"<p>Gets all discovered service registrations.</p> <pre><code>public System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.ServiceCatalogEntry&gt; Services { get; }\n</code></pre> <p>Implements Services</p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/ServiceCatalog/#property-value_7","title":"Property Value","text":"<p>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Catalog.ServiceCatalogEntry&gt;</p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/SignalRExtensions/","title":"SignalRExtensions","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR/SignalRExtensions/#nexuslabsneedlrsignalr","title":"NexusLabs.Needlr.SignalR","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR/SignalRExtensions/#nexuslabsneedlrsignalr_1","title":"NexusLabs.Needlr.SignalR","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR/SignalRExtensions/#signalrextensions-class","title":"SignalRExtensions Class","text":"<p>Extension methods for configuring SignalR hub registration via Needlr.</p> <pre><code>public static class SignalRExtensions\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 SignalRExtensions</p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/SignalRExtensions/#example","title":"Example","text":"<pre><code>// Reflection-based (not AOT-safe)\napp.UseSignalRHubsWithReflection();\n\n// Source-generated (AOT-safe) \u2014 requires NexusLabs.Needlr.SignalR.Generators\napp.MapGeneratedHubs();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/SignalRExtensions/#remarks","title":"Remarks","text":"<p>Two approaches are supported: - Reflection-based (UseSignalRHubsWithReflection(this WebApplication, IPluginFactory, IEnumerable&lt;Assembly&gt;)): discovers and maps hubs at                runtime. Convenient but incompatible with AOT/trimmed builds. - Source-generated (<code>app.MapGeneratedHubs()</code>): emits hub mappings at compile time.                Required for AOT/trimmed applications.</p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/SignalRExtensions/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR/SignalRExtensions/#signalrextensionsaddsignalrhubregistrationwithreflectionthis-iservicecollection-method","title":"SignalRExtensions.AddSignalRHubRegistrationWithReflection(this IServiceCollection) Method","text":"<p>Adds the reflection-based SignalR hub registration plugin to the service collection.</p> <pre><code>public static Microsoft.Extensions.DependencyInjection.IServiceCollection AddSignalRHubRegistrationWithReflection(this Microsoft.Extensions.DependencyInjection.IServiceCollection services);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/SignalRExtensions/#parameters","title":"Parameters","text":"<p><code>services</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service collection to configure.</p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/SignalRExtensions/#returns","title":"Returns","text":"<p>Microsoft.Extensions.DependencyInjection.IServiceCollection The service collection for chaining.</p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/SignalRExtensions/#remarks_1","title":"Remarks","text":"<p>This registers the SignalRHubRegistrationPlugin which uses reflection to discover and map SignalR hubs at runtime.</p> <p>For AOT/trimmed applications, do not use this method. Instead,             call <code>app.MapGeneratedHubs()</code> directly after building the application.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/SignalRExtensions/#signalrextensionsusesignalrhubswithreflectionthis-webapplication-ipluginfactory-ienumerableassembly-method","title":"SignalRExtensions.UseSignalRHubsWithReflection(this WebApplication, IPluginFactory, IEnumerable&lt;Assembly&gt;) Method","text":"<p>Registers SignalR hubs using reflection-based discovery.</p> <pre><code>public static Microsoft.AspNetCore.Builder.WebApplication UseSignalRHubsWithReflection(this Microsoft.AspNetCore.Builder.WebApplication app, NexusLabs.Needlr.IPluginFactory? pluginFactory=null, System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt;? assemblies=null);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/SignalRExtensions/#parameters_1","title":"Parameters","text":"<p><code>app</code> Microsoft.AspNetCore.Builder.WebApplication</p> <p>The web application to configure.</p> <p></p> <p><code>pluginFactory</code> NexusLabs.Needlr.IPluginFactory</p> <p>The plugin factory to use for discovering hub registration plugins.</p> <p></p> <p><code>assemblies</code> System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt;</p> <p>The assemblies to scan for hub registration plugins.</p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/SignalRExtensions/#returns_1","title":"Returns","text":"<p>Microsoft.AspNetCore.Builder.WebApplication The web application for chaining.</p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/SignalRExtensions/#remarks_2","title":"Remarks","text":"<p>This method uses reflection to discover IHubRegistrationPlugin implementations and invoke <code>MapHub&lt;T&gt;()</code> at runtime.</p> <p>For AOT/trimmed applications, use the source-generated approach instead:</p> <pre><code>app.MapGeneratedHubs(); // Generated at compile-time, no reflection\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/SignalRHubRegistrationPlugin/","title":"SignalRHubRegistrationPlugin","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR/SignalRHubRegistrationPlugin/#nexuslabsneedlrsignalr","title":"NexusLabs.Needlr.SignalR","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR/SignalRHubRegistrationPlugin/#nexuslabsneedlrsignalr_1","title":"NexusLabs.Needlr.SignalR","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR/SignalRHubRegistrationPlugin/#signalrhubregistrationplugin-class","title":"SignalRHubRegistrationPlugin Class","text":"<p>Plugin that registers SignalR hubs discovered via IHubRegistrationPlugin implementations.</p> <pre><code>public sealed class SignalRHubRegistrationPlugin : NexusLabs.Needlr.AspNet.IWebApplicationPlugin\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 SignalRHubRegistrationPlugin</p> <p>Implements NexusLabs.Needlr.AspNet.IWebApplicationPlugin</p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/SignalRHubRegistrationPlugin/#remarks","title":"Remarks","text":"<p>This plugin uses reflection to invoke MapHub() at runtime because the SignalR API does not provide a non-generic overload. <p>For AOT/trimmed applications, use the source-generated approach instead:</p> <pre><code>var app = builder.Build();\napp.MapGeneratedHubs(); // Generated at compile-time, no reflection\n</code></pre> <p>This plugin is marked with NexusLabs.Needlr.DoNotAutoRegisterAttribute to prevent automatic registration in source-gen scenarios. To use this reflection-based approach, explicitly register the plugin or call UseSignalRHubsWithReflection(this WebApplication, IPluginFactory, IEnumerable&lt;Assembly&gt;).</p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/SignalRWebApplicationBuilderPlugin/","title":"SignalRWebApplicationBuilderPlugin","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR/SignalRWebApplicationBuilderPlugin/#nexuslabsneedlrsignalr","title":"NexusLabs.Needlr.SignalR","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR/SignalRWebApplicationBuilderPlugin/#nexuslabsneedlrsignalr_1","title":"NexusLabs.Needlr.SignalR","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR/SignalRWebApplicationBuilderPlugin/#signalrwebapplicationbuilderplugin-class","title":"SignalRWebApplicationBuilderPlugin Class","text":"<p>Plugin that registers SignalR services with the web application builder. Automatically adds SignalR support to the ASP.NET Core application.</p> <pre><code>public sealed class SignalRWebApplicationBuilderPlugin : NexusLabs.Needlr.AspNet.IWebApplicationBuilderPlugin\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 SignalRWebApplicationBuilderPlugin</p> <p>Implements NexusLabs.Needlr.AspNet.IWebApplicationBuilderPlugin</p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/TypeRegistry/","title":"TypeRegistry","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR/TypeRegistry/#nexuslabsneedlrsignalr","title":"NexusLabs.Needlr.SignalR","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR/TypeRegistry/#nexuslabsneedlrsignalrgenerated","title":"NexusLabs.Needlr.SignalR.Generated","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR/TypeRegistry/#typeregistry-class","title":"TypeRegistry Class","text":"<p>Compile-time generated registry of injectable types and plugins. This eliminates the need for runtime reflection-based type discovery.</p> <pre><code>public static class TypeRegistry\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 TypeRegistry</p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/TypeRegistry/#methods","title":"Methods","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR/TypeRegistry/#typeregistryapplydecoratorsiservicecollection-method","title":"TypeRegistry.ApplyDecorators(IServiceCollection) Method","text":"<p>Applies all discovered decorators, interceptors, and hosted services to the service collection. Decorators are applied in order, with lower Order values applied first (closer to the original service).</p> <pre><code>public static void ApplyDecorators(Microsoft.Extensions.DependencyInjection.IServiceCollection services);\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/TypeRegistry/#parameters","title":"Parameters","text":"<p><code>services</code> Microsoft.Extensions.DependencyInjection.IServiceCollection</p> <p>The service collection to apply decorators to.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/TypeRegistry/#typeregistrygetinjectabletypes-method","title":"TypeRegistry.GetInjectableTypes() Method","text":"<p>Gets all injectable types discovered at compile time.</p> <pre><code>public static System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.InjectableTypeInfo&gt; GetInjectableTypes();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/TypeRegistry/#returns","title":"Returns","text":"<p>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.InjectableTypeInfo&gt; A read-only list of injectable type information.</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/TypeRegistry/#typeregistrygetplugintypes-method","title":"TypeRegistry.GetPluginTypes() Method","text":"<p>Gets all plugin types discovered at compile time.</p> <pre><code>public static System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.PluginTypeInfo&gt; GetPluginTypes();\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SignalR/TypeRegistry/#returns_1","title":"Returns","text":"<p>System.Collections.Generic.IReadOnlyList&lt;NexusLabs.Needlr.Generators.PluginTypeInfo&gt; A read-only list of plugin type information.</p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR.Analyzers/","title":"Index","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR.Analyzers/#nexuslabsneedlrsignalranalyzers-namespace","title":"NexusLabs.Needlr.SignalR.Analyzers Namespace","text":"Classes DiagnosticDescriptors Diagnostic descriptors for SignalR-specific Needlr analyzers. DiagnosticIds Diagnostic IDs for SignalR-specific Needlr analyzers. HubPathAttributeAnalyzer Analyzer that validates HubPathAttribute usage for AOT compatibility."},{"location":"api/dev/NexusLabs.Needlr.SignalR.Analyzers/DiagnosticDescriptors/","title":"DiagnosticDescriptors","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR.Analyzers/DiagnosticDescriptors/#nexuslabsneedlrsignalranalyzers","title":"NexusLabs.Needlr.SignalR.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR.Analyzers/DiagnosticDescriptors/#diagnosticdescriptors-class","title":"DiagnosticDescriptors Class","text":"<p>Diagnostic descriptors for SignalR-specific Needlr analyzers.</p> <pre><code>public static class DiagnosticDescriptors\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 DiagnosticDescriptors</p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR.Analyzers/DiagnosticDescriptors/#fields","title":"Fields","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR.Analyzers/DiagnosticDescriptors/#diagnosticdescriptorshubpathmustbeconstant-field","title":"DiagnosticDescriptors.HubPathMustBeConstant Field","text":"<p>NDLRSIG001: HubPath must be a constant expression for AOT compatibility.</p> <pre><code>public static readonly DiagnosticDescriptor HubPathMustBeConstant;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SignalR.Analyzers/DiagnosticDescriptors/#field-value","title":"Field Value","text":"<p>Microsoft.CodeAnalysis.DiagnosticDescriptor</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR.Analyzers/DiagnosticDescriptors/#diagnosticdescriptorshubtypemustbetypeof-field","title":"DiagnosticDescriptors.HubTypeMustBeTypeOf Field","text":"<p>NDLRSIG002: HubType must be a typeof expression for AOT compatibility.</p> <pre><code>public static readonly DiagnosticDescriptor HubTypeMustBeTypeOf;\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SignalR.Analyzers/DiagnosticDescriptors/#field-value_1","title":"Field Value","text":"<p>Microsoft.CodeAnalysis.DiagnosticDescriptor</p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR.Analyzers/DiagnosticIds/","title":"DiagnosticIds","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR.Analyzers/DiagnosticIds/#nexuslabsneedlrsignalranalyzers","title":"NexusLabs.Needlr.SignalR.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR.Analyzers/DiagnosticIds/#diagnosticids-class","title":"DiagnosticIds Class","text":"<p>Diagnostic IDs for SignalR-specific Needlr analyzers.</p> <pre><code>public static class DiagnosticIds\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 DiagnosticIds</p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR.Analyzers/DiagnosticIds/#remarks","title":"Remarks","text":"<p>SignalR analyzer codes use the NDLRSIG prefix.</p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR.Analyzers/DiagnosticIds/#fields","title":"Fields","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR.Analyzers/DiagnosticIds/#diagnosticidshubpathmustbeconstant-field","title":"DiagnosticIds.HubPathMustBeConstant Field","text":"<p>NDLRSIG001: HubPath must be a constant expression.</p> <pre><code>public const string HubPathMustBeConstant = \"NDLRSIG001\";\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SignalR.Analyzers/DiagnosticIds/#field-value","title":"Field Value","text":"<p>System.String</p> <p></p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR.Analyzers/DiagnosticIds/#diagnosticidshubtypemustbetypeof-field","title":"DiagnosticIds.HubTypeMustBeTypeOf Field","text":"<p>NDLRSIG002: HubType must be a typeof expression.</p> <pre><code>public const string HubTypeMustBeTypeOf = \"NDLRSIG002\";\n</code></pre>"},{"location":"api/dev/NexusLabs.Needlr.SignalR.Analyzers/DiagnosticIds/#field-value_1","title":"Field Value","text":"<p>System.String</p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR.Analyzers/HubPathAttributeAnalyzer/","title":"HubPathAttributeAnalyzer","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR.Analyzers/HubPathAttributeAnalyzer/#nexuslabsneedlrsignalranalyzers","title":"NexusLabs.Needlr.SignalR.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR.Analyzers/HubPathAttributeAnalyzer/#hubpathattributeanalyzer-class","title":"HubPathAttributeAnalyzer Class","text":"<p>Analyzer that validates HubPathAttribute usage for AOT compatibility.</p> <pre><code>public sealed class HubPathAttributeAnalyzer\n</code></pre> <p>Inheritance Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer \ud83e\udc52 HubPathAttributeAnalyzer</p>"},{"location":"api/dev/NexusLabs.Needlr.SignalR.Analyzers/NexusLabs.Needlr.SignalR.Analyzers/","title":"NexusLabs.Needlr.SignalR.Analyzers","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR.Analyzers/NexusLabs.Needlr.SignalR.Analyzers/#nexuslabsneedlrsignalranalyzers-namespace","title":"NexusLabs.Needlr.SignalR.Analyzers Namespace","text":"Classes DiagnosticDescriptors Diagnostic descriptors for SignalR-specific Needlr analyzers. DiagnosticIds Diagnostic IDs for SignalR-specific Needlr analyzers. HubPathAttributeAnalyzer Analyzer that validates HubPathAttribute usage for AOT compatibility."},{"location":"api/dev/NexusLabs.Needlr.SignalR.Generators/","title":"Index","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR.Generators/#nexuslabsneedlrsignalrgenerators-namespace","title":"NexusLabs.Needlr.SignalR.Generators Namespace","text":"Classes SignalRHubRegistryGenerator Source generator for SignalR hub registrations. Discovers IHubRegistrationPlugin implementations and generates registration code."},{"location":"api/dev/NexusLabs.Needlr.SignalR.Generators/NexusLabs.Needlr.SignalR.Generators/","title":"NexusLabs.Needlr.SignalR.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR.Generators/NexusLabs.Needlr.SignalR.Generators/#nexuslabsneedlrsignalrgenerators-namespace","title":"NexusLabs.Needlr.SignalR.Generators Namespace","text":"Classes SignalRHubRegistryGenerator Source generator for SignalR hub registrations. Discovers IHubRegistrationPlugin implementations and generates registration code."},{"location":"api/dev/NexusLabs.Needlr.SignalR.Generators/SignalRHubRegistryGenerator/","title":"SignalRHubRegistryGenerator","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR.Generators/SignalRHubRegistryGenerator/#nexuslabsneedlrsignalrgenerators","title":"NexusLabs.Needlr.SignalR.Generators","text":""},{"location":"api/dev/NexusLabs.Needlr.SignalR.Generators/SignalRHubRegistryGenerator/#signalrhubregistrygenerator-class","title":"SignalRHubRegistryGenerator Class","text":"<p>Source generator for SignalR hub registrations. Discovers IHubRegistrationPlugin implementations and generates registration code.</p> <pre><code>public class SignalRHubRegistryGenerator\n</code></pre> <p>Inheritance System.Object \ud83e\udc52 Microsoft.CodeAnalysis.IIncrementalGenerator \ud83e\udc52 SignalRHubRegistryGenerator</p>"},{"location":"api/stable/","title":"API Reference (Stable)","text":"<p>This documentation is for the latest stable release.</p> <p>For development (unreleased) documentation, see dev.</p>"},{"location":"api/stable/#packages","title":"Packages","text":"<p>API documentation will be generated during the next release.</p>"}]}