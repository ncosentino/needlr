using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace NexusLabs.Needlr.FluentValidation.Generators;

/// <summary>
/// Source generator that creates IValidateOptions adapters for FluentValidation validators
/// and registers them via NeedlrSourceGenBootstrap.RegisterExtension.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class FluentValidationAdapterGenerator : IIncrementalGenerator
{
    private const string OptionsAttributeName = "NexusLabs.Needlr.Generators.OptionsAttribute";
    private const string AbstractValidatorName = "FluentValidation.AbstractValidator<T>";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var optionsWithValidators = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                OptionsAttributeName,
                predicate: static (node, _) => node is ClassDeclarationSyntax,
                transform: static (ctx, _) => GetOptionsWithFluentValidator(ctx))
            .Where(static x => x != null)
            .Select(static (x, _) => x!.Value);

        var compilationAndOptions = optionsWithValidators.Collect().Combine(context.CompilationProvider);

        context.RegisterSourceOutput(compilationAndOptions, GenerateSource);
    }

    private static (INamedTypeSymbol OptionsType, INamedTypeSymbol ValidatorType)? GetOptionsWithFluentValidator(
        GeneratorAttributeSyntaxContext ctx)
    {
        var classSymbol = ctx.TargetSymbol as INamedTypeSymbol;
        if (classSymbol == null)
            return null;

        foreach (var attr in ctx.Attributes)
        {
            foreach (var namedArg in attr.NamedArguments)
            {
                if (namedArg.Key == "Validator" && namedArg.Value.Value is INamedTypeSymbol validatorType)
                {
                    if (InheritsFromAbstractValidator(validatorType))
                    {
                        return (classSymbol, validatorType);
                    }
                }
            }
        }

        return null;
    }

    private static bool InheritsFromAbstractValidator(INamedTypeSymbol type)
    {
        var current = type.BaseType;
        while (current != null)
        {
            if (current.OriginalDefinition.ToDisplayString() == AbstractValidatorName)
                return true;
            current = current.BaseType;
        }
        return false;
    }

    private static void GenerateSource(
        SourceProductionContext spc,
        (ImmutableArray<(INamedTypeSymbol OptionsType, INamedTypeSymbol ValidatorType)> Items, Compilation Compilation) source)
    {
        var (items, compilation) = source;

        if (items.IsDefaultOrEmpty)
            return;

        var assemblyName = compilation.AssemblyName ?? "Generated";
        var safeAssemblyName = MakeSafeIdentifier(assemblyName);

        var adapters = new List<(string AdapterName, string OptionsFullName, string ValidatorFullName, string OptionsName)>();

        foreach (var (optionsType, validatorType) in items)
        {
            var adapterName = $"{validatorType.Name}Adapter";
            var optionsFullName = optionsType.ToDisplayString();
            var validatorFullName = validatorType.ToDisplayString();

            adapters.Add((adapterName, optionsFullName, validatorFullName, optionsType.Name));

            var adapterSource = GenerateAdapterClass(adapterName, optionsFullName, validatorFullName, safeAssemblyName);
            spc.AddSource($"{adapterName}.g.cs", SourceText.From(adapterSource, Encoding.UTF8));
        }

        var registrySource = GenerateRegistry(adapters, safeAssemblyName);
        spc.AddSource("FluentValidationTypeRegistry.g.cs", SourceText.From(registrySource, Encoding.UTF8));

        var bootstrapSource = GenerateBootstrap(safeAssemblyName);
        spc.AddSource("FluentValidationBootstrap.g.cs", SourceText.From(bootstrapSource, Encoding.UTF8));
    }

    private static string GenerateAdapterClass(string adapterName, string optionsFullName, string validatorFullName, string ns)
    {
        return $@"// <auto-generated />
#nullable enable

using FluentValidation;

using Microsoft.Extensions.Options;

namespace {ns}.Generated.FluentValidation;

/// <summary>
/// Adapter that wraps <see cref=""{validatorFullName}""/> to implement <see cref=""IValidateOptions{{T}}""/>.
/// </summary>
internal sealed class {adapterName} : IValidateOptions<{optionsFullName}>
{{
    private readonly IValidator<{optionsFullName}> _validator;

    public {adapterName}(IValidator<{optionsFullName}> validator)
    {{
        _validator = validator;
    }}

    public ValidateOptionsResult Validate(string? name, {optionsFullName} options)
    {{
        var result = _validator.Validate(options);
        if (result.IsValid)
            return ValidateOptionsResult.Success;

        var errors = result.Errors.Select(e => e.ErrorMessage).ToList();
        return ValidateOptionsResult.Fail(errors);
    }}
}}
";
    }

    private static string GenerateRegistry(
        List<(string AdapterName, string OptionsFullName, string ValidatorFullName, string OptionsName)> adapters,
        string ns)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using FluentValidation;");
        sb.AppendLine();
        sb.AppendLine("using Microsoft.Extensions.Configuration;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection.Extensions;");
        sb.AppendLine("using Microsoft.Extensions.Options;");
        sb.AppendLine();
        sb.AppendLine($"namespace {ns}.Generated.FluentValidation;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Registry for FluentValidation validators generated by Needlr.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("internal static class FluentValidationTypeRegistry");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Registers all FluentValidation validators with the service collection.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static void RegisterFluentValidators(IServiceCollection services, IConfiguration configuration)");
        sb.AppendLine("    {");

        foreach (var (adapterName, optionsFullName, validatorFullName, _) in adapters)
        {
            sb.AppendLine($"        // Register validator and adapter for {optionsFullName}");
            sb.AppendLine($"        services.TryAddSingleton<{validatorFullName}>();");
            sb.AppendLine($"        services.TryAddSingleton<IValidator<{optionsFullName}>>(sp => sp.GetRequiredService<{validatorFullName}>());");
            sb.AppendLine($"        services.AddSingleton<IValidateOptions<{optionsFullName}>>(sp =>");
            sb.AppendLine($"            new {adapterName}(sp.GetRequiredService<IValidator<{optionsFullName}>>()));");
            sb.AppendLine();
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static string GenerateBootstrap(string ns)
    {
        return $@"// <auto-generated />
#nullable enable

using System.Runtime.CompilerServices;

using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

namespace {ns}.Generated.FluentValidation;

/// <summary>
/// Module initializer that registers FluentValidation validators with Needlr.
/// </summary>
internal static class FluentValidationModuleInitializer
{{
    [ModuleInitializer]
    internal static void Initialize()
    {{
        global::NexusLabs.Needlr.Generators.NeedlrSourceGenBootstrap.RegisterExtension(
            (services, config) => FluentValidationTypeRegistry.RegisterFluentValidators(
                (IServiceCollection)services,
                (IConfiguration)config));
    }}
}}
";
    }

    private static string MakeSafeIdentifier(string name)
    {
        var sb = new StringBuilder();
        foreach (var part in name.Split('.'))
        {
            if (sb.Length > 0)
                sb.Append('.');

            var safePart = part;
            if (char.IsDigit(safePart[0]))
                safePart = "_" + safePart;
            safePart = safePart.Replace('-', '_').Replace(' ', '_');
            sb.Append(safePart);
        }
        return sb.ToString();
    }
}
