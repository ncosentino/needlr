using Azure;
using Azure.AI.OpenAI;

using Microsoft.Agents.AI.Workflows;
using Microsoft.Extensions.AI;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

using NexusLabs.Needlr.AgentFramework;
using NexusLabs.Needlr.AgentFramework.Workflows;
using NexusLabs.Needlr.Injection;
using NexusLabs.Needlr.Injection.Reflection;

// Generated extension methods: CreateTriageHandoffWorkflow() on IWorkflowFactory.
// These are emitted by the source generator in SimpleAgentFrameworkApp.Agents based on
// [AgentHandoffsTo] attributes declared on TriageAgent.
using SimpleAgentFrameworkApp.Agents.Generated;

var configuration = new ConfigurationBuilder()
    .AddJsonFile("appsettings.json", optional: true)
    .AddJsonFile("appsettings.Development.json", optional: true)
    .AddEnvironmentVariables()
    .Build();

var azureSection = configuration.GetSection("AzureOpenAI");
IChatClient chatClient = new AzureOpenAIClient(
        new Uri(azureSection["Endpoint"]
            ?? throw new InvalidOperationException("No AzureOpenAI:Endpoint set")),
        new AzureKeyCredential(azureSection["ApiKey"]
            ?? throw new InvalidOperationException("No AzureOpenAI:ApiKey set")))
    .GetChatClient(azureSection["DeploymentName"]
        ?? throw new InvalidOperationException("No AzureOpenAI:DeploymentName set"))
    .AsIChatClient();

// The [ModuleInitializer] emitted by the source generator in SimpleAgentFrameworkApp.Agents
// fires on assembly load and registers all [NeedlrAiAgent] types, [AgentFunction] types,
// [AgentFunctionGroup] groups, and [AgentHandoffsTo] topology with AgentFrameworkGeneratedBootstrap.
// UsingAgentFramework() detects these and auto-populates — no explicit Add* calls needed.
var serviceProvider = new Syringe()
    .UsingReflection()
    .UsingAssemblyProvider(b => b.MatchingAssemblies(path =>
        path.Contains("SimpleAgentFrameworkApp", StringComparison.OrdinalIgnoreCase)).Build())
    .UsingAgentFramework(af => af.UsingChatClient(chatClient))
    .BuildServiceProvider(configuration);

// IWorkflowFactory reads topology declared via [AgentHandoffsTo] on agent classes.
// No agent type references or workflow builder calls needed in the composition root.
var workflowFactory = serviceProvider.GetRequiredService<IWorkflowFactory>();

// CreateTriageHandoffWorkflow() is generated by the source generator because TriageAgent
// is decorated with [AgentHandoffsTo(typeof(GeographyAgent), ...)] and
// [AgentHandoffsTo(typeof(LifestyleAgent), ...)].
// Adding a new handoff target requires only updating TriageAgent.cs — this line never changes.
var workflow = workflowFactory.CreateTriageHandoffWorkflow();

Console.WriteLine("=== Needlr + MAF: Triage → Handoff Multi-Agent Workflow ===");
Console.WriteLine("  Topology declared via [AgentHandoffsTo] on TriageAgent.");
Console.WriteLine("  Workflow assembled by IWorkflowFactory — Program.cs is topology-agnostic.");
Console.WriteLine();

var questions = new[]
{
    "Which countries has Nick lived in?",
    "What are Nick's top hobbies?",
    "What's Nick's favorite ice cream?",
    "What cities does Nick love?",
};

foreach (var question in questions)
{
    Console.WriteLine($"Q: {question}");

    await using var run = await InProcessExecution.RunStreamingAsync(
        workflow,
        new ChatMessage(ChatRole.User, question));

    await run.TrySendMessageAsync(new TurnToken(emitEvents: true));

    // CollectAgentResponsesAsync replaces the manual await-foreach + Dictionary<string,StringBuilder>.
    var responses = await run.CollectAgentResponsesAsync();

    foreach (var (executorId, text) in responses)
    {
        Console.WriteLine($"  [{executorId}]: {text.Trim()}");
    }

    Console.WriteLine();
}
