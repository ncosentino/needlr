// Copyright (c) NexusLabs. All rights reserved.
// Licensed under the MIT License.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using NexusLabs.Needlr.Generators.Models;

namespace NexusLabs.Needlr.Generators;

/// <summary>
/// Generates diagnostic markdown output files (DependencyGraph.md, LifetimeSummary.md, RegistrationIndex.md, AnalyzerStatus.md, OptionsSummary.md).
/// </summary>
internal static class DiagnosticsGenerator
{
    internal static string GenerateDiagnosticsSource(DiscoveryResult discoveryResult, string assemblyName, string? projectDirectory, DiagnosticOptions options, IReadOnlyList<string> referencedTypeRegistryAssemblies, Dictionary<string, List<DiagnosticTypeInfo>> referencedAssemblyTypes)
    {
        var builder = new StringBuilder();
        var safeAssemblyName = GeneratorHelpers.SanitizeIdentifier(assemblyName);
        var timestamp = DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm:ss");

        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("// Needlr Diagnostic Output Metadata");
        builder.AppendLine($"// Generated: {timestamp} UTC");
        builder.AppendLine("// This file contains diagnostic markdown content for extraction by MSBuild.");
        builder.AppendLine();
        builder.AppendLine("#nullable enable");
        builder.AppendLine();
        builder.AppendLine($"namespace {safeAssemblyName}.Generated;");
        builder.AppendLine();
        builder.AppendLine("/// <summary>");
        builder.AppendLine("/// Contains diagnostic output markdown content generated at compile time.");
        builder.AppendLine("/// Use NeedlrDiagnostics MSBuild property to enable file generation.");
        builder.AppendLine("/// </summary>");
        builder.AppendLine("[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"NexusLabs.Needlr.Generators\", \"1.0.0\")]");
        builder.AppendLine("internal static class NeedlrDiagnostics");
        builder.AppendLine("{");

        // Output path for MSBuild target
        builder.AppendLine($"    public const string OutputPath = @\"{GeneratorHelpers.EscapeStringLiteral(options.OutputPath)}\";");
        builder.AppendLine();

        // Generate all three diagnostic outputs when enabled
        var dependencyGraphContent = GenerateDependencyGraphMarkdown(discoveryResult, assemblyName, timestamp, options.TypeFilter, referencedTypeRegistryAssemblies, referencedAssemblyTypes);
        builder.AppendLine("    /// <summary>DependencyGraph.md content</summary>");
        builder.AppendLine($"    public const string DependencyGraph = @\"{GeneratorHelpers.EscapeVerbatimStringLiteral(dependencyGraphContent)}\";");
        builder.AppendLine();

        var lifetimeSummaryContent = GenerateLifetimeSummaryMarkdown(discoveryResult, assemblyName, timestamp, options.TypeFilter, referencedAssemblyTypes);
        builder.AppendLine("    /// <summary>LifetimeSummary.md content</summary>");
        builder.AppendLine($"    public const string LifetimeSummary = @\"{GeneratorHelpers.EscapeVerbatimStringLiteral(lifetimeSummaryContent)}\";");
        builder.AppendLine();

        var registrationIndexContent = GenerateRegistrationIndexMarkdown(discoveryResult, assemblyName, projectDirectory, timestamp, options.TypeFilter, referencedAssemblyTypes);
        builder.AppendLine("    /// <summary>RegistrationIndex.md content</summary>");
        builder.AppendLine($"    public const string RegistrationIndex = @\"{GeneratorHelpers.EscapeVerbatimStringLiteral(registrationIndexContent)}\";");
        builder.AppendLine();

        var analyzerStatusContent = GenerateAnalyzerStatusMarkdown(timestamp);
        builder.AppendLine("    /// <summary>AnalyzerStatus.md content</summary>");
        builder.AppendLine($"    public const string AnalyzerStatus = @\"{GeneratorHelpers.EscapeVerbatimStringLiteral(analyzerStatusContent)}\";");
        builder.AppendLine();

        var optionsSummaryContent = GenerateOptionsSummaryMarkdown(discoveryResult, assemblyName, timestamp, options.TypeFilter);
        builder.AppendLine("    /// <summary>OptionsSummary.md content</summary>");
        builder.AppendLine($"    public const string OptionsSummary = @\"{GeneratorHelpers.EscapeVerbatimStringLiteral(optionsSummaryContent)}\";");

        builder.AppendLine("}");

        return builder.ToString();
    }

    internal static string GenerateDependencyGraphMarkdown(DiscoveryResult discovery, string assemblyName, string timestamp, HashSet<string> typeFilter, IReadOnlyList<string> referencedTypeRegistryAssemblies, Dictionary<string, List<DiagnosticTypeInfo>> referencedAssemblyTypes)
    {
        var sb = new StringBuilder();
        var types = FilterTypes(discovery.InjectableTypes, typeFilter);

        sb.AppendLine("# Needlr Dependency Graph");
        sb.AppendLine();
        sb.AppendLine($"Generated: {timestamp} UTC");
        sb.AppendLine($"Assembly: {assemblyName}");
        sb.AppendLine();

        // Show referenced TypeRegistry assemblies with their types
        if (referencedAssemblyTypes.Count > 0)
        {
            sb.AppendLine("## Referenced Plugin Assemblies");
            sb.AppendLine();
            sb.AppendLine("Types from referenced assemblies with `[GenerateTypeRegistry]`:");
            sb.AppendLine();

            foreach (var kvp in referencedAssemblyTypes.OrderBy(kv => kv.Key))
            {
                var refAsm = kvp.Key;
                var refTypes = kvp.Value;
                
                sb.AppendLine($"### {refAsm}");
                sb.AppendLine();
                sb.AppendLine("```mermaid");
                sb.AppendLine("graph TD");

                // Group by lifetime
                var refSingletons = refTypes.Where(t => t.Lifetime == GeneratorLifetime.Singleton).ToList();
                var refScopeds = refTypes.Where(t => t.Lifetime == GeneratorLifetime.Scoped).ToList();
                var refTransients = refTypes.Where(t => t.Lifetime == GeneratorLifetime.Transient).ToList();

                if (refSingletons.Any())
                {
                    sb.AppendLine($"    subgraph Singleton[\"{refAsm} - Singleton\"]");
                    foreach (var type in refSingletons)
                    {
                        var shape = type.IsDecorator ? "[[" : (type.HasFactory ? "{{" : "[");
                        var endShape = type.IsDecorator ? "]]" : (type.HasFactory ? "}}" : "]");
                        sb.AppendLine($"        {GeneratorHelpers.GetMermaidNodeId(type.FullName)}{shape}\"{type.ShortName}\"{endShape}");
                    }
                    sb.AppendLine("    end");
                }
                if (refScopeds.Any())
                {
                    sb.AppendLine($"    subgraph Scoped[\"{refAsm} - Scoped\"]");
                    foreach (var type in refScopeds)
                    {
                        var shape = type.IsDecorator ? "[[" : (type.HasFactory ? "{{" : "[");
                        var endShape = type.IsDecorator ? "]]" : (type.HasFactory ? "}}" : "]");
                        sb.AppendLine($"        {GeneratorHelpers.GetMermaidNodeId(type.FullName)}{shape}\"{type.ShortName}\"{endShape}");
                    }
                    sb.AppendLine("    end");
                }
                if (refTransients.Any())
                {
                    sb.AppendLine($"    subgraph Transient[\"{refAsm} - Transient\"]");
                    foreach (var type in refTransients)
                    {
                        var shape = type.IsDecorator ? "[[" : (type.HasFactory ? "{{" : "[");
                        var endShape = type.IsDecorator ? "]]" : (type.HasFactory ? "}}" : "]");
                        sb.AppendLine($"        {GeneratorHelpers.GetMermaidNodeId(type.FullName)}{shape}\"{type.ShortName}\"{endShape}");
                    }
                    sb.AppendLine("    end");
                }

                // Show dependency edges within this assembly
                var refTypeNames = new HashSet<string>(refTypes.Select(t => t.ShortName), StringComparer.Ordinal);
                foreach (var type in refTypes)
                {
                    foreach (var dep in type.Dependencies)
                    {
                        var depShort = GeneratorHelpers.GetShortTypeName(dep);
                        var matchingType = refTypes.FirstOrDefault(t =>
                            t.ShortName == depShort ||
                            t.Interfaces.Any(i => GeneratorHelpers.GetShortTypeName(i) == depShort));
                        if (matchingType.FullName != null)
                        {
                            sb.AppendLine($"    {GeneratorHelpers.GetMermaidNodeId(type.FullName)} --> {GeneratorHelpers.GetMermaidNodeId(matchingType.FullName)}");
                        }
                    }
                }

                // Show factory→product edges (dotted arrows)
                var factorySources = refTypes.Where(t => t.HasFactory).ToList();
                foreach (var source in factorySources)
                {
                    var factoryName = source.ShortName + "Factory";
                    var matchingFactory = refTypes.FirstOrDefault(t => t.ShortName == factoryName);
                    if (matchingFactory.FullName != null)
                    {
                        sb.AppendLine($"    {GeneratorHelpers.GetMermaidNodeId(matchingFactory.FullName)} -.->|produces| {GeneratorHelpers.GetMermaidNodeId(source.FullName)}");
                    }
                }

                sb.AppendLine("```");
                sb.AppendLine();

                // Show summary table for this assembly
                sb.AppendLine($"| Service | Lifetime | Interfaces |");
                sb.AppendLine($"|---------|----------|------------|");
                foreach (var type in refTypes.OrderBy(t => t.ShortName))
                {
                    var interfaces = type.Interfaces.Any() ? string.Join(", ", type.Interfaces.Select(GeneratorHelpers.GetShortTypeName)) : "-";
                    sb.AppendLine($"| {type.ShortName} | {type.Lifetime} | {interfaces} |");
                }
                sb.AppendLine();
            }
        }

        var singletons = types.Where(t => t.Lifetime == GeneratorLifetime.Singleton).ToList();
        var scopeds = types.Where(t => t.Lifetime == GeneratorLifetime.Scoped).ToList();
        var transients = types.Where(t => t.Lifetime == GeneratorLifetime.Transient).ToList();

        sb.AppendLine("## Service Dependencies");
        sb.AppendLine();
        sb.AppendLine("```mermaid");
        sb.AppendLine("graph TD");

        // Emit subgraphs by lifetime
        if (singletons.Any())
        {
            sb.AppendLine("    subgraph Singleton");
            foreach (var type in singletons)
                sb.AppendLine($"        {GeneratorHelpers.GetMermaidNodeId(type.TypeName)}[\"{GeneratorHelpers.GetShortTypeName(type.TypeName)}\"]");
            sb.AppendLine("    end");
        }
        if (scopeds.Any())
        {
            sb.AppendLine("    subgraph Scoped");
            foreach (var type in scopeds)
                sb.AppendLine($"        {GeneratorHelpers.GetMermaidNodeId(type.TypeName)}[\"{GeneratorHelpers.GetShortTypeName(type.TypeName)}\"]");
            sb.AppendLine("    end");
        }
        if (transients.Any())
        {
            sb.AppendLine("    subgraph Transient");
            foreach (var type in transients)
                sb.AppendLine($"        {GeneratorHelpers.GetMermaidNodeId(type.TypeName)}[\"{GeneratorHelpers.GetShortTypeName(type.TypeName)}\"]");
            sb.AppendLine("    end");
        }

        // Emit edges for dependencies
        var typeNames = new HashSet<string>(types.Select(t => GeneratorHelpers.GetShortTypeName(t.TypeName)), StringComparer.Ordinal);
        foreach (var type in types)
        {
            foreach (var dep in type.ConstructorParameterTypes)
            {
                var depShort = GeneratorHelpers.GetShortTypeName(dep);
                // Find if we have a type implementing this interface
                var matchingType = types.FirstOrDefault(t =>
                    GeneratorHelpers.GetShortTypeName(t.TypeName) == depShort ||
                    t.InterfaceNames.Any(i => GeneratorHelpers.GetShortTypeName(i) == depShort));

                if (matchingType.TypeName != null)
                    sb.AppendLine($"    {GeneratorHelpers.GetMermaidNodeId(type.TypeName)} --> {GeneratorHelpers.GetMermaidNodeId(matchingType.TypeName)}");
            }
        }

        sb.AppendLine("```");
        sb.AppendLine();

        // Decorator chains section (aggregates host and plugin decorators)
        var pluginDecorators = referencedAssemblyTypes
            .SelectMany(kv => kv.Value.Where(t => t.IsDecorator).Select(t => (Assembly: kv.Key, Type: t)))
            .ToList();
        
        if (discovery.Decorators.Any() || pluginDecorators.Any())
        {
            sb.AppendLine("## Decorator Chains");
            sb.AppendLine();
            sb.AppendLine("```mermaid");
            sb.AppendLine("graph LR");

            // Host decorators - group by service type
            var decoratorsByService = discovery.Decorators
                .GroupBy(d => d.ServiceTypeName)
                .OrderBy(g => g.Key);

            foreach (var serviceGroup in decoratorsByService)
            {
                var serviceShortName = GeneratorHelpers.GetShortTypeName(serviceGroup.Key);
                var orderedDecorators = serviceGroup.OrderByDescending(d => d.Order).ToList();

                // Find the underlying implementation for this service
                var implementation = types.FirstOrDefault(t =>
                    t.InterfaceNames.Any(i => GeneratorHelpers.GetShortTypeName(i) == serviceShortName) &&
                    !discovery.Decorators.Any(d => GeneratorHelpers.GetShortTypeName(d.DecoratorTypeName) == GeneratorHelpers.GetShortTypeName(t.TypeName)));

                // Build the chain: highest order decorator -> ... -> lowest order decorator -> implementation
                for (int i = 0; i < orderedDecorators.Count; i++)
                {
                    var decorator = orderedDecorators[i];
                    var decoratorId = GeneratorHelpers.GetMermaidNodeId(decorator.DecoratorTypeName);
                    var decoratorName = GeneratorHelpers.GetShortTypeName(decorator.DecoratorTypeName);

                    // Add node definition
                    sb.AppendLine($"    {decoratorId}[[\"{decoratorName}\"]]");

                    // Add edge to next decorator or implementation
                    if (i < orderedDecorators.Count - 1)
                    {
                        var nextDecorator = orderedDecorators[i + 1];
                        sb.AppendLine($"    {decoratorId} --> {GeneratorHelpers.GetMermaidNodeId(nextDecorator.DecoratorTypeName)}");
                    }
                    else if (implementation.TypeName != null)
                    {
                        var implId = GeneratorHelpers.GetMermaidNodeId(implementation.TypeName);
                        var implName = GeneratorHelpers.GetShortTypeName(implementation.TypeName);
                        sb.AppendLine($"    {implId}[\"{implName}\"]");
                        sb.AppendLine($"    {decoratorId} --> {implId}");
                    }
                }
            }

            // Plugin decorators (we don't have chain order info, just show the decorator types)
            foreach (var (assembly, type) in pluginDecorators.OrderBy(x => x.Type.ShortName))
            {
                var decoratorId = GeneratorHelpers.GetMermaidNodeId(type.FullName);
                var decoratorName = type.ShortName;
                sb.AppendLine($"    {decoratorId}[[\"{decoratorName}\"]]");
            }

            sb.AppendLine("```");
            sb.AppendLine();
        }

        // Intercepted services section (aggregates host and plugin interceptors)
        var interceptedServices = discovery.InterceptedServices.ToList();
        var pluginInterceptors = referencedAssemblyTypes
            .SelectMany(kv => kv.Value.Where(t => t.HasInterceptorProxy).Select(t => (Assembly: kv.Key, Type: t)))
            .ToList();
        
        if (interceptedServices.Any() || pluginInterceptors.Any())
        {
            sb.AppendLine("## Intercepted Services");
            sb.AppendLine();
            sb.AppendLine("```mermaid");
            sb.AppendLine("graph LR");

            // Host intercepted services
            foreach (var service in interceptedServices.OrderBy(s => s.TypeName))
            {
                var targetId = GeneratorHelpers.GetMermaidNodeId(service.TypeName);
                var targetName = GeneratorHelpers.GetShortTypeName(service.TypeName);
                var proxyId = targetId + "_Proxy";
                var proxyName = targetName + "_InterceptorProxy";

                // Target service
                sb.AppendLine($"    {targetId}[\"{targetName}\"]");
                // Proxy with stadium shape
                sb.AppendLine($"    {proxyId}[[\"{proxyName}\"]]");
                // Edge showing proxy wraps target
                sb.AppendLine($"    {proxyId} -.->|wraps| {targetId}");
                
                // Show interceptors applied
                foreach (var interceptorType in service.AllInterceptorTypeNames)
                {
                    var interceptorId = GeneratorHelpers.GetMermaidNodeId(interceptorType);
                    var interceptorName = GeneratorHelpers.GetShortTypeName(interceptorType);
                    sb.AppendLine($"    {interceptorId}([[\"{interceptorName}\"]])");
                    sb.AppendLine($"    {proxyId} --> {interceptorId}");
                }
            }

            // Plugin intercepted services
            foreach (var (assembly, type) in pluginInterceptors.OrderBy(x => x.Type.ShortName))
            {
                var targetId = GeneratorHelpers.GetMermaidNodeId(type.FullName);
                var targetName = type.ShortName;
                var proxyId = targetId + "_Proxy";
                var proxyName = targetName + "_InterceptorProxy";

                sb.AppendLine($"    {targetId}[\"{targetName}\"]");
                sb.AppendLine($"    {proxyId}[[\"{proxyName}\"]]");
                sb.AppendLine($"    {proxyId} -.->|wraps| {targetId}");
            }

            sb.AppendLine("```");
            sb.AppendLine();
        }

        // Keyed services section
        var keyedTypes = types.Where(t => t.IsKeyed).ToList();
        if (keyedTypes.Any())
        {
            sb.AppendLine("## Keyed Services");
            sb.AppendLine();
            sb.AppendLine("```mermaid");
            sb.AppendLine("graph TD");

            // Group by service key
            var typesByKey = keyedTypes
                .SelectMany(t => t.ServiceKeys.Select(k => (Key: k, Type: t)))
                .GroupBy(x => x.Key)
                .OrderBy(g => g.Key);

            foreach (var keyGroup in typesByKey)
            {
                var safeKey = GeneratorHelpers.SanitizeIdentifier(keyGroup.Key);
                sb.AppendLine($"    subgraph key_{safeKey}[\"{keyGroup.Key}\"]");
                foreach (var item in keyGroup.OrderBy(x => x.Type.TypeName))
                {
                    var nodeId = GeneratorHelpers.GetMermaidNodeId(item.Type.TypeName);
                    var nodeName = GeneratorHelpers.GetShortTypeName(item.Type.TypeName);
                    sb.AppendLine($"        {nodeId}[\"{nodeName}\"]");
                }
                sb.AppendLine("    end");
            }

            sb.AppendLine("```");
            sb.AppendLine();
        }

        // Plugin assemblies section
        var plugins = FilterPluginTypes(discovery.PluginTypes, typeFilter);
        if (plugins.Any())
        {
            sb.AppendLine("## Plugin Assemblies");
            sb.AppendLine();
            sb.AppendLine("```mermaid");
            sb.AppendLine("graph TD");

            // Group plugins by assembly
            var pluginsByAssembly = plugins
                .GroupBy(p => p.AssemblyName)
                .OrderBy(g => g.Key);

            foreach (var asmGroup in pluginsByAssembly)
            {
                var safeAsm = GeneratorHelpers.SanitizeIdentifier(asmGroup.Key);
                var shortAsm = GeneratorHelpers.GetShortTypeName(asmGroup.Key);
                sb.AppendLine($"    subgraph asm_{safeAsm}[\"{shortAsm}\"]");
                foreach (var plugin in asmGroup.OrderBy(p => p.TypeName))
                {
                    var nodeId = GeneratorHelpers.GetMermaidNodeId(plugin.TypeName);
                    var nodeName = GeneratorHelpers.GetShortTypeName(plugin.TypeName);
                    // Use stadium shape for plugins
                    sb.AppendLine($"        {nodeId}([\"{nodeName}\"])");
                }
                sb.AppendLine("    end");
            }

            sb.AppendLine("```");
            sb.AppendLine();
        }

        // Factory services section (aggregates host and plugin factories)
        var factories = FilterFactories(discovery.Factories, typeFilter);
        var pluginFactories = referencedAssemblyTypes
            .SelectMany(kv => kv.Value.Where(t => t.HasFactory).Select(t => (Assembly: kv.Key, Type: t)))
            .ToList();
        
        if (factories.Any() || pluginFactories.Any())
        {
            sb.AppendLine("## Factory Services");
            sb.AppendLine();
            sb.AppendLine("```mermaid");
            sb.AppendLine("graph LR");

            // Host factories
            foreach (var factory in factories.OrderBy(f => f.TypeName))
            {
                var sourceNodeId = GeneratorHelpers.GetMermaidNodeId(factory.TypeName);
                var sourceName = GeneratorHelpers.GetShortTypeName(factory.TypeName);
                var factoryNodeId = sourceNodeId + "Factory";
                var factoryName = sourceName + "Factory";

                // Generated factory with regular shape
                sb.AppendLine($"    {factoryNodeId}[\"{factoryName}\"]");
                // Source type (product) with hexagon shape
                sb.AppendLine($"    {sourceNodeId}{{{{\"{sourceName}\"}}}}");
                // Edge showing factory produces the type (dotted arrow)
                sb.AppendLine($"    {factoryNodeId} -.->|produces| {sourceNodeId}");
            }

            // Plugin factories
            foreach (var (assembly, type) in pluginFactories.OrderBy(f => f.Type.ShortName))
            {
                var sourceNodeId = GeneratorHelpers.GetMermaidNodeId(type.FullName);
                var sourceName = type.ShortName;
                var factoryNodeId = sourceNodeId + "Factory";
                var factoryName = sourceName + "Factory";

                // Generated factory with regular shape
                sb.AppendLine($"    {factoryNodeId}[\"{factoryName}\"]");
                // Source type (product) with hexagon shape
                sb.AppendLine($"    {sourceNodeId}{{{{\"{sourceName}\"}}}}");
                // Edge showing factory produces the type (dotted arrow)
                sb.AppendLine($"    {factoryNodeId} -.->|produces| {sourceNodeId}");
            }

            sb.AppendLine("```");
            sb.AppendLine();
        }

        // Interface mapping section
        var typesWithInterfaces = types.Where(t => t.InterfaceNames.Length > 0).ToList();
        if (typesWithInterfaces.Any())
        {
            sb.AppendLine("## Interface Mapping");
            sb.AppendLine();
            sb.AppendLine("```mermaid");
            sb.AppendLine("graph LR");

            foreach (var type in typesWithInterfaces.OrderBy(t => t.TypeName))
            {
                var implId = GeneratorHelpers.GetMermaidNodeId(type.TypeName);
                var implName = GeneratorHelpers.GetShortTypeName(type.TypeName);
                sb.AppendLine($"    {implId}[\"{implName}\"]");

                foreach (var iface in type.InterfaceNames)
                {
                    var ifaceId = GeneratorHelpers.GetMermaidNodeId(iface);
                    var ifaceName = GeneratorHelpers.GetShortTypeName(iface);
                    // Interface uses rounded box, dotted edge points from interface to impl
                    sb.AppendLine($"    {ifaceId}((\"{ifaceName}\"))");
                    sb.AppendLine($"    {ifaceId} -.-> {implId}");
                }
            }

            sb.AppendLine("```");
            sb.AppendLine();
        }

        // Complexity metrics section
        sb.AppendLine("## Complexity Metrics");
        sb.AppendLine();
        sb.AppendLine("| Metric | Value |");
        sb.AppendLine("|--------|-------|");

        sb.AppendLine($"| Total Services | {types.Count} |");

        // Calculate max dependency depth using BFS
        var maxDepth = CalculateMaxDependencyDepth(types);
        sb.AppendLine($"| Max Dependency Depth | {maxDepth} |");

        // Calculate hub services (services that appear as dependencies in 3+ other services)
        var hubServices = CalculateHubServices(types, 3);
        sb.AppendLine($"| Hub Services (≥3 dependents) | {hubServices.Count} |");

        if (hubServices.Any())
        {
            sb.AppendLine();
            sb.AppendLine("**Hub Services:** " + string.Join(", ", hubServices.Select(h => $"{GeneratorHelpers.GetShortTypeName(h.TypeName)} ({h.DependentCount})")));
        }

        sb.AppendLine();

        // Dependency details table
        sb.AppendLine("## Dependency Details");
        sb.AppendLine();
        sb.AppendLine("| Service | Lifetime | Dependencies |");
        sb.AppendLine("|---------|----------|--------------|");

        foreach (var type in types.OrderBy(t => t.TypeName))
        {
            var deps = type.ConstructorParameterTypes.Any()
                ? string.Join(", ", type.ConstructorParameterTypes.Select(GeneratorHelpers.GetShortTypeName))
                : "-";
            sb.AppendLine($"| {GeneratorHelpers.GetShortTypeName(type.TypeName)} | {type.Lifetime} | {deps} |");
        }

        return sb.ToString();
    }

    internal static string GenerateLifetimeSummaryMarkdown(DiscoveryResult discovery, string assemblyName, string timestamp, HashSet<string> typeFilter, Dictionary<string, List<DiagnosticTypeInfo>> referencedAssemblyTypes)
    {
        var sb = new StringBuilder();
        var types = FilterTypes(discovery.InjectableTypes, typeFilter);

        var singletons = types.Where(t => t.Lifetime == GeneratorLifetime.Singleton).ToList();
        var scopeds = types.Where(t => t.Lifetime == GeneratorLifetime.Scoped).ToList();
        var transients = types.Where(t => t.Lifetime == GeneratorLifetime.Transient).ToList();
        var total = types.Count;

        sb.AppendLine("# Needlr Lifetime Summary");
        sb.AppendLine();
        sb.AppendLine($"Generated: {timestamp} UTC");
        sb.AppendLine($"Assembly: {assemblyName}");
        sb.AppendLine();

        // Referenced plugin assemblies lifetime breakdown
        if (referencedAssemblyTypes.Count > 0)
        {
            sb.AppendLine("## Referenced Plugin Assemblies");
            sb.AppendLine();

            foreach (var kvp in referencedAssemblyTypes.OrderBy(kv => kv.Key))
            {
                var refAsm = kvp.Key;
                var refTypes = kvp.Value;
                var refSingletons = refTypes.Count(t => t.Lifetime == GeneratorLifetime.Singleton);
                var refScopeds = refTypes.Count(t => t.Lifetime == GeneratorLifetime.Scoped);
                var refTransients = refTypes.Count(t => t.Lifetime == GeneratorLifetime.Transient);
                var refTotal = refTypes.Count;

                sb.AppendLine($"### {refAsm}");
                sb.AppendLine();
                sb.AppendLine("| Lifetime | Count | % |");
                sb.AppendLine("|----------|-------|---|");
                if (refTotal > 0)
                {
                    sb.AppendLine($"| Singleton | {refSingletons} | {GeneratorHelpers.Percentage(refSingletons, refTotal)}% |");
                    sb.AppendLine($"| Scoped | {refScopeds} | {GeneratorHelpers.Percentage(refScopeds, refTotal)}% |");
                    sb.AppendLine($"| Transient | {refTransients} | {GeneratorHelpers.Percentage(refTransients, refTotal)}% |");
                    sb.AppendLine($"| **Total** | **{refTotal}** | 100% |");
                }
                sb.AppendLine();
            }
        }

        sb.AppendLine("## Registration Counts");
        sb.AppendLine();
        sb.AppendLine("| Lifetime | Count | % |");
        sb.AppendLine("|----------|-------|---|");

        if (total > 0)
        {
            sb.AppendLine($"| Singleton | {singletons.Count} | {GeneratorHelpers.Percentage(singletons.Count, total)}% |");
            sb.AppendLine($"| Scoped | {scopeds.Count} | {GeneratorHelpers.Percentage(scopeds.Count, total)}% |");
            sb.AppendLine($"| Transient | {transients.Count} | {GeneratorHelpers.Percentage(transients.Count, total)}% |");
            sb.AppendLine($"| **Total** | **{total}** | 100% |");
        }
        else
        {
            sb.AppendLine("| (none) | 0 | - |");
        }

        sb.AppendLine();

        // List by category
        if (singletons.Any())
        {
            sb.AppendLine($"## Singleton ({singletons.Count})");
            sb.AppendLine();
            foreach (var type in singletons.OrderBy(t => t.TypeName))
                sb.AppendLine($"- {GeneratorHelpers.GetShortTypeName(type.TypeName)}");
            sb.AppendLine();
        }

        if (scopeds.Any())
        {
            sb.AppendLine($"## Scoped ({scopeds.Count})");
            sb.AppendLine();
            foreach (var type in scopeds.OrderBy(t => t.TypeName))
                sb.AppendLine($"- {GeneratorHelpers.GetShortTypeName(type.TypeName)}");
            sb.AppendLine();
        }

        if (transients.Any())
        {
            sb.AppendLine($"## Transient ({transients.Count})");
            sb.AppendLine();
            foreach (var type in transients.OrderBy(t => t.TypeName))
                sb.AppendLine($"- {GeneratorHelpers.GetShortTypeName(type.TypeName)}");
            sb.AppendLine();
        }

        return sb.ToString();
    }

    internal static string GenerateRegistrationIndexMarkdown(DiscoveryResult discovery, string assemblyName, string? projectDirectory, string timestamp, HashSet<string> typeFilter, Dictionary<string, List<DiagnosticTypeInfo>> referencedAssemblyTypes)
    {
        var sb = new StringBuilder();
        var types = FilterTypes(discovery.InjectableTypes, typeFilter);
        var plugins = FilterPluginTypes(discovery.PluginTypes, typeFilter);
        var decorators = FilterDecorators(discovery.Decorators, typeFilter);

        sb.AppendLine("# Needlr Registration Index");
        sb.AppendLine();
        sb.AppendLine($"Generated: {timestamp} UTC");
        sb.AppendLine($"Assembly: {assemblyName}");
        sb.AppendLine();

        // Referenced plugin assemblies services
        if (referencedAssemblyTypes.Count > 0)
        {
            sb.AppendLine("## Referenced Plugin Assemblies");
            sb.AppendLine();

            foreach (var kvp in referencedAssemblyTypes.OrderBy(kv => kv.Key))
            {
                var refAsm = kvp.Key;
                var refTypes = kvp.Value;

                sb.AppendLine($"### {refAsm} ({refTypes.Count} services)");
                sb.AppendLine();
                sb.AppendLine("| # | Interface | Implementation | Lifetime |");
                sb.AppendLine("|---|-----------|----------------|----------|");

                var index = 1;
                foreach (var type in refTypes.OrderBy(t => t.ShortName))
                {
                    var iface = type.Interfaces.FirstOrDefault() ?? "-";
                    sb.AppendLine($"| {index} | {GeneratorHelpers.GetShortTypeName(iface)} | {type.ShortName} | {type.Lifetime} |");
                    index++;
                }
                sb.AppendLine();
            }
        }

        // Services table
        sb.AppendLine($"## Services ({types.Count})");
        sb.AppendLine();

        if (types.Any())
        {
            sb.AppendLine("| # | Interface | Implementation | Lifetime | Source |");
            sb.AppendLine("|---|-----------|----------------|----------|--------|");

            var index = 1;
            foreach (var type in types.OrderBy(t => t.TypeName))
            {
                var iface = type.InterfaceNames.FirstOrDefault() ?? "-";
                var source = BreadcrumbWriter.GetRelativeSourcePath(type.SourceFilePath, projectDirectory);
                sb.AppendLine($"| {index} | {GeneratorHelpers.GetShortTypeName(iface)} | {GeneratorHelpers.GetShortTypeName(type.TypeName)} | {type.Lifetime} | {source} |");
                index++;
            }
            sb.AppendLine();
        }
        else
        {
            sb.AppendLine("No injectable services discovered.");
            sb.AppendLine();
        }

        // Decorators section (aggregates host and plugin decorators)
        var pluginDecorators = referencedAssemblyTypes
            .SelectMany(kv => kv.Value.Where(t => t.IsDecorator).Select(t => (Assembly: kv.Key, Type: t)))
            .ToList();
        
        if (decorators.Any() || pluginDecorators.Any())
        {
            var totalCount = decorators.Count + pluginDecorators.Count;
            sb.AppendLine($"## Decorators ({totalCount})");
            sb.AppendLine();
            sb.AppendLine("| Service | Decorator Chain | Assembly |");
            sb.AppendLine("|---------|-----------------|----------|");

            // Host decorators
            var decoratorsByTarget = decorators
                .GroupBy(d => d.ServiceTypeName)
                .OrderBy(g => g.Key);

            foreach (var group in decoratorsByTarget)
            {
                var chain = string.Join(" → ",
                    group.OrderBy(d => d.Order)
                         .Select(d => GeneratorHelpers.GetShortTypeName(d.DecoratorTypeName)));
                sb.AppendLine($"| {GeneratorHelpers.GetShortTypeName(group.Key)} | {chain} | (host) |");
            }

            // Plugin decorators
            foreach (var (assembly, type) in pluginDecorators.OrderBy(x => x.Type.ShortName))
            {
                // For plugin decorators, we show them individually since we don't have chain info
                var serviceName = type.Interfaces.FirstOrDefault() ?? "-";
                sb.AppendLine($"| {GeneratorHelpers.GetShortTypeName(serviceName)} | {type.ShortName} | {assembly} |");
            }
            sb.AppendLine();
        }

        // Interceptors section (aggregates host and plugin interceptors)
        var interceptedServices = discovery.InterceptedServices.ToList();
        var pluginIntercepted = referencedAssemblyTypes
            .SelectMany(kv => kv.Value.Where(t => t.HasInterceptorProxy).Select(t => (Assembly: kv.Key, Type: t)))
            .ToList();
        
        if (interceptedServices.Any() || pluginIntercepted.Any())
        {
            var totalCount = interceptedServices.Count + pluginIntercepted.Count;
            sb.AppendLine($"## Intercepted Services ({totalCount})");
            sb.AppendLine();
            sb.AppendLine("| Service | Interceptors | Proxy | Assembly |");
            sb.AppendLine("|---------|--------------|-------|----------|");

            // Host intercepted services
            foreach (var service in interceptedServices.OrderBy(s => s.TypeName))
            {
                var serviceName = GeneratorHelpers.GetShortTypeName(service.TypeName);
                var interceptors = string.Join(", ", service.AllInterceptorTypeNames.Select(GeneratorHelpers.GetShortTypeName));
                var proxyName = serviceName + "_InterceptorProxy";
                sb.AppendLine($"| {serviceName} | {interceptors} | {proxyName} | (host) |");
            }

            // Plugin intercepted services
            foreach (var (assembly, type) in pluginIntercepted.OrderBy(x => x.Type.ShortName))
            {
                var proxyName = type.ShortName + "_InterceptorProxy";
                sb.AppendLine($"| {type.ShortName} | (see plugin) | {proxyName} | {assembly} |");
            }
            sb.AppendLine();
        }

        // Factories section (aggregates host and plugin factories)
        var factories = discovery.Factories.ToList();
        var pluginFactories = referencedAssemblyTypes
            .SelectMany(kv => kv.Value.Where(t => t.HasFactory).Select(t => (Assembly: kv.Key, Type: t)))
            .ToList();
        
        if (factories.Any() || pluginFactories.Any())
        {
            var totalCount = factories.Count + pluginFactories.Count;
            sb.AppendLine($"## Factories ({totalCount})");
            sb.AppendLine();
            sb.AppendLine("| Source Type | Factory Interface | Generated Factory | Assembly |");
            sb.AppendLine("|-------------|-------------------|-------------------|----------|");

            // Host factories
            foreach (var factory in factories.OrderBy(f => f.TypeName))
            {
                var sourceName = factory.SimpleTypeName;
                var factoryInterface = "I" + sourceName + "Factory";
                var factoryImpl = sourceName + "Factory";
                sb.AppendLine($"| {sourceName} | {factoryInterface} | {factoryImpl} | (host) |");
            }

            // Plugin factories
            foreach (var (assembly, type) in pluginFactories.OrderBy(x => x.Type.ShortName))
            {
                var factoryInterface = "I" + type.ShortName + "Factory";
                var factoryImpl = type.ShortName + "Factory";
                sb.AppendLine($"| {type.ShortName} | {factoryInterface} | {factoryImpl} | {assembly} |");
            }
            sb.AppendLine();
        }

        // Plugins section
        if (plugins.Any())
        {
            var orderedPlugins = plugins.OrderBy(p => p.Order).ThenBy(p => p.TypeName);

            sb.AppendLine($"## Plugins ({plugins.Count})");
            sb.AppendLine();
            sb.AppendLine("| Order | Plugin | Interfaces |");
            sb.AppendLine("|-------|--------|------------|");

            foreach (var plugin in orderedPlugins)
            {
                var interfaces = string.Join(", ", plugin.InterfaceNames.Select(GeneratorHelpers.GetShortTypeName));
                sb.AppendLine($"| {plugin.Order} | {GeneratorHelpers.GetShortTypeName(plugin.TypeName)} | {interfaces} |");
            }
            sb.AppendLine();
        }

        // Keyed Services section
        var keyedTypes = types.Where(t => t.ServiceKeys.Length > 0).ToList();
        if (keyedTypes.Any())
        {
            sb.AppendLine($"## Keyed Services ({keyedTypes.Sum(t => t.ServiceKeys.Length)})");
            sb.AppendLine();
            sb.AppendLine("| Key | Interface | Implementation | Lifetime |");
            sb.AppendLine("|-----|-----------|----------------|----------|");

            foreach (var type in keyedTypes.OrderBy(t => t.TypeName))
            {
                foreach (var key in type.ServiceKeys)
                {
                    var iface = type.InterfaceNames.FirstOrDefault() ?? "-";
                    sb.AppendLine($"| `\"{key}\"` | {GeneratorHelpers.GetShortTypeName(iface)} | {GeneratorHelpers.GetShortTypeName(type.TypeName)} | {type.Lifetime} |");
                }
            }
            sb.AppendLine();
        }

        return sb.ToString();
    }

    internal static string GenerateAnalyzerStatusMarkdown(string timestamp)
    {
        var sb = new StringBuilder();

        sb.AppendLine("# Needlr Analyzer Status");
        sb.AppendLine();
        sb.AppendLine($"Generated: {timestamp} UTC");
        sb.AppendLine();
        sb.AppendLine("## Active Analyzers");
        sb.AppendLine();
        sb.AppendLine("| ID | Name | Status | Default Severity | Description |");
        sb.AppendLine("|:---|:-----|:-------|:-----------------|:------------|");
        sb.AppendLine("| NDLRCOR001 | Reflection in AOT | ⚪ Conditional | Error | Detects reflection APIs in AOT projects |");
        sb.AppendLine("| NDLRCOR002 | Plugin Constructor | ✅ Active | Warning | Plugins should have parameterless constructors |");
        sb.AppendLine("| NDLRCOR003 | DeferToContainer in Generated | ✅ Active | Error | [DeferToContainer] must be on user code |");
        sb.AppendLine("| NDLRCOR004 | Global Namespace Type | ✅ Active | Warning | Types in global namespace may not be discovered |");
        sb.AppendLine("| NDLRCOR005 | Lifetime Mismatch | ✅ Active | Warning | Detects captive dependencies |");
        sb.AppendLine("| NDLRCOR006 | Circular Dependency | ✅ Active | Error | Detects circular service dependencies |");
        sb.AppendLine("| NDLRCOR007 | Intercept Type | ✅ Active | Error | Intercept type must implement IMethodInterceptor |");
        sb.AppendLine("| NDLRCOR008 | Intercept Without Interface | ✅ Active | Warning | [Intercept] requires interface-based class |");
        sb.AppendLine("| NDLRCOR009 | Lazy Resolution | ✅ Active | Info | Lazy<T> references undiscovered type |");
        sb.AppendLine("| NDLRCOR010 | Collection Resolution | ✅ Active | Info | IEnumerable<T> has no implementations |");
        sb.AppendLine("| NDLRCOR011 | Keyed Service Usage | ✅ Active | Info | Tracks [FromKeyedServices] parameter usage |");
        sb.AppendLine();
        sb.AppendLine("## Mode");
        sb.AppendLine();
        sb.AppendLine("**Source Generation**: Enabled (GenerateTypeRegistry detected)");
        sb.AppendLine();
        sb.AppendLine("## Configuration");
        sb.AppendLine();
        sb.AppendLine("Analyzer severity can be configured via `.editorconfig`:");
        sb.AppendLine();
        sb.AppendLine("```ini");
        sb.AppendLine("# Example: Suppress Lazy resolution warnings");
        sb.AppendLine("dotnet_diagnostic.NDLRCOR009.severity = none");
        sb.AppendLine();
        sb.AppendLine("# Example: Promote to warning");
        sb.AppendLine("dotnet_diagnostic.NDLRCOR009.severity = warning");
        sb.AppendLine("```");
        sb.AppendLine();

        return sb.ToString();
    }

    internal static IReadOnlyList<DiscoveredType> FilterTypes(IReadOnlyList<DiscoveredType> types, HashSet<string> filter)
    {
        if (filter == null || filter.Count == 0)
            return types;

        return types.Where(t => 
            filter.Contains(t.TypeName) ||                                      // global::TestApp.OrderService
            filter.Contains(GeneratorHelpers.GetShortTypeName(t.TypeName)) ||                    // OrderService
            filter.Contains(GeneratorHelpers.StripGlobalPrefix(t.TypeName)))                     // TestApp.OrderService
                    .ToList();
    }

    internal static IReadOnlyList<DiscoveredPlugin> FilterPluginTypes(IReadOnlyList<DiscoveredPlugin> plugins, HashSet<string> filter)
    {
        if (filter == null || filter.Count == 0)
            return plugins;

        return plugins.Where(p => 
            filter.Contains(p.TypeName) ||
            filter.Contains(GeneratorHelpers.GetShortTypeName(p.TypeName)) ||
            filter.Contains(GeneratorHelpers.StripGlobalPrefix(p.TypeName)))
                      .ToList();
    }

    internal static IReadOnlyList<DiscoveredDecorator> FilterDecorators(IReadOnlyList<DiscoveredDecorator> decorators, HashSet<string> filter)
    {
        if (filter == null || filter.Count == 0)
            return decorators;

        return decorators.Where(d => 
            filter.Contains(d.DecoratorTypeName) ||
            filter.Contains(GeneratorHelpers.GetShortTypeName(d.DecoratorTypeName)) ||
            filter.Contains(GeneratorHelpers.StripGlobalPrefix(d.DecoratorTypeName)) ||
            filter.Contains(d.ServiceTypeName) ||
            filter.Contains(GeneratorHelpers.GetShortTypeName(d.ServiceTypeName)) ||
            filter.Contains(GeneratorHelpers.StripGlobalPrefix(d.ServiceTypeName)))
                         .ToList();
    }

    internal static IReadOnlyList<DiscoveredFactory> FilterFactories(IReadOnlyList<DiscoveredFactory> factories, HashSet<string> filter)
    {
        if (filter == null || filter.Count == 0)
            return factories;

        return factories.Where(f => 
            filter.Contains(f.TypeName) ||
            filter.Contains(GeneratorHelpers.GetShortTypeName(f.TypeName)) ||
            filter.Contains(GeneratorHelpers.StripGlobalPrefix(f.TypeName)))
                        .ToList();
    }

    internal static int CalculateMaxDependencyDepth(IReadOnlyList<DiscoveredType> types)
    {
        if (types.Count == 0) return 0;

        // Build a lookup from interface/type name to the type that provides it
        var providerLookup = new Dictionary<string, DiscoveredType>(StringComparer.Ordinal);
        foreach (var type in types)
        {
            providerLookup[GeneratorHelpers.GetShortTypeName(type.TypeName)] = type;
            foreach (var iface in type.InterfaceNames)
                providerLookup[GeneratorHelpers.GetShortTypeName(iface)] = type;
        }

        // Calculate depth for each type using memoization
        var depthCache = new Dictionary<string, int>(StringComparer.Ordinal);
        int maxDepth = 0;

        foreach (var type in types)
        {
            var depth = GetDepth(type, providerLookup, depthCache, new HashSet<string>());
            if (depth > maxDepth) maxDepth = depth;
        }

        return maxDepth;
    }

    internal static int GetDepth(DiscoveredType type, Dictionary<string, DiscoveredType> providerLookup, Dictionary<string, int> cache, HashSet<string> visiting)
    {
        var key = GeneratorHelpers.GetShortTypeName(type.TypeName);
        
        if (cache.TryGetValue(key, out var cached))
            return cached;

        // Cycle detection
        if (!visiting.Add(key))
            return 0;

        int maxChildDepth = 0;
        foreach (var dep in type.ConstructorParameterTypes)
        {
            var depShort = GeneratorHelpers.GetShortTypeName(dep);
            if (providerLookup.TryGetValue(depShort, out var depType))
            {
                var childDepth = GetDepth(depType, providerLookup, cache, visiting);
                if (childDepth > maxChildDepth)
                    maxChildDepth = childDepth;
            }
        }

        visiting.Remove(key);
        var result = maxChildDepth + 1;
        cache[key] = result;
        return result;
    }

    internal static List<(string TypeName, int DependentCount)> CalculateHubServices(IReadOnlyList<DiscoveredType> types, int minDependents)
    {
        // Count how many times each type/interface appears as a dependency
        var dependentCounts = new Dictionary<string, int>(StringComparer.Ordinal);

        foreach (var type in types)
        {
            foreach (var dep in type.ConstructorParameterTypes)
            {
                var depShort = GeneratorHelpers.GetShortTypeName(dep);
                if (!dependentCounts.ContainsKey(depShort))
                    dependentCounts[depShort] = 0;
                dependentCounts[depShort]++;
            }
        }

        // Find types that are depended upon by minDependents or more services
        var hubs = new List<(string TypeName, int DependentCount)>();
        foreach (var type in types)
        {
            var shortName = GeneratorHelpers.GetShortTypeName(type.TypeName);
            var count = 0;

            // Check if this type's name or any of its interfaces is depended upon
            if (dependentCounts.TryGetValue(shortName, out var c1))
                count += c1;

            foreach (var iface in type.InterfaceNames)
            {
                if (dependentCounts.TryGetValue(GeneratorHelpers.GetShortTypeName(iface), out var c2))
                    count += c2;
            }

            if (count >= minDependents)
                hubs.Add((type.TypeName, count));
        }

        return hubs.OrderByDescending(h => h.DependentCount).ToList();
    }

    internal static string GenerateOptionsSummaryMarkdown(DiscoveryResult discovery, string assemblyName, string timestamp, HashSet<string> typeFilter)
    {
        var sb = new StringBuilder();
        var options = FilterOptions(discovery.Options, typeFilter);

        sb.AppendLine("# Needlr Options Summary");
        sb.AppendLine();
        sb.AppendLine($"Generated: {timestamp} UTC");
        sb.AppendLine($"Assembly: {assemblyName}");
        sb.AppendLine();

        if (options.Count == 0)
        {
            sb.AppendLine("*No options classes discovered. Add `[Options]` attribute to configuration classes.*");
            sb.AppendLine();
            return sb.ToString();
        }

        sb.AppendLine($"## Overview");
        sb.AppendLine();
        sb.AppendLine($"| Metric | Count |");
        sb.AppendLine($"|:-------|------:|");
        sb.AppendLine($"| Total Options Classes | {options.Count} |");
        sb.AppendLine($"| Named Options | {options.Count(o => o.IsNamed)} |");
        sb.AppendLine($"| With Validation | {options.Count(o => o.ValidateOnStart)} |");
        sb.AppendLine($"| With External Validator | {options.Count(o => o.HasExternalValidator)} |");
        sb.AppendLine();

        // Options table
        sb.AppendLine("## Options Classes");
        sb.AppendLine();
        sb.AppendLine("| Class | Section | Name | ValidateOnStart | Validator |");
        sb.AppendLine("|:------|:--------|:-----|:---------------:|:----------|");

        foreach (var opt in options.OrderBy(o => o.SectionName).ThenBy(o => o.TypeName))
        {
            var shortName = GeneratorHelpers.GetShortTypeName(opt.TypeName);
            var namedLabel = opt.IsNamed ? opt.Name : "-";
            var validateIcon = opt.ValidateOnStart ? "✅" : "❌";
            var validatorInfo = GetValidatorDescription(opt);

            sb.AppendLine($"| `{shortName}` | `{opt.SectionName}` | {namedLabel} | {validateIcon} | {validatorInfo} |");
        }

        sb.AppendLine();

        // Detailed breakdown by section
        var sectionGroups = options.GroupBy(o => o.SectionName).OrderBy(g => g.Key);
        
        sb.AppendLine("## Configuration Sections");
        sb.AppendLine();

        foreach (var group in sectionGroups)
        {
            sb.AppendLine($"### `{group.Key}`");
            sb.AppendLine();

            foreach (var opt in group.OrderBy(o => o.TypeName))
            {
                var shortName = GeneratorHelpers.GetShortTypeName(opt.TypeName);
                sb.AppendLine($"**{shortName}**");
                sb.AppendLine();
                sb.AppendLine($"- Configuration Path: `{group.Key}`");
                
                if (opt.IsNamed)
                    sb.AppendLine($"- Named Options: `{opt.Name}`");
                
                sb.AppendLine($"- Validate On Start: {(opt.ValidateOnStart ? "Yes" : "No")}");

                if (opt.HasExternalValidator)
                {
                    sb.AppendLine($"- External Validator: `{GeneratorHelpers.GetShortTypeName(opt.ValidatorTypeName!)}`");
                }

                if (opt.HasValidatorMethod)
                {
                    var methodType = opt.ValidatorMethod!.Value.IsStatic ? "static" : "instance";
                    sb.AppendLine($"- Validation Method: `{opt.ValidatorMethod.Value.MethodName}()` ({methodType})");
                }
                else if (opt.ValidateMethodOverride != null)
                {
                    sb.AppendLine($"- Validation Method: `{opt.ValidateMethodOverride}()` (specified but not found)");
                }

                if (opt.SourceFilePath != null)
                {
                    // Use just the filename for brevity in markdown
                    var fileName = System.IO.Path.GetFileName(opt.SourceFilePath);
                    sb.AppendLine($"- Source: `{fileName}`");
                }

                sb.AppendLine();
            }
        }

        // Validation warnings
        var missingValidation = options.Where(o => !o.ValidateOnStart && (o.HasValidatorMethod || o.HasExternalValidator)).ToList();
        if (missingValidation.Count > 0)
        {
            sb.AppendLine("## ⚠️ Potential Issues");
            sb.AppendLine();
            sb.AppendLine("The following options have validators configured but `ValidateOnStart` is disabled:");
            sb.AppendLine();

            foreach (var opt in missingValidation)
            {
                var shortName = GeneratorHelpers.GetShortTypeName(opt.TypeName);
                sb.AppendLine($"- `{shortName}`: Has validator but won't run at startup");
            }

            sb.AppendLine();
            sb.AppendLine("*Set `ValidateOnStart = true` in the `[Options]` attribute to enable startup validation.*");
            sb.AppendLine();
        }

        // Usage example
        sb.AppendLine("## Usage");
        sb.AppendLine();
        sb.AppendLine("Options are automatically registered via source generation. Access them via:");
        sb.AppendLine();
        sb.AppendLine("```csharp");
        sb.AppendLine("// Constructor injection");
        sb.AppendLine("public MyService(IOptions<DatabaseOptions> options) { }");
        sb.AppendLine();
        sb.AppendLine("// Named options");
        sb.AppendLine("public MyService(IOptionsSnapshot<ConnectionOptions> options)");
        sb.AppendLine("{");
        sb.AppendLine("    var primary = options.Get(\"Primary\");");
        sb.AppendLine("}");
        sb.AppendLine("```");
        sb.AppendLine();

        return sb.ToString();
    }

    private static string GetValidatorDescription(DiscoveredOptions opt)
    {
        if (opt.HasExternalValidator)
        {
            var validatorShort = GeneratorHelpers.GetShortTypeName(opt.ValidatorTypeName!);
            return $"`{validatorShort}`";
        }

        if (opt.HasValidatorMethod)
        {
            var methodType = opt.ValidatorMethod!.Value.IsStatic ? "static" : "self";
            return $"`{opt.ValidatorMethod.Value.MethodName}()` ({methodType})";
        }

        if (opt.ValidateMethodOverride != null)
        {
            return $"`{opt.ValidateMethodOverride}()` (not found)";
        }

        return "-";
    }

    internal static IReadOnlyList<DiscoveredOptions> FilterOptions(IReadOnlyList<DiscoveredOptions> options, HashSet<string> filter)
    {
        if (filter == null || filter.Count == 0)
            return options;

        return options.Where(o => 
            filter.Contains(o.TypeName) ||
            filter.Contains(GeneratorHelpers.GetShortTypeName(o.TypeName)) ||
            filter.Contains(GeneratorHelpers.StripGlobalPrefix(o.TypeName)))
                      .ToList();
    }
}

