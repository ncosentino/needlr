using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using NexusLabs.Needlr.Generators.Models;

namespace NexusLabs.Needlr.Generators.CodeGen;

/// <summary>
/// Generates the ServiceCatalog implementation from DiscoveryResult.
/// </summary>
internal static class ServiceCatalogCodeGenerator
{
    internal static string GenerateServiceCatalogSource(
        DiscoveryResult discoveryResult,
        string assemblyName,
        string? projectDirectory,
        BreadcrumbWriter breadcrumbs)
    {
        var builder = new StringBuilder();
        var safeAssemblyName = GeneratorHelpers.SanitizeIdentifier(assemblyName);
        var timestamp = DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm:ss");

        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("// Needlr Service Catalog");
        builder.AppendLine($"// Generated: {timestamp} UTC");
        builder.AppendLine();
        builder.AppendLine("#nullable enable");
        builder.AppendLine();
        builder.AppendLine($"namespace {safeAssemblyName}.Generated;");
        builder.AppendLine();
        
        breadcrumbs.WriteInlineComment(builder, "", $"ServiceCatalog: {discoveryResult.InjectableTypes.Count} services, {discoveryResult.Decorators.Count} decorators, {discoveryResult.HostedServices.Count} hosted services");

        builder.AppendLine("/// <summary>");
        builder.AppendLine("/// Compile-time service catalog containing all discovered registrations.");
        builder.AppendLine("/// </summary>");
        builder.AppendLine("[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"NexusLabs.Needlr.Generators\", \"1.0.0\")]");
        builder.AppendLine($"public sealed class ServiceCatalog : global::NexusLabs.Needlr.Catalog.IServiceCatalog");
        builder.AppendLine("{");
        builder.AppendLine($"    /// <inheritdoc />");
        builder.AppendLine($"    public string AssemblyName => \"{GeneratorHelpers.EscapeStringLiteral(assemblyName)}\";");
        builder.AppendLine();
        builder.AppendLine($"    /// <inheritdoc />");
        builder.AppendLine($"    public string GeneratedAt => \"{timestamp}\";");
        builder.AppendLine();

        // Services
        GenerateServicesProperty(builder, discoveryResult.InjectableTypes, projectDirectory);
        
        // Decorators
        GenerateDecoratorsProperty(builder, discoveryResult.Decorators, projectDirectory);
        
        // Hosted Services
        GenerateHostedServicesProperty(builder, discoveryResult.HostedServices, projectDirectory);
        
        // Intercepted Services
        GenerateInterceptedServicesProperty(builder, discoveryResult.InterceptedServices, projectDirectory);
        
        // Options
        GenerateOptionsProperty(builder, discoveryResult.Options, projectDirectory);
        
        // Plugins
        GeneratePluginsProperty(builder, discoveryResult.PluginTypes, projectDirectory);

        builder.AppendLine("}");

        return builder.ToString();
    }

    private static void GenerateServicesProperty(
        StringBuilder builder,
        IReadOnlyList<DiscoveredType> types,
        string? projectDirectory)
    {
        builder.AppendLine($"    /// <inheritdoc />");
        builder.AppendLine($"    public global::System.Collections.Generic.IReadOnlyList<global::NexusLabs.Needlr.Catalog.ServiceCatalogEntry> Services {{ get; }} = new global::NexusLabs.Needlr.Catalog.ServiceCatalogEntry[]");
        builder.AppendLine("    {");

        foreach (var type in types)
        {
            var shortName = GeneratorHelpers.GetShortTypeName(type.TypeName);
            var lifetimeStr = type.Lifetime switch
            {
                GeneratorLifetime.Singleton => "global::NexusLabs.Needlr.Catalog.ServiceCatalogLifetime.Singleton",
                GeneratorLifetime.Scoped => "global::NexusLabs.Needlr.Catalog.ServiceCatalogLifetime.Scoped",
                GeneratorLifetime.Transient => "global::NexusLabs.Needlr.Catalog.ServiceCatalogLifetime.Transient",
                _ => "global::NexusLabs.Needlr.Catalog.ServiceCatalogLifetime.Scoped"
            };
            var sourceFilePath = GetRelativeSourcePath(type.SourceFilePath, projectDirectory);
            var sourceFilePathLiteral = sourceFilePath != null 
                ? $"\"{GeneratorHelpers.EscapeStringLiteral(sourceFilePath)}\"" 
                : "null";

            // Build interfaces array (for backwards compat)
            var interfacesArray = $"new string[] {{ {string.Join(", ", type.InterfaceNames.Select(i => $"\"{GeneratorHelpers.EscapeStringLiteral(i)}\""))} }}";
            
            // Build interface entries array with locations
            var interfaceEntriesBuilder = new StringBuilder();
            interfaceEntriesBuilder.Append("new global::NexusLabs.Needlr.Catalog.InterfaceEntry[] { ");
            foreach (var ifaceInfo in type.InterfaceInfos)
            {
                var ifaceFilePath = GetRelativeSourcePath(ifaceInfo.SourceFilePath, projectDirectory);
                var ifaceFilePathLiteral = ifaceFilePath != null 
                    ? $"\"{GeneratorHelpers.EscapeStringLiteral(ifaceFilePath)}\"" 
                    : "null";
                interfaceEntriesBuilder.Append($"new global::NexusLabs.Needlr.Catalog.InterfaceEntry(\"{GeneratorHelpers.EscapeStringLiteral(ifaceInfo.FullName)}\", {ifaceFilePathLiteral}, {ifaceInfo.SourceLine}), ");
            }
            interfaceEntriesBuilder.Append('}');
            
            // Build constructor parameters array
            var constructorParamsBuilder = new StringBuilder();
            constructorParamsBuilder.Append("new global::NexusLabs.Needlr.Catalog.ConstructorParameterEntry[] { ");
            foreach (var param in type.ConstructorParameters)
            {
                var serviceKeyLiteral = param.ServiceKey != null 
                    ? $"\"{GeneratorHelpers.EscapeStringLiteral(param.ServiceKey)}\"" 
                    : "null";
                var paramName = param.ParameterName ?? "unknown";
                constructorParamsBuilder.Append($"new global::NexusLabs.Needlr.Catalog.ConstructorParameterEntry(\"{GeneratorHelpers.EscapeStringLiteral(paramName)}\", \"{GeneratorHelpers.EscapeStringLiteral(param.TypeName)}\", {(param.IsKeyed ? "true" : "false")}, {serviceKeyLiteral}), ");
            }
            constructorParamsBuilder.Append('}');
            
            // Build service keys array
            var serviceKeysArray = $"new string[] {{ {string.Join(", ", type.ServiceKeys.Select(k => $"\"{GeneratorHelpers.EscapeStringLiteral(k)}\""))} }}";

            builder.AppendLine($"        new global::NexusLabs.Needlr.Catalog.ServiceCatalogEntry(\"{GeneratorHelpers.EscapeStringLiteral(type.TypeName)}\", \"{GeneratorHelpers.EscapeStringLiteral(shortName)}\", \"{GeneratorHelpers.EscapeStringLiteral(type.AssemblyName)}\", {lifetimeStr}, {interfacesArray}, {constructorParamsBuilder}, {serviceKeysArray}, {sourceFilePathLiteral}, {type.SourceLine}, {interfaceEntriesBuilder}),");
        }

        builder.AppendLine("    };");
        builder.AppendLine();
    }

    private static void GenerateDecoratorsProperty(
        StringBuilder builder,
        IReadOnlyList<DiscoveredDecorator> decorators,
        string? projectDirectory)
    {
        builder.AppendLine($"    /// <inheritdoc />");
        builder.AppendLine($"    public global::System.Collections.Generic.IReadOnlyList<global::NexusLabs.Needlr.Catalog.DecoratorCatalogEntry> Decorators {{ get; }} = new global::NexusLabs.Needlr.Catalog.DecoratorCatalogEntry[]");
        builder.AppendLine("    {");

        foreach (var decorator in decorators)
        {
            var shortName = GeneratorHelpers.GetShortTypeName(decorator.DecoratorTypeName);
            var sourceFilePath = GetRelativeSourcePath(decorator.SourceFilePath, projectDirectory);
            var sourceFilePathLiteral = sourceFilePath != null 
                ? $"\"{GeneratorHelpers.EscapeStringLiteral(sourceFilePath)}\"" 
                : "null";

            builder.AppendLine($"        new global::NexusLabs.Needlr.Catalog.DecoratorCatalogEntry(\"{GeneratorHelpers.EscapeStringLiteral(decorator.DecoratorTypeName)}\", \"{GeneratorHelpers.EscapeStringLiteral(shortName)}\", \"{GeneratorHelpers.EscapeStringLiteral(decorator.ServiceTypeName)}\", {decorator.Order}, \"{GeneratorHelpers.EscapeStringLiteral(decorator.AssemblyName)}\", {sourceFilePathLiteral}),");
        }

        builder.AppendLine("    };");
        builder.AppendLine();
    }

    private static void GenerateHostedServicesProperty(
        StringBuilder builder,
        IReadOnlyList<DiscoveredHostedService> hostedServices,
        string? projectDirectory)
    {
        builder.AppendLine($"    /// <inheritdoc />");
        builder.AppendLine($"    public global::System.Collections.Generic.IReadOnlyList<global::NexusLabs.Needlr.Catalog.HostedServiceCatalogEntry> HostedServices {{ get; }} = new global::NexusLabs.Needlr.Catalog.HostedServiceCatalogEntry[]");
        builder.AppendLine("    {");

        foreach (var hosted in hostedServices)
        {
            var shortName = GeneratorHelpers.GetShortTypeName(hosted.TypeName);
            var sourceFilePath = GetRelativeSourcePath(hosted.SourceFilePath, projectDirectory);
            var sourceFilePathLiteral = sourceFilePath != null 
                ? $"\"{GeneratorHelpers.EscapeStringLiteral(sourceFilePath)}\"" 
                : "null";

            // Build constructor parameters array
            var constructorParamsBuilder = new StringBuilder();
            constructorParamsBuilder.Append("new global::NexusLabs.Needlr.Catalog.ConstructorParameterEntry[] { ");
            foreach (var param in hosted.ConstructorParameters)
            {
                var serviceKeyLiteral = param.ServiceKey != null 
                    ? $"\"{GeneratorHelpers.EscapeStringLiteral(param.ServiceKey)}\"" 
                    : "null";
                var paramName = param.ParameterName ?? "unknown";
                constructorParamsBuilder.Append($"new global::NexusLabs.Needlr.Catalog.ConstructorParameterEntry(\"{GeneratorHelpers.EscapeStringLiteral(paramName)}\", \"{GeneratorHelpers.EscapeStringLiteral(param.TypeName)}\", {(param.IsKeyed ? "true" : "false")}, {serviceKeyLiteral}), ");
            }
            constructorParamsBuilder.Append('}');

            builder.AppendLine($"        new global::NexusLabs.Needlr.Catalog.HostedServiceCatalogEntry(\"{GeneratorHelpers.EscapeStringLiteral(hosted.TypeName)}\", \"{GeneratorHelpers.EscapeStringLiteral(shortName)}\", \"{GeneratorHelpers.EscapeStringLiteral(hosted.AssemblyName)}\", {constructorParamsBuilder}, {sourceFilePathLiteral}),");
        }

        builder.AppendLine("    };");
        builder.AppendLine();
    }

    private static void GenerateInterceptedServicesProperty(
        StringBuilder builder,
        IReadOnlyList<DiscoveredInterceptedService> interceptedServices,
        string? projectDirectory)
    {
        builder.AppendLine($"    /// <inheritdoc />");
        builder.AppendLine($"    public global::System.Collections.Generic.IReadOnlyList<global::NexusLabs.Needlr.Catalog.InterceptedServiceCatalogEntry> InterceptedServices {{ get; }} = new global::NexusLabs.Needlr.Catalog.InterceptedServiceCatalogEntry[]");
        builder.AppendLine("    {");

        foreach (var intercepted in interceptedServices)
        {
            var shortName = GeneratorHelpers.GetShortTypeName(intercepted.TypeName);
            var lifetimeStr = intercepted.Lifetime switch
            {
                GeneratorLifetime.Singleton => "global::NexusLabs.Needlr.Catalog.ServiceCatalogLifetime.Singleton",
                GeneratorLifetime.Scoped => "global::NexusLabs.Needlr.Catalog.ServiceCatalogLifetime.Scoped",
                GeneratorLifetime.Transient => "global::NexusLabs.Needlr.Catalog.ServiceCatalogLifetime.Transient",
                _ => "global::NexusLabs.Needlr.Catalog.ServiceCatalogLifetime.Scoped"
            };
            var sourceFilePath = GetRelativeSourcePath(intercepted.SourceFilePath, projectDirectory);
            var sourceFilePathLiteral = sourceFilePath != null 
                ? $"\"{GeneratorHelpers.EscapeStringLiteral(sourceFilePath)}\"" 
                : "null";

            var interfacesArray = $"new string[] {{ {string.Join(", ", intercepted.InterfaceNames.Select(i => $"\"{GeneratorHelpers.EscapeStringLiteral(i)}\""))} }}";
            var interceptorsArray = $"new string[] {{ {string.Join(", ", intercepted.AllInterceptorTypeNames.Select(i => $"\"{GeneratorHelpers.EscapeStringLiteral(i)}\""))} }}";

            builder.AppendLine($"        new global::NexusLabs.Needlr.Catalog.InterceptedServiceCatalogEntry(\"{GeneratorHelpers.EscapeStringLiteral(intercepted.TypeName)}\", \"{GeneratorHelpers.EscapeStringLiteral(shortName)}\", \"{GeneratorHelpers.EscapeStringLiteral(intercepted.AssemblyName)}\", {lifetimeStr}, {interfacesArray}, {interceptorsArray}, {sourceFilePathLiteral}),");
        }

        builder.AppendLine("    };");
        builder.AppendLine();
    }

    private static void GenerateOptionsProperty(
        StringBuilder builder,
        IReadOnlyList<DiscoveredOptions> options,
        string? projectDirectory)
    {
        builder.AppendLine($"    /// <inheritdoc />");
        builder.AppendLine($"    public global::System.Collections.Generic.IReadOnlyList<global::NexusLabs.Needlr.Catalog.OptionsCatalogEntry> Options {{ get; }} = new global::NexusLabs.Needlr.Catalog.OptionsCatalogEntry[]");
        builder.AppendLine("    {");

        foreach (var opt in options)
        {
            var shortName = GeneratorHelpers.GetShortTypeName(opt.TypeName);
            var sourceFilePath = GetRelativeSourcePath(opt.SourceFilePath, projectDirectory);
            var sourceFilePathLiteral = sourceFilePath != null 
                ? $"\"{GeneratorHelpers.EscapeStringLiteral(sourceFilePath)}\"" 
                : "null";
            var nameLiteral = opt.Name != null 
                ? $"\"{GeneratorHelpers.EscapeStringLiteral(opt.Name)}\"" 
                : "null";

            builder.AppendLine($"        new global::NexusLabs.Needlr.Catalog.OptionsCatalogEntry(\"{GeneratorHelpers.EscapeStringLiteral(opt.TypeName)}\", \"{GeneratorHelpers.EscapeStringLiteral(shortName)}\", \"{GeneratorHelpers.EscapeStringLiteral(opt.SectionName)}\", \"{GeneratorHelpers.EscapeStringLiteral(opt.AssemblyName)}\", {nameLiteral}, {(opt.ValidateOnStart ? "true" : "false")}, {(opt.HasValidatorMethod ? "true" : "false")}, {(opt.HasDataAnnotations ? "true" : "false")}, {sourceFilePathLiteral}),");
        }

        builder.AppendLine("    };");
        builder.AppendLine();
    }

    private static void GeneratePluginsProperty(
        StringBuilder builder,
        IReadOnlyList<DiscoveredPlugin> plugins,
        string? projectDirectory)
    {
        builder.AppendLine($"    /// <inheritdoc />");
        builder.AppendLine($"    public global::System.Collections.Generic.IReadOnlyList<global::NexusLabs.Needlr.Catalog.PluginCatalogEntry> Plugins {{ get; }} = new global::NexusLabs.Needlr.Catalog.PluginCatalogEntry[]");
        builder.AppendLine("    {");

        foreach (var plugin in plugins)
        {
            var shortName = GeneratorHelpers.GetShortTypeName(plugin.TypeName);
            var sourceFilePath = GetRelativeSourcePath(plugin.SourceFilePath, projectDirectory);
            var sourceFilePathLiteral = sourceFilePath != null 
                ? $"\"{GeneratorHelpers.EscapeStringLiteral(sourceFilePath)}\"" 
                : "null";

            var interfacesArray = $"new string[] {{ {string.Join(", ", plugin.InterfaceNames.Select(i => $"\"{GeneratorHelpers.EscapeStringLiteral(i)}\""))} }}";

            builder.AppendLine($"        new global::NexusLabs.Needlr.Catalog.PluginCatalogEntry(\"{GeneratorHelpers.EscapeStringLiteral(plugin.TypeName)}\", \"{GeneratorHelpers.EscapeStringLiteral(shortName)}\", {interfacesArray}, \"{GeneratorHelpers.EscapeStringLiteral(plugin.AssemblyName)}\", {plugin.Order}, {sourceFilePathLiteral}),");
        }

        builder.AppendLine("    };");
    }

    private static string? GetRelativeSourcePath(string? fullPath, string? projectDirectory)
    {
        if (fullPath == null || projectDirectory == null)
            return fullPath;

        if (fullPath.StartsWith(projectDirectory, StringComparison.OrdinalIgnoreCase))
        {
            var relative = fullPath.Substring(projectDirectory.Length);
            return relative.TrimStart('/', '\\');
        }

        return fullPath;
    }
}
