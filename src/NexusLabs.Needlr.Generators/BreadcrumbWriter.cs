using System.Text;

namespace NexusLabs.Needlr.Generators;

/// <summary>
/// Helper class for writing documentation breadcrumbs to generated source code.
/// Respects the configured <see cref="BreadcrumbLevel"/> to control output verbosity.
/// </summary>
internal sealed class BreadcrumbWriter
{
    private const int BoxWidth = 73;
    private const string BoxTopLeft = "┌";
    private const string BoxTopRight = "┐";
    private const string BoxBottomLeft = "└";
    private const string BoxBottomRight = "┘";
    private const string BoxVertical = "│";
    private const string BoxHorizontal = "─";

    public BreadcrumbLevel Level { get; }

    public BreadcrumbWriter(BreadcrumbLevel level)
    {
        Level = level;
    }

    /// <summary>
    /// Writes a simple inline comment. Only outputs at Minimal or Verbose level.
    /// </summary>
    public void WriteInlineComment(StringBuilder sb, string indent, string comment)
    {
        if (Level == BreadcrumbLevel.None)
            return;

        sb.AppendLine($"{indent}// {comment}");
    }

    /// <summary>
    /// Writes a verbose box comment with multiple lines. Only outputs at Verbose level.
    /// At Minimal level, outputs a simple inline comment with the title.
    /// </summary>
    public void WriteVerboseBox(StringBuilder sb, string indent, string title, params string[] lines)
    {
        if (Level == BreadcrumbLevel.None)
            return;

        if (Level == BreadcrumbLevel.Minimal)
        {
            sb.AppendLine($"{indent}// {title}");
            return;
        }

        // Verbose: Full box
        var horizontalLine = new string('─', BoxWidth);
        sb.AppendLine($"{indent}// {BoxTopLeft}{horizontalLine}{BoxTopRight}");
        sb.AppendLine($"{indent}// {BoxVertical} {PadRight(title, BoxWidth - 1)}{BoxVertical}");

        foreach (var line in lines)
        {
            sb.AppendLine($"{indent}// {BoxVertical} {PadRight(line, BoxWidth - 1)}{BoxVertical}");
        }

        sb.AppendLine($"{indent}// {BoxBottomLeft}{horizontalLine}{BoxBottomRight}");
    }

    /// <summary>
    /// Writes the file header with breadcrumb level indicator. Only at Verbose level.
    /// </summary>
    public void WriteFileHeader(StringBuilder sb, string assemblyName, string fileDescription)
    {
        sb.AppendLine("// <auto-generated/>");

        if (Level == BreadcrumbLevel.Verbose)
        {
            sb.AppendLine("// ═══════════════════════════════════════════════════════════════════════════════");
            sb.AppendLine($"// {fileDescription}");
            sb.AppendLine($"// Assembly: {assemblyName}");
            sb.AppendLine($"// Breadcrumb Level: {Level}");
            sb.AppendLine("// ═══════════════════════════════════════════════════════════════════════════════");
        }
    }

    /// <summary>
    /// Gets a relative path from an absolute path, using the project directory as base.
    /// Falls back to just the filename if project root is unavailable.
    /// </summary>
    public static string GetRelativeSourcePath(string? absolutePath, string? projectDirectory)
    {
        if (absolutePath == null || absolutePath.Length == 0)
            return "[unknown]";

        // Normalize path separators for cross-platform compatibility
        var normalizedPath = absolutePath.Replace("\\", "/");

        if (projectDirectory == null || projectDirectory.Length == 0)
        {
            // Fallback to just the filename - use LastIndexOf for cross-platform
            var lastSlash = normalizedPath.LastIndexOf('/');
            return lastSlash >= 0 ? normalizedPath.Substring(lastSlash + 1) : normalizedPath;
        }

        var normalizedProjectDir = projectDirectory.Replace("\\", "/");
        // Ensure project dir doesn't end with slash for consistent comparison
        if (normalizedProjectDir.EndsWith("/"))
            normalizedProjectDir = normalizedProjectDir.Substring(0, normalizedProjectDir.Length - 1);

        // Try to make it relative
        if (normalizedPath.StartsWith(normalizedProjectDir, StringComparison.OrdinalIgnoreCase))
        {
            var relative = normalizedPath.Substring(normalizedProjectDir.Length);
            if (relative.StartsWith("/"))
                relative = relative.Substring(1);
            return relative;
        }

        // Couldn't make relative, just return filename
        var lastSlashFallback = normalizedPath.LastIndexOf('/');
        return lastSlashFallback >= 0 ? normalizedPath.Substring(lastSlashFallback + 1) : normalizedPath;
    }

    private static string PadRight(string text, int totalWidth)
    {
        if (text.Length >= totalWidth)
            return text.Substring(0, totalWidth);
        return text + new string(' ', totalWidth - text.Length);
    }
}
