using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Diagnostics;

using Xunit;

namespace NexusLabs.Needlr.Generators.Tests;

/// <summary>
/// Comprehensive tests for the breadcrumb documentation feature in generated source code.
/// Tests cover all three levels (None, Minimal, Verbose), inheritance, overrides, and edge cases.
/// </summary>
public sealed class BreadcrumbTests
{
    #region Default Level Tests

    [Fact]
    public void BreadcrumbLevel_Default_IsMinimal()
    {
        // Arrange - No NeedlrBreadcrumbLevel property set
        var source = @"
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry]

namespace TestApp
{
    public class MyService { }
}";

        // Act
        var generatedCode = RunGeneratorWithBreadcrumbLevel(source, breadcrumbLevel: null);

        // Assert - Should have minimal comments (inline) but not verbose boxes
        Assert.Contains("// <auto-generated/>", generatedCode);
        // Minimal should have some inline comments
        Assert.Contains("//", generatedCode);
        // Should NOT have verbose box characters
        Assert.DoesNotContain("┌", generatedCode);
        Assert.DoesNotContain("└", generatedCode);
        Assert.DoesNotContain("═══════════════", generatedCode);
    }

    #endregion

    #region None Level Tests

    [Fact]
    public void BreadcrumbLevel_None_OnlyHasAutoGeneratedHeader()
    {
        // Arrange
        var source = @"
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry]

namespace TestApp
{
    public interface IMyService { }
    public class MyService : IMyService { }
}";

        // Act
        var generatedCode = RunGeneratorWithBreadcrumbLevel(source, "None");

        // Assert - Should only have <auto-generated/> header (no breadcrumb boxes)
        Assert.Contains("// <auto-generated/>", generatedCode);
        
        // None level should NOT have verbose box characters
        Assert.DoesNotContain("┌", generatedCode);
        Assert.DoesNotContain("└", generatedCode);
        Assert.DoesNotContain("═══════════════", generatedCode);
        
        // None level should NOT have the verbose header showing breadcrumb level
        Assert.DoesNotContain("Breadcrumb Level:", generatedCode);
    }

    [Fact]
    public void BreadcrumbLevel_None_NoVerboseBoxes()
    {
        // Arrange
        var source = @"
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry]

namespace TestApp
{
    public class MyService { }
}";

        // Act
        var generatedCode = RunGeneratorWithBreadcrumbLevel(source, "None");

        // Assert - No box drawing characters
        Assert.DoesNotContain("┌", generatedCode);
        Assert.DoesNotContain("┐", generatedCode);
        Assert.DoesNotContain("└", generatedCode);
        Assert.DoesNotContain("┘", generatedCode);
        Assert.DoesNotContain("│", generatedCode);
        Assert.DoesNotContain("─", generatedCode);
        Assert.DoesNotContain("═", generatedCode);
    }

    [Fact]
    public void BreadcrumbLevel_None_NoSourcePathComments()
    {
        // Arrange
        var source = @"
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry]

namespace TestApp
{
    public class ServiceA { }
    public class ServiceB { }
}";

        // Act
        var generatedCode = RunGeneratorWithBreadcrumbLevel(source, "None");

        // Assert - No source path comments
        Assert.DoesNotContain("Source:", generatedCode);
        Assert.DoesNotContain(".cs", generatedCode.Replace("// <auto-generated/>", "")
            .Replace("TypeRegistry.g.cs", "")
            .Replace("NeedlrSourceGenBootstrap.g.cs", ""));
    }

    #endregion

    #region Minimal Level Tests

    [Fact]
    public void BreadcrumbLevel_Minimal_HasInlineComments()
    {
        // Arrange
        var source = @"
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry]

namespace TestApp
{
    public interface IMyService { }
    [Singleton]
    public class MyService : IMyService { }
}";

        // Act
        var generatedCode = RunGeneratorWithBreadcrumbLevel(source, "Minimal");

        // Assert - Should have inline comments
        Assert.Contains("// <auto-generated/>", generatedCode);
        // Minimal adds type info as inline comments
        Assert.Contains("//", generatedCode);
    }

    [Fact]
    public void BreadcrumbLevel_Minimal_NoVerboseBoxes()
    {
        // Arrange
        var source = @"
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry]

namespace TestApp
{
    public class MyService { }
}";

        // Act
        var generatedCode = RunGeneratorWithBreadcrumbLevel(source, "Minimal");

        // Assert - No box drawing characters
        Assert.DoesNotContain("┌", generatedCode);
        Assert.DoesNotContain("└", generatedCode);
        Assert.DoesNotContain("═══════════════", generatedCode);
    }

    [Fact]
    public void BreadcrumbLevel_Minimal_CaseInsensitive()
    {
        // Arrange
        var source = @"
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry]

namespace TestApp
{
    public class MyService { }
}";

        // Act - Test various case combinations
        var generatedCodeLower = RunGeneratorWithBreadcrumbLevel(source, "minimal");
        var generatedCodeUpper = RunGeneratorWithBreadcrumbLevel(source, "MINIMAL");
        var generatedCodeMixed = RunGeneratorWithBreadcrumbLevel(source, "MiNiMaL");

        // Assert - All should produce same structure (no verbose boxes)
        Assert.DoesNotContain("┌", generatedCodeLower);
        Assert.DoesNotContain("┌", generatedCodeUpper);
        Assert.DoesNotContain("┌", generatedCodeMixed);
    }

    #endregion

    #region Verbose Level Tests

    [Fact]
    public void BreadcrumbLevel_Verbose_HasFullBoxComments()
    {
        // Arrange
        var source = @"
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry]

namespace TestApp
{
    public class MyService { }
}";

        // Act
        var generatedCode = RunGeneratorWithBreadcrumbLevel(source, "Verbose");

        // Assert - Should have full verbose header
        Assert.Contains("═══════════════════════════════════════════════════════════════════════════════", generatedCode);
        Assert.Contains("Breadcrumb Level: Verbose", generatedCode);
    }

    [Fact]
    public void BreadcrumbLevel_Verbose_HasAssemblyName()
    {
        // Arrange
        var source = @"
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry]

namespace TestApp
{
    public class MyService { }
}";

        // Act
        var generatedCode = RunGeneratorWithBreadcrumbLevel(source, "Verbose");

        // Assert - Should include assembly name
        Assert.Contains("Assembly: TestAssembly", generatedCode);
    }

    [Fact]
    public void BreadcrumbLevel_Verbose_HasTypeBoxComments()
    {
        // Arrange
        var source = @"
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry]

namespace TestApp
{
    public interface IMyService { }
    [Singleton]
    public class MyService : IMyService { }
}";

        // Act
        var generatedCode = RunGeneratorWithBreadcrumbLevel(source, "Verbose");

        // Assert - Should have box drawing characters for type info
        Assert.Contains("┌", generatedCode);
        Assert.Contains("└", generatedCode);
        Assert.Contains("│", generatedCode);
    }

    [Fact]
    public void BreadcrumbLevel_Verbose_CaseInsensitive()
    {
        // Arrange
        var source = @"
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry]

namespace TestApp
{
    public class MyService { }
}";

        // Act - Test various case combinations
        var generatedCodeLower = RunGeneratorWithBreadcrumbLevel(source, "verbose");
        var generatedCodeUpper = RunGeneratorWithBreadcrumbLevel(source, "VERBOSE");
        var generatedCodeMixed = RunGeneratorWithBreadcrumbLevel(source, "VeRbOsE");

        // Assert - All should produce verbose output with box characters
        Assert.Contains("┌", generatedCodeLower);
        Assert.Contains("┌", generatedCodeUpper);
        Assert.Contains("┌", generatedCodeMixed);
    }

    [Fact]
    public void BreadcrumbLevel_Verbose_IncludesLifetimeInfo()
    {
        // Arrange
        var source = @"
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry]

namespace TestApp
{
    [Singleton]
    public class SingletonService { }
    
    [Scoped]
    public class ScopedService { }
    
    [Transient]
    public class TransientService { }
}";

        // Act
        var generatedCode = RunGeneratorWithBreadcrumbLevel(source, "Verbose");

        // Assert - Should include lifetime info in verbose boxes
        Assert.Contains("Lifetime:", generatedCode);
    }

    #endregion

    #region Invalid Level Tests

    [Fact]
    public void BreadcrumbLevel_InvalidValue_FallsBackToMinimal()
    {
        // Arrange
        var source = @"
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry]

namespace TestApp
{
    public class MyService { }
}";

        // Act - Use invalid level
        var generatedCode = RunGeneratorWithBreadcrumbLevel(source, "InvalidLevel");

        // Assert - Should fall back to Minimal (no verbose boxes)
        Assert.DoesNotContain("┌", generatedCode);
        Assert.DoesNotContain("Breadcrumb Level:", generatedCode);
    }

    [Fact]
    public void BreadcrumbLevel_EmptyString_FallsBackToMinimal()
    {
        // Arrange
        var source = @"
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry]

namespace TestApp
{
    public class MyService { }
}";

        // Act - Use empty string
        var generatedCode = RunGeneratorWithBreadcrumbLevel(source, "");

        // Assert - Should fall back to Minimal (no verbose boxes)
        Assert.DoesNotContain("┌", generatedCode);
        Assert.DoesNotContain("Breadcrumb Level:", generatedCode);
    }

    [Fact]
    public void BreadcrumbLevel_WhitespaceOnly_FallsBackToMinimal()
    {
        // Arrange
        var source = @"
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry]

namespace TestApp
{
    public class MyService { }
}";

        // Act - Use whitespace only
        var generatedCode = RunGeneratorWithBreadcrumbLevel(source, "   ");

        // Assert - Should fall back to Minimal (no verbose boxes)
        Assert.DoesNotContain("┌", generatedCode);
        Assert.DoesNotContain("Breadcrumb Level:", generatedCode);
    }

    #endregion

    #region None Level Tests for Different File Types

    [Fact]
    public void BreadcrumbLevel_None_TypeRegistryFile_MinimalComments()
    {
        // Arrange
        var source = @"
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry]

namespace TestApp
{
    public interface IService { }
    public class Service : IService { }
}";

        // Act
        var generatedFiles = RunGeneratorWithBreadcrumbLevelGetFiles(source, "None");
        var typeRegistryFile = generatedFiles.FirstOrDefault(f => f.FilePath.Contains("TypeRegistry.g.cs"));

        // Assert
        Assert.NotNull(typeRegistryFile);
        Assert.Contains("// <auto-generated/>", typeRegistryFile.Content);
        Assert.DoesNotContain("┌", typeRegistryFile.Content);
    }

    [Fact]
    public void BreadcrumbLevel_None_BootstrapFile_MinimalComments()
    {
        // Arrange
        var source = @"
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry]

namespace TestApp
{
    public class Service { }
}";

        // Act
        var generatedFiles = RunGeneratorWithBreadcrumbLevelGetFiles(source, "None");
        var bootstrapFile = generatedFiles.FirstOrDefault(f => f.FilePath.Contains("NeedlrSourceGenBootstrap.g.cs"));

        // Assert
        Assert.NotNull(bootstrapFile);
        Assert.Contains("// <auto-generated/>", bootstrapFile.Content);
        Assert.DoesNotContain("┌", bootstrapFile.Content);
    }

    #endregion

    #region Verbose Level Tests for Different File Types

    [Fact]
    public void BreadcrumbLevel_Verbose_TypeRegistryFile_FullDocumentation()
    {
        // Arrange
        var source = @"
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry]

namespace TestApp
{
    public interface IService { }
    [Singleton]
    public class Service : IService { }
}";

        // Act
        var generatedFiles = RunGeneratorWithBreadcrumbLevelGetFiles(source, "Verbose");
        var typeRegistryFile = generatedFiles.FirstOrDefault(f => f.FilePath.Contains("TypeRegistry.g.cs"));

        // Assert
        Assert.NotNull(typeRegistryFile);
        Assert.Contains("Type Registry", typeRegistryFile.Content);
        Assert.Contains("Assembly: TestAssembly", typeRegistryFile.Content);
        Assert.Contains("Breadcrumb Level: Verbose", typeRegistryFile.Content);
    }

    [Fact]
    public void BreadcrumbLevel_Verbose_BootstrapFile_FullDocumentation()
    {
        // Arrange
        var source = @"
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry]

namespace TestApp
{
    public class Service { }
}";

        // Act
        var generatedFiles = RunGeneratorWithBreadcrumbLevelGetFiles(source, "Verbose");
        var bootstrapFile = generatedFiles.FirstOrDefault(f => f.FilePath.Contains("NeedlrSourceGenBootstrap.g.cs"));

        // Assert
        Assert.NotNull(bootstrapFile);
        Assert.Contains("Needlr Source-Gen Bootstrap", bootstrapFile.Content);
        Assert.Contains("Assembly: TestAssembly", bootstrapFile.Content);
    }

    #endregion

    #region Interceptor Breadcrumb Tests

    [Fact]
    public void Interceptor_BreadcrumbLevel_None_NoInterceptorComments()
    {
        // Arrange
        var source = @"
using NexusLabs.Needlr;
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry(IncludeNamespacePrefixes = new[] { ""TestApp"" })]

namespace TestApp
{
    public interface IOrderService
    {
        string GetOrder(int id);
    }

    public class LoggingInterceptor : IMethodInterceptor
    {
        public System.Threading.Tasks.ValueTask<object?> InterceptAsync(IMethodInvocation invocation)
        {
            return invocation.ProceedAsync();
        }
    }

    [Intercept<LoggingInterceptor>]
    [Scoped]
    public class OrderService : IOrderService
    {
        public string GetOrder(int id) => $""Order {id}"";
    }
}";

        // Act
        var generatedCode = RunGeneratorWithBreadcrumbLevel(source, "None");

        // Assert - Should have interceptor proxy but no documentation boxes
        Assert.Contains("OrderService_InterceptorProxy", generatedCode);
        Assert.DoesNotContain("┌", generatedCode);
        Assert.DoesNotContain("Interceptor Proxy:", generatedCode);
    }

    [Fact]
    public void Interceptor_BreadcrumbLevel_Minimal_HasInlineComments()
    {
        // Arrange
        var source = @"
using NexusLabs.Needlr;
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry(IncludeNamespacePrefixes = new[] { ""TestApp"" })]

namespace TestApp
{
    public interface IOrderService
    {
        string GetOrder(int id);
    }

    public class LoggingInterceptor : IMethodInterceptor
    {
        public System.Threading.Tasks.ValueTask<object?> InterceptAsync(IMethodInvocation invocation)
        {
            return invocation.ProceedAsync();
        }
    }

    [Intercept<LoggingInterceptor>]
    [Scoped]
    public class OrderService : IOrderService
    {
        public string GetOrder(int id) => $""Order {id}"";
    }
}";

        // Act
        var generatedCode = RunGeneratorWithBreadcrumbLevel(source, "Minimal");

        // Assert - Should have inline comments but no boxes
        Assert.Contains("OrderService_InterceptorProxy", generatedCode);
        Assert.DoesNotContain("┌", generatedCode);
        // Minimal may still have inline comments about interceptor
        Assert.Contains("//", generatedCode);
    }

    [Fact]
    public void Interceptor_BreadcrumbLevel_Verbose_HasFullInterceptorDocumentation()
    {
        // Arrange
        var source = @"
using NexusLabs.Needlr;
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry(IncludeNamespacePrefixes = new[] { ""TestApp"" })]

namespace TestApp
{
    public interface IOrderService
    {
        string GetOrder(int id);
    }

    public class LoggingInterceptor : IMethodInterceptor
    {
        public System.Threading.Tasks.ValueTask<object?> InterceptAsync(IMethodInvocation invocation)
        {
            return invocation.ProceedAsync();
        }
    }

    [Intercept<LoggingInterceptor>]
    [Scoped]
    public class OrderService : IOrderService
    {
        public string GetOrder(int id) => $""Order {id}"";
    }
}";

        // Act
        var generatedCode = RunGeneratorWithBreadcrumbLevel(source, "Verbose");

        // Assert - Should have full documentation boxes for interceptor proxy
        Assert.Contains("OrderService_InterceptorProxy", generatedCode);
        Assert.Contains("┌", generatedCode);
        Assert.Contains("Interceptor Proxy:", generatedCode);
        Assert.Contains("LoggingInterceptor", generatedCode);
    }

    [Fact]
    public void Interceptor_BreadcrumbLevel_Verbose_ShowsMultipleInterceptorsInOrder()
    {
        // Arrange
        var source = @"
using NexusLabs.Needlr;
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry(IncludeNamespacePrefixes = new[] { ""TestApp"" })]

namespace TestApp
{
    public interface IOrderService
    {
        string GetOrder(int id);
    }

    public class LoggingInterceptor : IMethodInterceptor
    {
        public System.Threading.Tasks.ValueTask<object?> InterceptAsync(IMethodInvocation invocation)
        {
            return invocation.ProceedAsync();
        }
    }

    public class CachingInterceptor : IMethodInterceptor
    {
        public System.Threading.Tasks.ValueTask<object?> InterceptAsync(IMethodInvocation invocation)
        {
            return invocation.ProceedAsync();
        }
    }

    public class ValidationInterceptor : IMethodInterceptor
    {
        public System.Threading.Tasks.ValueTask<object?> InterceptAsync(IMethodInvocation invocation)
        {
            return invocation.ProceedAsync();
        }
    }

    [Intercept<LoggingInterceptor>(Order = 1)]
    [Intercept<CachingInterceptor>(Order = 2)]
    [Intercept<ValidationInterceptor>(Order = 3)]
    [Scoped]
    public class OrderService : IOrderService
    {
        public string GetOrder(int id) => $""Order {id}"";
    }
}";

        // Act
        var generatedCode = RunGeneratorWithBreadcrumbLevel(source, "Verbose");

        // Assert - Should show all interceptors in order
        Assert.Contains("1.", generatedCode); // Order indicator
        Assert.Contains("LoggingInterceptor", generatedCode);
        Assert.Contains("CachingInterceptor", generatedCode);
        Assert.Contains("ValidationInterceptor", generatedCode);
    }

    #endregion

    #region Decorator Breadcrumb Tests

    [Fact]
    public void Decorator_BreadcrumbLevel_Verbose_ShowsDecoratorChain()
    {
        // Arrange
        var source = @"
using NexusLabs.Needlr;
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry]

namespace TestApp
{
    public interface IService { }
    
    public class BaseService : IService { }
    
    [DecoratorFor(typeof(IService), Order = 1)]
    public class LoggingDecorator : IService
    {
        private readonly IService _inner;
        public LoggingDecorator(IService inner) => _inner = inner;
    }
    
    [DecoratorFor(typeof(IService), Order = 2)]
    public class CachingDecorator : IService
    {
        private readonly IService _inner;
        public CachingDecorator(IService inner) => _inner = inner;
    }
}";

        // Act
        var generatedCode = RunGeneratorWithBreadcrumbLevel(source, "Verbose");

        // Assert - Should have decorator documentation
        Assert.Contains("LoggingDecorator", generatedCode);
        Assert.Contains("CachingDecorator", generatedCode);
    }

    #endregion

    #region BreadcrumbWriter Unit Tests

    [Fact]
    public void BreadcrumbWriter_GetRelativeSourcePath_WithValidPath_ReturnsRelative()
    {
        // Arrange
        var projectDir = @"C:\projects\MyApp";
        var absolutePath = @"C:\projects\MyApp\src\Services\MyService.cs";

        // Act
        var result = BreadcrumbWriter.GetRelativeSourcePath(absolutePath, projectDir);

        // Assert
        Assert.Equal("src/Services/MyService.cs", result);
    }

    [Fact]
    public void BreadcrumbWriter_GetRelativeSourcePath_WithNullPath_ReturnsUnknown()
    {
        // Act
        var result = BreadcrumbWriter.GetRelativeSourcePath(null, @"C:\projects\MyApp");

        // Assert
        Assert.Equal("[unknown]", result);
    }

    [Fact]
    public void BreadcrumbWriter_GetRelativeSourcePath_WithEmptyPath_ReturnsUnknown()
    {
        // Act
        var result = BreadcrumbWriter.GetRelativeSourcePath("", @"C:\projects\MyApp");

        // Assert
        Assert.Equal("[unknown]", result);
    }

    [Fact]
    public void BreadcrumbWriter_GetRelativeSourcePath_WithNullProjectDir_ReturnsFilename()
    {
        // Arrange
        var absolutePath = @"C:\projects\MyApp\src\Services\MyService.cs";

        // Act
        var result = BreadcrumbWriter.GetRelativeSourcePath(absolutePath, null);

        // Assert
        Assert.Equal("MyService.cs", result);
    }

    [Fact]
    public void BreadcrumbWriter_GetRelativeSourcePath_WithEmptyProjectDir_ReturnsFilename()
    {
        // Arrange
        var absolutePath = @"C:\projects\MyApp\src\Services\MyService.cs";

        // Act
        var result = BreadcrumbWriter.GetRelativeSourcePath(absolutePath, "");

        // Assert
        Assert.Equal("MyService.cs", result);
    }

    [Fact]
    public void BreadcrumbWriter_GetRelativeSourcePath_WithPathOutsideProject_ReturnsFilename()
    {
        // Arrange - Path is not inside the project directory
        var projectDir = @"C:\projects\MyApp";
        var absolutePath = @"D:\other\location\SomeFile.cs";

        // Act
        var result = BreadcrumbWriter.GetRelativeSourcePath(absolutePath, projectDir);

        // Assert - Should just return filename when can't make relative
        Assert.Equal("SomeFile.cs", result);
    }

    [Fact]
    public void BreadcrumbWriter_GetRelativeSourcePath_WithTrailingSlash_Works()
    {
        // Arrange
        var projectDir = @"C:\projects\MyApp\";
        var absolutePath = @"C:\projects\MyApp\src\MyService.cs";

        // Act
        var result = BreadcrumbWriter.GetRelativeSourcePath(absolutePath, projectDir);

        // Assert
        Assert.Equal("src/MyService.cs", result);
    }

    [Fact]
    public void BreadcrumbWriter_GetRelativeSourcePath_CaseInsensitive()
    {
        // Arrange - Different casing in path
        var projectDir = @"C:\Projects\MyApp";
        var absolutePath = @"C:\projects\myapp\src\MyService.cs";

        // Act
        var result = BreadcrumbWriter.GetRelativeSourcePath(absolutePath, projectDir);

        // Assert - Should still work with case differences
        Assert.Equal("src/MyService.cs", result);
    }

    #endregion

    #region Level Transition Tests

    [Theory]
    [InlineData("None", "Minimal")]
    [InlineData("Minimal", "Verbose")]
    [InlineData("Verbose", "None")]
    public void BreadcrumbLevel_Transitions_ProduceCorrectOutput(string fromLevel, string toLevel)
    {
        // Arrange
        var source = @"
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry]

namespace TestApp
{
    public class MyService { }
}";

        // Act
        var generatedCodeFrom = RunGeneratorWithBreadcrumbLevel(source, fromLevel);
        var generatedCodeTo = RunGeneratorWithBreadcrumbLevel(source, toLevel);

        // Assert - Generated code should be different between levels
        Assert.NotEqual(generatedCodeFrom, generatedCodeTo);
    }

    [Fact]
    public void BreadcrumbLevel_None_ProducesSmallestOutput()
    {
        // Arrange
        var source = @"
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry]

namespace TestApp
{
    public class MyService { }
}";

        // Act
        var noneOutput = RunGeneratorWithBreadcrumbLevel(source, "None");
        var minimalOutput = RunGeneratorWithBreadcrumbLevel(source, "Minimal");
        var verboseOutput = RunGeneratorWithBreadcrumbLevel(source, "Verbose");

        // Assert - None should be smallest, Verbose should be largest
        Assert.True(noneOutput.Length <= minimalOutput.Length,
            $"None ({noneOutput.Length}) should be <= Minimal ({minimalOutput.Length})");
        Assert.True(minimalOutput.Length <= verboseOutput.Length,
            $"Minimal ({minimalOutput.Length}) should be <= Verbose ({verboseOutput.Length})");
    }

    #endregion

    #region ProjectDir Tests

    [Fact]
    public void ProjectDir_WhenProvided_UsedForRelativePaths()
    {
        // Arrange
        var source = @"
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry]

namespace TestApp
{
    public class MyService { }
}";

        // Act - Verbose level will show source paths
        var generatedCode = RunGeneratorWithOptions(source, "Verbose", @"C:\test\project");

        // Assert - In verbose mode, source paths should appear
        // Since we're using in-memory compilation, paths may show as [unknown]
        // but the mechanism should work
        Assert.Contains("// <auto-generated/>", generatedCode);
    }

    #endregion

    #region Inheritance and Override Tests
    
    /// <summary>
    /// Tests that verify the breadcrumb level configuration inheritance works correctly.
    /// These tests ensure that:
    /// 1. A parent project can set breadcrumb level for all child projects
    /// 2. Child projects can override the parent's setting
    /// 3. The configuration is properly read from AnalyzerConfigOptions
    /// </summary>
    
    [Fact]
    public void Inheritance_ParentSetsVerbose_ChildInherits()
    {
        // This test simulates a parent Directory.Build.props setting Verbose
        // and a child project inheriting that setting
        var source = @"
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry]

namespace ChildProject
{
    public interface IService { }
    public class MyService : IService { }
}";

        // Act - Simulate parent setting Verbose (child inherits)
        var generatedCode = RunGeneratorWithBreadcrumbLevel(source, "Verbose");

        // Assert - Should have verbose output with box characters
        Assert.Contains("┌", generatedCode);
        Assert.Contains("═══════════════", generatedCode);
        Assert.Contains("Breadcrumb Level: Verbose", generatedCode);
    }

    [Fact]
    public void Inheritance_ParentSetsNone_ChildInherits()
    {
        // This test simulates a parent Directory.Build.props setting None
        // and a child project inheriting that setting
        var source = @"
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry]

namespace ChildProject
{
    public class MyService { }
}";

        // Act - Simulate parent setting None (child inherits)
        var generatedCode = RunGeneratorWithBreadcrumbLevel(source, "None");

        // Assert - Should have no verbose boxes
        Assert.DoesNotContain("┌", generatedCode);
        Assert.DoesNotContain("═══════════════", generatedCode);
        Assert.DoesNotContain("Breadcrumb Level:", generatedCode);
    }

    [Fact]
    public void Override_ParentSetsVerbose_ChildOverridesToNone()
    {
        // This test verifies that a child project can override parent settings
        // Parent: Verbose, Child Override: None
        var source = @"
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry]

namespace ChildProject
{
    public class MyService { }
}";

        // Act - Run with parent's Verbose setting
        var parentVerboseCode = RunGeneratorWithBreadcrumbLevel(source, "Verbose");
        
        // Act - Run with child's None override
        var childOverrideCode = RunGeneratorWithBreadcrumbLevel(source, "None");

        // Assert - Parent code should have verbose boxes
        Assert.Contains("┌", parentVerboseCode);
        Assert.Contains("Breadcrumb Level: Verbose", parentVerboseCode);
        
        // Assert - Child override should NOT have verbose boxes
        Assert.DoesNotContain("┌", childOverrideCode);
        Assert.DoesNotContain("Breadcrumb Level:", childOverrideCode);
    }

    [Fact]
    public void Override_ParentSetsNone_ChildOverridesToVerbose()
    {
        // This test verifies that a child project can override parent settings
        // Parent: None, Child Override: Verbose
        var source = @"
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry]

namespace ChildProject
{
    public interface IMyService { }
    [Singleton]
    public class MyService : IMyService { }
}";

        // Act - Run with parent's None setting
        var parentNoneCode = RunGeneratorWithBreadcrumbLevel(source, "None");
        
        // Act - Run with child's Verbose override
        var childOverrideCode = RunGeneratorWithBreadcrumbLevel(source, "Verbose");

        // Assert - Parent code should NOT have verbose boxes
        Assert.DoesNotContain("┌", parentNoneCode);
        Assert.DoesNotContain("Breadcrumb Level:", parentNoneCode);
        
        // Assert - Child override should have verbose boxes
        Assert.Contains("┌", childOverrideCode);
        Assert.Contains("Breadcrumb Level: Verbose", childOverrideCode);
    }

    [Fact]
    public void Override_ParentSetsMinimal_ChildOverridesToVerbose()
    {
        // This test verifies that a child project can override parent settings
        // Parent: Minimal, Child Override: Verbose
        var source = @"
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry]

namespace ChildProject
{
    public class MyService { }
}";

        // Act - Run with parent's Minimal setting
        var parentMinimalCode = RunGeneratorWithBreadcrumbLevel(source, "Minimal");
        
        // Act - Run with child's Verbose override
        var childOverrideCode = RunGeneratorWithBreadcrumbLevel(source, "Verbose");

        // Assert - Parent code should NOT have verbose boxes (Minimal is inline only)
        Assert.DoesNotContain("┌", parentMinimalCode);
        Assert.DoesNotContain("Breadcrumb Level:", parentMinimalCode);
        
        // Assert - Child override should have verbose boxes
        Assert.Contains("┌", childOverrideCode);
        Assert.Contains("Breadcrumb Level: Verbose", childOverrideCode);
    }

    [Theory]
    [InlineData("None", "Minimal")]
    [InlineData("None", "Verbose")]
    [InlineData("Minimal", "None")]
    [InlineData("Minimal", "Verbose")]
    [InlineData("Verbose", "None")]
    [InlineData("Verbose", "Minimal")]
    public void Override_AllLevelTransitions_ProduceDifferentOutput(string parentLevel, string childLevel)
    {
        // This test verifies that all possible override combinations produce different output
        var source = @"
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry]

namespace ChildProject
{
    public class MyService { }
}";

        // Act
        var parentCode = RunGeneratorWithBreadcrumbLevel(source, parentLevel);
        var childCode = RunGeneratorWithBreadcrumbLevel(source, childLevel);

        // Assert - Different levels should produce different output
        Assert.NotEqual(parentCode, childCode);
    }

    [Fact]
    public void Configuration_MultipleFilesGenerated_AllRespectLevel()
    {
        // This test verifies that when multiple files are generated,
        // they all respect the same breadcrumb level configuration
        var source = @"
using NexusLabs.Needlr;
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry(IncludeNamespacePrefixes = new[] { ""TestApp"" })]

namespace TestApp
{
    public interface IOrderService
    {
        string GetOrder(int id);
    }

    public class LoggingInterceptor : IMethodInterceptor
    {
        public System.Threading.Tasks.ValueTask<object?> InterceptAsync(IMethodInvocation invocation)
        {
            return invocation.ProceedAsync();
        }
    }

    [Intercept<LoggingInterceptor>]
    [Scoped]
    public class OrderService : IOrderService
    {
        public string GetOrder(int id) => $""Order {id}"";
    }
}";

        // Act - Get all files with Verbose
        var verboseFiles = RunGeneratorWithBreadcrumbLevelGetFiles(source, "Verbose");
        
        // Act - Get all files with None
        var noneFiles = RunGeneratorWithBreadcrumbLevelGetFiles(source, "None");

        // Assert - Multiple files should be generated
        Assert.True(verboseFiles.Length >= 2, "Should have at least TypeRegistry and InterceptorProxies files");
        Assert.True(noneFiles.Length >= 2, "Should have at least TypeRegistry and InterceptorProxies files");

        // Assert - All verbose files should have verbose markers
        foreach (var file in verboseFiles)
        {
            Assert.Contains("═══════════════", file.Content);
        }

        // Assert - No none files should have verbose markers
        foreach (var file in noneFiles)
        {
            Assert.DoesNotContain("═══════════════", file.Content);
        }
    }

    [Fact]
    public void Configuration_DefaultIsMinimal_WhenNoPropertySet()
    {
        // This test verifies that when no NeedlrBreadcrumbLevel property is set,
        // the generator defaults to Minimal level
        var source = @"
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry]

namespace TestApp
{
    public class MyService { }
}";

        // Act - Don't set any breadcrumb level (null simulates no property set)
        var defaultCode = RunGeneratorWithBreadcrumbLevel(source, null);
        
        // Act - Explicitly set Minimal
        var minimalCode = RunGeneratorWithBreadcrumbLevel(source, "Minimal");

        // Assert - Default (null) should behave like Minimal
        // Both should not have verbose boxes
        Assert.DoesNotContain("┌", defaultCode);
        Assert.DoesNotContain("┌", minimalCode);
        Assert.DoesNotContain("Breadcrumb Level:", defaultCode);
        Assert.DoesNotContain("Breadcrumb Level:", minimalCode);
    }

    [Fact]
    public void Inheritance_ConsistentAcrossRebuilds()
    {
        // This test verifies that the same configuration produces identical output
        // across multiple builds (deterministic generation)
        var source = @"
using NexusLabs.Needlr.Generators;

[assembly: GenerateTypeRegistry]

namespace TestApp
{
    public interface IService { }
    public class MyService : IService { }
}";

        // Act - Run generator multiple times with same config
        var run1 = RunGeneratorWithBreadcrumbLevel(source, "Verbose");
        var run2 = RunGeneratorWithBreadcrumbLevel(source, "Verbose");
        var run3 = RunGeneratorWithBreadcrumbLevel(source, "Verbose");

        // Assert - All runs should produce identical output
        Assert.Equal(run1, run2);
        Assert.Equal(run2, run3);
    }

    #endregion

    #region Helper Methods

    private static string RunGeneratorWithBreadcrumbLevel(string source, string? breadcrumbLevel)
    {
        return RunGeneratorWithOptions(source, breadcrumbLevel, null);
    }

    private static string RunGeneratorWithOptions(string source, string? breadcrumbLevel, string? projectDir)
    {
        var syntaxTree = CSharpSyntaxTree.ParseText(source);

        var references = Basic.Reference.Assemblies.Net90.References.All
            .Concat(new[]
            {
                MetadataReference.CreateFromFile(typeof(GenerateTypeRegistryAttribute).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(DeferToContainerAttribute).Assembly.Location),
            })
            .ToArray();

        var compilation = CSharpCompilation.Create(
            "TestAssembly",
            new[] { syntaxTree },
            references,
            new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

        var generator = new TypeRegistryGenerator();
        
        // Create options provider with breadcrumb level
        var optionsProvider = new TestAnalyzerConfigOptionsProvider(breadcrumbLevel, projectDir);
        
        var driver = CSharpGeneratorDriver.Create(
            generators: new[] { generator.AsSourceGenerator() },
            additionalTexts: Array.Empty<AdditionalText>(),
            parseOptions: (CSharpParseOptions)syntaxTree.Options,
            optionsProvider: optionsProvider);

        driver = (CSharpGeneratorDriver)driver.RunGeneratorsAndUpdateCompilation(
            compilation,
            out var outputCompilation,
            out var diagnostics);

        var generatedTrees = outputCompilation.SyntaxTrees
            .Where(t => t.FilePath.EndsWith(".g.cs"))
            .OrderBy(t => t.FilePath)
            .ToList();

        if (generatedTrees.Count == 0)
        {
            return string.Empty;
        }

        return string.Join("\n\n", generatedTrees.Select(t => t.GetText().ToString()));
    }

    private static GeneratedFile[] RunGeneratorWithBreadcrumbLevelGetFiles(string source, string? breadcrumbLevel)
    {
        var syntaxTree = CSharpSyntaxTree.ParseText(source);

        var references = Basic.Reference.Assemblies.Net90.References.All
            .Concat(new[]
            {
                MetadataReference.CreateFromFile(typeof(GenerateTypeRegistryAttribute).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(DeferToContainerAttribute).Assembly.Location),
            })
            .ToArray();

        var compilation = CSharpCompilation.Create(
            "TestAssembly",
            new[] { syntaxTree },
            references,
            new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

        var generator = new TypeRegistryGenerator();
        
        // Create options provider with breadcrumb level
        var optionsProvider = new TestAnalyzerConfigOptionsProvider(breadcrumbLevel, null);
        
        var driver = CSharpGeneratorDriver.Create(
            generators: new[] { generator.AsSourceGenerator() },
            additionalTexts: Array.Empty<AdditionalText>(),
            parseOptions: (CSharpParseOptions)syntaxTree.Options,
            optionsProvider: optionsProvider);

        driver = (CSharpGeneratorDriver)driver.RunGeneratorsAndUpdateCompilation(
            compilation,
            out var outputCompilation,
            out var diagnostics);

        return outputCompilation.SyntaxTrees
            .Where(t => t.FilePath.EndsWith(".g.cs"))
            .Select(t => new GeneratedFile(t.FilePath, t.GetText().ToString()))
            .OrderBy(f => f.FilePath)
            .ToArray();
    }

    private sealed record GeneratedFile(string FilePath, string Content);

    #endregion

    #region Test Infrastructure

    /// <summary>
    /// Test implementation of AnalyzerConfigOptionsProvider that allows setting
    /// MSBuild properties for generator testing.
    /// </summary>
    private sealed class TestAnalyzerConfigOptionsProvider : AnalyzerConfigOptionsProvider
    {
        private readonly TestAnalyzerConfigOptions _globalOptions;

        public TestAnalyzerConfigOptionsProvider(string? breadcrumbLevel, string? projectDir)
        {
            var options = new Dictionary<string, string>();
            
            if (breadcrumbLevel != null)
            {
                options["build_property.NeedlrBreadcrumbLevel"] = breadcrumbLevel;
            }
            
            if (projectDir != null)
            {
                options["build_property.ProjectDir"] = projectDir;
            }

            _globalOptions = new TestAnalyzerConfigOptions(options);
        }

        public override AnalyzerConfigOptions GlobalOptions => _globalOptions;

        public override AnalyzerConfigOptions GetOptions(SyntaxTree tree) => _globalOptions;

        public override AnalyzerConfigOptions GetOptions(AdditionalText textFile) => _globalOptions;
    }

    /// <summary>
    /// Test implementation of AnalyzerConfigOptions that returns configured values.
    /// </summary>
    private sealed class TestAnalyzerConfigOptions : AnalyzerConfigOptions
    {
        private readonly Dictionary<string, string> _options;

        public TestAnalyzerConfigOptions(Dictionary<string, string> options)
        {
            _options = options;
        }

        public override bool TryGetValue(string key, out string value)
        {
            return _options.TryGetValue(key, out value!);
        }
    }

    #endregion
}
